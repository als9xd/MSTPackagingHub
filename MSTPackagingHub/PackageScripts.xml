<?xml version="1.0"?>
<ArrayOfScript xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\7zip.18_05\prod\update.pl</FullName>
    <Length>1905</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-01T16:00:45.3963506-05:00</CreationTime>
    <CreationTimeUtc>2018-05-01T21:00:45.3963506Z</CreationTimeUtc>
    <LastWriteTime>2018-05-01T16:08:23.4425777-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-01T21:08:23.4425777Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-01T16:00:45.3963506-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-01T21:00:45.3963506Z</LastAccessTimeUtc>
    <Text># 7-zip 18.05 x64
# Package Created May 2011
# Packaged by Todd Hartman
# Last Updated 2018-05-01 cts28d

=pod

Begin-Doc
Modified: $Date: 2011-05-19 06:58:36 -0500 (Thu, 19 May 2011) $
Name: update.pl
Type: script
Description: 7-zip 9.20 x64
Language: Perl
LastUpdatedBy: $Author: t-klmhw9 $
Version: $Revision: 689 $
Doc-SVN-Repository: $URL: https://svn.mst.edu/project/itwindist/trunk/win7/appdist/7zip.9/prod/update.pl $
RCSId: $Id: update.pl 689 2011-05-19 11:58:36Z thartman $
End-Doc

=cut


use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; '7-zip.18_05',
        package_revision =&gt; '20180501T1700',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

GetOptions(
    'uninstall' =&gt; sub { exit(!uninstall()); },
);

do_install( 
    allowed_versions =&gt; [
        OSVER_XP_32,
        OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2,
        OSVER_WIN7_SP0, OSVER_WIN7_SP1
    ],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs =&gt; [ 'clc', 'desktop', 'traveling',
                      'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    msi_name_x86 =&gt; '7z1805.msi',
    msi_name_x64 =&gt; '7z1805-x64.msi',
    additional_msi_properties =&gt; 'REBOOT="ReallySuppress"',
);
IM_Exit(EXIT_SUCCESS);


sub uninstall {

    output("Uninstalling 7-Zip 9: ");
    my $outcome = 
        install_msi( app_id =&gt; '{23170F69-40C1-2702-1805-000001000000}',
                     msi_action_flag =&gt; 'x');
					 
	sleep(20);
	
    output(($outcome?'OK':'FAILED')."\n");
    if ($outcome) {
        delete_product_registry_key(get_package_name().".".get_version());
    }

    return $outcome;
}
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\abaqus.2016\dev\update.pl</FullName>
    <Length>4892</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-06-15T10:31:17.143805-05:00</CreationTime>
    <CreationTimeUtc>2016-06-15T15:31:17.143805Z</CreationTimeUtc>
    <LastWriteTime>2018-02-22T10:14:03.5369295-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-02-22T16:14:03.5369295Z</LastWriteTimeUtc>
    <LastAccessTime>2016-06-15T10:31:17.143805-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-06-15T15:31:17.143805Z</LastAccessTimeUtc>
    <Text># Abaqus 2016 Research Lisence
# Package Created June 15, 2016
# Packaged by Jason Mao

=pod

Begin-Doc
Modified: $Date$
Name: Abaqus 6.10
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;
use Getopt::Long;
use Win32::Registry;
use File::Copy;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN
{
  %INSTALLMONKEY_OPTIONS = (

    # same name as the appdist directory
    package_id       =&gt; 'abaqus.2016',
    package_revision =&gt; '20160615T1500',

    #         # if different from default location
    #         output_log =&gt; 'path_to_output_log',
  );
}

# Add InstallMonkey Library to the path
use lib ('\\\\minerfiles.mst.edu\dfs\software\loginscripts\im', $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 'C:\temp',);
use InstallMonkey::Shared;
my $sourcefilesdir = get_pkg_sourcefiles();

sub preinstall
{
  print "Clearing directories for install:\n";
  run_command("rd /s /q \"C:\\Program Files\\Dassault Systemes\\SimulationServices\\V6R2016x\" ");
  run_command("rd /s /q  C:\\SIMLUIA\\CAE\\2016");
  run_command("rd /s /q  C:\\SIMULIA\\Commands");
  return 1;
}

sub install
{
  $| = 1;
  my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\abaqus.2016\\unload";

  my $command = $appdeploy."\\AM_DOC_SIM_EstPrd.AllOS\\1\\DOC_SIMULIA_Abaqus_fe-safe\\1\\Abaqus_2016\\setup.exe -replay $appdeploy\\installer.properties";
  output("\n  Installing Abaqus 2016 Documentation with command: $command\n");
  run_command($command, 'IgnoreReturnCode'=&gt;1);
  output("  Setup Done.\n");

  #install some of the solvers
  $command = $appdeploy."\\AM_SIM_Abaqus_Extend.AllOS\\1\\3DEXPERIENCE_AbaqusSolver\\Windows64\\1\\StartTUI.exe --silent $appdeploy\\AM_SIM_Abaqus_Extend.AllOS\\1\\3DEXPERIENCE_AbaqusSolver\\UserIntentions.xml";
  output("\n  Installing Abaqus 2016 Solver Part 1 with command: $command");
  run_command($command, 'IgnoreReturnCode'=&gt;1);
  output("  Setup Done.\n");

  #install some of the solvers part 2
  $command = $appdeploy."\\AM_SIM_Abaqus_Extend.AllOS\\1\\CAA_3DEXPERIENCE_AbaqusSolver\\Windows64\\1\\StartTUI.exe --silent $appdeploy\\AM_SIM_Abaqus_Extend.AllOS\\1\\CAA_3DEXPERIENCE_AbaqusSolver\\Windows64\\1\\UserIntentions.xml";
  output("\n  Installing Abaqus 2016 Solver Part 2 with command: $command");
  run_command($command, 'IgnoreReturnCode'=&gt;1);
  output("  Setup Done.\n");

  #install CAE
  $command = $appdeploy."\\AM_SIM_Abaqus_Extend.AllOS\\1\\SIMULIA_Abaqus_CAE\\Windows64\\1\\StartTUI.exe --silent $appdeploy\\AM_SIM_Abaqus_Extend.AllOS\\1\\SIMULIA_Abaqus_CAE\\Windows64\\1\\UserIntentions.xml";
  output("\n  Installing Abaqus 2016 CAE with command: $command\n\n");
  run_command($command, 'IgnoreReturnCode'=&gt;1);
  output("  Setup Done.\n");

  sleep(30);

  my $firewallAdd = "netsh advfirewall firewall add rule name=\"Abaqus 2016\" dir=in action=allow program=\"C:\\simulia\\CAE\\2016\\win_b64\\code\\bin\\abqcaek.exe\" enable=yes";
  if(run_command($firewallAdd)){
      output("added firewall exception\n");
  }
  else{
      output("$firewallAdd didn't work\n");
  }


  return 1;
}

#recursive directory deleter
sub deldir
{
  my $trg = shift;

  print "looking in $trg\n";
  opendir(my $dh, $trg) or return 1;

  my $thing;
  for $thing (readdir $dh)
  {
    chomp $trg;
    chomp $thing;
    if($thing eq '.' or $thing eq '..')
    {
      next;
    }
    elsif(-f $trg.'\\'.$thing)
    {
      print "found file: $thing\n";
      unlink $trg."\\".$thing;
    }
    elsif(-d $trg.'\\'.$thing)
    {
      print "found dir: $thing\n";
      deldir($trg.'\\'.$thing);
      rmdir $trg."\\".$thing;
      print "emptied and deleted $thing\n";
    }
  }
}

sub postinstall{
  my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\abaqus.2016\\unload";
  my $start = "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Dassault Systemes SIMULIA Abaqus CAE 2016";

  if(-e $start."\\Abaqus CAE.lnk")
  {
    unless(-e "C:\\temp")
    {
      mkdir "C:\\temp";
    }
    unlink $start."\\Abaqus CAE.lnk";
    copy($appdeploy."\\Abaqus CAE.lnk", $start);
  }
    else
  {
    output "couldn't find the file\n";
  }

  return 1;
}

do_install(
  no_source_files  =&gt; 1,
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  preinstall_sub =&gt; \&amp;preinstall,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>Abaqus2017.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\abaqus.2017\prod\Abaqus2017.pl</FullName>
    <Length>8569</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-05-19T15:51:21.0345015-05:00</CreationTime>
    <CreationTimeUtc>2017-05-19T20:51:21.0345015Z</CreationTimeUtc>
    <LastWriteTime>2018-05-25T10:06:10.2639476-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-25T15:06:10.2639476Z</LastWriteTimeUtc>
    <LastAccessTime>2017-05-19T15:51:21.0345015-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-05-19T20:51:21.0345015Z</LastAccessTimeUtc>
    <Text># Abaqus 2017 Research Lisence
# Package Created June 15, 2017
# Packaged by Jason Mao
# Updated May 2017 cts28d
# Updated Aug 2017 - Jason S. Holm (Corrected issue with missing menu item for Abaqus CAE)

=pod

Begin-Doc
Modified: $Date$
Name: Abaqus 6.10
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;
use Getopt::Long;
use Win32::Registry;
use File::Copy;
use Win32::TieRegistry;

our %INSTALLMONKEY_OPTIONS;
BEGIN
{
	%INSTALLMONKEY_OPTIONS = (
		package_id       =&gt; 'abaqus.2017',
		package_revision =&gt; '20170419T1600',
	);
}

use lib ('\\\\minerfiles.mst.edu\dfs\software\loginscripts\im', $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 'C:\temp',);
use InstallMonkey::Shared;
my $src = get_pkg_sourcefiles();
	my $startFESAFE = "$ENV{'PROGRAMDATA'}\\Microsoft\\Windows\\Start Menu\\Programs\\Dassault Systemes SIMULIA fe-safe 2017";


sub preinstall
{
	print "Clearing directories for install:\n";
	# Update - 20170901 - Jason S. Holm
	#	Trying to prevent errors due to the location we are trying to remove not existing.
	#	Used array to reduce the amount of repeated code...allows for more removes if needed.

	my @directory_location = (
							  'C:\\Program Files\\Dassault Systemes\\SimulationServices\\V6R2017x',
							  'C:\\SIMLUIA\\CAE\\2017',
							  'C:\\SIMULIA\\Commands'
							 );
	my $i = 0;
	my $array_items = @directory_location;
	while ($i &lt; $array_items)
	{
	 output("Checking for: $directory_location[$i]...");
	 if (-e $directory_location[$i])
	 {
	  output("location exists, removing...");
	  run_command("rd /s /q $directory_location[$i]");
	  output("done!\n");
	 }
	 else
	 {
	  output("location not found, so no need to remove.\n");
	 }
	 $i++;
	}



	return 1;
}

#In order to get the "UserIntentions_*.xml" file for silent installs, you must first install abaqus manually.
#This is most easily done by running the suite installer through the GUI installer, which will call each individual
#	component GUI installer for you to click through. After each component completion, make note of the installer path
#	using psexec or simliar, and find the UserIntentions file in &lt;install_dir&gt;\InstallData and copy to the $appdeploy
#	source based on the path shown in psexec. Close the component installer after getting the path, but before copying
#	UserIntentions because otherwise UserIntentions won't exist.
#Abaqus tends to change install file layouts between versions, so hopefully that will lessen the headache of that.
#Do match the order that the suite installer uses. Things are dependent on each other and will fail if out of order.
sub install
{
	$| = 1;
	#easier to read install directories
	my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\abaqus.2017.new\\AM_SIM_Abaqus_Extend.AllOS";
	my $dir_simuliadocs = "$appdeploy\\1\\SIMULIA_Documentation\\AllOS\\1";
	my $dir_abaqusservices = "$appdeploy\\1\\SIMULIA_AbaqusServices\\Windows64\\1";
	my $dir_caaapi = "$appdeploy\\1\\SIMULIA_AbaqusServices_CAA_API\\Windows64\\1";
	my $dir_cae = "$appdeploy\\1\\SIMULIA_Abaqus_CAE\\Windows64\\1";
	my $dir_tosca = "$appdeploy\\2\\SIMULIA_Tosca\\Windows64\\1";
	my $dir_isight = "$appdeploy\\2\\SIMULIA_Isight\\Windows64\\1";

	output("\n  Installing fe-safe...");
	run_command("robocopy \"$appdeploy\\fe-safe\" \"C:\\SIMULIA\\fe-safe\" /E", 'IgnoreExitCodes' =&gt; [1,2,3]);
	output("\n  Configuring registry...");
	run_command("REG IMPORT \"$src\\license.reg\"");
	output("\n  Configuring shortcuts...\n");
	run_command("robocopy \"$src\\Dassault Systemes SIMULIA fe-safe 2017\" \"$startFESAFE\" /E", 'IgnoreExitCodes' =&gt; [1,2,3]);
	output("  DONE\n");

	#SIMULIA Documentation
	my $command = "$dir_simuliadocs\\starttui.exe --silent $dir_simuliadocs\\UserIntentions_DOC.xml";
	output("\n  Installing SIMULIA Documentation with command: $command\n");
	run_command($command, 'verbose' =&gt; 1);
	output("  DONE\n");

	#Abaqus Services
	my $command = "$dir_abaqusservices\\starttui.exe --silent $dir_abaqusservices\\UserIntentions_CODE.xml";
	output("\n  Installing Abaqus Services with command: $command\n");
	run_command($command, 'verbose' =&gt; 1);
	output("  DONE\n");
	#Abaqus Services (CAA API)
	my $command = "$dir_caaapi\\starttui.exe --silent $dir_caaapi\\UserIntentions_CAA_Additional.xml";
	output("\n  Installing Abaqus Services CAA API with command: $command\n");
	run_command($command, 'verbose' =&gt; 1);
	output("  DONE\n");
	#Abaqus CAE
	my $command = "$dir_cae\\starttui.exe --silent $dir_cae\\UserIntentions_CODE.xml";
	output("\n  Installing Abaqus 2017 CAE with command: $command\n");
	run_command($command, 'verbose' =&gt; 1);
	output("  DONE\n");
	#SIMULIA Tosca
	my $command = "$dir_tosca\\starttui.exe --silent $dir_tosca\\UserIntentions_CODE.xml";
	output("\n  Installing SIMULIA Tosca with command: $command\n");
	run_command($command, 'verbose' =&gt; 1);
	output("  DONE\n");
	#SIMULIA Isight
	my $command = "$dir_isight\\starttui.exe --silent $dir_isight\\UserIntentions_CODE.xml";
	output("\n  Installing SIMULIA Isight with command: $command\n");
	run_command($command, 'verbose' =&gt; 1);
	output("  DONE\n");



	sleep(30);

	my $firewallAdd = "netsh advfirewall firewall add rule name=\"Abaqus 2017\" dir=in action=allow program=\"C:\\simulia\\CAE\\2017\\win_b64\\code\\bin\\abqcaek.exe\" enable=yes";
	if(run_command($firewallAdd)) {
		output("added firewall exception\n");
	}
	else {
		output("$firewallAdd didn't work\n");
	}
	return 1;
}


sub checkReg {
  my $env_var = shift;

  return $Registry-&gt;{"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment\\\\".$env_var};
}

#recursive directory deleter
sub deldir
{
	my $trg = shift;

	print "looking in $trg\n";
	opendir(my $dh, $trg) or return 1;

	my $thing;
	for $thing (readdir $dh) {
		chomp $trg;
		chomp $thing;
		if($thing eq '.' or $thing eq '..') {
			next;
		}
		elsif(-f $trg.'\\'.$thing) {
			print "found file: $thing\n";
			unlink $trg."\\".$thing;
		}
		elsif(-d $trg.'\\'.$thing) {
			print "found dir: $thing\n";
			deldir($trg.'\\'.$thing);
			rmdir $trg."\\".$thing;
			print "emptied and deleted $thing\n";
		}
	}
}


sub postinstall{
	my $localfile = "C:\\SourceFiles\\abaqus.2017\\CustomStartMenuItems";

	my $startCAE = "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Dassault Systemes SIMULIA Abaqus CAE 2017";
	my $desk = get_allusers_desktop();

	if(-e $startCAE."\\Abaqus CAE.lnk") {
		unless(-e "C:\\temp") {
			mkdir "C:\\temp";
		}
		unlink $startCAE."\\Abaqus CAE.lnk";
		copy($localfile."\\Abaqus CAE.lnk", $startCAE);
	}
	else {
		output("couldn't find the file\n");
	}

	output("Adding Abaqus License Variable...\n");

	#my $lm_reg = checkReg('LM_LICENSE_FILE'); #normally what's used, not here tho
	my $lm_reg = checkReg('FLEXNET_ABAQUS_LICENSE_FILE');

	 if (!defined($lm_reg) || ($lm_reg !~ m/\b1751\@abaqus\.lic\.mst\.edu\b/i)) {
		output("Adding 1751\@abaqus.lic.mst.edu to FLEXNET_ABAQUS_LICENSE_FILE\n");

		my @paths = split(/;/,$lm_reg || '');
		push(@paths,'1751@abaqus.lic.mst.edu');

		my @command = (
			'SETX.EXE',
			'LM_LICENSE_FILE',
			'"'.join(';',@paths).'"',
			(is_XP()?'-M':'/M'),
		);
		if(run_command(join(' ',@command))) {
			output("Success!\n");
		}
		else {
			output("Failed.\n");
			return 0;
		}
	}
	else {
		output("License already configured.\n");
	}

	# Place autoit script in place of shortcut
	output("Placing script: ");
	if(!run_command("copy /Y \"$src\\autoit\\fe-safe 2017.lnk\" \"$startFESAFE\\fe-safe 2017.lnk\"")){
		output("FAILED:$!\nProgram will not be licensed on first launch!\n");
	}
	output("OK\n");

	output("Removing desktop shortcuts: ");
	run_command("DEL /Q \"$desk\\Isight 2017 Design Gateway.lnk\"");
	run_command("DEL /Q \"$desk\\SIMULIA Execution Engine 2017 Station.lnk\"");
	output("OK\n");

  return 1;
}

do_install(
	#no_source_files  =&gt; 1,
	allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
	allowed_os_architectures =&gt; [OSARCH_x64],
	allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
	exit_on_failure =&gt; 1,
	preinstall_sub =&gt; \&amp;preinstall,
	install_sub =&gt; \&amp;install,
	postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>Abaqus2017Teaching.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\abaqus.2017\prod\Abaqus2017Teaching.pl</FullName>
    <Length>7914</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-05-19T15:51:21.0501018-05:00</CreationTime>
    <CreationTimeUtc>2017-05-19T20:51:21.0501018Z</CreationTimeUtc>
    <LastWriteTime>2017-06-19T16:56:48.0422157-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-19T21:56:48.0422157Z</LastWriteTimeUtc>
    <LastAccessTime>2017-05-19T15:51:21.0501018-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-05-19T20:51:21.0501018Z</LastAccessTimeUtc>
    <Text># Abaqus 2017 Research Lisence
# Package Created June 15, 2017
# Packaged by Jason Mao
# Updated May 2017 cts28d

=pod

Begin-Doc
Modified: $Date$
Name: Abaqus 6.10
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;
use Getopt::Long;
use Win32::Registry;
use File::Copy;
use Win32::TieRegistry;

our %INSTALLMONKEY_OPTIONS;
BEGIN
{
	%INSTALLMONKEY_OPTIONS = (
		package_id       =&gt; 'abaqus-teaching.2017',
		package_revision =&gt; '20170419T1600',
	);
}

use lib ('\\\\minerfiles.mst.edu\dfs\software\loginscripts\im', $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 'C:\temp',);
use InstallMonkey::Shared;
my $src = get_pkg_sourcefiles();
	my $startFESAFE = "$ENV{'PROGRAMDATA'}\\Microsoft\\Windows\\Start Menu\\Programs\\Dassault Systemes SIMULIA fe-safe 2017";


sub preinstall
{
	print "Clearing directories for install:\n";
	run_command("rd /s /q \"C:\\Program Files\\Dassault Systemes\\SimulationServices\\V6R2017x\" ");
	run_command("rd /s /q  C:\\SIMLUIA\\CAE\\2017");
	run_command("rd /s /q  C:\\SIMULIA\\Commands");
	return 1;
}

#In order to get the "UserIntentions_*.xml" file for silent installs, you must first install abaqus manually.
#This is most easily done by running the suite installer through the GUI installer, which will call each individual
#	component GUI installer for you to click through. After each component completion, make note of the installer path
#	using psexec or simliar, and find the UserIntentions file in &lt;install_dir&gt;\InstallData and copy to the $appdeploy
#	source based on the path shown in psexec. Close the component installer after getting the path, but before copying
#	UserIntentions because otherwise UserIntentions won't exist.
#Abaqus tends to change install file layouts between versions, so hopefully that will lessen the headache of that.
#Do match the order that the suite installer uses. Things are dependent on each other and will fail if out of order.
sub install
{
	$| = 1;
	#easier to read install directories
	my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\abaqus.2017.new\\AM_SIM_Abaqus_Extend.AllOS";
	my $dir_simuliadocs = "$appdeploy\\1\\SIMULIA_Documentation\\AllOS\\1";
	my $dir_abaqusservices = "$appdeploy\\1\\SIMULIA_AbaqusServices\\Windows64\\1";
	my $dir_caaapi = "$appdeploy\\1\\SIMULIA_AbaqusServices_CAA_API\\Windows64\\1";
	my $dir_cae = "$appdeploy\\1\\SIMULIA_Abaqus_CAE\\Windows64\\1";
	my $dir_tosca = "$appdeploy\\2\\SIMULIA_Tosca\\Windows64\\1";
	my $dir_isight = "$appdeploy\\2\\SIMULIA_Isight\\Windows64\\1";
	
	output("\n  Installing fe-safe...");
	run_command("robocopy \"$appdeploy\\fe-safe\" \"C:\\SIMULIA\\fe-safe\" /E", 'IgnoreExitCodes' =&gt; [1,2,3]);
	output("\n  Configuring registry...");
	run_command("REG IMPORT \"$src\\license.reg\"");
	output("\n  Configuring shortcuts...\n");
	run_command("robocopy \"$src\\Dassault Systemes SIMULIA fe-safe 2017\" \"$startFESAFE\" /E", 'IgnoreExitCodes' =&gt; [1,2,3]);
	output("  DONE\n");
	
	#SIMULIA Documentation
	my $command = "$dir_simuliadocs\\starttui.exe --silent $dir_simuliadocs\\UserIntentions_DOC.xml";
	output("\n  Installing SIMULIA Documentation with command: $command\n");
	run_command($command, 'verbose' =&gt; 1);
	output("  DONE\n");

	#Abaqus Services
	my $command = "$dir_abaqusservices\\starttui.exe --silent $dir_abaqusservices\\UserIntentions_CODE.xml";
	output("\n  Installing Abaqus Services with command: $command\n");
	run_command($command, 'verbose' =&gt; 1);
	output("  DONE\n");
	#Abaqus Services (CAA API)
	my $command = "$dir_caaapi\\starttui.exe --silent $dir_caaapi\\UserIntentions_CAA_Additional.xml";
	output("\n  Installing Abaqus Services CAA API with command: $command\n");
	run_command($command, 'verbose' =&gt; 1);
	output("  DONE\n");
	#Abaqus CAE
	my $command = "$dir_cae\\starttui.exe --silent $dir_cae\\UserIntentions_CODEt.xml";
	output("\n  Installing Abaqus 2017 CAE with command: $command\n");
	run_command($command, 'verbose' =&gt; 1);
	output("  DONE\n");
	#SIMULIA Tosca
	my $command = "$dir_tosca\\starttui.exe --silent $dir_tosca\\UserIntentions_CODEt.xml";
	output("\n  Installing SIMULIA Tosca with command: $command\n");
	run_command($command, 'verbose' =&gt; 1);
	output("  DONE\n");
	#SIMULIA Isight
	my $command = "$dir_isight\\starttui.exe --silent $dir_isight\\UserIntentions_CODEt.xml";
	output("\n  Installing SIMULIA Isight with command: $command\n");
	run_command($command, 'verbose' =&gt; 1);
	output("  DONE\n");
	
	
	
	sleep(30);

	my $firewallAdd = "netsh advfirewall firewall add rule name=\"Abaqus 2017\" dir=in action=allow program=\"C:\\simulia\\CAE\\2017\\win_b64\\code\\bin\\abqcaek.exe\" enable=yes";
	if(run_command($firewallAdd)) {
		output("added firewall exception\n");
	}
	else {
		output("$firewallAdd didn't work\n");
	}
	return 1;
}


sub checkReg {
  my $env_var = shift;

  return $Registry-&gt;{"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment\\\\".$env_var};
}

#recursive directory deleter
sub deldir
{
	my $trg = shift;

	print "looking in $trg\n";	
	opendir(my $dh, $trg) or return 1;

	my $thing;	
	for $thing (readdir $dh) {
		chomp $trg;
		chomp $thing;
		if($thing eq '.' or $thing eq '..') {
			next;
		}
		elsif(-f $trg.'\\'.$thing) {
			print "found file: $thing\n";
			unlink $trg."\\".$thing;
		}
		elsif(-d $trg.'\\'.$thing) {
			print "found dir: $thing\n";
			deldir($trg.'\\'.$thing);
			rmdir $trg."\\".$thing;
			print "emptied and deleted $thing\n";
		}
	}
}

sub postinstall{
	my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\abaqus.2017\\unload";
	my $startCAE = "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Dassault Systemes SIMULIA Abaqus CAE 2017";
	my $desk = get_allusers_desktop();
	
	if(-e $startCAE."\\Abaqus CAE.lnk") {
		unless(-e "C:\\temp") {
			mkdir "C:\\temp";
		}
		unlink $startCAE."\\Abaqus CAE.lnk";
		copy($appdeploy."\\Abaqus CAE.lnk", $startCAE);
	}
	else {
		output "couldn't find the file\n";
	}

	output("Adding Abaqus License Variable...\n");

	#my $lm_reg = checkReg('LM_LICENSE_FILE'); #normally what's used, not here tho
	my $lm_reg = checkReg('FLEXNET_ABAQUS_LICENSE_FILE');

	 if (!defined($lm_reg) || ($lm_reg !~ m/\b1751\@abaqus-teaching\.lic\.mst\.edu\b/i)) {
		output("Adding 1751\@abaqus.lic.mst.edu to FLEXNET_ABAQUS_LICENSE_FILE\n");

		my @paths = split(/;/,$lm_reg || '');
		push(@paths,'1751@abaqus.lic.mst.edu');

		my @command = (
			'SETX.EXE',
			'LM_LICENSE_FILE',
			'"'.join(';',@paths).'"',
			(is_XP()?'-M':'/M'),
		);
		if(run_command(join(' ',@command))) {
			output("Success!\n");
		}
		else {
			output("Failed.\n");
			return 0;
		}
	}
	else {
		output("License already configured.\n");
	}
	
	# Place autoit script in place of shortcut
	output("Placing script: ");
	if(!run_command("copy /Y \"$src\\autoit\\fe-safe 2017.lnk\" \"$startFESAFE\\fe-safe 2017.lnk\"")){
		output("FAILED:$!\nProgram will not be licensed on first launch!\n");
	}
	output("OK\n");
	output("Removing desktop shortcuts: ");
	run_command("DEL /Q \"$desk\\Isight 2017 Design Gateway.lnk\"");
	run_command("DEL /Q \"$desk\\SIMULIA Execution Engine 2017 Station.lnk\"");
	output("OK\n");
	
  return 1;
}

do_install(
	#no_source_files  =&gt; 1,
	allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
	allowed_os_architectures =&gt; [OSARCH_x64],
	allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
	exit_on_failure =&gt; 1,
	preinstall_sub =&gt; \&amp;preinstall,
	install_sub =&gt; \&amp;install,
	postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>FirewallException.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\abaqus.2017\prod\FirewallException.pl</FullName>
    <Length>306</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-05-19T15:51:21.0657021-05:00</CreationTime>
    <CreationTimeUtc>2017-05-19T20:51:21.0657021Z</CreationTimeUtc>
    <LastWriteTime>2016-11-02T13:58:00.4114045-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-11-02T18:58:00.4114045Z</LastWriteTimeUtc>
    <LastAccessTime>2017-05-19T15:51:21.0657021-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-05-19T20:51:21.0657021Z</LastAccessTimeUtc>
    <Text>my $firewallAdd = "netsh advfirewall firewall add rule name=\"Abaqus 2016\" dir=in action=allow program=\"C:\\simulia\\CAE\\2016\\win_b64\\code\\bin\\abqcaek.exe\" enable=yes";
if(system($firewallAdd) != -1){
    print("added firewall exception\n");
}
else{
    print("$firewallAdd didn't work\n");
}</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\abaqus.2018\prod\update.pl</FullName>
    <Length>9446</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-03-05T10:46:00.6051036-06:00</CreationTime>
    <CreationTimeUtc>2018-03-05T16:46:00.6051036Z</CreationTimeUtc>
    <LastWriteTime>2018-06-01T16:06:07.31475-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-01T21:06:07.31475Z</LastWriteTimeUtc>
    <LastAccessTime>2018-03-05T10:46:00.6051036-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-03-05T16:46:00.6051036Z</LastAccessTimeUtc>
    <Text># Abaqus 2018 Research License
# Package Created March 5, 2018
# Packaged by Ryan Andrews
# Updated June 1, 2018 by Robert Smith

=pod

Begin-Doc
Modified: $Date$
Name: Abaqus 6.18
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;
use Getopt::Long;
use Win32::Registry;
use File::Copy;
use Win32::TieRegistry;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN
{
  %INSTALLMONKEY_OPTIONS = (

    # same name as the appdist directory
    package_id       =&gt; 'abaqus.2018',
    package_revision =&gt; '20180530T1602',

    #         # if different from default location
    #         output_log =&gt; 'path_to_output_log',
  );
}

# Add InstallMonkey Library to the path
use lib ('\\\\minerfiles.mst.edu\dfs\software\loginscripts\im', $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 'C:\temp',);
use InstallMonkey::Shared;
my $sourcefilesdir = get_pkg_sourcefiles();
my $startFESAFE = "$ENV{'PROGRAMDATA'}\\Microsoft\\Windows\\Start Menu\\Programs\\Dassault Systemes SIMULIA fe-safe 2018";

sub preinstall
{
  print "Clearing directories for install:\n";
  # Update - 20170901 - Jason S. Holm
  #	Trying to prevent errors due to the location we are trying to remove not existing.
  #	Used array to reduce the amount of repeated code...allows for more removes if needed.

  my @directory_location = (
    'C:\\Program Files\\Dassault Systemes\\SimulationServices\\V6R2018x',
    'C:\\SIMLUIA'
  );

  my $i = 0;
  my $array_items = @directory_location;
  while ($i &lt; $array_items)
  {
    output("Checking for: $directory_location[$i]...");
    if (-e $directory_location[$i])
    {
      output("location exists, removing...");
      run_command("rd /s /q $directory_location[$i]");
      output("done!\n");
    }
    else
    {
      output("location not found, so no need to remove.\n");
    }

    $i++;

  }

  return 1;
}

#In order to get the "UserIntentions_*.xml" file for silent installs, you must first install abaqus manually.
#This is most easily done by running the suite installer through the GUI installer, which will call each individual
#	component GUI installer for you to click through. After each component completion, make note of the installer path
#	using psexec or simliar, and find the UserIntentions file in &lt;install_dir&gt;\InstallData and copy to the $appdeploy
#	source based on the path shown in psexec. Close the component installer after getting the path, but before copying
#	UserIntentions because otherwise UserIntentions won't exist.
#Abaqus tends to change install file layouts between versions, so hopefully that will lessen the headache of that.
#Do match the order that the suite installer uses. Things are dependent on each other and will fail if out of order.
sub install
{
  $| = 1;
  my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\abaqus.2018\\2018.AM_SIM_Abaqus_Extend.AllOS.4-4\\AM_SIM_Abaqus_Extend.AllOS";

  #SIMULIA Documentation
  my $command = $appdeploy."\\1\\SIMULIA_Documentation\\AllOS\\1\\StartTUI.exe --silent $appdeploy\\1\\SIMULIA_Documentation\\AllOS\\1\\UserIntentions_DOC.xml";
  output("\n  Installing Abaqus 2018 Documentation with command: $command\n\n");
  run_command($command, 'IgnoreReturnCode'=&gt;1);
  output("  Setup Done.\n");

  #install Simulation Services
  $command = $appdeploy."\\1\\SIMULIA_AbaqusServices\\Windows64\\1\\StartTUI.exe --silent $appdeploy\\1\\SIMULIA_AbaqusServices\\Windows64\\1\\UserIntentions_CODE.xml";
  output("\n  Installing Abaqus 2018 Simulation Services: $command\n\n");
  run_command($command, 'IgnoreReturnCode'=&gt;1);
  output("  Setup Done.\n");

  #install 3DEXPERIENCE CAA API
  $command = $appdeploy."\\1\\SIMULIA_AbaqusServices_CAA_API\\Windows64\\1\\StartTUI.exe --silent $appdeploy\\1\\SIMULIA_AbaqusServices_CAA_API\\Windows64\\1\\UserIntentions_CAA.xml";
  output("\n  Installing Abaqus 2018 3DExperience CAA API: $command\n\n");
  run_command($command, 'IgnoreReturnCode'=&gt;1);
  output("  Setup Done.\n");

  #install CAE
  $command = $appdeploy."\\1\\SIMULIA_Abaqus_CAE\\Windows64\\1\\StartTUI.exe --silent $appdeploy\\1\\SIMULIA_Abaqus_CAE\\Windows64\\1\\UserIntentions_CODE.xml";
  output("\n  Installing Abaqus 2018 CAE with command: $command\n\n");
  run_command($command, 'IgnoreReturnCode'=&gt;1);
  output("  Setup Done.\n");

  #install Fe-Safe
  $command = $appdeploy."\\2\\SIMULIA_fesafe\\Windows64\\1\\StartTUI.exe --silent $appdeploy\\2\\SIMULIA_fesafe\\Windows64\\1\\UserIntentions_CODE.xml";
  output("\n  Installing Abaqus 2018 Fe Safe with command: $command\n\n");
  run_command($command, 'IgnoreReturnCode'=&gt;1);
  output("  Setup Done.\n");

  #install Tosca
  $command = $appdeploy."\\2\\SIMULIA_Tosca\\Windows64\\1\\StartTUI.exe --silent $appdeploy\\2\\SIMULIA_Tosca\\Windows64\\1\\UserIntentions_CODE.xml";
  output("\n  Installing Abaqus 2018 Tosca with command: $command\n\n");
  run_command($command, 'IgnoreReturnCode'=&gt;1);
  output("  Setup Done.\n");

  #install Isight
  $command = $appdeploy."\\2\\SIMULIA_Isight\\Windows64\\1\\StartTUI.exe --silent $appdeploy\\2\\SIMULIA_Isight\\Windows64\\1\\UserIntentions_CODE.xml";
  output("\n  Installing Abaqus 2018 Isight with command: $command\n\n");
  run_command($command, 'IgnoreReturnCode'=&gt;1);
  output("  Setup Done.\n");


  # Added 5/30/2018
  sleep(30);

  my $firewallAdd = "netsh advfirewall firewall add rule name=\"Abaqus 2018\" dir=in action=allow program=\"C:\\simulia\\CAE\\2018\\win_b64\\code\\bin\\abqcaek.exe\" enable=yes";
  if(run_command($firewallAdd))
  {
    output("added firewall exception\n");
  }
  else
  {
    output("$firewallAdd didn't work\n");
  }


  return 1;
}


sub checkReg {
  my $env_var = shift;

  return $Registry-&gt;{"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment\\\\".$env_var};
}

#recursive directory deleter
sub deldir
{
  my $trg = shift;

  print "looking in $trg\n";
  opendir(my $dh, $trg) or return 1;

  my $thing;
  for $thing (readdir $dh)
  {
    chomp $trg;
    chomp $thing;
    if($thing eq '.' or $thing eq '..')
    {
      next;
    }
    elsif(-f $trg.'\\'.$thing)
    {
      print "found file: $thing\n";
      unlink $trg."\\".$thing;
    }
    elsif(-d $trg.'\\'.$thing)
    {
      print "found dir: $thing\n";
      deldir($trg.'\\'.$thing);
      rmdir $trg."\\".$thing;
      print "emptied and deleted $thing\n";
    }
  }
}

sub postinstall
{
  # Abaqus 2018 doesn't seem to have any *.lnk files in its \appdeploy\ folder.
  # Keeping this code from the 2016 version here for future reference
  my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\abaqus.2018\\unload";
  my $start = "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Dassault Systemes SIMULIA Abaqus CAE 2018";
  my $desk = get_allusers_desktop();

  # Abaqus 2018 doesn't seem to have *.lnk files in its \SourceFiles\ directory
  # Keeping this code from the 2017 version here for future reference
  my $localfile = "C:\\SourceFiles\\abaqus.2018\\CustomStartMenuItems";

  output("Deleting shortcuts. . .\n");
	if(-e $start."\\Abaqus CAE.lnk")
	{
		unless(-e "C:\\temp")
		{
			mkdir "C:\\temp";
		}
		unlink $start."\\Abaqus CAE.lnk";
		copy($appdeploy."\\Abaqus CAE.lnk", $start);
		copy($localfile."\\Abaqus CAE.lnk", $start);
	}
	else
	{
		output "Couldn't find the file\n";
	}

# not needed for 2018?
#=pod
  output("Adding Abaqus License Variable...\n");

	#my $lm_reg = checkReg('LM_LICENSE_FILE'); #normally what's used, not here tho
	my $lm_reg = checkReg('FLEXNET_ABAQUS_LICENSE_FILE');

	 if (!defined($lm_reg) || ($lm_reg !~ m/\b1751\@abaqus\.lic\.mst\.edu\b/i)) {
		output("Adding 1751\@abaqus.lic.mst.edu to FLEXNET_ABAQUS_LICENSE_FILE\n");

		my @paths = split(/;/,$lm_reg || '');
		push(@paths,'1751@abaqus.lic.mst.edu');

		my @command = (
			'SETX.EXE',
			'LM_LICENSE_FILE',
			'"'.join(';',@paths).'"',
			(is_XP()?'-M':'/M'),
		);
		if(run_command(join(' ',@command))) {
			output("Success!\n");
		}
		else {
			output("Failed.\n");
			return 0;
		}
	}
	else {
		output("License already configured.\n");
	}

	# Place autoit script in place of shortcut
	output("Placing script: ");
	if(!run_command("copy /Y \"$sourcefilesdir\\autoit\\fe-safe 2018.lnk\" \"$startFESAFE\\fe-safe 2018.lnk\"")){
		output("FAILED:$!\nProgram will not be licensed on first launch!\n");
	}
	output("OK\n");
#=cut

	output("Removing desktop shortcuts: ");
	run_command("DEL /Q \"$desk\\Isight 2018 Design Gateway.lnk\"");
	run_command("DEL /Q \"$desk\\SIMULIA Execution Engine 2018 Station.lnk\"");
	output("OK\n");

  return 1;
}

do_install(
  no_source_files  =&gt; 1,
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  preinstall_sub =&gt; \&amp;preinstall,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>updateTeaching.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\abaqus.2018\prod\updateTeaching.pl</FullName>
    <Length>9383</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-30T11:03:11.2327845-05:00</CreationTime>
    <CreationTimeUtc>2018-05-30T16:03:11.2327845Z</CreationTimeUtc>
    <LastWriteTime>2018-06-01T16:06:06.0090685-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-01T21:06:06.0090685Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-30T11:03:11.2327845-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-30T16:03:11.2327845Z</LastAccessTimeUtc>
    <Text># Abaqus 2018 Teaching License
# Package Created March 5, 2018
# Packaged by Ryan Andrews
# Updated June 1, 2018 by Robert Smith

=pod

Begin-Doc
Modified: $Date$
Name: Abaqus 6.18
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;
use Getopt::Long;
use Win32::Registry;
use File::Copy;
use Win32::TieRegistry;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN
{
	%INSTALLMONKEY_OPTIONS = (

		# same name as the appdist directory
		package_id       =&gt; 'abaqus-teaching.2018',
		package_revision =&gt; '20180530T1602',

		#         # if different from default location
    #         output_log =&gt; 'path_to_output_log',
	);
}

# Add InstallMonkey Library to the path
use lib ('\\\\minerfiles.mst.edu\dfs\software\loginscripts\im', $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 'C:\temp',);
use InstallMonkey::Shared;
my $sourcefilesdir = get_pkg_sourcefiles();
my $startFESAFE = "$ENV{'PROGRAMDATA'}\\Microsoft\\Windows\\Start Menu\\Programs\\Dassault Systemes SIMULIA fe-safe 2018";

sub preinstall
{
	print "Clearing directories for install:\n";
	# Update - 20170901 - Jason S. Holm
  #	Trying to prevent errors due to the location we are trying to remove not existing.
  #	Used array to reduce the amount of repeated code...allows for more removes if needed.

	my @directory_location = (
    'C:\\Program Files\\Dassault Systemes\\SimulationServices\\V6R2018x',
    'C:\\SIMLUIA'
  );

	my $i = 0;
  my $array_items = @directory_location;
  while ($i &lt; $array_items)
  {
    output("Checking for: $directory_location[$i]...");
    if (-e $directory_location[$i])
    {
      output("location exists, removing...");
      run_command("rd /s /q $directory_location[$i]");
      output("done!\n");
    }
    else
    {
      output("location not found, so no need to remove.\n");
    }

    $i++;

  }

	return 1;
}

#In order to get the "UserIntentions_*.xml" file for silent installs, you must first install abaqus manually.
#This is most easily done by running the suite installer through the GUI installer, which will call each individual
#	component GUI installer for you to click through. After each component completion, make note of the installer path
#	using psexec or simliar, and find the UserIntentions file in &lt;install_dir&gt;\InstallData and copy to the $appdeploy
#	source based on the path shown in psexec. Close the component installer after getting the path, but before copying
#	UserIntentions because otherwise UserIntentions won't exist.
#Abaqus tends to change install file layouts between versions, so hopefully that will lessen the headache of that.
#Do match the order that the suite installer uses. Things are dependent on each other and will fail if out of order.
sub install
{
	$| = 1;
	my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\abaqus.2018\\2018.AM_SIM_Abaqus_Extend.AllOS.4-4\\AM_SIM_Abaqus_Extend.AllOS";

	#SIMULIA Documentation
	my $command = $appdeploy."\\1\\SIMULIA_Documentation\\AllOS\\1\\StartTUI.exe --silent $appdeploy\\1\\SIMULIA_Documentation\\AllOS\\1\\UserIntentions_DOC.xml";
	output("\n  Installing Abaqus 2018 Documentation with command: $command\n\n");
	run_command($command, 'IgnoreReturnCode'=&gt;1);
	output("  Setup Done.\n");

	#install Simulation Services
  $command = $appdeploy."\\1\\SIMULIA_AbaqusServices\\Windows64\\1\\StartTUI.exe --silent $appdeploy\\1\\SIMULIA_AbaqusServices\\Windows64\\1\\UserIntentions_CODE.xml";
  output("\n  Installing Abaqus 2018 Simulation Services: $command\n\n");
  run_command($command, 'IgnoreReturnCode'=&gt;1);
  output("  Setup Done.\n");

	#install 3DEXPERIENCE CAA API
	$command = $appdeploy."\\1\\SIMULIA_AbaqusServices_CAA_API\\Windows64\\1\\StartTUI.exe --silent $appdeploy\\1\\SIMULIA_AbaqusServices_CAA_API\\Windows64\\1\\UserIntentions_CAA.xml";
  output("\n  Installing Abaqus 2018 3DExperience CAA API: $command\n\n");
  run_command($command, 'IgnoreReturnCode'=&gt;1);
  output("  Setup Done.\n");

	#install CAE
  $command = $appdeploy."\\1\\SIMULIA_Abaqus_CAE\\Windows64\\1\\StartTUI.exe --silent $appdeploy\\1\\SIMULIA_Abaqus_CAE\\Windows64\\1\\UserIntentions_CODEt.xml";
  output("\n  Installing Abaqus 2018 CAE with command: $command\n\n");
  run_command($command, 'IgnoreReturnCode'=&gt;1);
  output("  Setup Done.\n");

	#install Fe-Safe
	$command = $appdeploy."\\2\\SIMULIA_fesafe\\Windows64\\1\\StartTUI.exe --silent $appdeploy\\2\\SIMULIA_fesafe\\Windows64\\1\\UserIntentions_CODE.xml";
	output("\n  Installing Abaqus 2018 Fe Safe with command: $command\n\n");
	run_command($command, 'IgnoreReturnCode'=&gt;1);
	output("  Setup Done.\n");

	#install Tosca
	$command = $appdeploy."\\2\\SIMULIA_Tosca\\Windows64\\1\\StartTUI.exe --silent $appdeploy\\2\\SIMULIA_Tosca\\Windows64\\1\\UserIntentions_CODEt.xml";
  output("\n  Installing Abaqus 2018 Tosca with command: $command\n\n");
  run_command($command, 'IgnoreReturnCode'=&gt;1);
  output("  Setup Done.\n");

	#install Isight
  $command = $appdeploy."\\2\\SIMULIA_Isight\\Windows64\\1\\StartTUI.exe --silent $appdeploy\\2\\SIMULIA_Isight\\Windows64\\1\\UserIntentions_CODEt.xml";
  output("\n  Installing Abaqus 2018 Isight with command: $command\n\n");
  run_command($command, 'IgnoreReturnCode'=&gt;1);
  output("  Setup Done.\n");


	# Added 5/30/2018
  sleep(30);

  my $firewallAdd = "netsh advfirewall firewall add rule name=\"Abaqus 2018\" dir=in action=allow program=\"C:\\simulia\\CAE\\2018\\win_b64\\code\\bin\\abqcaek.exe\" enable=yes";
  if(run_command($firewallAdd))
  {
    output("added firewall exception\n");
  }
  else
  {
    output("$firewallAdd didn't work\n");
  }


  return 1;
}


sub checkReg {
  my $env_var = shift;

  return $Registry-&gt;{"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment\\\\".$env_var};
}

#recursive directory deleter
sub deldir
{
	my $trg = shift;

	print "looking in $trg\n";
	opendir(my $dh, $trg) or return 1;

	my $thing;
	for $thing (readdir $dh)
	{
		chomp $trg;
		chomp $thing;
		if($thing eq '.' or $thing eq '..')
		{
			next;
		}
		elsif(-f $trg.'\\'.$thing)
		{
			print "found file: $thing\n";
			unlink $trg."\\".$thing;
		}
		elsif(-d $trg.'\\'.$thing)
		{
			print "found dir: $thing\n";
			deldir($trg.'\\'.$thing);
			rmdir $trg."\\".$thing;
			print "emptied and deleted $thing\n";
		}
	}
}

sub postinstall
{
	# Abaqus 2018 doesn't seem to have any *.lnk files in its \appdeploy\ folder.
  # Keeping this code from the 2016 version here for future reference
	my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\abaqus.2018\\unload";
	my $start = "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Dassault Systemes SIMULIA Abaqus CAE 2018";
	my $desk = get_allusers_desktop();

	# Abaqus 2018 doesn't seem to have *.lnk files in its \SourceFiles\ directory
	# Keeping this code from the 2017 version here for future reference
	my $localfile = "C:\\SourceFiles\\abaqus.2018\\CustomStartMenuItems";

	output("Deleting shortcuts. . .\n");
	if(-e $start."\\Abaqus CAE.lnk")
	{
		unless(-e "C:\\temp")
		{
			mkdir "C:\\temp";
		}
		unlink $start."\\Abaqus CAE.lnk";
		copy($appdeploy."\\Abaqus CAE.lnk", $start);
		copy($localfile."\\Abaqus CAE.lnk", $start);
	}
	else
	{
		output "Couldn't find the file\n";
	}

# not needed for 2018?
#=pod
	output("Adding Abaqus License Variable...\n");

	#my $lm_reg = checkReg('LM_LICENSE_FILE'); #normally what's used, not here tho
	my $lm_reg = checkReg('FLEXNET_ABAQUS_LICENSE_FILE');

	 if (!defined($lm_reg) || ($lm_reg !~ m/\b1751\@abaqus-teaching\.lic\.mst\.edu\b/i)) {
		output("Adding 1751\@abaqus-teaching.lic.mst.edu to FLEXNET_ABAQUS_LICENSE_FILE\n");

		my @paths = split(/;/,$lm_reg || '');
		push(@paths,'1751@abaqus-teaching.lic.mst.edu');

		my @command = (
			'SETX.EXE',
			'LM_LICENSE_FILE',
			'"'.join(';',@paths).'"',
			(is_XP()?'-M':'/M'),
		);
		if(run_command(join(' ',@command))) {
			output("Success!\n");
		}
		else {
			output("Failed.\n");
			return 0;
		}
	}
	else {
		output("License already configured.\n");
	}

	# Place autoit script in place of shortcut
	output("Placing script: ");
	if(!run_command("copy /Y \"$sourcefilesdir\\autoit\\fe-safe 2018.lnk\" \"$startFESAFE\\fe-safe 2018.lnk\"")){
		output("FAILED:$!\nProgram will not be licensed on first launch!\n");
	}
	output("OK\n");
#=cut

	output("Removing desktop shortcuts: ");
	run_command("DEL /Q \"$desk\\Isight 2018 Design Gateway.lnk\"");
	run_command("DEL /Q \"$desk\\SIMULIA Execution Engine 2018 Station.lnk\"");
	output("OK\n");

  return 1;
}

do_install(
	no_source_files  =&gt; 1,
	allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
	allowed_os_architectures =&gt; [OSARCH_x64],
	allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
	exit_on_failure =&gt; 1,
	preinstall_sub =&gt; \&amp;preinstall,
	install_sub =&gt; \&amp;install,
	postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\acis_3d.21\dev\update.pl</FullName>
    <Length>2551</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-07-18T10:21:35.5643977-05:00</CreationTime>
    <CreationTimeUtc>2017-07-18T15:21:35.5643977Z</CreationTimeUtc>
    <LastWriteTime>2017-07-20T14:54:33.7271804-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-07-20T19:54:33.7271804Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-18T10:21:35.6112695-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-18T15:21:35.6112695Z</LastAccessTimeUtc>
    <Text># Package Name: ACIS 3D Modeler R21
# Package Created: July 18, 2017
# Packaged by: Jason S. Holm
# Last Updated: July 20, 2017 (updated the setup.iss file)

=pod

Begin-Doc
Modified: $Date$
Name: ACIS 3D Modeler R21
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the module.

our %INSTALLMONKEY_OPTIONS;
BEGIN {
       %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'acis_3d.21',
        package_revision =&gt; '201707200900',
       );
      }

# Add InstallMonkey Library to the path
my $umrinst = $ENV{'WINDIR'}.'\\SYSTEM32\\UMRINST';
use lib (
         '\\\\minerfiles.mst.edu\\dfs\\software\\loginscripts\\im',
         '$umrinst',
         'C:\\temp',
        );

use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
sub install 
{
 my $srcfiles = get_pkg_sourcefiles();

 # Build the ACIS install command.
 # "/s",
 # "\"C:\\SourceFiles\\acis_3d.21\\setup.iss\"",
 
 my @command_acis = (
                     "\"C:\\SourceFiles\\acis_3d.21\\r21sp2_acis_win_10_64\\setup.exe\"",
					 "/s",
					 "/f1\"C:\\SourceFiles\\acis_3d.21\\setup.iss\"",",
					);

 print "\nInstalling ACIS: ";
 if (!run_command(join(' ',@command_acis)))
 {
  output("Install Fail!\n");
  # print "Failure!\n";
  return 0;
 }
 else
 {
  output("Install Success!\n");
  # print "Success!\n";
 }
 return 1;
}

sub postinstall
{
 # Create Start Menu Folder - ACIS
 print "Creating start menu folder for ACIS 3D...";
 run_command("if not exist \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\ACIS 3D\\.\" mkdir \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\ACIS 3D\"");
 print "done!\n";
 
 # Create Start Menu Program Shortcut - ACIS 3D.lnk
 print "Creating program link in ACIS 3D start menu folder...";
 run_command("xcopy \"C:\\SourceFiles\\acis_3d.21\\ACIS 3D.lnk\" \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\ACIS 3D\\\" /y");
 print "done!\n";
 
}

do_install( 
           allowed_versions =&gt; ['OSVER_WIN7_SP0', 'OSVER_WIN7_SP1', 'OSVER_WIN10_SP0'],
           allowed_os_architectures =&gt; ['x64', 'OSARCH_x64', 'AMD64'],
           allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-desktop'],
           exit_on_failure =&gt; 1,
           install_sub =&gt; \&amp;install,
		   postinstall_sub =&gt; \&amp;postinstall,
          );

# ALL installers need to have an explicit exit code.
IM_Exit('EXIT_SUCCESS');</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\acis_3d.21\prod\update.pl</FullName>
    <Length>2454</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-07-20T09:04:56.2704853-05:00</CreationTime>
    <CreationTimeUtc>2017-07-20T14:04:56.2704853Z</CreationTimeUtc>
    <LastWriteTime>2017-07-20T15:44:33.4263581-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-07-20T20:44:33.4263581Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-20T15:08:48.1366467-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-20T20:08:48.1366467Z</LastAccessTimeUtc>
    <Text># Package Name: ACIS 3D Modeler R21
# Package Created: July 18, 2017
# Packaged by: Jason S. Holm
# Last Updated: July 20, 2017 (updated the setup.iss file)

=pod

Begin-Doc
Modified: $Date$
Name: ACIS 3D Modeler R21
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the module.

our %INSTALLMONKEY_OPTIONS;
BEGIN {
       %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'acis_3d.21',
        package_revision =&gt; '201707200900',
       );
      }

# Add InstallMonkey Library to the path
my $umrinst = $ENV{'WINDIR'}.'\\SYSTEM32\\UMRINST';
use lib (
         '\\\\minerfiles.mst.edu\\dfs\\software\\loginscripts\\im',
         '$umrinst',
         'C:\\temp',
        );

use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
sub install 
{
 my $srcfiles = get_pkg_sourcefiles();

 my @command_acis = (
                     "\"C:\\SourceFiles\\acis_3d.21\\r21sp2_acis_win_10_64\\setup.exe\"",
					 "/s",
					 "/f1\"C:\\SourceFiles\\acis_3d.21\\setup.iss\"",
					);

 print "\nInstalling ACIS: ";
 if (!run_command(join(' ',@command_acis)))
 {
  output("Install Fail!\n");
  # print "Failure!\n";
  return 0;
 }
 else
 {
  output("Install Success!\n");
  # print "Success!\n";
 }
 return 1;
}

sub postinstall
{
 # Create Start Menu Folder - ACIS
 print "Creating start menu folder for ACIS 3D...";
 run_command("if not exist \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\ACIS 3D\\.\" mkdir \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\ACIS 3D\"");
 print "done!\n";
 
 # Create Start Menu Program Shortcut - ACIS 3D.lnk
 print "Creating program link in ACIS 3D start menu folder...";
 run_command("xcopy \"C:\\SourceFiles\\acis_3d.21\\ACIS 3D.lnk\" \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\ACIS 3D\\\" /y");
 print "done!\n";
 
}

do_install( 
           allowed_versions =&gt; ['OSVER_WIN7_SP0', 'OSVER_WIN7_SP1', 'OSVER_WIN10_SP0'],
           allowed_os_architectures =&gt; ['x64', 'OSARCH_x64', 'AMD64'],
           allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-desktop'],
           exit_on_failure =&gt; 1,
           install_sub =&gt; \&amp;install,
		   postinstall_sub =&gt; \&amp;postinstall,
          );

# ALL installers need to have an explicit exit code.
IM_Exit('EXIT_SUCCESS');</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\ads.2017\prod\update.pl</FullName>
    <Length>1666</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-20T13:49:14.3055676-06:00</CreationTime>
    <CreationTimeUtc>2017-11-20T19:49:14.3055676Z</CreationTimeUtc>
    <LastWriteTime>2017-11-27T13:26:04.1876523-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-11-27T19:26:04.1876523Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-20T13:49:14.3055676-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-20T19:49:14.3055676Z</LastAccessTimeUtc>
    <Text># ADS 2017
# Package Created Nov 2017
# Packaged by Austin Wall

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'ADS.2017',
        package_revision =&gt; '20171127T1326',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();

sub preinstall
{
    output("Creating ADS_LICENSE_FILE: ");
    if(!add_environment_variable("ADS_LICENSE_FILE", "1790\@ads.lic.mst.edu"))
    {
        output("FAILED\n");
        return 0;
    }
    output("OK\n");
    
    return 1;
}

sub install
{
    output("Installing ADS 2017: ");
    if (!run_command("\"$srcfiles\\ads2017_shp.exe\" -i silent -f \"$srcfiles\\installer.properties\""))
    {
        output("FAILED\n");
        return 0;
    }
    output("OK\n");

    return 1;
}

sub postinstall
{
    # output("Fixing registry ... ");
    # if (!run_command("regedit /s \"$srcfiles\\ads.reg\""))
    # {
        # output("[ERROR]\n");
        # return 0;
    # }

    my $remove_dir = $ENV{'SystemDrive'}.'\temp\hpeesof';
    if (-e "${remove_dir}")
    {
        run_command("RD /S /Q \"$remove_dir\"");
    }

    return 1;
}

do_install(
    allowed_versions =&gt; [ OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [ 'clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\aggflow.459_190\dev\update.pl</FullName>
    <Length>2108</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-01-04T10:14:26.947667-06:00</CreationTime>
    <CreationTimeUtc>2018-01-04T16:14:26.947667Z</CreationTimeUtc>
    <LastWriteTime>2018-01-04T10:50:40.4942534-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-04T16:50:40.4942534Z</LastWriteTimeUtc>
    <LastAccessTime>2018-01-04T10:14:26.947667-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-01-04T16:14:26.947667Z</LastAccessTimeUtc>
    <Text># Aggflow 459.190
# Package Created March 22, 2012
# Packaged by Eric Boyer
# Last Updated by Dillon Lustick

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'aggflow.459_190',
        package_revision =&gt; '20171117T190',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

use Getopt::Long;

######
GetOptions(
    'uninstall' =&gt; sub { exit(!uninstall()); },
) || die "Usage: $!";

sub install
{
  my $command = get_pkg_sourcefiles();
  $command = $command . '\\installAggFlowDM.exe /s';
  #$command = $command . '\\installAggFlowDM.msi /quiet';

  if (run_command($command))
  {
    output("Install successful.\n");
    return 1;
  }
  else
  {
    output("Install failed: $!");
    return 0;
  }
}
sub postinstall
{
    #Give users permissions on the installation folder. AggFlow doesn't run an updater program to update itself, so the only way to update it is to let the user update it.
    output( "Granting users installation access: " );
    if( !run_command( "icacls C:\\Program\ Files (x86)\\AggFlow DM\" /T /C /grant Users:(OI)(CI)M" ) )
    {
    output( "FAILED to grant permissions: $!\n" );
    return 0;
    }
    output( "Successfully granted permissions!\n" );
    return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\aggflow.459_190\prod\update.pl</FullName>
    <Length>2879</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-17T12:46:11.4168987-06:00</CreationTime>
    <CreationTimeUtc>2017-11-17T18:46:11.4168987Z</CreationTimeUtc>
    <LastWriteTime>2018-01-04T12:56:42.9723488-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-04T18:56:42.9723488Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-17T12:46:11.4168987-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-17T18:46:11.4168987Z</LastAccessTimeUtc>
    <Text># Aggflow 454.48
# Package Created March 22, 2012
# Packaged by Eric Boyer
# Last Updated by Daniel T. Holtzclaw

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'aggflow.459_190',
        package_revision =&gt; '20171117T190',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

use Getopt::Long;
######
GetOptions(
    'uninstall' =&gt; sub { exit(!uninstall()); },
) || die "Usage: $!";


sub uninstall {
    output("\nUninstalling AggFlow: ");
    run_command("rmdir \"%programfiles(X86)%\\AggFlow DM\" /q /s");
    run_command("rmdir \"%programdata%\\Microsoft\\Windows\\Start Menu\\Programs\\AggFlow\" /q /s");

    output("Success!\n\n");

    delete_product_registry_key(get_package_name() . "." . get_version());

    return 1;
}

my $srcfiles= get_pkg_sourcefiles();

sub install
{
  output("\nInstalling Aggflow: ");

  run_command("del \"\%programfiles(X86)%\\AggFlow DM\" /q /s");
  run_command("mkdir \"\%programfiles(x86)%\\AggFlow DM\"");
  run_command("xcopy \"$srcfiles\\AggFlow DM\" \"\%programfiles(x86)%\\AggFlow DM\" /E /Q /I");

  #Create a start menu folder for AggFlow so people can find it
  run_command("mkdir \"\%programdata%\\Microsoft\\Windows\\Start Menu\\Programs\\AggFlow\"");
  #Copy the shortcut to AggFlow to the start menu folder created above
  run_command("move \"\%programfiles(x86)%\\AggFlow DM\\AggFlow.lnk\" \"\%programdata%\\Microsoft\\Windows\\Start Menu\\Programs\\AggFlow\"");

  output("Success\n");

  return 1;
}

sub postinstall
{
    #Give users permissions on the installation folder. AggFlow doesn't run an updater program to update itself, so the only way to update it is to let the user update it.
    output( "Granting users installation access: " );
    if( !run_command( "icacls \"\%programfiles(x86)%\\AggFlow DM\" /T /C /grant Users:(OI)(CI)M" ) )
    {
    output( "FAILED to grant permissions: $!\n" );
    return 0;
    }
    output( "Successfully granted permissions!\n" );
    return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\an1310.1_05r\prod\update.pl</FullName>
    <Length>1436</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-25T15:21:49.6325384-05:00</CreationTime>
    <CreationTimeUtc>2018-05-25T20:21:49.6325384Z</CreationTimeUtc>
    <LastWriteTime>2018-05-25T15:28:55.5800525-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-25T20:28:55.5800525Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-25T15:21:49.6325384-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-25T20:21:49.6325384Z</LastAccessTimeUtc>
    <Text>#AN1310 1.05r
# Package Created May 25th, 2018
# Packaged by Cameron Loren
# Last updated by Cameron Loren

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'an1310.1_05r',
        package_revision =&gt; '20180522T1522',
    );
}

# Add InstallMonkey Library to the path
use lib (
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
sub install{
	output("Installing AN1310 1.05r\n");
    if(!run_command("\"$sourcefilesdir\\Serial Bootloader AN1310 v1.05r.exe\" /S"))
    {
        output("AN1310 1.05r installation did not complete!\n");
        return 0;
    }
    else{
        output("AN1310 1.05r installation was successful!\n");
    }
    return 1;
}

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                     'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
	  need_reboot =&gt; 0,
    install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\anaconda.4_3_1\dev\update.pl</FullName>
    <Length>1350</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-05T15:28:45.4800683-05:00</CreationTime>
    <CreationTimeUtc>2017-06-05T20:28:45.4800683Z</CreationTimeUtc>
    <LastWriteTime>2017-08-25T12:21:35.8249391-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-08-25T17:21:35.8249391Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-05T15:28:45.4800683-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-05T20:28:45.4800683Z</LastAccessTimeUtc>
    <Text>
    # anaconda
    # Package Created June 05, 2017
    # Packaged by Krueger, Benjamin (S&amp;T IT Student Employee)
    # Last Updated August 25, 2017 by Alexander Schrimpf

    BEGIN {
        %::INSTALLMONKEY_OPTIONS = (
            package_id =&gt; 'anaconda.4_3_1',
            package_revision =&gt; '20170605T1528',
        );
    }

    use lib (
        '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
        $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
        'C:\temp',
    );
    use InstallMonkey::Shared;

    my $srcfiles = get_pkg_sourcefiles();
    my $log_dir = get_applogs_dir();

    sub install {
        output(get_package_id());
        my $success = run_command($srcfiles."\\Anaconda3-4.3.1-Windows-x86_64.exe /InstallationType=AllUsers /S");
        output(($success)?"OK\n":"FAILED\n");
        return $success;
    }

    do_install( 
        exit_on_failure =&gt; 1,
        allowed_versions          =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
        allowed_os_architectures  =&gt; [ OSARCH_x64 ],
        allowed_regs              =&gt; [ "clc", "desktop", "traveling", "virtual-desktop", "virtual-clc" ],
        install_sub               =&gt; \&amp;install,

        
    );

    IM_Exit(EXIT_SUCCESS);

    ########################################################################
    </Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\anaconda.4_3_1\prod\update.pl</FullName>
    <Length>1350</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-08-25T12:31:41.1307376-05:00</CreationTime>
    <CreationTimeUtc>2017-08-25T17:31:41.1307376Z</CreationTimeUtc>
    <LastWriteTime>2018-05-01T23:19:23.8205565-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-02T04:19:23.8205565Z</LastWriteTimeUtc>
    <LastAccessTime>2017-08-25T12:31:41.1307376-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-08-25T17:31:41.1307376Z</LastAccessTimeUtc>
    <Text>
    # anaconda
    # Package Created June 05, 2017
    # Packaged by Krueger, Benjamin (S&amp;T IT Student Employee)
    # Last Updated August 25, 2017 by Alexander Schrimpf

    BEGIN {
        %::INSTALLMONKEY_OPTIONS = (
            package_id =&gt; 'anaconda.4_3_1',
            package_revision =&gt; '20170605T1528',
        );
    }

    use lib (
        '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
        $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
        'C:\temp',
    );
    use InstallMonkey::Shared;

    my $srcfiles = get_pkg_sourcefiles();
    my $log_dir = get_applogs_dir();

    sub install {
        output(get_package_id());
        my $success = run_command($srcfiles."\\Anaconda3-4.3.1-Windows-x86_64.exe /InstallationType=AllUsers /S");
        output(($success)?"OK\n":"FAILED\n");
        return $success;
    }

    do_install( 
        exit_on_failure =&gt; 1,
        allowed_versions          =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
        allowed_os_architectures  =&gt; [ OSARCH_x64 ],
        allowed_regs              =&gt; [ "clc", "desktop", "traveling", "virtual-desktop", "virtual-clc" ],
        install_sub               =&gt; \&amp;install,

        
    );

    IM_Exit(EXIT_SUCCESS);

    ########################################################################
    </Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\androidstudio.2_3_1\prod\update.pl</FullName>
    <Length>2378</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-05-31T09:34:29.9766103-05:00</CreationTime>
    <CreationTimeUtc>2017-05-31T14:34:29.9766103Z</CreationTimeUtc>
    <LastWriteTime>2017-05-31T14:48:00.9215184-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-05-31T19:48:00.9215184Z</LastWriteTimeUtc>
    <LastAccessTime>2017-05-31T09:34:29.9766103-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-05-31T14:34:29.9766103Z</LastAccessTimeUtc>
    <Text>#Android Studio 2.3.1
#Package Created June 2016
#Packaged by Chris Schaaf
#Last Updated May 2017 by cts28d

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;
use File::Copy;
use File::Spec;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'androidstudio.2_3_1',
        package_revision =&gt; '20170531T1445',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\\dfs\\software\\loginscripts\\im',
    $ENV{'WINDIR'}.'\\SYSTEM32\\UMRINST',
    'C:\\temp',
);
use InstallMonkey::Shared;

use Getopt::Long;

sub usage {
    print qq(
usage: $0 [--help] [--uninstall]

);
}
GetOptions(
    'help' =&gt; sub { usage(); exit(0); },
    'uninstall' =&gt; sub { exit(!uninstall()); },
);

my $sourcefilesdir = get_pkg_sourcefiles();
my $installer = build_path(get_pkg_sourcefiles(), "android-studio-bundle-162.3871768-windows.exe");

do_install(
	allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1],
	allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
	allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
	exit_on_failure =&gt; 1,
	
	install_sub =&gt; \&amp;install,
	postinstall_sub =&gt; \&amp;postinst_sub,
);
IM_Exit(EXIT_SUCCESS);

sub uninstall {
  my $success = run_command("\"C:\\Program Files\\Android\\Android Studio\\uninstall.exe\" /S") ;
  if ($success) {
    output("Success!\n");
    delete_product_registry_key(get_package_name().".".get_version());
  }
  else {
    output("FAILED!\n");
  }

  return $success;
}


sub install{
	output("Installing Android Studio 2.3.1...\n");
	#set args for:
	my $args = " /S";
	my $outcome = run_command($installer . $args, 'IgnoreReturnCode' =&gt; 1);
	if(!$outcome){
		#ignores return code "1223" which fails install but seems to have no real effect on program
		output("Android Studio 2.3.1 installed.\n");
	}
	else{ 
		output("Android Studio Install Failed.\n");
		return 0;
	}
	return 1;
}


sub postinst_sub{
	#may have to add in JAVA_HOME $ENV var creation here, but it works as tested so not doing it for now
	return 1;

}</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\ansys.17_1\prod\update.pl</FullName>
    <Length>3097</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-06-14T11:48:23.3793917-05:00</CreationTime>
    <CreationTimeUtc>2016-06-14T16:48:23.3793917Z</CreationTimeUtc>
    <LastWriteTime>2016-09-27T15:49:09.4601727-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-09-27T20:49:09.4601727Z</LastWriteTimeUtc>
    <LastAccessTime>2016-06-14T11:48:23.4105921-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-06-14T16:48:23.4105921Z</LastAccessTimeUtc>
    <Text># Ansys 17.1
# Package Created June 2016
# Packaged by Ronith (based on Dane Greer's 2014 package)
# Last Updated ...

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'ansys.17_1',
        package_revision =&gt; '20160614T1150',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;
my $installtype = 'research';
GetOptions('clc' =&gt; sub{$installtype = 'clc';});
my $sourcefilesdir = get_pkg_sourcefiles();
my $applogs=get_applogs_dir();
my $programfiles = get_arch_programfiles(OSARCH_x64);


sub install{
	output("Installing Ansys 17.1\n");
	output("Installation may take an hour or more...\n");
    if(!run_command("start /wait \"\" $sourcefilesdir\\disk1\\setup.exe -silent -media_dir2 $sourcefilesdir\\disk2"))
    {
        output("ANSYS 17.1 installation did not complete!\n");
        return 0;
    }
    else{
        output("ANSYS 17.1 installation was successful!\n");
    }
    return 1;
}

sub postinstall{
    my $licdir = "$programfiles\\ANSYS Inc\\Shared Files\\Licensing";
	my $if_clc = "clc";
	my $machine_type = get_machine_type();
	output("$machine_type\n");
	if(! -d $licdir) 
		{
			run_command("mkdir \"$licdir\"");
		}
	if($machine_type == $if_clc || $installtype == 'clc'){
		if(!run_command("COPY \"$sourcefilesdir\\classroom license\\ansyslmd.ini\" \"$licdir\""))
		{
			output("Copying license files has failed! Please restart the installation!\n");
			return 0;
		} else{
			output("License file was installed!\n");
		}
	}
	elsif($installtype == 'research') # I don't know why we default install the research license..
	{
		if(!run_command("COPY \"$sourcefilesdir\\research license\\ansyslmd.ini\" \"$licdir\""))
		{
			output("Copying license files has failed! Please restart the installation!\n");
			return 0;
		} else{
			output("License file was installed!\n");
		}
	}
    output("addding firewall exceptions\n");
	# add firewall exceptions
	# this causes trouble sometimes
	if(!run_command("netsh -f \"$sourcefilesdir\\firewallexceptions.txt\""))
	{
		output("Firewall exceptions have not be entered!\n");
	}
    #copy error logs
    return 1;    
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN10_SP0,OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\ansys.18\prod\update.pl</FullName>
    <Length>3072</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-05-22T15:14:52.2453511-05:00</CreationTime>
    <CreationTimeUtc>2017-05-22T20:14:52.2453511Z</CreationTimeUtc>
    <LastWriteTime>2017-05-23T09:57:28.7164213-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-05-23T14:57:28.7164213Z</LastWriteTimeUtc>
    <LastAccessTime>2017-05-22T15:14:52.2453511-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-05-22T20:14:52.2453511Z</LastAccessTimeUtc>
    <Text># Ansys 18
# Package Created June 2016 for 18
# Packaged by Ronith (based on Dane Greer's 2014 package)
# Last Updated May 2017 by cts28d

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'ansys.18',
        package_revision =&gt; '20170522T1515',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;
my $installtype = 'research';
GetOptions('clc' =&gt; sub{$installtype = 'clc';});
my $src = get_pkg_sourcefiles();
my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\ansys.18";
my $applogs=get_applogs_dir();
my $programfiles = get_arch_programfiles(OSARCH_x64);


sub install {
	output("Installing Ansys 18\n");
	output("Installation may take an hour or more...\n");
    if(!run_command("start /wait \"\" \"$appdeploy\\disk1\\setup.exe\"
			-silent -media_dir2 \"$appdeploy\\disk2\"")) {
        output("ANSYS 18 installation did not complete!\n");
        return 0;
    }
    else {
        output("ANSYS 18 installation was successful!\n");
    }
    return 1;
}

sub postinstall {
    my $licdir = "$programfiles\\ANSYS Inc\\Shared Files\\Licensing";
	my $if_clc = "clc";
	my $machine_type = get_machine_type();
	output("$machine_type\n");
	if(! -d $licdir) {
			run_command("mkdir \"$licdir\"");
		}
	if($machine_type == $if_clc || $installtype == 'clc'){
		if(!run_command("COPY \"$src\\classroom license\\ansyslmd.ini\" \"$licdir\"")) {
			output("Copying license files has failed! Please restart the installation!\n");
			return 0;
		} else {
			output("License file was installed!\n");
		}
	}
	elsif($installtype == 'research') {
		if(!run_command("COPY \"$src\\research license\\ansyslmd.ini\" \"$licdir\"")) {
			output("Copying license files has failed! Please restart the installation!\n");
			return 0;
		} else {
			output("License file was installed!\n");
		}
	}
    output("addding firewall exceptions\n");
	# add firewall exceptions
	# this causes trouble sometimes
	if(!run_command("netsh -f \"$src\\firewallexceptions.txt\"")) {
		output("Firewall exceptions have not be entered!\n");
	}
    #copy error logs
    return 1;    
}

do_install ( 
    allowed_versions =&gt; [OSVER_WIN10_SP0,OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\ansys.18_1\prod\update.pl</FullName>
    <Length>3086</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-05-26T13:39:43.9794261-05:00</CreationTime>
    <CreationTimeUtc>2017-05-26T18:39:43.9794261Z</CreationTimeUtc>
    <LastWriteTime>2017-05-26T13:42:10.7470485-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-05-26T18:42:10.7470485Z</LastWriteTimeUtc>
    <LastAccessTime>2017-05-26T13:39:43.9794261-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-05-26T18:39:43.9794261Z</LastAccessTimeUtc>
    <Text># Ansys 18.1
# Package Created June 2016 for 18.1
# Packaged by Ronith (based on Dane Greer's 2014 package)
# Last Updated May 2017 by cts28d

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'ansys.18_1',
        package_revision =&gt; '20170522T1515',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;
my $installtype = 'research';
GetOptions('clc' =&gt; sub{$installtype = 'clc';});
my $src = get_pkg_sourcefiles();
my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\ansys.18_1";
my $applogs=get_applogs_dir();
my $programfiles = get_arch_programfiles(OSARCH_x64);


sub install {
	output("Installing Ansys 18.1\n");
	output("Installation may take an hour or more...\n");
    if(!run_command("start /wait \"\" \"$appdeploy\\disk1\\setup.exe\"
			-silent -media_dir2 \"$appdeploy\\disk2\"")) {
        output("ANSYS 18.1 installation did not complete!\n");
        return 0;
    }
    else {
        output("ANSYS 18.1 installation was successful!\n");
    }
    return 1;
}

sub postinstall {
    my $licdir = "$programfiles\\ANSYS Inc\\Shared Files\\Licensing";
	my $if_clc = "clc";
	my $machine_type = get_machine_type();
	output("$machine_type\n");
	if(! -d $licdir) {
			run_command("mkdir \"$licdir\"");
		}
	if($machine_type == $if_clc || $installtype == 'clc'){
		if(!run_command("COPY \"$src\\classroom license\\ansyslmd.ini\" \"$licdir\"")) {
			output("Copying license files has failed! Please restart the installation!\n");
			return 0;
		} else {
			output("License file was installed!\n");
		}
	}
	elsif($installtype == 'research') {
		if(!run_command("COPY \"$src\\research license\\ansyslmd.ini\" \"$licdir\"")) {
			output("Copying license files has failed! Please restart the installation!\n");
			return 0;
		} else {
			output("License file was installed!\n");
		}
	}
    output("addding firewall exceptions\n");
	# add firewall exceptions
	# this causes trouble sometimes
	if(!run_command("netsh -f \"$src\\firewallexceptions.txt\"")) {
		output("Firewall exceptions have not be entered!\n");
	}
    #copy error logs
    return 1;    
}

do_install ( 
    allowed_versions =&gt; [OSVER_WIN10_SP0,OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\ansys.19_1\prod\update.pl</FullName>
    <Length>3119</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-29T09:02:47.2244106-05:00</CreationTime>
    <CreationTimeUtc>2018-05-29T14:02:47.2244106Z</CreationTimeUtc>
    <LastWriteTime>2018-06-05T08:13:06.5390252-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-05T13:13:06.5390252Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-29T09:02:47.2244106-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-29T14:02:47.2244106Z</LastAccessTimeUtc>
    <Text># Ansys 18.1
# Package Created June 2016 for 18.1
# Packaged by Ronith (based on Dane Greer's 2014 package)
# Updated May 2017 by cts28d
# Last Updated May 2018 by Gavin Altermatt

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'ansys.19_1',
        package_revision =&gt; '20180605T0813',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;
my $installtype = 'research';
GetOptions('clc' =&gt; sub{$installtype = 'clc';});
my $src = get_pkg_sourcefiles();
my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\ansys.19_1";
my $applogs=get_applogs_dir();
my $programfiles = get_arch_programfiles(OSARCH_x64);


sub install {
	output("Installing Ansys 19.1\n");
	output("Installation may take an hour or more...\n");
    if(!run_command("start /wait \"\" \"$appdeploy\\disk1\\setup.exe\"
			-silent -media_dir2 \"$appdeploy\\disk2\"")) {
        output("ANSYS 19.1 installation did not complete!\n");
        return 0;
    }
    else {
        output("ANSYS 19.1 installation was successful!\n");
    }
    return 1;
}

sub postinstall {
    my $licdir = "$programfiles\\ANSYS Inc\\Shared Files\\Licensing";
	my $if_clc = "clc";
	my $machine_type = get_machine_type();
	output("$machine_type\n");
	if(! -d $licdir) {
			run_command("mkdir \"$licdir\"");
		}
	if($machine_type == $if_clc || $installtype == 'clc'){
		if(!run_command("COPY \"$src\\classroom license\\ansyslmd.ini\" \"$licdir\"")) {
			output("Copying license files has failed! Please restart the installation!\n");
			return 0;
		} else {
			output("License file was installed!\n");
		}
	}
	elsif($installtype == 'research') {
		if(!run_command("COPY \"$src\\research license\\ansyslmd.ini\" \"$licdir\"")) {
			output("Copying license files has failed! Please restart the installation!\n");
			return 0;
		} else {
			output("License file was installed!\n");
		}
	}
    output("addding firewall exceptions\n");
	# add firewall exceptions
	# this causes trouble sometimes
	if(!run_command("netsh -f \"$src\\firewallexceptions.txt\"")) {
		output("Firewall exceptions have not be entered!\n");
	}
    #copy error logs
    return 1;
}

do_install (
    allowed_versions =&gt; [OSVER_WIN10_SP0,OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update1CLC.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\ansys.19_1\prod\update1CLC.pl</FullName>
    <Length>2766</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-05T08:22:13.662468-05:00</CreationTime>
    <CreationTimeUtc>2018-06-05T13:22:13.662468Z</CreationTimeUtc>
    <LastWriteTime>2018-06-05T08:30:38.8542633-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-05T13:30:38.8542633Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-05T08:22:13.662468-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-05T13:22:13.662468Z</LastAccessTimeUtc>
    <Text># Ansys 19.1
# Package Created June 2016 for 18.1
# Packaged by Ronith (based on Dane Greer's 2014 package)
# Updated May 2017 by cts28d
# Last Updated May 2018 by Gavin Altermatt

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN
{
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'ansys.19_1',
        package_revision =&gt; '20180605T0813',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;
my $installtype = 'research';
GetOptions('clc' =&gt; sub{$installtype = 'clc';});
my $src = get_pkg_sourcefiles();
my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\ansys.19_1";
my $applogs=get_applogs_dir();
my $programfiles = get_arch_programfiles(OSARCH_x64);


sub install
{
	output("Installing Ansys 19.1\n");
	output("Installation may take an hour or more...\n");

  if(!run_command("start /wait \"\" \"$appdeploy\\disk1\\setup.exe\"
		 -silent -media_dir2 \"$appdeploy\\disk2\""))
  {
    output("ANSYS 19.1 installation did not complete!\n");
    return 0;
  }
  else
  {
    output("ANSYS 19.1 installation was successful!\n");
  }

    return 1;
}

sub postinstall
{
  my $licdir = "$programfiles\\ANSYS Inc\\Shared Files\\Licensing";
	my $machine_type = get_machine_type();
	output("$machine_type\n");
	if(! -d $licdir)
  {
			run_command("mkdir \"$licdir\"");
	}

	#clc install
	if(!run_command("COPY \"$src\\classroom license\\ansyslmd.ini\" \"$licdir\""))
  {
		output("Copying license files has failed! Please restart the installation!\n");
		return 0;
	}
  else
  {
		output("License file was installed!\n");
	}

  output("addding firewall exceptions\n");
	# add firewall exceptions
	# this causes trouble sometimes
	if(!run_command("netsh -f \"$src\\firewallexceptions.txt\"")) {
		output("Firewall exceptions have not be entered!\n");
	}
    #copy error logs
    return 1;
}

do_install (
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update1Research.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\ansys.19_1\prod\update1Research.pl</FullName>
    <Length>2772</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-04T14:38:41.922415-05:00</CreationTime>
    <CreationTimeUtc>2018-06-04T19:38:41.922415Z</CreationTimeUtc>
    <LastWriteTime>2018-06-05T08:30:50.4787918-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-05T13:30:50.4787918Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-04T14:38:41.9536566-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-04T19:38:41.9536566Z</LastAccessTimeUtc>
    <Text># Ansys 19.1
# Package Created June 2016 for 18.1
# Packaged by Ronith (based on Dane Greer's 2014 package)
# Updated May 2017 by cts28d
# Last Updated May 2018 by Gavin Altermatt

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN
{
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'ansys.19_1',
        package_revision =&gt; '20180605T0813',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;
my $installtype = 'research';
GetOptions('clc' =&gt; sub{$installtype = 'clc';});
my $src = get_pkg_sourcefiles();
my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\ansys.19_1";
my $applogs=get_applogs_dir();
my $programfiles = get_arch_programfiles(OSARCH_x64);


sub install
{
	output("Installing Ansys 19.1\n");
	output("Installation may take an hour or more...\n");

  if(!run_command("start /wait \"\" \"$appdeploy\\disk1\\setup.exe\"
		 -silent -media_dir2 \"$appdeploy\\disk2\""))
  {
    output("ANSYS 19.1 installation did not complete!\n");
    return 0;
  }
  else
  {
    output("ANSYS 19.1 installation was successful!\n");
  }

    return 1;
}

sub postinstall
{
  my $licdir = "$programfiles\\ANSYS Inc\\Shared Files\\Licensing";
	my $machine_type = get_machine_type();
	output("$machine_type\n");
	if(! -d $licdir)
  {
			run_command("mkdir \"$licdir\"");
	}

  # research install
	if(!run_command("COPY \"$src\\research license\\ansyslmd.ini\" \"$licdir\""))
  {
		output("Copying license files has failed! Please restart the installation!\n");
		return 0;
	}
  else
  {
		output("License file was installed!\n");
	}

  output("addding firewall exceptions\n");
	# add firewall exceptions
	# this causes trouble sometimes
	if(!run_command("netsh -f \"$src\\firewallexceptions.txt\"")) {
		output("Firewall exceptions have not be entered!\n");
	}
    #copy error logs
    return 1;
}

do_install (
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\anyconnect.3_1_05182\prod\update.pl</FullName>
    <Length>1346</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-21T09:47:14.0675379-06:00</CreationTime>
    <CreationTimeUtc>2017-11-21T15:47:14.0675379Z</CreationTimeUtc>
    <LastWriteTime>2017-11-21T11:00:09.4550766-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-11-21T17:00:09.4550766Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-21T09:47:14.0675379-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-21T15:47:14.0675379Z</LastAccessTimeUtc>
    <Text>BEGIN{
    %INSTALLMONKEY_OPTIONS =(
        package_id =&gt; "anyconnect.3_1_05182",
        package_revision =&gt; "20171112T1005"
    )
}

use lib(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;
GetOptions('uninstall' =&gt; sub {exit(!uninstall());});
sub install {
    output("Runninng Anyconnect installation executable..\n");
    if(!run_command("".get_pkg_sourcefiles()."\\install.exe /quiet"))
    {
        output("Anyconnect installation failed.\n");
        return 0;
    }
    return 1;
}
sub uninstall
{
    if(!run_command())
    {
        output("Anyconnect Removal Failed.");
        return 0;
    }
    #run_command("REG DELETE  HKEY_LOCAL_MACHINE\\SOFTWARE\\UMR\\INSTALL\\Product_List\\VisualStudioCode1.2 /f");
    delete_product_registry_key(get_package_name().".".get_version());
    return 1;
}
sub postinstall
{
    
    return 1;   
}
do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1,OSVER_WIN8_SP0,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64,OSARCH_x86],
    allowed_regs =&gt; ['desktop','virtual-desktop','traveling','clc','virtual-clc'],
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);
IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\appsanywheredeploy.1_1_0\prod\update.pl</FullName>
    <Length>2546</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-07-20T10:27:22.5169608-05:00</CreationTime>
    <CreationTimeUtc>2017-07-20T15:27:22.5169608Z</CreationTimeUtc>
    <LastWriteTime>2017-07-20T10:58:59.1403448-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-07-20T15:58:59.1403448Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-20T10:27:22.5169608-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-20T15:27:22.5169608Z</LastAccessTimeUtc>
    <Text># AppsAnywhere Deploy 1.1.0
# Created by Austin Wall

#Adds necessary files to machines designed for Software2 usage
#	Creates a shortcut on the desktop to https://appsanywhere.mst.edu
#	Inserts the following registry keys:
#		a.	HKLM\Software\Software2\Hub\Environment
#		b.	HKLM\Software\Software2\Hub, RegSZ:SVORUO=1 
#		c.	HKLM\Software\Software2\Hub, RegSZ:SVOROS=1
#	Installs AppsAnywhere client


use strict;
use warnings;
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'appsanywheredeploy.1_1_0',
        package_revision =&gt; '20170720T1034',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

# All Variables (except success values):

my $src = get_pkg_sourcefiles();
my $desk = get_allusers_desktop();


sub install {
    output("\nInstalling AppsAnywhere... ");
    if(!run_command("\"$src\\apps-anywhere-installer-x64.msi\" /qn")) {
        output("FAIL: $?\n");
        return 0;
    }
    output("\nInstalling Cloudpaging... ");
    if(!run_command("\"$src\\cloudpaging-player-setup-x64.msi\" /qn")) {
        output("FAIL: $?\n");
        return 0;
    }
    output("OK\n");
    return 1;
}
################################################################################
################################################################################
sub postinstall {
    output("Performing registry changes... ");
    if(!run_command("regedit /s \"$src\\s2.reg\"")){
        output("FAIL: $?");
        return 0;
    }
    #I'm using the icon from the AppsAnywhere website. It's only 32x32, might want to source
    #	a higher res one for the production run
    output("OK\nPlacing Shortcut... ");
    if(!run_command("copy \"$src\\AppsAnywhere.lnk\" \"$desk\\AppsAnywhere.lnk\"")){
        output("FAIL: $?\n");
        return 0;
    }
    output("OK\nDeleting Cloudpaging Player Shortcut... ");
    if(!run_command("del /F \"$desk\\Cloudpaging Player.lnk\"")) {
        output("FAIL: $?\n");
        return 0;
    }
    output("OK\n");
    return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);



</Text>
  </Script>
  <Script>
    <Name>remove.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\appsanywheredeploy.1_2_0\prod\remove.pl</FullName>
    <Length>2319</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-01-11T12:04:13.4280982-06:00</CreationTime>
    <CreationTimeUtc>2018-01-11T18:04:13.4280982Z</CreationTimeUtc>
    <LastWriteTime>2018-04-19T16:15:28.2969887-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-04-19T21:15:28.2969887Z</LastWriteTimeUtc>
    <LastAccessTime>2018-01-11T12:04:13.4280982-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-01-11T18:04:13.4280982Z</LastAccessTimeUtc>
    <Text># AppsAnywhere Deploy 1.2.0 Remove Script
# Created by Austin Wall
# Packaged December 19, 2017
# Last Updated 2018-01-11 by Austin Wall

#Adds necessary files to machines designed for Software2 usage
#	Uninstalls any known existing S2 applications


use strict;
use warnings;
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'appsanywhereremove.1_2_0',
        package_revision =&gt; '20180111T1424',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

# All Variables (except success values):

my $src = get_pkg_sourcefiles();
my $desk = get_allusers_desktop();

sub install {
    output("Checking for previous versions...\n");
    # To find product GUIDs:  wmic product get &gt; C:\InstalledPrograms.txt
    KillProcess(qw(JukeboxPlayer.exe AppsAnywhere.exe AppsAnywhereUpdaterService.exe));
    my @guids = ('{19BB2ED9-56F5-4217-966F-3334F840C7C3}', # AppsAnywhere [version unknown]
                 '{23F6FB7C-C1E2-491B-91A1-0441D5191BC7}', # Cloudpaging Player 9.0.4.20227 / 9.0.4.21424 / 9.1.1.22090
                 '{21A970DD-0097-4394-8C58-487A97D43E7F}', # AppsAnywhere 1.2.0
                 );
    
    foreach my $guid (@guids){
        if (IsAppInstalled('AppID' =&gt; $guid)) {
        output("Removing application with guid: $guid\n");
            if(!install_msi( app_id =&gt; $guid,
                             msi_action_flag =&gt; 'x',
                             logfile_name =&gt; 'removeappsanywhere.txt',
                             IgnoreExitCodes =&gt; ['3010'])){
                output("Failed to remove application\n");
                return 0;
            }
        }
    }
    
    delete_product_registry_key('appsanywheredeploy.1_2_0');
    delete_product_registry_key('appsanywhereremove.1_2_0'); 
    output("Finished removing previous versions.\n");
}


do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    no_install_check =&gt; 1,
);



</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\appsanywheredeploy.1_2_0\prod\update.pl</FullName>
    <Length>2494</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-01-11T12:04:13.4593712-06:00</CreationTime>
    <CreationTimeUtc>2018-01-11T18:04:13.4593712Z</CreationTimeUtc>
    <LastWriteTime>2018-04-24T11:21:48.6598413-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-04-24T16:21:48.6598413Z</LastWriteTimeUtc>
    <LastAccessTime>2018-01-11T12:04:13.4593712-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-01-11T18:04:13.4593712Z</LastAccessTimeUtc>
    <Text># AppsAnywhere Deploy 1.2.0 Install Script
# Created by Austin Wall
# Packaged December 19, 2017
# Last Updated 2018-04-24 by Austin Wall

#Adds necessary files to machines designed for Software2 usage
#	Creates a shortcut on the desktop to https://appsanywhere.mst.edu
#	Inserts the following registry keys:
#		a.	HKLM\Software\Software2\Hub\Environment
#		b.	HKLM\Software\Software2\Hub, RegSZ:SVORUO=1 
#		c.	HKLM\Software\Software2\Hub, RegSZ:SVOROS=1
#	Installs AppsAnywhere client


use strict;
use warnings;
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'appsanywheredeploy.1_2_0',
        package_revision =&gt; '20180424T1117',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

# All Variables (except success values):

my $src = get_pkg_sourcefiles();
my $desk = get_allusers_desktop();

sub install {
    output("\nInstalling AppsAnywhere... ");
    if(!run_command("\"$src\\apps-anywhere-installer-x64.msi\" /qn")) {
        output("FAIL: $?\n");
        return 0;
    }
    output("\nInstalling Cloudpaging... ");
    if(!run_command("\"$src\\Application Jukebox Player x64.msi\" /qn")) {
        output("FAIL: $?\n");
        return 0;
    }
    output("OK\n");
    return 1;
}
################################################################################
################################################################################
sub postinstall {
    output("Performing registry changes... ");
    if(!run_command("regedit /s \"$src\\s2.reg\"")){
        output("FAIL: $?");
        return 0;
    }

    output("OK\nPlacing Shortcut... ");
    if(!run_command("copy \"$src\\AppsAnywhere.lnk\" \"$desk\\AppsAnywhere.lnk\"")){
        output("FAIL: $?\n");
        return 0;
    }
    output("OK\nDeleting Cloudpaging Player Shortcut... ");
    if(!run_command("del /F \"$desk\\Cloudpaging Player.lnk\"")) {
        output("FAIL: $?\n");
        return 0;
    }
    output("OK\n");
    return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);



</Text>
  </Script>
  <Script>
    <Name>remove.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\appsanywheredeploy.1_2_0\prod.old\remove.pl</FullName>
    <Length>2287</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-12-19T12:01:36.7881838-06:00</CreationTime>
    <CreationTimeUtc>2017-12-19T18:01:36.7881838Z</CreationTimeUtc>
    <LastWriteTime>2018-01-11T14:52:54.9351041-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-11T20:52:54.9351041Z</LastWriteTimeUtc>
    <LastAccessTime>2017-12-19T12:01:36.7881838-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-12-19T18:01:36.7881838Z</LastAccessTimeUtc>
    <Text># AppsAnywhere Deploy 1.2.0 Remove Script
# Created by Austin Wall
# Packaged December 19, 2017
# Last Updated 2018-01-11 by Austin Wall

#Adds necessary files to machines designed for Software2 usage
#	Uninstalls any known existing S2 applications


use strict;
use warnings;
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'appsanywhereremove.1_2_0',
        package_revision =&gt; '20180111T1424',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

# All Variables (except success values):

my $src = get_pkg_sourcefiles();
my $desk = get_allusers_desktop();

sub install {
    output("Checking for previous versions...\n");
    # To find product GUIDs:  wmic product get &gt; C:\InstalledPrograms.txt
    KillProcess(qw(JukeboxPlayer.exe AppsAnywhere.exe AppsAnywhereUpdaterService.exe));
    my @guids = ('{19BB2ED9-56F5-4217-966F-3334F840C7C3}', # AppsAnywhere
                 '{23F6FB7C-C1E2-491B-91A1-0441D5191BC7}', # Cloudpaging Player 9.0.4.20227 / 9.0.4.21424
                 '{21A970DD-0097-4394-8C58-487A97D43E7F}', # AppsAnywhere 1.2.0
                 );
    
    foreach my $guid (@guids){
        if (IsAppInstalled('AppID' =&gt; $guid)) {
        output("Removing application with guid: $guid\n");
            if(!install_msi( app_id =&gt; $guid,
                             msi_action_flag =&gt; 'x',
                             logfile_name =&gt; 'removeappsanywhere.txt',
                             IgnoreExitCodes =&gt; ['3010'])){
                output("Failed to remove application\n");
                return 0;
            }
        }
    }
    
    delete_product_registry_key('appsanywheredeploy.1_2_0');
    delete_product_registry_key('appsanywhereremove.1_2_0'); 
    output("Finished removing previous versions.\n");
}


do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    no_install_check =&gt; 1,
);



</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\appsanywheredeploy.1_2_0\prod.old\update.pl</FullName>
    <Length>2492</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-12-19T11:02:43.034585-06:00</CreationTime>
    <CreationTimeUtc>2017-12-19T17:02:43.034585Z</CreationTimeUtc>
    <LastWriteTime>2017-12-19T13:12:11.6523828-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-12-19T19:12:11.6523828Z</LastWriteTimeUtc>
    <LastAccessTime>2017-12-19T11:02:43.034585-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-12-19T17:02:43.034585Z</LastAccessTimeUtc>
    <Text># AppsAnywhere Deploy 1.2.0 Install Script
# Created by Austin Wall
# Packaged December 19, 2017
# Last Updated 2017-12-19 by Austin Wall

#Adds necessary files to machines designed for Software2 usage
#	Creates a shortcut on the desktop to https://appsanywhere.mst.edu
#	Inserts the following registry keys:
#		a.	HKLM\Software\Software2\Hub\Environment
#		b.	HKLM\Software\Software2\Hub, RegSZ:SVORUO=1 
#		c.	HKLM\Software\Software2\Hub, RegSZ:SVOROS=1
#	Installs AppsAnywhere client


use strict;
use warnings;
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'appsanywheredeploy.1_2_0',
        package_revision =&gt; '20171219T1103',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

# All Variables (except success values):

my $src = get_pkg_sourcefiles();
my $desk = get_allusers_desktop();

sub install {
    output("\nInstalling AppsAnywhere... ");
    if(!run_command("\"$src\\apps-anywhere-installer-x64.msi\" /qn")) {
        output("FAIL: $?\n");
        return 0;
    }
    output("\nInstalling Cloudpaging... ");
    if(!run_command("\"$src\\cloudpaging-player-setup-x64.msi\" /qn")) {
        output("FAIL: $?\n");
        return 0;
    }
    output("OK\n");
    return 1;
}
################################################################################
################################################################################
sub postinstall {
    output("Performing registry changes... ");
    if(!run_command("regedit /s \"$src\\s2.reg\"")){
        output("FAIL: $?");
        return 0;
    }

    output("OK\nPlacing Shortcut... ");
    if(!run_command("copy \"$src\\AppsAnywhere.lnk\" \"$desk\\AppsAnywhere.lnk\"")){
        output("FAIL: $?\n");
        return 0;
    }
    output("OK\nDeleting Cloudpaging Player Shortcut... ");
    if(!run_command("del /F \"$desk\\Cloudpaging Player.lnk\"")) {
        output("FAIL: $?\n");
        return 0;
    }
    output("OK\n");
    return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);



</Text>
  </Script>
  <Script>
    <Name>remove.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\appsanywheredeploy.1_3_0\prod\remove.pl</FullName>
    <Length>2287</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-07-10T08:19:12.5385117-05:00</CreationTime>
    <CreationTimeUtc>2018-07-10T13:19:12.5385117Z</CreationTimeUtc>
    <LastWriteTime>2018-06-27T11:39:06.8510938-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-27T16:39:06.8510938Z</LastWriteTimeUtc>
    <LastAccessTime>2018-07-10T08:19:12.5385117-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-07-10T13:19:12.5385117Z</LastAccessTimeUtc>
    <Text># AppsAnywhere Deploy 1.3.0 Remove Script
# Created by Austin Wall
# Packaged 2018-06-27
# Last Updated 

#Adds necessary files to machines designed for Software2 usage
#	Uninstalls any known existing S2 applications


use strict;
use warnings;
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'appsanywhereremove.1_3_0',
        package_revision =&gt; '20180627T1133',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

# All Variables (except success values):

my $src = get_pkg_sourcefiles();
my $desk = get_allusers_desktop();

sub install {
    output("Checking for previous versions...\n");
    # To find product GUIDs:  wmic product get &gt; C:\InstalledPrograms.txt
    KillProcess(qw(JukeboxPlayer.exe AppsAnywhere.exe AppsAnywhereUpdaterService.exe));
    my @guids = ('{19BB2ED9-56F5-4217-966F-3334F840C7C3}', # AppsAnywhere [version unknown]
                 '{23F6FB7C-C1E2-491B-91A1-0441D5191BC7}', # Cloudpaging Player 9.0.4.20227 / 9.0.4.21424 / 9.1.1.22090
                 '{21A970DD-0097-4394-8C58-487A97D43E7F}', # AppsAnywhere 1.2.0
                 );
    
    foreach my $guid (@guids){
        if (IsAppInstalled('AppID' =&gt; $guid)) {
        output("Removing application with guid: $guid\n");
            if(!install_msi( app_id =&gt; $guid,
                             msi_action_flag =&gt; 'x',
                             logfile_name =&gt; 'removeappsanywhere.txt',
                             IgnoreExitCodes =&gt; ['3010'])){
                output("Failed to remove application\n");
                return 0;
            }
        }
    }
    
    delete_product_registry_key('appsanywheredeploy.1_3_0');
    delete_product_registry_key('appsanywhereremove.1_3_0'); 
    output("Finished removing previous versions.\n");
}


do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    no_install_check =&gt; 1,
);



</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\appsanywheredeploy.1_3_0\prod\update.pl</FullName>
    <Length>2061</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-07-10T08:19:12.5541334-05:00</CreationTime>
    <CreationTimeUtc>2018-07-10T13:19:12.5541334Z</CreationTimeUtc>
    <LastWriteTime>2018-07-03T14:46:00.1889192-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-03T19:46:00.1889192Z</LastWriteTimeUtc>
    <LastAccessTime>2018-07-10T08:19:12.5541334-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-07-10T13:19:12.5541334Z</LastAccessTimeUtc>
    <Text># AppsAnywhere Deploy 1.3.0 Install Script
# Created by Austin Wall
# Packaged 2018-06-27
# Last Updated 


use strict;
use warnings;
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'appsanywheredeploy.1_3_0',
        package_revision =&gt; '20180703T1445',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

# All Variables (except success values):

my $src = get_pkg_sourcefiles();
my $desk = get_allusers_desktop();

sub install {
    output("\nInstalling AppsAnywhere... ");
    if(!run_command("\"$src\\apps-anywhere-installer-x64.msi\" /qn")) {
        output("FAIL: $?\n");
        return 0;
    }
    output("\nInstalling Cloudpaging... ");
    if(!run_command("\"$src\\Application Jukebox Player x64.msi\" /qn")) {
        output("FAIL: $?\n");
        return 0;
    }
    output("OK\n");
    return 1;
}
################################################################################
################################################################################
sub postinstall {
    output("Performing registry changes... ");
    if(!run_command("regedit /s \"$src\\s2.reg\"")){
        output("FAIL: $?");
        return 0;
    }

    output("OK\nPlacing Shortcut... ");
    if(!run_command("copy \"$src\\AppsAnywhere.lnk\" \"$desk\\AppsAnywhere.lnk\"")){
        output("FAIL: $?\n");
        return 0;
    }
    output("OK\nDeleting Cloudpaging Player Shortcut... ");
    if(!run_command("del /F \"$desk\\Cloudpaging Player.lnk\"")) {
        output("FAIL: $?\n");
        return 0;
    }
    output("OK\n");
    return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);



</Text>
  </Script>
  <Script>
    <Name>remove.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\appsanywheredeploy.1_3_0\prod.old\remove.pl</FullName>
    <Length>2287</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-27T10:59:50.2031808-05:00</CreationTime>
    <CreationTimeUtc>2018-06-27T15:59:50.2031808Z</CreationTimeUtc>
    <LastWriteTime>2018-06-27T11:39:06.8510938-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-27T16:39:06.8510938Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-27T10:59:50.2031808-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-27T15:59:50.2031808Z</LastAccessTimeUtc>
    <Text># AppsAnywhere Deploy 1.3.0 Remove Script
# Created by Austin Wall
# Packaged 2018-06-27
# Last Updated 

#Adds necessary files to machines designed for Software2 usage
#	Uninstalls any known existing S2 applications


use strict;
use warnings;
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'appsanywhereremove.1_3_0',
        package_revision =&gt; '20180627T1133',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

# All Variables (except success values):

my $src = get_pkg_sourcefiles();
my $desk = get_allusers_desktop();

sub install {
    output("Checking for previous versions...\n");
    # To find product GUIDs:  wmic product get &gt; C:\InstalledPrograms.txt
    KillProcess(qw(JukeboxPlayer.exe AppsAnywhere.exe AppsAnywhereUpdaterService.exe));
    my @guids = ('{19BB2ED9-56F5-4217-966F-3334F840C7C3}', # AppsAnywhere [version unknown]
                 '{23F6FB7C-C1E2-491B-91A1-0441D5191BC7}', # Cloudpaging Player 9.0.4.20227 / 9.0.4.21424 / 9.1.1.22090
                 '{21A970DD-0097-4394-8C58-487A97D43E7F}', # AppsAnywhere 1.2.0
                 );
    
    foreach my $guid (@guids){
        if (IsAppInstalled('AppID' =&gt; $guid)) {
        output("Removing application with guid: $guid\n");
            if(!install_msi( app_id =&gt; $guid,
                             msi_action_flag =&gt; 'x',
                             logfile_name =&gt; 'removeappsanywhere.txt',
                             IgnoreExitCodes =&gt; ['3010'])){
                output("Failed to remove application\n");
                return 0;
            }
        }
    }
    
    delete_product_registry_key('appsanywheredeploy.1_3_0');
    delete_product_registry_key('appsanywhereremove.1_3_0'); 
    output("Finished removing previous versions.\n");
}


do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    no_install_check =&gt; 1,
);



</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\appsanywheredeploy.1_3_0\prod.old\update.pl</FullName>
    <Length>2061</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-27T10:59:50.2187978-05:00</CreationTime>
    <CreationTimeUtc>2018-06-27T15:59:50.2187978Z</CreationTimeUtc>
    <LastWriteTime>2018-07-03T14:46:00.1889192-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-03T19:46:00.1889192Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-27T10:59:50.2187978-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-27T15:59:50.2187978Z</LastAccessTimeUtc>
    <Text># AppsAnywhere Deploy 1.3.0 Install Script
# Created by Austin Wall
# Packaged 2018-06-27
# Last Updated 


use strict;
use warnings;
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'appsanywheredeploy.1_3_0',
        package_revision =&gt; '20180703T1445',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

# All Variables (except success values):

my $src = get_pkg_sourcefiles();
my $desk = get_allusers_desktop();

sub install {
    output("\nInstalling AppsAnywhere... ");
    if(!run_command("\"$src\\apps-anywhere-installer-x64.msi\" /qn")) {
        output("FAIL: $?\n");
        return 0;
    }
    output("\nInstalling Cloudpaging... ");
    if(!run_command("\"$src\\Application Jukebox Player x64.msi\" /qn")) {
        output("FAIL: $?\n");
        return 0;
    }
    output("OK\n");
    return 1;
}
################################################################################
################################################################################
sub postinstall {
    output("Performing registry changes... ");
    if(!run_command("regedit /s \"$src\\s2.reg\"")){
        output("FAIL: $?");
        return 0;
    }

    output("OK\nPlacing Shortcut... ");
    if(!run_command("copy \"$src\\AppsAnywhere.lnk\" \"$desk\\AppsAnywhere.lnk\"")){
        output("FAIL: $?\n");
        return 0;
    }
    output("OK\nDeleting Cloudpaging Player Shortcut... ");
    if(!run_command("del /F \"$desk\\Cloudpaging Player.lnk\"")) {
        output("FAIL: $?\n");
        return 0;
    }
    output("OK\n");
    return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);



</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\aqtesolv_pro.4_5_0\dev\update.pl</FullName>
    <Length>1318</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-21T15:52:32.4361466-05:00</CreationTime>
    <CreationTimeUtc>2017-06-21T20:52:32.4361466Z</CreationTimeUtc>
    <LastWriteTime>2017-06-22T10:57:10.7474233-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-22T15:57:10.7474233Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-22T10:56:47.0911424-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-22T15:56:47.0911424Z</LastAccessTimeUtc>
    <Text># AQTESOLV Pro 4.5.0
# Package Created June 21, 2017
# Packaged by Alex Schrimpf
# Last Updated 06/21/2017 by Alex Schrimpf

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: .
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'aqtesolv_pro.4_5_0',
        package_revision =&gt; '20170621T1017'
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
my $srcfiles= get_pkg_sourcefiles();

use Getopt::Long;

GetOptions
(
);

sub install
{
	my $sTime = time;
	output("Installing: AQTESOLV Pro 4.5.0\n");	
	my $suc = run_command("$srcfiles\\aqtp450setup.exe /s /V/qn");
	print("Done: ".time-$sTime." seconds");
	return($suc);
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\aqtesolv_pro.4_5_0\prod\update.pl</FullName>
    <Length>1303</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-22T09:59:49.102578-05:00</CreationTime>
    <CreationTimeUtc>2017-06-22T14:59:49.102578Z</CreationTimeUtc>
    <LastWriteTime>2017-07-13T14:34:16.86543-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-07-13T19:34:16.86543Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-13T14:34:08.1760928-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-13T19:34:08.1760928Z</LastAccessTimeUtc>
    <Text># AQTESOLV Pro 4.5.0
# Package Created June 21, 2017
# Packaged by Alex Schrimpf
# Last Updated 06/21/2017 by Alex Schrimpf

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: .
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'aqtesolv_pro.4_5_0',
        package_revision =&gt; '20170621T1017'
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles= get_pkg_sourcefiles();

sub prereq
{
	return new Win32::TieRegistry "HKEY_LOCAL_MACHINE\\SOFTWARE\\UMR\\INSTALL\\Product_List\\dotnet.2_0_sp1",{ Access=&gt;"KEY_READ", Delimiter=&gt;"\\" };
}

do_install(
    msi_name =&gt; "AQTESOLV\ Pro\ 4.5.msi",
    quiet =&gt; "/qn",
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    prerequisite_sub =&gt; \&amp;prereq,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\arcgis.10_5_1\dev\update.pl</FullName>
    <Length>1887</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-01-11T12:38:44.7560533-06:00</CreationTime>
    <CreationTimeUtc>2018-01-11T18:38:44.7560533Z</CreationTimeUtc>
    <LastWriteTime>2018-01-12T15:22:48.7785153-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-12T21:22:48.7785153Z</LastWriteTimeUtc>
    <LastAccessTime>2014-12-02T13:21:26-06:00</LastAccessTime>
    <LastAccessTimeUtc>2014-12-02T19:21:26Z</LastAccessTimeUtc>
    <Text># ArcGIS 10.5.1
# Package Created January 11, 2018
# Packaged by Austin wall
# Last Updated ...



use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'arcgis.10_5_1',

        package_revision =&gt; '20180112T1313',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles= get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

use Data::Dumper;


sub postinstall 
{
    output("Licensing application: \n");
    my $prvc = 'C:\SourceFiles\arcgis.10_5_1\ArcGISDesktopAdvanced_SingleUse_598297.prvc';
    #my $success = run_command("\"C:\\Program Files (x86)\\Common Files\\ArcGIS\\bin\\SoftwareAuthorization.exe\" -s -ver 10.5 lif $prvc");
    #output("$success\n");
    #`"C:\\Program Files (x86)\\Common Files\\ArcGIS\\bin\\SoftwareAuthorization.exe" -s -ver 10.5 -lif $prvc`;
    return run_command("START \"\" /WAIT \"C:\\Program Files (x86)\\Common Files\\ArcGIS\\bin\\SoftwareAuthorization.exe\" -s -ver 10.5 -lif \"$prvc\"",
        FailureCallback=&gt;
        sub {
            print Dumper(@_);
        }
    );
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,

    # install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,

    msi_name =&gt; 'setup.msi',
    msi_ignore_exit_codes =&gt; [ 3010 &amp; 0xFF ], # Reboot required
    additional_msi_properties =&gt; 'SOFTWARE_CLASS="Professional" ADDLOCAL="ALL"',
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\arcgis.10_5_1\prod\update.pl</FullName>
    <Length>1918</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-01-12T15:40:47.7888914-06:00</CreationTime>
    <CreationTimeUtc>2018-01-12T21:40:47.7888914Z</CreationTimeUtc>
    <LastWriteTime>2018-01-26T14:53:16.2345151-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-26T20:53:16.2345151Z</LastWriteTimeUtc>
    <LastAccessTime>2018-01-12T15:40:47.7888914-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-01-12T21:40:47.7888914Z</LastAccessTimeUtc>
    <Text># ArcGIS 10.5.1
# Package Created January 11, 2018
# Packaged by Austin wall
# Last Updated by Austin Wall on January 26, 2018



use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'arcgis.10_5_1',

        package_revision =&gt; '20180126T1453',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles= get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

use Data::Dumper;


sub postinstall 
{
    output("Licensing application: \n");
    my $prvc = 'C:\SourceFiles\arcgis.10_5_1\ArcGISDesktopAdvanced_SingleUse_605202.prvc';
    #my $success = run_command("\"C:\\Program Files (x86)\\Common Files\\ArcGIS\\bin\\SoftwareAuthorization.exe\" -s -ver 10.5 lif $prvc");
    #output("$success\n");
    #`"C:\\Program Files (x86)\\Common Files\\ArcGIS\\bin\\SoftwareAuthorization.exe" -s -ver 10.5 -lif $prvc`;
    return run_command("START \"\" /WAIT \"C:\\Program Files (x86)\\Common Files\\ArcGIS\\bin\\SoftwareAuthorization.exe\" -s -ver 10.5 -lif \"$prvc\"",
        FailureCallback=&gt;
        sub {
            print Dumper(@_);
        }
    );
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,

    # install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,

    msi_name =&gt; 'setup.msi',
    msi_ignore_exit_codes =&gt; [ 3010 &amp; 0xFF ], # Reboot required
    additional_msi_properties =&gt; 'SOFTWARE_CLASS="Professional" ADDLOCAL="ALL"',
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\arduino_ide.1_8_5\prod\update.pl</FullName>
    <Length>2387</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-17T11:22:49.5628113-05:00</CreationTime>
    <CreationTimeUtc>2018-05-17T16:22:49.5628113Z</CreationTimeUtc>
    <LastWriteTime>2018-05-22T10:21:42.9761426-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-22T15:21:42.9761426Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-17T11:22:49.5628113-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-17T16:22:49.5628113Z</LastAccessTimeUtc>
    <Text># Codeblocks 17.12
# Package Created 22 May 2018
# Packaged by Robert Smith
# Last Updated 22 May 2018

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'arduino_ide.1_8_5',
        package_revision =&gt; '20180522T0927',
    );
}


use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();

 sub install {
	output("Installing Arduino IDE 1.8.5\n");

  # Manual install of certificates is necessary for a silent install
  if (!run_command("start /wait \"\" certutil -addstore TrustedPublisher $sourcefilesdir\\arduino_llc_cert.cer"))
  {
    output("Arduino IDE LLC certificate did not install correctly\n");
    return 0;
  }
  if (!run_command("start /wait \"\" certutil -addstore TrustedPublisher $sourcefilesdir\\arduino_srl_cert.cer"))
  {
    output("Arduino IDE srl certificate did not install correctly\n");
    return 0;
  }

	if(!run_command("start /wait \"\" $sourcefilesdir\\arduino-1.8.5-windows.exe /S")){
		output("Arduino IDE did not install correctly\n");
		return 0;
	}
	else{
		output("Installation successful!\n");
	}

   return 1;
}

sub post {
    output("Removing icons from public: ");
    my $Remove1 = run_command("del \"%systemdrive%\\Users\\Public\\Desktop\\Arduino.lnk\" /Q");
    output($Remove1 ? "Success!\n" : "FAILED: $!\n");

    output("Removing icons from user: ");
    my $current_user = getlogin || getpwuid($&lt;) || "Default";
    my $Remove2 = run_command("del \"%systemdrive%\\Users\\$current_user\\Desktop\\Arduino.lnk\" /Q");
    output($Remove2 ? "Success!\n" : "FAILED: $!\n");

    return ($Remove1 || $Remove2);
}


do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling','virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
	  install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;post,
);


IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\arena.14\dev\update.pl</FullName>
    <Length>1139</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-07-18T13:05:44.3212236-05:00</CreationTime>
    <CreationTimeUtc>2017-07-18T18:05:44.3212236Z</CreationTimeUtc>
    <LastWriteTime>2017-07-18T14:29:11.6427767-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-07-18T19:29:11.6427767Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-18T13:05:44.3212236-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-18T18:05:44.3212236Z</LastAccessTimeUtc>
    <Text>
    # Arena 14
    # Package Created July 18, 2017
    # Packaged by Krueger, Benjamin (S&amp;T IT Student Employee)
    # Last Updated --
    BEGIN {
        %::INSTALLMONKEY_OPTIONS = (
            package_id =&gt; 'arena.14',
            package_revision =&gt; '20170718T1304',
        );
    }

    use lib (
        '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
        $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
        'C:\temp',
    );
    sub install {
        my $sourcefilesdir = get_pkg_sourcefiles();

        if(!run_command($sourcefilesdir."\\arena.14.exe /qn"))
        {
            output("\nProgram did not install succesfully.\n");
            return 0;
        }
        return 1;
    }
    use InstallMonkey::Shared;
    use Getopt::Long;
    do_install(
        allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
        allowed_os_architectures =&gt; [OSARCH_x64],
        allowed_regs =&gt; ["clc", "desktop", "traveling", "virtual-desktop", "virtual-clc"],
        exit_on_failure =&gt; 1,
        install_sub =&gt; \&amp;install,
        
    );
    IM_Exit(EXIT_SUCCESS);
    </Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\arena.15\dev\update.pl</FullName>
    <Length>1769</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-07-28T09:22:58.9859818-05:00</CreationTime>
    <CreationTimeUtc>2017-07-28T14:22:58.9859818Z</CreationTimeUtc>
    <LastWriteTime>2018-01-31T15:41:52.2648059-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-31T21:41:52.2648059Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-18T13:05:44-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-18T18:05:44Z</LastAccessTimeUtc>
    <Text>
    # Arena 15
    # Package Created July 18, 2017
    # Packaged by Krueger, Benjamin (S&amp;T IT Student Employee)
    # Last Updated - 20180131 by Jason Holm to disable the ENV for the LIC server.
	
    BEGIN {
        %::INSTALLMONKEY_OPTIONS = (
            package_id =&gt; 'arena.15',
            package_revision =&gt; '20180131T1541',
        );
    }

    use lib (
        '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
        $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
        'C:\temp',
    );
    use Win32::TieRegistry;

    sub install {
        my $sourcefilesdir = get_pkg_sourcefiles();
        if (0) # Disabled for the moment...we do not have a licensed for this software, it should be installed and used as a demo copy.
		{
		 output("Setting LM environment variable");
         $Registry-&gt;Delimiter("/");
         $Registry-&gt;{"HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Control/Session Manager/Environment//LM_LICENSE_FILE"} = '1780@arena.lic.mst.edu';
         $ENV{'LM_LICENSE_FILE'} = '1780@arena.lic.mst.edu';
        }
        output("Installing Arena 15 package");
        if(!run_command($sourcefilesdir."\\15.00.00001.9740-71_x64\\MediaImage\\Install\\Arena\\Setup.exe /QN"))
        {
            output("\nProgram did not install succesfully.\n");
            return 0;
        }

        return 1;
    }
    use InstallMonkey::Shared;
    use Getopt::Long;
    do_install(
        allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
        allowed_os_architectures =&gt; [OSARCH_x64],
        allowed_regs =&gt; ["clc", "desktop", "traveling", "virtual-desktop", "virtual-clc"],
        exit_on_failure =&gt; 1,
        install_sub =&gt; \&amp;install,

    );
    IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\arena.15\dev32\update.pl</FullName>
    <Length>2023</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-01-31T16:30:37.3106743-06:00</CreationTime>
    <CreationTimeUtc>2018-01-31T22:30:37.3106743Z</CreationTimeUtc>
    <LastWriteTime>2018-02-05T19:36:45.2184998-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-02-06T01:36:45.2184998Z</LastWriteTimeUtc>
    <LastAccessTime>2018-01-31T16:30:37.3106743-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-01-31T22:30:37.3106743Z</LastAccessTimeUtc>
    <Text>
    # Arena 15 - 32-Bit Version
    # Original Package By Benjamin Krueger
    # Modified By Jason S. Holm for 32-Bit Version on 201801311636
    # NOTE: License Server Disabled - Does NOT add the ENV for the LIC server.
	
    BEGIN {
        %::INSTALLMONKEY_OPTIONS = (
            package_id =&gt; 'arena32.2015',
            package_revision =&gt; '20180205T1935',
        );
    }

    use lib (
        '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
        $ENV{'WINDIR'}.'\\SYSTEM32\\UMRINST',
        'C:\temp',
    );
    use Win32::TieRegistry;

    sub install {
        my $sourcefilesdir = get_pkg_sourcefiles();

		# output("Starting MSI uninstall...");
		# $static_location = "\\15.10.00000.10472-885_x86\\MediaImage\\Install\\Arena\\Arena_x86.msi /qn /norestart";
		# $whole_location = $sourcefilesdir . $static_location;
		# run_command("msiexec /x $whole_location");
		# output("done!");
		
		## Install
		
		output("Installing Arena 2015 32-Bit Package");
        if(!run_command($sourcefilesdir."\\15.10.00000.10472-885_x86\\MediaImage\\Install\\Arena\\Setup.exe /QN"))
        {
            output("\nProgram did not install succesfully.\n");
            return 0;
        }
		
		## Copy Working Shortcut to Desktop
		 $source_location = "C:\\SourceFiles\\arena32.2015\\15.10.00000.10472-885_x86\\MediaImage\\Arena.lnk";
		 $dest_location = "C:\\Users\\Public\\Desktop\\";
		 output("Success! Now creating an All User Desktop Shortcut...");
		 run_command("xcopy /y $source_location $dest_location");
		 output("done!\n\n");
		
        return 1;
    }
    use InstallMonkey::Shared;
    use Getopt::Long;
    do_install(
        allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
        allowed_os_architectures =&gt; [OSARCH_x64],
        allowed_regs =&gt; ["clc", "desktop", "traveling", "virtual-desktop", "virtual-clc"],
        exit_on_failure =&gt; 1,
        install_sub =&gt; \&amp;install,

    );
    IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\aspenONEEng.10\dev\update.pl</FullName>
    <Length>4294</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-09-08T10:26:12.5685046-05:00</CreationTime>
    <CreationTimeUtc>2017-09-08T15:26:12.5685046Z</CreationTimeUtc>
    <LastWriteTime>2017-09-08T14:28:34.942247-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-09-08T19:28:34.942247Z</LastWriteTimeUtc>
    <LastAccessTime>2017-09-08T10:26:12.6311269-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-09-08T15:26:12.6311269Z</LastAccessTimeUtc>
    <Text># AspenONE Engineering V10
# Package Created September 2017
# Packaged by Alex Schrimpf
# Last Updated September 2017 by Alex Schrimpf

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'aspenONEEng.10',
        package_revision =&gt; '20170623T1200',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;
use File::Copy;
use File::Basename;
use File::Path qw(make_path remove_tree);

my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy";

sub create_login_script;

sub install{
	output("INSTALLING...\n");
	if(!run_command("$appdeploy\\aspenONE.10\\AtRunUnattended.exe \"$appdeploy\\aspenONE.10\\aspenONE Engineering V10.xml\" /S /noreboot /L logfile=\"%TEMP%\\aspenONE Engineering V10.log\" altsource=\"$appdeploy\\aspenONE.10\"")){
		output("FAILED\n");
		return 0;
	}
	output("SUCCESS\n");
	return 1;
}

sub postinstall	{
	output("BUILDING LOGIN SCRIPT\n");
	my $script_wrapper = cmd_quote(create_login_script());
	output("SUCCESS\n");

	#run script if not system
	if(!(`whoami` eq "nt authority\\system\n")){
		output("RUNNING LOGIN SCRIPT FOR CURRENT USER\n");
		if(!run_command($script_wrapper)){
			output("FAILED\n");
			return 0;
		}
		output("SUCCESS\n");   
	}
	else{
		output("DETECTED RUNNING AS SYSTEM\n")
	}

	create_activesetup_action(
		'Identifier' =&gt; $INSTALLMONKEY_OPTIONS{'package_id'}.'_setup',
		'ComponentID' =&gt; $INSTALLMONKEY_OPTIONS{'package_id'},
		'Description' =&gt; 'aspenONE v10 disable registration prompt',
		'Version' =&gt; '1.0',
		'StubPath' =&gt; $script_wrapper);	

	return 1;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling','virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

#######################################################################################################################
#Builds login script and wrapper so that return value can be captured. Return location of wrapper if successfully built
#######################################################################################################################
sub create_login_script
{
	my $script_dir = build_path(get_allusers_scripts(),'standard',get_package_id());
    
	my $script_file = build_path($script_dir,get_package_id().'_userlogin.pl');
   
	my $script_wrapper = build_path($script_dir,get_package_id().'_userlogin.cmd');

	if (-d $script_dir) {
		remove_tree($script_dir) or
		output(":: ERROR | REMOVING EXISTING LOGIN SCRIPT DIRECTORY '${script_dir}': $! |\n",LOG_ONLY);
    }
    
	make_path($script_dir);

	if (open(my $script,'&gt;',$script_file)) {
		print $script q|
#!perl
use Win32::TieRegistry;

$Registry-&gt;{HKEY_CURRENT_USER}-&gt;{'SOFTWARE\AspenTech'} = {
    # Don't bother users about registration.
    'DoNotRegister' =&gt; '1',
};
|;
		close($script);
		output(join("\n",get_package_id(),' Login Script:',('-' x 60),
		get_file_contents($script_file),('-' x 60),''), LOG_ONLY);
	}
	else {
		output(":: ERROR | COULD NOT OPEN LOGIN SCRIPT FILE '${script_file}': $! | \n");
		return 0;
	}

	if (open(my $script,'&gt;',$script_wrapper)) {
		my $log_dir = build_path('%APPDATA%','MST','Logs');
		print $script q|
C:
IF NOT EXIST |.$log_dir.q| mkdir "|.$log_dir.q|"
perl "%~dp0|.basename($script_file).q|" &gt; "|.
            build_path($log_dir,get_package_id().'-loginscript.txt').q|" 2&gt;&amp;1
|;

		close($script);
		output(join("\n",get_package_id(),' Login Script:',('-' x 60),
		get_file_contents($script_wrapper),('-' x 60),''), LOG_ONLY);
	} 
	else {
		output(":: ERROR | COULD NOT OPEN LOGIN SCRIPT WRAPPER FILE '${script_wrapper}': $! |\n");
		return 0;
	}

	return $script_wrapper;
}

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\aspenONEEng.10\prod\update.pl</FullName>
    <Length>4882</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-23T12:56:04.4823996-05:00</CreationTime>
    <CreationTimeUtc>2017-06-23T17:56:04.4823996Z</CreationTimeUtc>
    <LastWriteTime>2017-09-15T11:51:40.5179152-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-09-15T16:51:40.5179152Z</LastWriteTimeUtc>
    <LastAccessTime>2017-09-12T09:29:42.2940853-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-09-12T14:29:42.2940853Z</LastAccessTimeUtc>
    <Text># AspenONE Engineering V10
# Package Created September 2017
# Packaged by Alex Schrimpf
# Last Updated September 2017 by Alex Schrimpf

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'aspenONEEng.10',
        package_revision =&gt; '20170623T1200',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;
use File::Copy;
use File::Basename;
use File::Path qw(make_path remove_tree);

my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy";

sub create_login_script;

sub install{
	output("INSTALLING...\n");
	if(!run_command("$appdeploy\\aspenONE.10\\AtRunUnattended.exe \"$appdeploy\\aspenONE.10\\aspenONE Engineering V10.xml\" /S /noreboot /L logfile=\"%TEMP%\\aspenONE Engineering V10.log\" altsource=\"$appdeploy\\aspenONE.10\"")){
		output("FAILED\n");
		return 0;
	}
	output("SUCCESS\n");
	return 1;
}

sub postinstall	{
	output("BUILDING LOGIN SCRIPT\n");
	my $script_wrapper = cmd_quote(create_login_script());
	output("SUCCESS\n");

	#run script if not system
	if(!(`whoami` eq "nt authority\\system\n")){
		output("RUNNING LOGIN SCRIPT FOR CURRENT USER\n");
		if(!run_command($script_wrapper,IgnoreExitCodes =&gt; [2])){
			output("FAILED\n");
			return 0;
		}
		output("SUCCESS\n");   
	}
	else{
		output("DETECTED RUNNING AS SYSTEM\n")
	}

	create_activesetup_action(
		'Identifier' =&gt; $INSTALLMONKEY_OPTIONS{'package_id'}.'_setup',
		'ComponentID' =&gt; $INSTALLMONKEY_OPTIONS{'package_id'},
		'Description' =&gt; 'aspenONE v10 disable registration prompt',
		'Version' =&gt; '1.0',
		'StubPath' =&gt; $script_wrapper);	

	return 1;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling','virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

#######################################################################################################################
#Builds login script and wrapper so that return value can be captured. Return location of wrapper if successfully built
#######################################################################################################################
sub create_login_script
{
	my $script_dir = build_path(get_allusers_scripts(),'standard',get_package_id());
    
	my $script_file = build_path($script_dir,get_package_id().'_userlogin.pl');
   
	my $script_wrapper = build_path($script_dir,get_package_id().'_userlogin.cmd');

	if (-d $script_dir) {
		remove_tree($script_dir) or
		output(":: ERROR | REMOVING EXISTING LOGIN SCRIPT DIRECTORY '${script_dir}': $! |\n",LOG_ONLY);
    }
    
	make_path($script_dir);

	if (open(my $script,'&gt;',$script_file)) {
		print $script q|
#!perl
use Win32::TieRegistry;
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;
$Registry-&gt;{HKEY_CURRENT_USER}-&gt;{'SOFTWARE\AspenTech'} = {
    # Don't bother users about registration.
    'DoNotRegister' =&gt; '1',
};
#delete Database File
my $bat_path = build_path('C:','ProgramData','AspenTech','APED V10.0','DeleteDBInstance.bat');
run_command($bat_path,IgnoreExitCodes =&gt; [2,1698]);
#restore database via dbTesterAdv.exe
my $dbdel_exe_path = build_path('C:','Program Files (x86)','AspenTech','AprSystem V10.0','PropertiesDatabase','Bin','dbTesterAdv.exe');
run_command($dbdel_exe_path);
IM_Exit(EXIT_SUCCESS);

|;
		close($script);
		output(join("\n",get_package_id(),' Login Script:',('-' x 60),
		get_file_contents($script_file),('-' x 60),''), LOG_ONLY);
	}
	else {
		output(":: ERROR | COULD NOT OPEN LOGIN SCRIPT FILE '${script_file}': $! | \n");
		return 0;
	}

	if (open(my $script,'&gt;',$script_wrapper)) {
		my $log_dir = build_path('%APPDATA%','MST','Logs');
		print $script q|
C:
IF NOT EXIST |.$log_dir.q| mkdir "|.$log_dir.q|"
perl "%~dp0|.basename($script_file).q|" &gt; "|.
            build_path($log_dir,get_package_id().'-loginscript.txt').q|" 2&gt;&amp;1
|;

		close($script);
		output(join("\n",get_package_id(),' Login Script:',('-' x 60),
		get_file_contents($script_wrapper),('-' x 60),''), LOG_ONLY);
	} 
	else {
		output(":: ERROR | COULD NOT OPEN LOGIN SCRIPT WRAPPER FILE '${script_wrapper}': $! |\n");
		return 0;
	}

	return $script_wrapper;
}

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\aspenONEEng.10\prod_back\update.pl</FullName>
    <Length>18135</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-23T12:56:04.4823996-05:00</CreationTime>
    <CreationTimeUtc>2017-06-23T17:56:04.4823996Z</CreationTimeUtc>
    <LastWriteTime>2017-09-08T10:22:25.5904093-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-09-08T15:22:25.5904093Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-19T09:51:26.475185-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-19T14:51:26.475185Z</LastAccessTimeUtc>
    <Text># AspenONE Engineering V10
# Package Created November 2016
# Packaged by Alex Schrimpf
# Last Updated June 2017 by Alex Schrimpf

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'aspenONEEng.10',
        package_revision =&gt; '20170623T1200',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;
use File::Basename;
use File::Temp qw(tempfile tempdir);
use File::Copy;
use File::Path qw(make_path remove_tree);
use Win32::TieRegistry;
use Text::CSV;
use Win32;
use Getopt::Long;
use Data::Dumper;
use Digest::SHA1;

my $src = get_pkg_sourcefiles();
my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\aspenONEEng.10";

my $logdir = tempdir('aspenOne-10-install-logs_XXXXXXXX',
                     DIR =&gt; $ENV{TEMP});
if (!$logdir) {
    output("Error creating temporary log directory: $!\n");
    return 0;
}

output("Log directory: ${logdir}\n", LOG_ONLY);
my $response_file = 'Aspen Engineering V10.xml';
my $templog = 'C:\\Windows\\System32\\UMRInst\\AppLogs\\apsen.log';

GetOptions(
    'prereq' =&gt; sub { exit(!install_prereqs()); },
    'configure' =&gt; sub { exit(!configure()); },
    'validate' =&gt; sub { exit(!validate_install()); },
);

#Borrowed from 8.6 installer
my @prereq_msi = (
    # These prereqs were moved out of the XML automation file.
    # All paths have SourceFiles prepended to them.
    # 'detect' contains:
    #    (arrayref) arguments to IsAppInstalled()
    #    (coderef) a subroutine that returns 1 if the prereq condition is met.
    # 'cmd'/'msi'/'code' refer to steps for installation.
    ############################################################

    {
        'name' =&gt; 'SQL Server 2005 Backward compatibility',
        'detect' =&gt; [
            'DisplayName' =&gt; 
                'Microsoft SQL Server 2005 Backward compatibility',
        ],
        'msi' =&gt; [
            'msi' =&gt; build_path($appdeploy,
                                'aspenoneengdvd','core',
                                'SQL2K5Expr','SQLServer2005_BC_x64.msi'),
            'additional_msi_properties' =&gt; 'ADDLOCAL=SQL_DMO,DTS_RUNTIME',
            'logfile_name' =&gt; sub_log('020-SQLServer2005_BC_x64')
        ],
    },

    ############################################################

    {
        'name' =&gt; 'SQL Server 2012 Express LocalDB',
        'detect' =&gt; [
            'DisplayName' =&gt; 
                qr/SQL Server 2012 Express LocalDB/i,
        ],
        'msi' =&gt; [
            'msi' =&gt; build_path($appdeploy,
                                'aspenoneengdvd','core',
                                'SQLLocalDB','x64','SqlLocaLDB.MSI'),
            'additional_msi_properties' =&gt; 'IACCEPTSQLLOCALDBLICENSETERMS=YES',
            'logfile_name' =&gt; sub_log('030-SqlLocaLDB')
        ],
    },

    ############################################################

    {
        'name' =&gt; 'Microsoft SQL Server 2012 Native Client',
        'detect' =&gt; [
            'DisplayName' =&gt; 
                qr/Microsoft SQL Server 2012 Native Client/i,
        ],
        'msi' =&gt; [
            'msi' =&gt; build_path($appdeploy,
                                'aspenoneengdvd','core',
                                'SQLLocalDB','x64','sqlncli.msi'),
            'additional_msi_properties' =&gt; 'IACCEPTSQLNCLILICENSETERMS=YES',
            'logfile_name' =&gt; sub_log('040-sqlncli')
        ],
    },

    ############################################################

    {
        'name' =&gt; 'Microsoft SQL Server 2012 Command Line Utilities',
        'detect' =&gt; [
            'DisplayName' =&gt; 
                qr/Microsoft SQL Server 2012 Command Line Utilities/i,
        ],
        'msi' =&gt; [
            'msi' =&gt; build_path($appdeploy,
                                'aspenoneengdvd','core',
                                'SQLLocalDB','x64','SqlCmdLnUtils.msi'),
            'additional_msi_properties' =&gt; 'IACCEPTSQLCMDLNUTILSLICENSETERMS=YES',
            'logfile_name' =&gt; sub_log('050-SqlCmdLnUtils')
        ],
    },

    ############################################################

    {
        'name' =&gt; 'Microsoft SQL Server 2012 ADOMD.NET',
        'detect' =&gt; [
            'DisplayName' =&gt; 
                qr/Microsoft SQL Server 2012 ADOMD.NET/i,
        ],
        'msi' =&gt; [
            'msi' =&gt; build_path($appdeploy,
                                'aspenoneengdvd','core',
                                'SQLComponents','SQL_AS_ADOMD_x64.msi'),
            'logfile_name' =&gt; sub_log('090-SQL_AS_ADOMD_x64'),
        ],
    },

    ############################################################

    {
        'name' =&gt; 'MSXML 6.0 Parser',
        'detect' =&gt; [
            'DisplayName' =&gt; 
                qr/MSXML 6.0 Parser/i, # It never gets detected.
        ],
        'msi' =&gt; [
            'msi' =&gt; build_path($appdeploy,
                                'aspenoneengdvd','core',
                                'SQLComponents','msxml6_x64.msi'),
            'logfile_name' =&gt; sub_log('100-msxml6_x64'),
        ],
    },

    ############################################################

    {
        'name' =&gt; 'Microsoft AS OLE DB Provider for SQL Server 2012',
        'detect' =&gt; [
            'DisplayName' =&gt; 
                qr/Microsoft AS OLE DB Provider for SQL Server 2012/i,
        ],
        'msi' =&gt; [
            'msi' =&gt; build_path($appdeploy,
                                'aspenoneengdvd','core',
                                'SQLComponents','SQL_AS_OLEDB_x64.msi',),
            'logfile_name' =&gt; sub_log('120-SQL_AS_OLEDB_x64'),
        ],
    },

    ############################################################

    {
        'name' =&gt; 'SQL Server 2012 Analysis Management Objects',
        'detect' =&gt; [
            'DisplayName' =&gt; 
                qr/SQL Server 2012 Analysis Management Objects/i,
        ],
        'msi' =&gt; [
            'msi' =&gt; build_path($appdeploy,
                                'aspenoneengdvd','core',
                                'SQLComponents','SQL_AS_AMO_x64.msi'),
            'logfile_name' =&gt; sub_log('130-SQL_AS_AMO_x64'),
        ],
    },

    ############################################################

    {
        'name' =&gt; 'Microsoft System CLR Types for SQL Server 2012',
        'detect' =&gt; [
            'DisplayName' =&gt; 
                qr/Microsoft System CLR Types for SQL Server 2012/i,
        ],
        'msi' =&gt; [
            'msi' =&gt; build_path($appdeploy,
                                'aspenoneengdvd','core',
                                'SQLComponents','SQLSysClrTypes_x64.msi'),
            'logfile_name' =&gt; sub_log('140-SQLSysClrTypes_x64'),
        ],
    },

    ############################################################

    {
        'name' =&gt; 'Microsoft SQL Server 2012 Management Objects',
        'detect' =&gt; [
            'DisplayName' =&gt; 
                qr/Microsoft SQL Server 2012 Management Objects/i,
        ],
        'msi' =&gt; [
            'msi' =&gt; build_path($appdeploy,
                                'aspenoneengdvd','core',
                                'SQLComponents',
                                'SharedManagementObjects_x64.msi'),
            'logfile_name' =&gt; sub_log('150-SharedManagementObjects_x64'),
        ],
    },

    ############################################################

);


sub pre_install {
    #Prerequisite Redistributables included with AspenONE 10
    output("Installing .NET components...\n   .NET 3.5: ");
    if(!run_command("\"$src\\redist\\Microsoft .NET Framework 3.5 SP1\\dotNetFx35.exe\" /qn", 'IgnoreExitCodes' =&gt; [3010])){
        output("FAIL\n");
        return 0;
    }
    # ALREADY ON IMAGE
    # output("OK\n   .NET 4.6.2: ");
    # if(!run_command("\"$src\\redist\\Microsoft .NET Framework 4.6.2\\NDP462-KB3151800-x86-x64-AllOS-ENU.exe\" /q /norestart", 'IgnoreExitCodes' =&gt; [3010])){
    #     output("FAIL\n");
    #     return 0;
    # }
    # output("OK\n");
    
    #Borrowing SQL prereqs from 8.6
    my $outcome = install_prereqs();
    if(!$outcome){
        return 0;
    }
    
    return 1;
}

 sub install {
    #From Aspen's deployment guidelines: http://www.aspentech.com/Support/Aspen-Deployment-Solutions/
    output("Installing Aspen Products: ");
    if(!run_command("\"$appdeploy\\AtRunUnattended.exe\"
                    \"$response_file\"
                    altsource=\"aspenoneengdvd\"
                    /L logfile=\"$templog\"
                    /noreboot")){
        output("FAIL\n");
        return 0;
    }
    output("OK\n");
   return 1;
}

sub install_prereqs {
    output("Installing SQL components...\n");

    my $success = 1;
    foreach my $prereq (@prereq_msi) {
        output('   '.$prereq-&gt;{name}.': ');

        if ($prereq-&gt;{detect}) {
            if (ref($prereq-&gt;{detect}) eq 'ARRAY') {
                output(Dumper($prereq-&gt;{detect}),LOG_ONLY);
                my @results = IsAppInstalled(@{$prereq-&gt;{detect}});
                # If IsAppInstalled returns anything, the component is installed.
                if (@results) {
                    output("ALREADY_SATISFIED\n");
                    output(join("\n\n",
                                map { Dumper($Registry-&gt;{$_}) } @results)."\n",
                           LOG_ONLY);
                    next;
                }
            } elsif (ref($prereq-&gt;{detect}) eq 'CODE') {
                if ($prereq-&gt;{detect}-&gt;()) {
                    output("ALREADY_SATISFIED\n");
                    next;
                }
            }
        }

        if ($prereq-&gt;{cmd}) {
            my $outcome =
                run_command(join(' ',@{$prereq-&gt;{cmd}}),
                            'Description' =&gt; 'installing '.$prereq-&gt;{name});
            output(($outcome?'OK':'FAILED')."\n");
            $success &amp;&amp;= $outcome;

        } elsif ($prereq-&gt;{msi}) {
            my $outcome = install_msi(@{$prereq-&gt;{msi}});
            output(($outcome?'OK':'FAILED')."\n");
            $success &amp;&amp;= $outcome;

        } elsif ($prereq-&gt;{code}) {
            my $outcome = $prereq-&gt;{code}-&gt;();
            output(($outcome?'OK':'FAILED')."\n");
            $success &amp;&amp;= $outcome;
        }
    }

    return $success;
}

sub configure {
    my $success = 1;

    $success &amp;&amp;= configure_login_script();
    $success &amp;&amp;= configure_compiler();
    my $userloginscript = build_path(get_allusers_scripts(), 'standard', 'aspenONEEng.10', 'aspentech_userlogin.cmd');
    # if(run_command($userloginscript)){ #Isn't running on its own, run here. Do not care about outcome, same as below implementation
    #     output("ran login script!\n");
    # }
    # else{
    #     output("Did not run login script\n");
    # }
    return $success;
}

# Begin-Doc
################################
# Name: sub_log()
# Description: Generate a log file based on the package ID and the supplied
#   string. This is meant to ensure that the log file has a name that reflects
#   its meaning but also sorts together with all the other package logs.
# Returns: a file name (not a path) to use as the log file
# LastUpdated: 2014-09-29
# CreatedBy: Todd Hartman
################################
# End-Doc
sub sub_log {
    my $suffix = shift;
    $suffix =~ s/[ ]/_/g;
    return get_package_name() . "." . get_version().'-' . $suffix.'.txt';
}
# Begin-Doc
################################
# Name: configure_login_script()
# Description: create an ActiveSetup action to invoke the user-level
#    customization script for aspenONE.
# Returns: true/false on success/failure
# LastUpdated: 2014-09-30
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub configure_login_script {
    output("   Configuring user-level customizations: ");

    my $script = create_login_script();
    return 0 if (!$script);

    my $success = 1;
    if (!create_activesetup_action(
             'Identifier' =&gt; get_package_id().'-UserCustomizations',
             'ComponentID' =&gt; get_package_id(),
             'Description' =&gt; 'preconfigure user environment for aspenONE',
             'Version' =&gt; '1,0,1,20141014',
             'StubPath' =&gt; cmd_quote($script),
        )) {
        output("     Error: cannot create Active Setup preconfigure user environment.\n");
        $success = 0;
    }

    # Run the script as the current user.
    # The success of the install is not contingent on this attempt.
    # We're only doing it so that interactive installs will function without
    #   requiring a logout/login.
    run_command($script,
                'Description' =&gt; 'invoking login script as the current user',
                'IgnoreReturnCode' =&gt; 1);

    output(($success?'OK':'FAILURE')."\n");
    return $success;
}


# Begin-Doc
################################
# Name: create_login_script()
# Description: Creates the user-level login script.
#    The script disables the registration check.
# Returns: the path to the script entry point (a CMD wrapper)
# LastUpdated: 2014-10-14
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub create_login_script {
    output("Creating login script...\n");
    my $script_dir = build_path(get_allusers_scripts(),'standard',
                                get_package_id());
    my $script_file = build_path($script_dir,
                                 'aspentech_userlogin.pl');
    my $script_wrapper = build_path($script_dir,
                                    'aspentech_userlogin.cmd');

    # Delete and recreate the script dir.
    if (-d $script_dir) {
        remove_tree($script_dir) or
            output("Error removing existing login script directory '${script_dir}': $!\n",
                   LOG_ONLY);
    }
    make_path($script_dir);
    
    if (open(my $SCRIPT,'&gt;',$script_file)) {
        print $SCRIPT q|
#!perl
use Win32::TieRegistry;
use Data::Dumper;

$Registry-&gt;{HKEY_CURRENT_USER}-&gt;{'SOFTWARE\AspenTech'} = {
    # Don't bother users about registration.
    'DoNotRegister' =&gt; '1',
    'V9UserRegistered' =&gt; '1',

    # Make Aspen Properties v10.0 (the only one installed) the default
    #   for the v10.0 apps.
    'AMSystem' =&gt; {
        '30.0' =&gt; {
            'Compatibility' =&gt; {
                'APrSystem'       =&gt; { '1' =&gt; '32.0' },
                'AspenPlus'       =&gt; { '1' =&gt; '32.0' },
                'AspenProperties' =&gt; { '1' =&gt; '32.0' },
            },
        },
    },

    # Configure the correct (default) compiler versions.
    'APrSystem' =&gt; {
        '32.0' =&gt; {
            'aplus' =&gt; {
                'CompilerSection' =&gt; 'IVF14_VS12',
            },
        },
    },
};

$Data::Dumper::Indent = 1;
print(Dumper($Registry-&gt;{HKEY_CURRENT_USER}-&gt;{'SOFTWARE\AspenTech'}));

|;
        close($SCRIPT);
        output(join("\n",
                    'aspenOne 10 Login Script:',
                    ('-' x 60),
                    get_file_contents($script_file),
                    ('-' x 60),''
               ), LOG_ONLY);
    } else {
        output("Error opening login script file '${script_file}': $!\n");
        return 0;
    }

    if (open(my $SCRIPT,'&gt;',$script_wrapper)) {
        my $log_dir = build_path('%APPDATA%','MST','Logs');
        print $SCRIPT q|
mkdir "|.$log_dir.q|"
perl "%~dp0|.basename($script_file).q|" &gt; "|.
            build_path($log_dir,get_package_id().'-loginscript.txt').q|" 2&gt;&amp;1
|;

        close($SCRIPT);
        output(join("\n",
                    'aspenOne 10 Login Script:',
                    ('-' x 60),
                    get_file_contents($script_wrapper),
                    ('-' x 60),''
               ), LOG_ONLY);
    } else {
        output("Error opening login script wrapper file '${script_wrapper}': $!\n");
        return 0;
    }

    return $script_wrapper;
}

# Begin-Doc
################################
# Name: configure_compiler()
# Description: Configure the compiler default to use Visual Studio 2013
#    and Intel Visual FORTRAN 2013.
# Returns: true/false on success/failure of setting registry data
# LastUpdated: 2014-09-30
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub configure_compiler {
    # Set the default to Visual Studio 2013 + Intel Visual Fortran 2013.
    # IVF13_VS12 actually requires Intel version 13.*. What we have is v14.*.
    # IVF14_VS12 is what we want.
    output("   Configuring compiler options: ");

    my $aspentech_hklm_reg = build_path(get_arch_software_key(OSARCH_x86),
                                        'AspenTech');

    my $reg_data = {
        'APrSystem' =&gt; {
            '32.0' =&gt; {
                'aplus' =&gt; {
                    'CompilerSection' =&gt; 'IVF14_VS12',
                },
            },
        },
    };
    $Registry-&gt;{$aspentech_hklm_reg} = 
        $reg_data;

    my $outcome = verify_registry_data($aspentech_hklm_reg,$reg_data);
    output(($outcome?'OK':'FAILED')."\n");

    return $outcome;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling','virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    preinstall_sub =&gt; \&amp;pre_install,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;configure,
);


IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\aspenONEEng.9\dev\update.pl</FullName>
    <Length>18361</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-11-07T11:33:28.3143004-06:00</CreationTime>
    <CreationTimeUtc>2016-11-07T17:33:28.3143004Z</CreationTimeUtc>
    <LastWriteTime>2016-11-09T16:37:06.3692975-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-11-09T22:37:06.3692975Z</LastWriteTimeUtc>
    <LastAccessTime>2016-11-07T11:33:28.3143004-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-11-07T17:33:28.3143004Z</LastAccessTimeUtc>
    <Text># AspenONE Engineering V9
# Package Created November 2016
# Packaged by Chris Schaaf
# Last Updated ...

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'aspenONEEng.9',
        package_revision =&gt; '20161107T1200',
    );
}


use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use File::Basename;
use File::Temp qw(tempfile tempdir);
use File::Copy;
use File::Path qw(make_path remove_tree);
use Win32::TieRegistry;
use Text::CSV;
use Win32;
use Getopt::Long;
use Data::Dumper;
use Digest::SHA1;

my $src = get_pkg_sourcefiles();
my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\aspenONEEng.9";

my $logdir = tempdir('aspenOne-8_6-install-logs_XXXXXXXX',
                     DIR =&gt; $ENV{TEMP});
if (!$logdir) {
    output("Error creating temporary log directory: $!\n");
    return 0;
}
output("Log directory: ${logdir}\n", LOG_ONLY);
my $working_root = 'C:\ProgramData\AspenTech';
my $response_file = 'Aspen Engineering V9.xml';
my $templog = 'C:\Windows\System32\UMRINST\AppLogs\Aspen Engineering V9.log';

GetOptions(
    'prereq' =&gt; sub { exit(!install_prereqs()); },
    'configure' =&gt; sub { exit(!configure()); },
    'validate' =&gt; sub { exit(!validate_install()); },
);

#Borrowed from 8.6 installer
my @prereq_msi = (
	# These prereqs were moved out of the XML automation file.
    # All paths have SourceFiles prepended to them.
    # 'detect' contains:
    #    (arrayref) arguments to IsAppInstalled()
    #    (coderef) a subroutine that returns 1 if the prereq condition is met.
    # 'cmd'/'msi'/'code' refer to steps for installation.
    ############################################################

    {
        'name' =&gt; 'SQL Server 2005 Backward compatibility',
        'detect' =&gt; [
            'DisplayName' =&gt; 
                'Microsoft SQL Server 2005 Backward compatibility',
        ],
        'msi' =&gt; [
            'msi' =&gt; build_path($appdeploy,
                                'aspenoneengdvd','core',
                                'SQL2K5Expr','SQLServer2005_BC_x64.msi'),
            'additional_msi_properties' =&gt; 'ADDLOCAL=SQL_DMO,DTS_RUNTIME',
            'logfile_name' =&gt; sub_log('020-SQLServer2005_BC_x64')
        ],
    },

    ############################################################

    {
        'name' =&gt; 'SQL Server 2012 Express LocalDB',
        'detect' =&gt; [
            'DisplayName' =&gt; 
                qr/SQL Server 2012 Express LocalDB/i,
        ],
        'msi' =&gt; [
            'msi' =&gt; build_path($appdeploy,
                                'aspenoneengdvd','core',
                                'SQLLocalDB','x64','SqlLocaLDB.MSI'),
            'additional_msi_properties' =&gt; 'IACCEPTSQLLOCALDBLICENSETERMS=YES',
            'logfile_name' =&gt; sub_log('030-SqlLocaLDB')
        ],
    },

    ############################################################

    {
        'name' =&gt; 'Microsoft SQL Server 2012 Native Client',
        'detect' =&gt; [
            'DisplayName' =&gt; 
                qr/Microsoft SQL Server 2012 Native Client/i,
        ],
        'msi' =&gt; [
            'msi' =&gt; build_path($appdeploy,
                                'aspenoneengdvd','core',
                                'SQLLocalDB','x64','sqlncli.msi'),
            'additional_msi_properties' =&gt; 'IACCEPTSQLNCLILICENSETERMS=YES',
            'logfile_name' =&gt; sub_log('040-sqlncli')
        ],
    },

    ############################################################

    {
        'name' =&gt; 'Microsoft SQL Server 2012 Command Line Utilities',
        'detect' =&gt; [
            'DisplayName' =&gt; 
                qr/Microsoft SQL Server 2012 Command Line Utilities/i,
        ],
        'msi' =&gt; [
            'msi' =&gt; build_path($appdeploy,
                                'aspenoneengdvd','core',
                                'SQLLocalDB','x64','SqlCmdLnUtils.msi'),
            'additional_msi_properties' =&gt; 'IACCEPTSQLCMDLNUTILSLICENSETERMS=YES',
            'logfile_name' =&gt; sub_log('050-SqlCmdLnUtils')
        ],
    },

    ############################################################

    {
        'name' =&gt; 'Microsoft SQL Server 2012 ADOMD.NET',
        'detect' =&gt; [
            'DisplayName' =&gt; 
                qr/Microsoft SQL Server 2012 ADOMD.NET/i,
        ],
        'msi' =&gt; [
            'msi' =&gt; build_path($appdeploy,
                                'aspenoneengdvd','core',
                                'SQLComponents','SQL_AS_ADOMD_x64.msi'),
            'logfile_name' =&gt; sub_log('090-SQL_AS_ADOMD_x64'),
        ],
    },

    ############################################################

    {
        'name' =&gt; 'MSXML 6.0 Parser',
        'detect' =&gt; [
            'DisplayName' =&gt; 
                qr/MSXML 6.0 Parser/i, # It never gets detected.
        ],
        'msi' =&gt; [
            'msi' =&gt; build_path($appdeploy,
                                'aspenoneengdvd','core',
                                'SQLComponents','msxml6_x64.msi'),
            'logfile_name' =&gt; sub_log('100-msxml6_x64'),
        ],
    },

    ############################################################

    {
        'name' =&gt; 'Microsoft AS OLE DB Provider for SQL Server 2012',
        'detect' =&gt; [
            'DisplayName' =&gt; 
                qr/Microsoft AS OLE DB Provider for SQL Server 2012/i,
        ],
        'msi' =&gt; [
            'msi' =&gt; build_path($appdeploy,
                                'aspenoneengdvd','core',
                                'SQLComponents','SQL_AS_OLEDB_x64.msi',),
            'logfile_name' =&gt; sub_log('120-SQL_AS_OLEDB_x64'),
        ],
    },

    ############################################################

    {
        'name' =&gt; 'SQL Server 2012 Analysis Management Objects',
        'detect' =&gt; [
            'DisplayName' =&gt; 
                qr/SQL Server 2012 Analysis Management Objects/i,
        ],
        'msi' =&gt; [
            'msi' =&gt; build_path($appdeploy,
                                'aspenoneengdvd','core',
                                'SQLComponents','SQL_AS_AMO_x64.msi'),
            'logfile_name' =&gt; sub_log('130-SQL_AS_AMO_x64'),
        ],
    },

    ############################################################

    {
        'name' =&gt; 'Microsoft System CLR Types for SQL Server 2012',
        'detect' =&gt; [
            'DisplayName' =&gt; 
                qr/Microsoft System CLR Types for SQL Server 2012/i,
        ],
        'msi' =&gt; [
            'msi' =&gt; build_path($appdeploy,
                                'aspenoneengdvd','core',
                                'SQLComponents','SQLSysClrTypes_x64.msi'),
            'logfile_name' =&gt; sub_log('140-SQLSysClrTypes_x64'),
        ],
    },

    ############################################################

    {
        'name' =&gt; 'Microsoft SQL Server 2012 Management Objects',
        'detect' =&gt; [
            'DisplayName' =&gt; 
                qr/Microsoft SQL Server 2012 Management Objects/i,
        ],
        'msi' =&gt; [
            'msi' =&gt; build_path($appdeploy,
                                'aspenoneengdvd','core',
                                'SQLComponents',
                                'SharedManagementObjects_x64.msi'),
            'logfile_name' =&gt; sub_log('150-SharedManagementObjects_x64'),
        ],
    },

    ############################################################

);

sub pre_install {
	#Prerequisite Redistributables included with AspenONE 9
	output("Installing .NET components...\n   .NET 3.5: ");
	if(!run_command("\"$src\\redist\\Microsoft .NET Framework 3.5 SP1\\dotNetFx35.exe\" /qn", 'IgnoreExitCodes' =&gt; [3010])){
		output("FAIL\n");
		return 0;
	}
	output("OK\n   .NET 4.5.2: ");
	if(!run_command("\"$src\\redist\\Microsoft .NET Framework 4.5.2\\NDP452-KB2901907-x86-x64-AllOS-ENU.exe\" /q /norestart", 'IgnoreExitCodes' =&gt; [3010])){
		output("FAIL\n");
		return 0;
	}
	#Documentation seems to suggest that Aspen will install its own localdb server anyway. Unsure that I need this. If I do, I don't know what configuration I need.
	#output("OK\nInstalling SQL Express: ");
	#if(!run_command("\"$src\\redist\\Microsoft SQL Express 2012 SP1\\SQLEXPR_x64_ENU.exe\" /Q
	#					/IACCEPTSQLSERVERLICENSETERMS
	#					/ACTION=INSTALL
	#					/PID=
	#					/FEATURES=SQL,AS,RS,IS,Tools")){
	#	output("FAIL\n");
	#	return 0;
	#}
	output("OK\n");
	
	#Borrowing SQL prereqs from 8.6
	my $outcome = install_prereqs();
	if(!$outcome){
		return 0;
	}
	
	return 1;

}

 sub install {
	#From Aspen's deployment guidelines: http://www.aspentech.com/Support/Aspen-Deployment-Solutions/
	output("Installing Aspen Products: ");
	if(!run_command("\"$appdeploy\\AtRunUnattended.exe\"
					\"$response_file\"
					altsource=\"aspenoneengdvd\"
					/L logfile=\"$templog\"
					/noreboot")){
		output("FAIL\n");
		return 0;
	}
	output("OK\n");
   return 1;
}

sub install_prereqs {
    output("Installing SQL components...\n");

    my $success = 1;
    foreach my $prereq (@prereq_msi) {
        output('   '.$prereq-&gt;{name}.': ');

        if ($prereq-&gt;{detect}) {
            if (ref($prereq-&gt;{detect}) eq 'ARRAY') {
                output(Dumper($prereq-&gt;{detect}),LOG_ONLY);
                my @results = IsAppInstalled(@{$prereq-&gt;{detect}});
                # If IsAppInstalled returns anything, the component is installed.
                if (@results) {
                    output("ALREADY_SATISFIED\n");
                    output(join("\n\n",
                                map { Dumper($Registry-&gt;{$_}) } @results)."\n",
                           LOG_ONLY);
                    next;
                }
            } elsif (ref($prereq-&gt;{detect}) eq 'CODE') {
                if ($prereq-&gt;{detect}-&gt;()) {
                    output("ALREADY_SATISFIED\n");
                    next;
                }
            }
        }

        if ($prereq-&gt;{cmd}) {
            my $outcome =
                run_command(join(' ',@{$prereq-&gt;{cmd}}),
                            'Description' =&gt; 'installing '.$prereq-&gt;{name});
            output(($outcome?'OK':'FAILED')."\n");
            $success &amp;&amp;= $outcome;

        } elsif ($prereq-&gt;{msi}) {
            my $outcome = install_msi(@{$prereq-&gt;{msi}});
            output(($outcome?'OK':'FAILED')."\n");
            $success &amp;&amp;= $outcome;

        } elsif ($prereq-&gt;{code}) {
            my $outcome = $prereq-&gt;{code}-&gt;();
            output(($outcome?'OK':'FAILED')."\n");
            $success &amp;&amp;= $outcome;
        }
    }

    return $success;
}

sub configure {
    my $success = 1;

    $success &amp;&amp;= configure_login_script();
    $success &amp;&amp;= configure_compiler();
	my $userloginscript = build_path(get_allusers_scripts(), 'standard', 'aspenONEEng.9', 'aspentech_userlogin.cmd');
	if(run_command($userloginscript)){ #Isn't running on its own, run here. Do not care about outcome, same as below implementation
		output("ran login script!\n");
	}
	else{
		output("Did not run login script\n");
	}
    return $success;
}

# Begin-Doc
################################
# Name: sub_log()
# Description: Generate a log file based on the package ID and the supplied
#   string. This is meant to ensure that the log file has a name that reflects
#   its meaning but also sorts together with all the other package logs.
# Returns: a file name (not a path) to use as the log file
# LastUpdated: 2014-09-29
# CreatedBy: Todd Hartman
################################
# End-Doc
sub sub_log {
    my $suffix = shift;
    $suffix =~ s/[ ]/_/g;
    return get_package_name() . "." . get_version().'-' . $suffix.'.txt';
}
# Begin-Doc
################################
# Name: configure_login_script()
# Description: create an ActiveSetup action to invoke the user-level
#    customization script for aspenONE.
# Returns: true/false on success/failure
# LastUpdated: 2014-09-30
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub configure_login_script {
    output("   Configuring user-level customizations: ");

    my $script = create_login_script();
    return 0 if (!$script);

    my $success = 1;
    if (!create_activesetup_action(
             'Identifier' =&gt; get_package_id().'-UserCustomizations',
             'ComponentID' =&gt; get_package_id(),
             'Description' =&gt; 'preconfigure user environment for aspenONE',
             'Version' =&gt; '1,0,1,20141014',
             'StubPath' =&gt; cmd_quote($script),
        )) {
        output("     Error: cannot create Active Setup preconfigure user environment.\n");
        $success = 0;
    }

    # Run the script as the current user.
    # The success of the install is not contingent on this attempt.
    # We're only doing it so that interactive installs will function without
    #   requiring a logout/login.
    run_command($script,
                'Description' =&gt; 'invoking login script as the current user',
                'IgnoreReturnCode' =&gt; 1);

    output(($success?'OK':'FAILURE')."\n");
    return $success;
}


# Begin-Doc
################################
# Name: create_login_script()
# Description: Creates the user-level login script.
#    The script disables the registration check.
# Returns: the path to the script entry point (a CMD wrapper)
# LastUpdated: 2014-10-14
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub create_login_script {
	output("Creating login script...\n");
    my $script_dir = build_path(get_allusers_scripts(),'standard',
                                get_package_id());
    my $script_file = build_path($script_dir,
                                 'aspentech_userlogin.pl');
    my $script_wrapper = build_path($script_dir,
                                    'aspentech_userlogin.cmd');

    # Delete and recreate the script dir.
    if (-d $script_dir) {
        remove_tree($script_dir) or
            output("Error removing existing login script directory '${script_dir}': $!\n",
                   LOG_ONLY);
    }
    make_path($script_dir);

    if (open(my $SCRIPT,'&gt;',$script_file)) {
        print $SCRIPT q|
#!perl
use Win32::TieRegistry;
use Data::Dumper;

$Registry-&gt;{HKEY_CURRENT_USER}-&gt;{'SOFTWARE\AspenTech'} = {
    # Don't bother users about registration.
    'DoNotRegister' =&gt; '1',
    'V9UserRegistered' =&gt; '1',

    # Make Aspen Properties v9.0 (the only one installed) the default
    #   for the v9.0 apps.
    'AMSystem' =&gt; {
        '30.0' =&gt; {
            'Compatibility' =&gt; {
                'APrSystem'       =&gt; { '1' =&gt; '32.0' },
                'AspenPlus'       =&gt; { '1' =&gt; '32.0' },
                'AspenProperties' =&gt; { '1' =&gt; '32.0' },
            },
        },
    },

    # Configure the correct (default) compiler versions.
    'APrSystem' =&gt; {
        '32.0' =&gt; {
            'aplus' =&gt; {
                'CompilerSection' =&gt; 'IVF14_VS12',
            },
        },
    },
};

$Data::Dumper::Indent = 1;
print(Dumper($Registry-&gt;{HKEY_CURRENT_USER}-&gt;{'SOFTWARE\AspenTech'}));

|;
        close($SCRIPT);
        output(join("\n",
                    'aspenOne 9 Login Script:',
                    ('-' x 60),
                    get_file_contents($script_file),
                    ('-' x 60),''
               ), LOG_ONLY);
    } else {
        output("Error opening login script file '${script_file}': $!\n");
        return 0;
    }

    if (open(my $SCRIPT,'&gt;',$script_wrapper)) {
        my $log_dir = build_path('%APPDATA%','MST','Logs');
        print $SCRIPT q|
mkdir "|.$log_dir.q|"
perl "%~dp0|.basename($script_file).q|" &gt; "|.
            build_path($log_dir,get_package_id().'-loginscript.txt').q|" 2&gt;&amp;1
|;

        close($SCRIPT);
        output(join("\n",
                    'aspenOne 9 Login Script:',
                    ('-' x 60),
                    get_file_contents($script_wrapper),
                    ('-' x 60),''
               ), LOG_ONLY);
    } else {
        output("Error opening login script wrapper file '${script_wrapper}': $!\n");
        return 0;
    }

    return $script_wrapper;
}

# Begin-Doc
################################
# Name: configure_compiler()
# Description: Configure the compiler default to use Visual Studio 2013
#    and Intel Visual FORTRAN 2013.
# Returns: true/false on success/failure of setting registry data
# LastUpdated: 2014-09-30
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub configure_compiler {
    # Set the default to Visual Studio 2013 + Intel Visual Fortran 2013.
    # IVF13_VS12 actually requires Intel version 13.*. What we have is v14.*.
    # IVF14_VS12 is what we want.
    output("   Configuring compiler options: ");

    my $aspentech_hklm_reg = build_path(get_arch_software_key(OSARCH_x86),
                                        'AspenTech');

    my $reg_data = {
        'APrSystem' =&gt; {
            '32.0' =&gt; {
                'aplus' =&gt; {
                    'CompilerSection' =&gt; 'IVF14_VS12',
                },
            },
        },
    };
    $Registry-&gt;{$aspentech_hklm_reg} = 
        $reg_data;

    my $outcome = verify_registry_data($aspentech_hklm_reg,$reg_data);
    output(($outcome?'OK':'FAILED')."\n");

    return $outcome;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling','virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
	preinstall_sub =&gt; \&amp;pre_install,
	install_sub =&gt; \&amp;install,
	postinstall_sub =&gt; \&amp;configure,
);


IM_Exit(EXIT_SUCCESS);


</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\aspenONEEng.9\prod\update.pl</FullName>
    <Length>18361</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-11-10T09:37:34.3800373-06:00</CreationTime>
    <CreationTimeUtc>2016-11-10T15:37:34.3800373Z</CreationTimeUtc>
    <LastWriteTime>2016-11-09T16:37:06.3692975-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-11-09T22:37:06.3692975Z</LastWriteTimeUtc>
    <LastAccessTime>2016-11-10T09:37:34.3800373-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-11-10T15:37:34.3800373Z</LastAccessTimeUtc>
    <Text># AspenONE Engineering V9
# Package Created November 2016
# Packaged by Chris Schaaf
# Last Updated ...

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'aspenONEEng.9',
        package_revision =&gt; '20161107T1200',
    );
}


use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use File::Basename;
use File::Temp qw(tempfile tempdir);
use File::Copy;
use File::Path qw(make_path remove_tree);
use Win32::TieRegistry;
use Text::CSV;
use Win32;
use Getopt::Long;
use Data::Dumper;
use Digest::SHA1;

my $src = get_pkg_sourcefiles();
my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\aspenONEEng.9";

my $logdir = tempdir('aspenOne-8_6-install-logs_XXXXXXXX',
                     DIR =&gt; $ENV{TEMP});
if (!$logdir) {
    output("Error creating temporary log directory: $!\n");
    return 0;
}
output("Log directory: ${logdir}\n", LOG_ONLY);
my $working_root = 'C:\ProgramData\AspenTech';
my $response_file = 'Aspen Engineering V9.xml';
my $templog = 'C:\Windows\System32\UMRINST\AppLogs\Aspen Engineering V9.log';

GetOptions(
    'prereq' =&gt; sub { exit(!install_prereqs()); },
    'configure' =&gt; sub { exit(!configure()); },
    'validate' =&gt; sub { exit(!validate_install()); },
);

#Borrowed from 8.6 installer
my @prereq_msi = (
	# These prereqs were moved out of the XML automation file.
    # All paths have SourceFiles prepended to them.
    # 'detect' contains:
    #    (arrayref) arguments to IsAppInstalled()
    #    (coderef) a subroutine that returns 1 if the prereq condition is met.
    # 'cmd'/'msi'/'code' refer to steps for installation.
    ############################################################

    {
        'name' =&gt; 'SQL Server 2005 Backward compatibility',
        'detect' =&gt; [
            'DisplayName' =&gt; 
                'Microsoft SQL Server 2005 Backward compatibility',
        ],
        'msi' =&gt; [
            'msi' =&gt; build_path($appdeploy,
                                'aspenoneengdvd','core',
                                'SQL2K5Expr','SQLServer2005_BC_x64.msi'),
            'additional_msi_properties' =&gt; 'ADDLOCAL=SQL_DMO,DTS_RUNTIME',
            'logfile_name' =&gt; sub_log('020-SQLServer2005_BC_x64')
        ],
    },

    ############################################################

    {
        'name' =&gt; 'SQL Server 2012 Express LocalDB',
        'detect' =&gt; [
            'DisplayName' =&gt; 
                qr/SQL Server 2012 Express LocalDB/i,
        ],
        'msi' =&gt; [
            'msi' =&gt; build_path($appdeploy,
                                'aspenoneengdvd','core',
                                'SQLLocalDB','x64','SqlLocaLDB.MSI'),
            'additional_msi_properties' =&gt; 'IACCEPTSQLLOCALDBLICENSETERMS=YES',
            'logfile_name' =&gt; sub_log('030-SqlLocaLDB')
        ],
    },

    ############################################################

    {
        'name' =&gt; 'Microsoft SQL Server 2012 Native Client',
        'detect' =&gt; [
            'DisplayName' =&gt; 
                qr/Microsoft SQL Server 2012 Native Client/i,
        ],
        'msi' =&gt; [
            'msi' =&gt; build_path($appdeploy,
                                'aspenoneengdvd','core',
                                'SQLLocalDB','x64','sqlncli.msi'),
            'additional_msi_properties' =&gt; 'IACCEPTSQLNCLILICENSETERMS=YES',
            'logfile_name' =&gt; sub_log('040-sqlncli')
        ],
    },

    ############################################################

    {
        'name' =&gt; 'Microsoft SQL Server 2012 Command Line Utilities',
        'detect' =&gt; [
            'DisplayName' =&gt; 
                qr/Microsoft SQL Server 2012 Command Line Utilities/i,
        ],
        'msi' =&gt; [
            'msi' =&gt; build_path($appdeploy,
                                'aspenoneengdvd','core',
                                'SQLLocalDB','x64','SqlCmdLnUtils.msi'),
            'additional_msi_properties' =&gt; 'IACCEPTSQLCMDLNUTILSLICENSETERMS=YES',
            'logfile_name' =&gt; sub_log('050-SqlCmdLnUtils')
        ],
    },

    ############################################################

    {
        'name' =&gt; 'Microsoft SQL Server 2012 ADOMD.NET',
        'detect' =&gt; [
            'DisplayName' =&gt; 
                qr/Microsoft SQL Server 2012 ADOMD.NET/i,
        ],
        'msi' =&gt; [
            'msi' =&gt; build_path($appdeploy,
                                'aspenoneengdvd','core',
                                'SQLComponents','SQL_AS_ADOMD_x64.msi'),
            'logfile_name' =&gt; sub_log('090-SQL_AS_ADOMD_x64'),
        ],
    },

    ############################################################

    {
        'name' =&gt; 'MSXML 6.0 Parser',
        'detect' =&gt; [
            'DisplayName' =&gt; 
                qr/MSXML 6.0 Parser/i, # It never gets detected.
        ],
        'msi' =&gt; [
            'msi' =&gt; build_path($appdeploy,
                                'aspenoneengdvd','core',
                                'SQLComponents','msxml6_x64.msi'),
            'logfile_name' =&gt; sub_log('100-msxml6_x64'),
        ],
    },

    ############################################################

    {
        'name' =&gt; 'Microsoft AS OLE DB Provider for SQL Server 2012',
        'detect' =&gt; [
            'DisplayName' =&gt; 
                qr/Microsoft AS OLE DB Provider for SQL Server 2012/i,
        ],
        'msi' =&gt; [
            'msi' =&gt; build_path($appdeploy,
                                'aspenoneengdvd','core',
                                'SQLComponents','SQL_AS_OLEDB_x64.msi',),
            'logfile_name' =&gt; sub_log('120-SQL_AS_OLEDB_x64'),
        ],
    },

    ############################################################

    {
        'name' =&gt; 'SQL Server 2012 Analysis Management Objects',
        'detect' =&gt; [
            'DisplayName' =&gt; 
                qr/SQL Server 2012 Analysis Management Objects/i,
        ],
        'msi' =&gt; [
            'msi' =&gt; build_path($appdeploy,
                                'aspenoneengdvd','core',
                                'SQLComponents','SQL_AS_AMO_x64.msi'),
            'logfile_name' =&gt; sub_log('130-SQL_AS_AMO_x64'),
        ],
    },

    ############################################################

    {
        'name' =&gt; 'Microsoft System CLR Types for SQL Server 2012',
        'detect' =&gt; [
            'DisplayName' =&gt; 
                qr/Microsoft System CLR Types for SQL Server 2012/i,
        ],
        'msi' =&gt; [
            'msi' =&gt; build_path($appdeploy,
                                'aspenoneengdvd','core',
                                'SQLComponents','SQLSysClrTypes_x64.msi'),
            'logfile_name' =&gt; sub_log('140-SQLSysClrTypes_x64'),
        ],
    },

    ############################################################

    {
        'name' =&gt; 'Microsoft SQL Server 2012 Management Objects',
        'detect' =&gt; [
            'DisplayName' =&gt; 
                qr/Microsoft SQL Server 2012 Management Objects/i,
        ],
        'msi' =&gt; [
            'msi' =&gt; build_path($appdeploy,
                                'aspenoneengdvd','core',
                                'SQLComponents',
                                'SharedManagementObjects_x64.msi'),
            'logfile_name' =&gt; sub_log('150-SharedManagementObjects_x64'),
        ],
    },

    ############################################################

);

sub pre_install {
	#Prerequisite Redistributables included with AspenONE 9
	output("Installing .NET components...\n   .NET 3.5: ");
	if(!run_command("\"$src\\redist\\Microsoft .NET Framework 3.5 SP1\\dotNetFx35.exe\" /qn", 'IgnoreExitCodes' =&gt; [3010])){
		output("FAIL\n");
		return 0;
	}
	output("OK\n   .NET 4.5.2: ");
	if(!run_command("\"$src\\redist\\Microsoft .NET Framework 4.5.2\\NDP452-KB2901907-x86-x64-AllOS-ENU.exe\" /q /norestart", 'IgnoreExitCodes' =&gt; [3010])){
		output("FAIL\n");
		return 0;
	}
	#Documentation seems to suggest that Aspen will install its own localdb server anyway. Unsure that I need this. If I do, I don't know what configuration I need.
	#output("OK\nInstalling SQL Express: ");
	#if(!run_command("\"$src\\redist\\Microsoft SQL Express 2012 SP1\\SQLEXPR_x64_ENU.exe\" /Q
	#					/IACCEPTSQLSERVERLICENSETERMS
	#					/ACTION=INSTALL
	#					/PID=
	#					/FEATURES=SQL,AS,RS,IS,Tools")){
	#	output("FAIL\n");
	#	return 0;
	#}
	output("OK\n");
	
	#Borrowing SQL prereqs from 8.6
	my $outcome = install_prereqs();
	if(!$outcome){
		return 0;
	}
	
	return 1;

}

 sub install {
	#From Aspen's deployment guidelines: http://www.aspentech.com/Support/Aspen-Deployment-Solutions/
	output("Installing Aspen Products: ");
	if(!run_command("\"$appdeploy\\AtRunUnattended.exe\"
					\"$response_file\"
					altsource=\"aspenoneengdvd\"
					/L logfile=\"$templog\"
					/noreboot")){
		output("FAIL\n");
		return 0;
	}
	output("OK\n");
   return 1;
}

sub install_prereqs {
    output("Installing SQL components...\n");

    my $success = 1;
    foreach my $prereq (@prereq_msi) {
        output('   '.$prereq-&gt;{name}.': ');

        if ($prereq-&gt;{detect}) {
            if (ref($prereq-&gt;{detect}) eq 'ARRAY') {
                output(Dumper($prereq-&gt;{detect}),LOG_ONLY);
                my @results = IsAppInstalled(@{$prereq-&gt;{detect}});
                # If IsAppInstalled returns anything, the component is installed.
                if (@results) {
                    output("ALREADY_SATISFIED\n");
                    output(join("\n\n",
                                map { Dumper($Registry-&gt;{$_}) } @results)."\n",
                           LOG_ONLY);
                    next;
                }
            } elsif (ref($prereq-&gt;{detect}) eq 'CODE') {
                if ($prereq-&gt;{detect}-&gt;()) {
                    output("ALREADY_SATISFIED\n");
                    next;
                }
            }
        }

        if ($prereq-&gt;{cmd}) {
            my $outcome =
                run_command(join(' ',@{$prereq-&gt;{cmd}}),
                            'Description' =&gt; 'installing '.$prereq-&gt;{name});
            output(($outcome?'OK':'FAILED')."\n");
            $success &amp;&amp;= $outcome;

        } elsif ($prereq-&gt;{msi}) {
            my $outcome = install_msi(@{$prereq-&gt;{msi}});
            output(($outcome?'OK':'FAILED')."\n");
            $success &amp;&amp;= $outcome;

        } elsif ($prereq-&gt;{code}) {
            my $outcome = $prereq-&gt;{code}-&gt;();
            output(($outcome?'OK':'FAILED')."\n");
            $success &amp;&amp;= $outcome;
        }
    }

    return $success;
}

sub configure {
    my $success = 1;

    $success &amp;&amp;= configure_login_script();
    $success &amp;&amp;= configure_compiler();
	my $userloginscript = build_path(get_allusers_scripts(), 'standard', 'aspenONEEng.9', 'aspentech_userlogin.cmd');
	if(run_command($userloginscript)){ #Isn't running on its own, run here. Do not care about outcome, same as below implementation
		output("ran login script!\n");
	}
	else{
		output("Did not run login script\n");
	}
    return $success;
}

# Begin-Doc
################################
# Name: sub_log()
# Description: Generate a log file based on the package ID and the supplied
#   string. This is meant to ensure that the log file has a name that reflects
#   its meaning but also sorts together with all the other package logs.
# Returns: a file name (not a path) to use as the log file
# LastUpdated: 2014-09-29
# CreatedBy: Todd Hartman
################################
# End-Doc
sub sub_log {
    my $suffix = shift;
    $suffix =~ s/[ ]/_/g;
    return get_package_name() . "." . get_version().'-' . $suffix.'.txt';
}
# Begin-Doc
################################
# Name: configure_login_script()
# Description: create an ActiveSetup action to invoke the user-level
#    customization script for aspenONE.
# Returns: true/false on success/failure
# LastUpdated: 2014-09-30
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub configure_login_script {
    output("   Configuring user-level customizations: ");

    my $script = create_login_script();
    return 0 if (!$script);

    my $success = 1;
    if (!create_activesetup_action(
             'Identifier' =&gt; get_package_id().'-UserCustomizations',
             'ComponentID' =&gt; get_package_id(),
             'Description' =&gt; 'preconfigure user environment for aspenONE',
             'Version' =&gt; '1,0,1,20141014',
             'StubPath' =&gt; cmd_quote($script),
        )) {
        output("     Error: cannot create Active Setup preconfigure user environment.\n");
        $success = 0;
    }

    # Run the script as the current user.
    # The success of the install is not contingent on this attempt.
    # We're only doing it so that interactive installs will function without
    #   requiring a logout/login.
    run_command($script,
                'Description' =&gt; 'invoking login script as the current user',
                'IgnoreReturnCode' =&gt; 1);

    output(($success?'OK':'FAILURE')."\n");
    return $success;
}


# Begin-Doc
################################
# Name: create_login_script()
# Description: Creates the user-level login script.
#    The script disables the registration check.
# Returns: the path to the script entry point (a CMD wrapper)
# LastUpdated: 2014-10-14
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub create_login_script {
	output("Creating login script...\n");
    my $script_dir = build_path(get_allusers_scripts(),'standard',
                                get_package_id());
    my $script_file = build_path($script_dir,
                                 'aspentech_userlogin.pl');
    my $script_wrapper = build_path($script_dir,
                                    'aspentech_userlogin.cmd');

    # Delete and recreate the script dir.
    if (-d $script_dir) {
        remove_tree($script_dir) or
            output("Error removing existing login script directory '${script_dir}': $!\n",
                   LOG_ONLY);
    }
    make_path($script_dir);

    if (open(my $SCRIPT,'&gt;',$script_file)) {
        print $SCRIPT q|
#!perl
use Win32::TieRegistry;
use Data::Dumper;

$Registry-&gt;{HKEY_CURRENT_USER}-&gt;{'SOFTWARE\AspenTech'} = {
    # Don't bother users about registration.
    'DoNotRegister' =&gt; '1',
    'V9UserRegistered' =&gt; '1',

    # Make Aspen Properties v9.0 (the only one installed) the default
    #   for the v9.0 apps.
    'AMSystem' =&gt; {
        '30.0' =&gt; {
            'Compatibility' =&gt; {
                'APrSystem'       =&gt; { '1' =&gt; '32.0' },
                'AspenPlus'       =&gt; { '1' =&gt; '32.0' },
                'AspenProperties' =&gt; { '1' =&gt; '32.0' },
            },
        },
    },

    # Configure the correct (default) compiler versions.
    'APrSystem' =&gt; {
        '32.0' =&gt; {
            'aplus' =&gt; {
                'CompilerSection' =&gt; 'IVF14_VS12',
            },
        },
    },
};

$Data::Dumper::Indent = 1;
print(Dumper($Registry-&gt;{HKEY_CURRENT_USER}-&gt;{'SOFTWARE\AspenTech'}));

|;
        close($SCRIPT);
        output(join("\n",
                    'aspenOne 9 Login Script:',
                    ('-' x 60),
                    get_file_contents($script_file),
                    ('-' x 60),''
               ), LOG_ONLY);
    } else {
        output("Error opening login script file '${script_file}': $!\n");
        return 0;
    }

    if (open(my $SCRIPT,'&gt;',$script_wrapper)) {
        my $log_dir = build_path('%APPDATA%','MST','Logs');
        print $SCRIPT q|
mkdir "|.$log_dir.q|"
perl "%~dp0|.basename($script_file).q|" &gt; "|.
            build_path($log_dir,get_package_id().'-loginscript.txt').q|" 2&gt;&amp;1
|;

        close($SCRIPT);
        output(join("\n",
                    'aspenOne 9 Login Script:',
                    ('-' x 60),
                    get_file_contents($script_wrapper),
                    ('-' x 60),''
               ), LOG_ONLY);
    } else {
        output("Error opening login script wrapper file '${script_wrapper}': $!\n");
        return 0;
    }

    return $script_wrapper;
}

# Begin-Doc
################################
# Name: configure_compiler()
# Description: Configure the compiler default to use Visual Studio 2013
#    and Intel Visual FORTRAN 2013.
# Returns: true/false on success/failure of setting registry data
# LastUpdated: 2014-09-30
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub configure_compiler {
    # Set the default to Visual Studio 2013 + Intel Visual Fortran 2013.
    # IVF13_VS12 actually requires Intel version 13.*. What we have is v14.*.
    # IVF14_VS12 is what we want.
    output("   Configuring compiler options: ");

    my $aspentech_hklm_reg = build_path(get_arch_software_key(OSARCH_x86),
                                        'AspenTech');

    my $reg_data = {
        'APrSystem' =&gt; {
            '32.0' =&gt; {
                'aplus' =&gt; {
                    'CompilerSection' =&gt; 'IVF14_VS12',
                },
            },
        },
    };
    $Registry-&gt;{$aspentech_hklm_reg} = 
        $reg_data;

    my $outcome = verify_registry_data($aspentech_hklm_reg,$reg_data);
    output(($outcome?'OK':'FAILED')."\n");

    return $outcome;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling','virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
	preinstall_sub =&gt; \&amp;pre_install,
	install_sub =&gt; \&amp;install,
	postinstall_sub =&gt; \&amp;configure,
);


IM_Exit(EXIT_SUCCESS);


</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\atom.1_12_2\prod\update.pl</FullName>
    <Length>1968</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-11-15T10:57:11.3218495-06:00</CreationTime>
    <CreationTimeUtc>2016-11-15T16:57:11.3218495Z</CreationTimeUtc>
    <LastWriteTime>2016-12-20T11:39:14.9679714-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-12-20T17:39:14.9679714Z</LastWriteTimeUtc>
    <LastAccessTime>2016-11-15T10:57:11.3218495-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-11-15T16:57:11.3218495Z</LastAccessTimeUtc>
    <Text># Atom 1.12.2016	
# Package Created Nov 2016
# Packaged by Ronith 
# Last Update 12/20/2016 By Benjamin Krueger

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'atom.1_12_2',
        package_revision =&gt; '20161115T1100',
    );
}

# Add InstallMonkey Library to the path 
use lib (
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
my $source = "$sourcefilesdir\\Atom";
my $startmenu = get_allusers_start_menu()."\\programs";
my $programDataDir = "C:\\Atom";

sub install{
	mkdir_im($programDataDir);
	output("Installing Atom 1.12.2\n");
    if(!run_command("XCOPY \"$source\" \"$programDataDir\" /E /H")){
		output("Error copying files\n");
	}
    return 1;
}

sub postinstall{
	my $exename = "C:\\Atom\\atom.exe";
    my $smlnk = get_allusers_start_menu().'\\Programs\\Atom.lnk';
	output($smlnk);
    create_shortcut(
        'target' =&gt;$exename,
        'link' =&gt; $smlnk,
        'description' =&gt; 'Launches Atom',
    );
 }
 
do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                     'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
	#need_reboot =&gt; 1,
	install_sub =&gt; \&amp;install,
	postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\atom.1_22_0\prod\update.pl</FullName>
    <Length>3730</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-02-01T11:44:19.8312808-06:00</CreationTime>
    <CreationTimeUtc>2018-02-01T17:44:19.8312808Z</CreationTimeUtc>
    <LastWriteTime>2018-05-08T15:32:38.9322702-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-08T20:32:38.9322702Z</LastWriteTimeUtc>
    <LastAccessTime>2018-02-01T11:44:19.8312808-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-02-01T17:44:19.8312808Z</LastAccessTimeUtc>
    <Text># Atom 1.8.0
# Package Created June 2016
# Packaged by Ronith
# Last Update ...

# 2/1/18 Being ported to network share - Daniel T. Holtzclaw t-dthxd8

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'atom.1_22_0',
        package_revision =&gt; '20170714T1300',
    );
}

# Add InstallMonkey Library to the path
use lib (
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
  '.\\',
  "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\atom.1_22_0",
);

use InstallMonkey::Shared;
use IM_helper(\%INSTALLMONKEY_OPTIONS, v4.06);

#my $sourcefilesdir = get_pkg_sourcefiles();
my $applogs = get_applogs_dir();
my $programfiles = get_arch_programfiles(OSARCH_x64);
my $zip = "C:\\Program Files\\7-zip\\7z.exe";
my $appdeploy_path = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\atom.1_22_0";

#The msi installs Atom installer to the machine, whenever a new user logs in the atom installer kicks in
#The actual software is installed to the user profile
#As of June 2016 this is the only way Atom allows installation to all users on the machine

sub install{
  ToggleSecurity();

  my $install_cmd = "start /wait $appdeploy_path\\atomsetup.exe --silent";
  #my $unzip_cmd = "\"$zip\" x -o\"C:\\Program Files (x86)\" \"$appdeploy_path\\Atom x64.7z\"";

	output("Installing Atom 1.22.0\n");
  run_command($install_cmd);

  ToggleSecurity();

	#if(!run_command($unzip_cmd))
	#{
  #  print "Error: failed to unzip Atom files!\n";
	#  return 0
	#}
  return 1;
}
sub postinstall
{
  sleep(60);
  #run_command("taskkill /IM atomsetup.exe /F");
  #run_command("taskkill /IM atom.exe /F");
	# Copy shortcut to start menu
	run_command("xcopy \"$appdeploy_path\\atom.lnk\" \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\\" /Q /I /Y");

}
do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                     'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    no_source_files =&gt; 1,
    need_reboot =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

###
## This sub turns off installer security certificate warnings so the installer
##   will run without a prompt. It is a pure toggle, so if you call it twice,
##   the registries (if they exist) will have reverted.
###
sub ToggleSecurity{
  my %security_keys = (
					'HKEY_CURRENT_USER/Software/Microsoft/Windows/CurrentVersion/Internet Settings/Zones/3' =&gt; '1806',
					'HKEY_LOCAL_MACHINE/Software/Microsoft/Windows/CurrentVersion/Internet Settings/Zones/3' =&gt; '1806',
				);

				while(my ($key,$value) = each %security_keys){
					IM_helper::get_reg_value_data(
						key=&gt;$key,
						value=&gt;$value,
						succ_cb=&gt;sub{
							my $value_data = {@_}-&gt;{results};
							if(defined $value_data){
								IM_helper::set_reg_key_values(
									key=&gt;$key,
									values=&gt;[
										$value=&gt;[
											('0x0000000'.(!$value_data)),
											'REG_DWORD'
										]
									]
								);
							}
						}
					);
				}
				return 1;
}

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\atom.1_23_3\prod\update.pl</FullName>
    <Length>5517</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-02-01T13:28:24.740082-06:00</CreationTime>
    <CreationTimeUtc>2018-02-01T19:28:24.740082Z</CreationTimeUtc>
    <LastWriteTime>2018-05-11T13:20:33.3555802-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-11T18:20:33.3555802Z</LastWriteTimeUtc>
    <LastAccessTime>2018-02-01T13:28:24.7884682-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-02-01T19:28:24.7884682Z</LastAccessTimeUtc>
    <Text># Atom 1.23.3
# Package Created Winter 2018
# Packaged by Alex Schrimpf


=pod

Begin-Doc
Modified: 
Name: 
Type:
Description: 
Language: Perl
LastUpdatedBy:
Version:
Doc-Package-Info
Doc-SVN-Repository:
RCSId:
End-Doc

=cut

use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'atom.1_23_3',
        package_revision =&gt; '',
    );
}

use lib ( '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 'C:\temp' );

use InstallMonkey::Shared;

my $activesetup_dir = "C:\\Windows\\System32\\UMRINST\\scripts\\$INSTALLMONKEY_OPTIONS{package_id}";

use IM_helper(
    \%INSTALLMONKEY_OPTIONS,
    v4.04,
    (	
        "INSTALL" =&gt; [
            sub{
                if(!(-e $activesetup_dir)){
                    return IM_helper::run_command(command=&gt;"mkdir \"$activesetup_dir\"");
                }
                return 1;
            },
            sub{
                my @activesetup_files = ('app.ico','atomsetup.exe');
                foreach my $file (@activesetup_files){
                    return 0 unless IM_helper::cp_file(
                        from =&gt; "$IM_helper::source_files\\$file",
                        to_file =&gt; "$activesetup_dir\\$file"
                    );
                }
                return 1;
            },
            # This is what the atom shorcut points to if the installer hasn't finished before the user finishes logging in
            # I think this will only happen if atom is deployed to a user whose account has already been built on the pc
            sub {
                IM_helper::write_file(
                    file=&gt;"$activesetup_dir\\atom_message.vbs",
                    data=&gt;IM_helper::normalize_text(
                        text=&gt;qq|
                            MsgBox "Please wait while atom finishes installing", vbExclamation
                        |
                    )
                );
            },
            sub {
                IM_helper::write_file(
                    file=&gt; "$activesetup_dir\\install_atom.vbs",
                    data=&gt;IM_helper::normalize_text(
                        text=&gt;qq|
                            Set WshShell = CreateObject("WScript.Shell")
                            Dim FSO
                            Set FSO = CreateObject("Scripting.FileSystemObject")

                            strDesktopPath = WshShell.SpecialFolders("Desktop")
                            strDesktopShortcut = strDesktopPath &amp; "\\Atom.lnk"
                            strStartMenuPath = WshShell.SpecialFolders("StartMenu") &amp; "\\Programs\\GitHub, Inc"

                            IF NOT fso.FolderExists(strStartMenuPath) Then
                                fso.CreateFolder(strStartMenuPath)
                            End If

                            IF fso.FileExists(strStartMenuPath &amp; "\\Atom.lnk") Then
                                fso.DeleteFile(strStartMenuPath &amp; "\\Atom.lnk")
                            End If

                            Set objShortcutUrl = WshShell.CreateShortcut(strStartMenuPath &amp; "\\Atom.lnk")
                            objShortcutUrl.TargetPath = "C:\\Windows\\System32\\UMRInst\\Scripts\\$INSTALLMONKEY_OPTIONS{package_id}\\atom_message.vbs"
                            objShortcutUrl.IconLocation = "C:\\Windows\\System32\\UMRInst\\Scripts\\$INSTALLMONKEY_OPTIONS{package_id}\\app.ico"
                            objShortcutUrl.Save

                            WScript.echo "Starting atom installer"
                            succ = WshShell.Run("C:\\Windows\\System32\\UMRInst\\Scripts\\$INSTALLMONKEY_OPTIONS{package_id}\\atomsetup.exe --silent")
                            IF succ = 0 Then
                                WScript.echo "Success"
                            ELSE
                                WScript.echo "Failed " &amp; succ
                            End If

                            WScript.echo "Waiting for installer to finish"
                            Do While Not fso.FileExists(strDesktopShortcut)
                            WScript.Sleep 2000
                            Loop 
                            WScript.echo "Done"
                            'This sleep is required because sometimes it will try to delete the shorcut while it is still being written
                            WScript.Sleep 2000
                            fso.DeleteFile strDesktopShortcut
                        |
                    ),
                    permissions=&gt;0755
                );
            },
            sub {
            	IM_helper::create_activesetup(
            		command=&gt;"cscript \"$activesetup_dir\\install_atom.vbs\"",
                    description=&gt;"Installs atom for the current user"
            	);
            }
        ]
    )
);

do_install(
    allowed_versions =&gt; [ 7.1.7601 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt;
      [ 'clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    no_install_check =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    no_product_key =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    install_sub =&gt; 
	    $IM_helper::exec_call_stack_override 
	    || 
	    sub{
	    	IM_helper::exec_call_stacks(
	    		ids=&gt;["INSTALL"]
	    	)
	    }
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\atom.1_8_0\prod\update.pl</FullName>
    <Length>1935</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-06-20T11:32:57.3989216-05:00</CreationTime>
    <CreationTimeUtc>2016-06-20T16:32:57.3989216Z</CreationTimeUtc>
    <LastWriteTime>2018-02-02T16:24:21.9466864-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-02-02T22:24:21.9466864Z</LastWriteTimeUtc>
    <LastAccessTime>2016-06-20T11:32:57.523724-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-06-20T16:32:57.523724Z</LastAccessTimeUtc>
    <Text># Atom 1.8.0
# Package Created June 2016
# Packaged by Ronith 
# Last Update ...

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'atom.1_8_0',
        package_revision =&gt; '20160629T1000',
    );
}

# Add InstallMonkey Library to the path 
use lib (
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
my $applogs=get_applogs_dir();
my $programfiles = get_arch_programfiles(OSARCH_x64);

#The msi installs Atom installer to the machine, whenever a new user logs in the atom installer kicks in 
#The actual software is installed to the user profile
#As of June 2016 this is the only way Atom allows installation to all users on the machine 

sub install{
	output("Installing Atom 1.8.0\n");
    if(!run_command("$sourcefilesdir\\atomsetup.msi /quiet"))
    {
        output("Atom 1.8.0 installation did not complete!\n");
        return 0;
    }
    else{
        output("Atom 1.8.0 installation was successful!\n");
    }
    return 1;
}

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                     'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
	need_reboot =&gt; 1,
	install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\audacity.2_1_3\prod\update.pl</FullName>
    <Length>1485</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-05-22T13:40:59.1330241-05:00</CreationTime>
    <CreationTimeUtc>2017-05-22T18:40:59.1330241Z</CreationTimeUtc>
    <LastWriteTime>2018-04-26T14:45:01.8291804-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-04-26T19:45:01.8291804Z</LastWriteTimeUtc>
    <LastAccessTime>2015-04-20T09:20:22-05:00</LastAccessTime>
    <LastAccessTimeUtc>2015-04-20T14:20:22Z</LastAccessTimeUtc>
    <Text># Audacity 2.1.3
# Package Created May 22, 2017
# Packaged by Austin Wall
# Last Updated May 22, 2017


use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'audacity.2_1_3',
        package_revision =&gt; '20170522T1351',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

our $srcfiles = get_pkg_sourcefiles();
our $need_reboot = 0;


sub install_audacity {
    my $sourcefilesdir = get_pkg_sourcefiles();
    my $getapplogsdir = get_applogs_dir();
    
    my @command = (
        $sourcefilesdir . '\audacity-win-2.1.3.exe', '/silent', '/norestart',
    );
    
    my $success = run_command(join(' ', @command));

    if ($success)
    {
        output("\n");
        output("Audacity was installed successfully.");
        output("\n");

        return 1;
    }
    else
    {
        output("Audacity was not installed successfully: $!\n");
        output("Please check the logs.");
        return 0;
    }
}



do_install( 
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs     =&gt; [ 'desktop', 'virtual-clc', 'virtual-desktop', 'traveling', 'clc' ],
    exit_on_failure  =&gt; 1,
    install_sub      =&gt; \&amp;install_audacity,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\audacity.2_2_2\prod\update.pl</FullName>
    <Length>2277</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-22T09:07:11.162408-05:00</CreationTime>
    <CreationTimeUtc>2018-05-22T14:07:11.162408Z</CreationTimeUtc>
    <LastWriteTime>2018-05-22T13:40:19.0968082-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-22T18:40:19.0968082Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-22T09:07:11.162408-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-22T14:07:11.162408Z</LastAccessTimeUtc>
    <Text># Audacity 2.1.3
# Package Created May 22, 2018
# Packaged by Robert Smith, based on Austin's 2.1.3 installer
# Last Updated May 22, 2018


use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'audacity.2_2_2',
        package_revision =&gt; '20180522T0908',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

our $srcfiles = get_pkg_sourcefiles();
our $need_reboot = 0;


sub install_audacity {
    my $sourcefilesdir = get_pkg_sourcefiles();
    my $getapplogsdir = get_applogs_dir();

#    my @command = (
#        $sourcefilesdir . '\audacity-win-2.2.2.exe', '/silent', '/norestart',
#    );
    my @command = (
        $sourcefilesdir . '\audacity-win-2.2.2.exe', 'TASKS=""', '/VERYSILENT',
        '/NORESTART', '/LOG="%temp%\Audacity 2.2.2.log"',
    );

    my $success = run_command(join(' ', @command));

    if ($success)
    {
        output("\n");
        output("Audacity was installed successfully.");
        output("\n");

        return 1;
    }
    else
    {
        output("Audacity was not installed successfully: $!\n");
        output("Please check the logs.");
        return 0;
    }
}

sub post {
    output("\n");

    output("Removing possible icons from public: ");
    my $Remove1 = run_command("del \"%systemdrive%\\Users\\Public\\Desktop\\Audacity.lnk\" /Q");
    output($Remove1 ? "Success!\n" : "FAILED: $!\n");

    output("Removing possible icons from user: ");
    my $current_user = getlogin || getpwuid($&lt;) || "Default";
    my $Remove2 = run_command("del \"%systemdrive%\\Users\\$current_user\\Desktop\\Audacity.lnk\" /Q");
    output($Remove2 ? "Success!\n" : "FAILED: $!\n");

    return ($Remove1 || $Remove2);
}


do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs     =&gt; [ 'desktop', 'virtual-clc', 'virtual-desktop', 'traveling', 'clc' ],
    exit_on_failure  =&gt; 1,
    install_sub      =&gt; \&amp;install_audacity,
    postinstall_sub  =&gt; \&amp;post,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\autocad.2017\prod\update.pl</FullName>
    <Length>4940</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-07T11:09:51.8758867-05:00</CreationTime>
    <CreationTimeUtc>2017-06-07T16:09:51.8758867Z</CreationTimeUtc>
    <LastWriteTime>2016-06-15T14:18:49.6946657-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-06-15T19:18:49.6946657Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-07T11:09:51.8758867-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-07T16:09:51.8758867Z</LastAccessTimeUtc>
    <Text># Package Created 2014-06-12
# Packaged by Dillon Lustick
# Last Updated 2016-5-24 by Jason Mao

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;
use Win32::TieRegistry;
use Getopt::Long;
print "Started PERL script...\n";

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'autocad.2017',
        package_revision =&gt; '20160524T1200',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;
print "Loaded InstallMonkey...\n";
#my $srcfiles = get_pkg_sourcefiles();
#my $log_dir = get_applogs_dir();

GetOptions(
    'uninstall' =&gt; sub { exit(! uninstall()); },
);

sub preinstall
{
    #output("Clearing reboot flag...\n");
    #$Registry-&gt;Delimiter("/");
    # The setup will restart the machine first if this key exists
    output("Inside PreInstall...\n");
    my @reglocs = ("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update\\RebootRequired", 
                "HKLM\\Software\\Microsoft\\Updates\\UpdateExeVolatile", 
                "HKLM\\System\\CurrentControlSet\\Control\\Session Manager\\PendingFileRenameOperations");
    #$Registry-&gt;{"LMachine/Software/Microsoft/Windows/CurrentVersion/WindowsUpdate/Auto Update/RebootRequired/"}
    foreach (@reglocs)
    {
        my $RegQ = run_command("reg query $_");
        if( !$RegQ )
        {
          return 1;
        }
        else
        {
            output("Pending reboot ($_), cannot continue installing. Please reboot and try again.\n");
            return 0;
        }
    }
    return 1;
    
}

sub install
{
    # This is run from appdeploy to avoid copying over 6GB of files per install.
    # The setup is generated with "Create Deployment" in the original install file.
    # More info available on wiki.
    output("Inside Install...\n");
    my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\autocad2017\\Img";
    my $Result = opendir(my $D, $appdeploy) || die "Can't Open $appdeploy: " . $!;
    if ($Result)
    {
        my @Dirs = grep{ $_ ne '.' &amp;&amp; $_ ne '..' &amp;&amp; $_ ne 'desktop.ini' } readdir($D);
        for (my $i = 0; $i &lt; (scalar @Dirs); $i++)
        {
            output("$appdeploy\\" . $Dirs[$i] . "\n");
        }
    }
    my $command = "$appdeploy\\Setup.exe /W /qb /I $appdeploy\\autocad.2017.ini /language en-us";

    output("Installing Autodesk Autocad with command: $command\n");
    run_command($command, 'IgnoreReturnCode'=&gt;1);

    # The run_command spawns a separate process and returns immediately so this loop waits until setup.exe finishes running.
    my $index = 0;
    while($index &lt; 3600) # 3600*5sec = 5 hours
    {
        $_ = `tasklist`;
        if(/setup\.exe/gi){
            $index++;
            sleep(5);
        }
        else{
            output("Setup finished!\n");
            return 1;
        }
    }

    output("Timed out...\n");

    return 0;
}

sub postinstall
{
    my $cwd = cwd();

    print("Copying License...\n");
    my $dest = get_arch_programfiles(OSARCH_x64).'\\Autodesk\\';
    run_command("copy \"$cwd\\LICPATH.LIC\" \"$dest\" /Y");
    run_command("setx ADSKFLEX_LICENSE_FILE \"C:\\Program Files\\Autodesk\\LICPATH.LIC\" \/m");
    
    output("Deleting desktop icons...\n");
    my $desk = get_allusers_desktop();
    run_command("DEL /Q \"$desk\\A360 Desktop.lnk\"");
    run_command("DEL /Q \"$desk\\AutoCAD 2017 - English.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk ReCap 360.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk Desktop App.lnk\"");
    return 1;
}

do_install(
    no_source_files  =&gt; 1,
    no_os_version_check =&gt; 1,
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
#    prerequisite_sub =&gt; \&amp;prerequisite,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    need_reboot =&gt; 1,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

sub uninstall
{
    output("Uninstalling AutoCAD 2016: ");
    
    my $outcome = run_command('"C:\Program Files\Autodesk\AutoCAD 2017\Setup\en-us\Setup\Setup.exe"
    /QB /W /T /P {5783F2D7-D001-0000-0102-0060B0CE6BBA} /R ACAD /language en-US');
    
    if($outcome)
    {
        delete_product_registry_key(get_package_name(). "." .get_version());
    }
    
    output(($outcome ? "OK\n" : "Failed\n"));
}
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\autocad.2018\prod\update.pl</FullName>
    <Length>4933</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-09T14:38:59.9609584-05:00</CreationTime>
    <CreationTimeUtc>2017-06-09T19:38:59.9609584Z</CreationTimeUtc>
    <LastWriteTime>2018-05-30T08:09:30.2554722-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-30T13:09:30.2554722Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-09T14:38:59.9609584-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-09T19:38:59.9609584Z</LastAccessTimeUtc>
    <Text># Package Created 2014-06-12
# Packaged by Dillon Lustick
# Last Updated June 2017 by cts28d

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;
use Win32::TieRegistry;
use Getopt::Long;
print "Started PERL script...\n";

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'autocad.2018',
        package_revision =&gt; '20170609T1500',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;
print "Loaded InstallMonkey...\n";
#my $srcfiles = get_pkg_sourcefiles();
#my $log_dir = get_applogs_dir();

GetOptions(
    'uninstall' =&gt; sub { exit(! uninstall()); },
);

sub preinstall
{
    #output("Clearing reboot flag...\n");
    #$Registry-&gt;Delimiter("/");
    # The setup will restart the machine first if this key exists
    output("Inside PreInstall...\n");
    my @reglocs = ("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update\\RebootRequired", 
                "HKLM\\Software\\Microsoft\\Updates\\UpdateExeVolatile", 
                "HKLM\\System\\CurrentControlSet\\Control\\Session Manager\\PendingFileRenameOperations");
    #$Registry-&gt;{"LMachine/Software/Microsoft/Windows/CurrentVersion/WindowsUpdate/Auto Update/RebootRequired/"}
    foreach (@reglocs)
    {
        my $RegQ = run_command("reg query $_");
        if( !$RegQ )
        {
          return 1;
        }
        else
        {
            output("Pending reboot ($_), cannot continue installing. Please reboot and try again.\n");
            return 0;
        }
    }
    return 1;
    
}

sub install
{
    # This is run from appdeploy to avoid copying over 6GB of files per install.
    # The setup is generated with "Create Deployment" in the original install file.
    # More info available on wiki.
    output("Inside Install...\n");
    my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\autocad.2018\\Img";
    my $Result = opendir(my $D, $appdeploy) || die "Can't Open $appdeploy: " . $!;
    if ($Result)
    {
        my @Dirs = grep{ $_ ne '.' &amp;&amp; $_ ne '..' &amp;&amp; $_ ne 'desktop.ini' } readdir($D);
        for (my $i = 0; $i &lt; (scalar @Dirs); $i++)
        {
            output("$appdeploy\\" . $Dirs[$i] . "\n");
        }
    }
    my $command = "$appdeploy\\Setup.exe /W /qb /I $appdeploy\\Default-MST.ini /language en-us";

    output("Installing Autodesk Autocad with command: $command\n");
    run_command($command, 'IgnoreReturnCode'=&gt;1);

    # The run_command spawns a separate process and returns immediately so this loop waits until setup.exe finishes running.
    my $index = 0;
    while($index &lt; 3600) # 3600*5sec = 5 hours
    {
        $_ = `tasklist`;
        if(/setup\.exe/gi){
            $index++;
            sleep(5);
        }
        else{
            output("Setup finished!\n");
            return 1;
        }
    }

    output("Timed out...\n");

    return 0;
}

sub postinstall
{
    my $cwd = cwd();

    print("Copying License...\n");
    my $dest = get_arch_programfiles(OSARCH_x64).'\\Autodesk\\';
    run_command("copy \"$cwd\\LICPATH.LIC\" \"$dest\" /Y");
    run_command("setx ADSKFLEX_LICENSE_FILE \"C:\\Program Files\\Autodesk\\LICPATH.LIC\" \/m");
    
    output("Deleting desktop icons...\n");
    my $desk = get_allusers_desktop();
    run_command("DEL /Q \"$desk\\A360 Desktop.lnk\"");
    run_command("DEL /Q \"$desk\\AutoCAD 2018 - English.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk ReCap.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk Desktop App.lnk\"");
    return 1;
}

do_install(
    no_source_files  =&gt; 1,
    no_os_version_check =&gt; 1,
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
#    prerequisite_sub =&gt; \&amp;prerequisite,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    need_reboot =&gt; 1,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

sub uninstall
{
    output("Uninstalling AutoCAD 2016: ");
    
    my $outcome = run_command('"C:\Program Files\Autodesk\AutoCAD 2018\Setup\en-us\Setup\Setup.exe"
    /QB /W /T /P {5783F2D7-D001-0000-0102-0060B0CE6BBA} /R ACAD /language en-US');
    
    if($outcome)
    {
        delete_product_registry_key(get_package_name(). "." .get_version());
    }
    
    output(($outcome ? "OK\n" : "Failed\n"));
}
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\autocad.2019\prod\update.pl</FullName>
    <Length>4981</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-25T10:40:44.8600059-05:00</CreationTime>
    <CreationTimeUtc>2018-05-25T15:40:44.8600059Z</CreationTimeUtc>
    <LastWriteTime>2018-07-12T12:22:28.5471986-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-12T17:22:28.5471986Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-25T10:40:44.8915453-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-25T15:40:44.8915453Z</LastAccessTimeUtc>
    <Text> # Package Created 2018-05-25
# Packaged by Kade Wessels

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;
use Win32::TieRegistry;
use Getopt::Long;
print "Started PERL script...\n";

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'autocad.2019',
        package_revision =&gt; '20180525T1002',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;
print "Loaded InstallMonkey...\n";
#my $srcfiles = get_pkg_sourcefiles();
#my $log_dir = get_applogs_dir();

GetOptions(
    'uninstall' =&gt; sub { exit(! uninstall()); },
);

sub preinstall
{
    #output("Clearing reboot flag...\n");
    #$Registry-&gt;Delimiter("/");
    # The setup will restart the machine first if this key exists
    output("Inside PreInstall...\n");
    my @reglocs = ("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update\\RebootRequired", 
                "HKLM\\Software\\Microsoft\\Updates\\UpdateExeVolatile", 
                "HKLM\\System\\CurrentControlSet\\Control\\Session Manager\\PendingFileRenameOperations");
    #$Registry-&gt;{"LMachine/Software/Microsoft/Windows/CurrentVersion/WindowsUpdate/Auto Update/RebootRequired/"}
    foreach (@reglocs)
    {
        my $RegQ = run_command("reg query \"$_\"");
        if( !$RegQ )
        {
          return 1;
        }
        else
        {
            output("Pending reboot ($_), cannot continue installing. Please reboot and try again.\n");
            return 0;
        }
    }
    return 1;
    
}

sub install
{
    # This is run from appdeploy to avoid copying over 6GB of files per install.
    # The setup is generated with "Create Deployment" in the original install file.
    # More info available on wiki.
    output("Inside Install...\n");
    my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\autocad.2019\\Img";
    my $Result = opendir(my $D, $appdeploy) || die "Can't Open $appdeploy: " . $!;
    if ($Result)
    {
        my @Dirs = grep{ $_ ne '.' &amp;&amp; $_ ne '..' &amp;&amp; $_ ne 'desktop.ini' } readdir($D);
        for (my $i = 0; $i &lt; (scalar @Dirs); $i++)
        {
            output("$appdeploy\\" . $Dirs[$i] . "\n");
        }
    }
    my $command = "$appdeploy\\Setup.exe /W /qb /I $appdeploy\\AutoCAD_2019.ini /language en-us";

    output("Installing Autodesk Autocad with command: $command\n");
    run_command($command, 'IgnoreReturnCode'=&gt;1);

    # The run_command spawns a separate process and returns immediately so this loop waits until setup.exe finishes running.
    my $index = 0;
    while($index &lt; 3600) # 3600*5sec = 5 hours
    {
        $_ = `tasklist`;
        if(/setup\.exe/gi){
            $index++;
            sleep(5);
        }
        else{
            output("Setup finished!\n");
            return 1;
        }
    }

    output("Timed out...\n");

    return 0;
}

sub postinstall
{
    my $cwd = cwd();

    print("Copying License...\n");
    my $dest = get_arch_programfiles(OSARCH_x64).'\\Autodesk\\';
    run_command("copy \"$cwd\\LICPATH.LIC\" \"$dest\" /Y");
    run_command("setx ADSKFLEX_LICENSE_FILE \"C:\\Program Files\\Autodesk\\LICPATH.LIC\" \/m");
    
    output("Deleting desktop icons...\n");
    my $desk = get_allusers_desktop();
    run_command("DEL /Q \"$desk\\A360 Desktop.lnk\"");
    run_command("DEL /Q \"$desk\\AutoCAD 2019 - English.lnk\"");
	run_command("DEL /Q \"$desk\\Autodesk ReCap.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk ReCap Photo.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk Desktop App.lnk\"");
    return 1;
}

do_install(
    no_source_files  =&gt; 1,
    no_os_version_check =&gt; 1,
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
#    prerequisite_sub =&gt; \&amp;prerequisite,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    need_reboot =&gt; 1,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

sub uninstall
{
    output("Uninstalling AutoCAD 2016: ");
    
    my $outcome = run_command('"C:\Program Files\Autodesk\AutoCAD 2019\Setup\en-us\Setup\Setup.exe"
    /QB /W /T /P {5783F2D7-D001-0000-0102-0060B0CE6BBA} /R ACAD /language en-US');
    
    if($outcome)
    {
        delete_product_registry_key(get_package_name(). "." .get_version());
    }
    
    output(($outcome ? "OK\n" : "Failed\n"));
}
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\axure_rp.8\prod\update.pl</FullName>
    <Length>4053</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-11-22T13:10:57.622333-06:00</CreationTime>
    <CreationTimeUtc>2016-11-22T19:10:57.622333Z</CreationTimeUtc>
    <LastWriteTime>2017-08-22T15:03:01.3807927-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-08-22T20:03:01.3807927Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-27T11:00:09.0470418-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-27T16:00:09.0470418Z</LastAccessTimeUtc>
    <Text># Axure RP 8.0
# Package Created May 2015 for Pro 7.0
# Packaged by Billy Rhoades
# Last Updated 2016-11-22 by Chris Schaaf

=pod

Begin-Doc
Modified: $Date June 05 2015
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author: dtptw6 $
Version: 8.0
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'axure_rp.8', 
        package_revision =&gt; '20160528T1303',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

use Getopt::Long;

my $srcfiles =  get_pkg_sourcefiles();
my $setup = "\"$srcfiles\\AxureRP-Setup.exe\"";

sub usage {
  print qq(
  usage: $0 [--help] [--uninstall]

  );
}

GetOptions(
  'help' =&gt; sub { usage(); exit(0); },
  'uninstall' =&gt; sub { exit(!uninstall()); },
);

sub uninstall
{
  my $logdir = get_default_app_log();
  $logdir =~ s/\.txt/_uninstall.txt/;

  output("\nUNINSTALLING Axure RP 8\n\n");

  InstallMonkey::Shared::copy_source_files(); # If we don't already have them, we need them

  output("Running Uninstaller: ");
  if( !run_command("$setup /s MODIFY=FALSE REMOVE=TRUE UNINSTALL=YES /l=\"$logdir\"" ) )
  {
    output("FAILED\n");
    return 0;
  }
  output("SUCCESS\n");

  delete_product_registry_key(get_package_id());

  return 1;
}

sub install
{
  my $logdir = get_default_app_log();
  $logdir =~ s/\.txt/_install.txt/;

=ehhh
  # This might fail on installs using a system account
  # The installer uses InstallAware which will rollback changes if there is an error in the install
  # and it will return success.
  output("Installing Axure RP: ");
  run_command("$setup /s /l=\"$logdir\"");

  # This checks if the dir does not exist
  if(!-d "$ENV{'PROGRAMFILES(x86)'}\\Axure")
  {

    output("FAILED: Error using a system account to install...\n");
    output("Trying backup method: ");
=cut
    # Had issue with installer hanging, so just going to manually copy the files 
    # So we are going to do a manual install of the files (this method is supported by Axure btw)
    if(!run_command("\"$srcfiles\\7z\\App\\7-Zip\\7z.exe\" x -o\"$ENV{'PROGRAMFILES(X86)'}\" \"$srcfiles\\Axure.7z\""))
    {
      output("FAILED\n");
      return 0;
    }
    else
    {
      output("Success!\n");
      output("Removing Zipped File: ");
      if( !run_command("DEL /Q \"$srcfiles\\Axure.7z\"") )
      {
        output( "FAILED\n");
      }
      output( "DONE\n");
      if(!run_command("XCOPY \"$srcfiles\\Axure\" \"$ENV{'PROGRAMDATA'}\\Microsoft\\Windows\\Start Menu\\Programs\\Axure\" /Y /Q /I /S"))
      {
        output("FAILED to copy start menu item");
      }
    }
  #}
  
  output("Success!\n");
  return 1;
}

sub postinstall
{
  my $desktop = get_allusers_desktop();
  my $target  = $desktop.'\\Axure RP 8.lnk';

  # http://www.itninja.com/software/axure-rp/axure/6-652
  # Copy a .lic file with license information to the target directory
  output("Installing License File: ");
  if( !run_command("COPY \"$srcfiles\\lic.key\" \"".$ENV{'PROGRAMFILES(x86)'}."\\Axure\\Axure RP 8\\\"") )
  {
    output("FAILED\n");
    return 0;
  }
  output("SUCCESS\n");

  output("Removing Shortcuts: ");
  if( !run_command("del /q \"$target\"", 'Description'=&gt;'deleting desktop shortcut') )
  {
    output("FAILED\n");
    return 0;
  }
  output("SUCCESS\n");

  return 1;
}

do_install( 
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
    allowed_os_architectures =&gt; [ OSARCH_x64, OSARCH_x86 ],
    allowed_regs =&gt; [ 'clc', 'desktop', 'traveling',
                      'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\blender.2_78a\prod\update.pl</FullName>
    <Length>2829</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-11-16T09:02:03.5834134-06:00</CreationTime>
    <CreationTimeUtc>2016-11-16T15:02:03.5834134Z</CreationTimeUtc>
    <LastWriteTime>2016-11-18T10:18:19.9680869-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-11-18T16:18:19.9680869Z</LastWriteTimeUtc>
    <LastAccessTime>2016-11-16T09:02:03.5834134-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-11-16T15:02:03.5834134Z</LastAccessTimeUtc>
    <Text># Blender 2.78a
# Package Created November 20, 2012
# Packaged by Eric Boyer
# Last Updated 2016-11-16 by Chris Schaaf

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'blender.2_78a',
        package_revision =&gt; '20161116T0140',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $src= get_pkg_sourcefiles();


sub install
{
  #Some versions may pop up with a security warning. Right-click the file, go to properties, select the bottom "Unblock" option.
  #This only needs to be done once.
  print "\nInstalling Blender 2.78a: ";
  if(!run_command("\"$src\\blender-2.78a-windows64.msi\"
					/qn
					/norestart")) {
    print "FAIL\n";
    return 0;
  }
  else {
    print "OK\n";
  }
  return 1;
}

sub postinstall 
{
  my $desk = build_path(get_allusers_desktop(), 'Blender.lnk');
  output("\nDeleting Desktop Icon: ");
  if(!run_command("DEL /q \"$desk\"")) {
    print "FAILED!!\n";
  }
  else {
    print "Success\n";
  }
  output("\nDeleting current user's desktop icon\n(expect failure unless run directly from update.pl)\n");
  my $userdesk = build_path('C:', 'Users', $ENV{USERNAME}, 'Desktop', 'Blender.lnk');
  if(!run_command("DEL /q \"$userdesk\"")) {
    print "Failure to delete, but most likely nothing to worry about.\n";
  }
  else {
    print "Success\n";
  }
  output("Adding Start Menu shortcuts...\n"); #This was not being installed with the rest of it through SCCM for some reason.
  my $start = build_path(get_allusers_start_menu(), 'Programs');
  if(!run_command("xcopy /YEFI \"$src\\Blender\" \"$start\\Blender\"")){
	output("FAIL\n");
  }
  else{
	print "Success\n"
  }
#This version doesn't place an uninstall link. Leaving this here for easy revision in case this ever changes again.
=pod
  my $uninstall = get_allusers_start_menu().'\Programs\\Blender Foundation\\Blender\\Uninstall.lnk';
  print "\nDeleting Uninstall Icon: ";
  if(!run_command("DEL /q \"$uninstall\"")) {
    print "FAILED!!\n";
  }
  else {
    print "Success\n";
  }
=cut
  
  return 1;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\blender.2_79b\prod\update.pl</FullName>
    <Length>2883</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-08T11:43:12.1337545-05:00</CreationTime>
    <CreationTimeUtc>2018-05-08T16:43:12.1337545Z</CreationTimeUtc>
    <LastWriteTime>2018-05-11T14:22:22.4385147-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-11T19:22:22.4385147Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-08T11:43:12.1337545-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-08T16:43:12.1337545Z</LastAccessTimeUtc>
    <Text># Blender 2.79b
# Package Created May 10, 2018
# Packaged by Robert Smith
# Last Updated 2018-05-10 by Robert Smith

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'blender.2_79b',
        package_revision =&gt; '20180510T1325',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $src= get_pkg_sourcefiles();


sub install
{
  #Some versions may pop up with a security warning. Right-click the file, go to properties, select the bottom "Unblock" option.
  #This only needs to be done once.
  print "\nInstalling Blender 2.79b: ";
  if(!run_command("\"$src\\blender-2.79b-windows64.msi\"
					/qn
					/norestart")) {
    print "FAIL\n";
    return 0;
  }
  else {
    print "OK\n";
  }
  return 1;
}

sub postinstall
{
  my $desk = build_path(get_allusers_desktop(), 'Blender.lnk');
  output("\nDeleting Desktop Icon: ");
  if(!run_command("DEL /q \"$desk\"")) {
    print "FAILED!!\n";
  }
  else {
    print "Success\n";
  }
  output("\nDeleting current user's desktop icon\n(expect failure unless run directly from update.pl)\n");
  my $userdesk = build_path('C:', 'Users', $ENV{USERNAME}, 'Desktop', 'Blender.lnk');
  if(!run_command("DEL /q \"$userdesk\"")) {
    print "Failure to delete, but most likely nothing to worry about.\n";
  }
  else {
    print "Success\n";
  }
  output("Adding Start Menu shortcuts...\n"); #This was not being installed with the rest of it through SCCM for some reason.
  my $start = build_path(get_allusers_start_menu(), 'Programs');
  if(!run_command("xcopy /YEFI \"$src\\Blender\" \"$start\\Blender\"")){
	output("FAIL\n");
  }
  else{
	print "Success\n"
  }
#This version doesn't place an uninstall link. Leaving this here for easy revision in case this ever changes again.
=pod
  my $uninstall = get_allusers_start_menu().'\Programs\\Blender Foundation\\Blender\\Uninstall.lnk';
  print "\nDeleting Uninstall Icon: ";
  if(!run_command("DEL /q \"$uninstall\"")) {
    print "FAILED!!\n";
  }
  else {
    print "Success\n";
  }
=cut

  return 1;
}

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                     'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
	  need_reboot =&gt; 0,
    install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\bluebeamrevuextreme.2017\prod\update.pl</FullName>
    <Length>1254</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-12-13T16:14:07.3123541-06:00</CreationTime>
    <CreationTimeUtc>2017-12-13T22:14:07.3123541Z</CreationTimeUtc>
    <LastWriteTime>2017-11-30T14:33:37.6205682-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-11-30T20:33:37.6205682Z</LastWriteTimeUtc>
    <LastAccessTime>2017-12-13T16:14:07.3123541-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-12-13T22:14:07.3123541Z</LastAccessTimeUtc>
    <Text># Bluebeam Revu 2017 eXtreme
# Package Created November 21, 2017
# Packaged by Austin Wall
# Last Updated --

BEGIN {
    %::INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'bluebeamrevuextreme.2017',
        package_revision =&gt; '20171121T1517',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

sub install {
    if(!install_msi(msi =&gt; $srcfiles.'\Bluebeam Revu x64 17.msi',
                    additional_msi_properties =&gt; 'TRANSFORMS="customizations.mst"'))
    {
        output("Installation failed!\n");
        return 0;
    }
    
    output("Installation successful!");
    return 1;
}

do_install( 
    exit_on_failure =&gt; 1,
    allowed_versions          =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures  =&gt; [ OSARCH_x64 ],
    allowed_regs              =&gt; [ "clc", "desktop", "traveling", "virtual-desktop", "virtual-clc" ],
    install_sub               =&gt; \&amp;install,

    
);

IM_Exit(EXIT_SUCCESS);

########################################################################</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\boost.1_64_0\prod\update.pl</FullName>
    <Length>3317</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-05T15:22:13.8501371-05:00</CreationTime>
    <CreationTimeUtc>2017-06-05T20:22:13.8501371Z</CreationTimeUtc>
    <LastWriteTime>2017-06-14T14:42:23.6771148-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-14T19:42:23.6771148Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-05T15:22:13.8501371-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-05T20:22:13.8501371Z</LastAccessTimeUtc>
    <Text># BoostCpp
# Package Created 2013-12-13
# Package by Joshua Hertlein
# Last Updated 2017-06-05 by Sergey Gruzdev

=pod

Begin-Doc
Modified: $Date$
Name: $Name$
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use strict;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'BoostCpp.1_64_0',
        package_revision =&gt; '20160621T1349',
    );
}


use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;
use Getopt::Long;

my $src = get_pkg_sourcefiles();
my $dest = "C:\\Program Files (x86)\\Boost";
my $zip = "C:\\Program Files\\7-zip\\7z.exe";

GetOptions('uninstall' =&gt; sub{exit(uninstall())});

sub preinstall
{
  # Make sure 7zip is installed
  if(!(-e "\"$zip\""))
  {
    output("Critical Error! 7-Zip not installed at location: $zip");
	exit(0);
  }
}

sub install
{
  my $srcfile = build_path($src,"boost_1_64_0.zip");
  
  # Create directory to install boost (if one doesn't already exist)
  if(!(-e $dest))
  {
    # Attempt to create directory
	if(!run_command("mkdir \"$dest\""))
	{
	  output("Couldn't create install directory: $dest\n");
	}
	else
	{
	  output("Created install directory!\n");
	}
  }
  
  # Copy zip file
  if(!run_command("XCOPY \"$srcfile\" \"$dest\" /Q /Y /I /E"))
  {
    output("Couldn't copy $srcfile into install directory $dest!\n");
    return 0;
  }
  output("Copied archive to install directory!\n");
  
  # Unpack the archive
  if(!run_command("\"$zip\" x -o\"$dest\" \"$dest\\boost_1_64_0.zip\""))
  {
    output("Couldn't unarchive Boost 1.64.0! Please try again!\n");
	return 0;
  }
  output("Successfully installed Boost 1.64.9!\n");
  
  # Delete the archive
  if(!run_command("del /F \"$dest\\boost_1_64_0.zip\" /Q /S"))
  {
    output("Could not delete $dest\\boost_1_64_0.zip! Please try again!\n");
  }
  output("$dest\\boost_1_64_0.zip deleted successfully! Installation complete!\n");
  
  return 1;
}

sub uninstall
{
  # Make sure there's something there to delete
  if(-e $dest)
  {
    # Delete all the stuff in the boost folder
    if(!run_command("del /F \"$dest\\*\" /Q /S"))
    {
      output("Error: could not delete contents of $dest!\n");
	  return 0;
    }
    output("Deleted contents of $dest!\n");
    # Delete the folder itself
    if(!run_command("rmdir \"$dest\" /Q /S"))
    {
      output("Error: could not remove directory: $dest!\n");
	  return 0;
    }
    output("Deleted directory $dest!\n");
  }
  if(!delete_product_registry_key(get_package_name().".".get_version()))
  {
    output("Error: could not delete registry key! Try again!\n");
	return 0;
  }
  output("Deleted product registry key! Uninstallation complete!\n");
  return 1;
}

do_install
(
  allowed_versions =&gt; ['OSVER_WIN10_SP0', 'OSVER_WIN10_SP1'],
  allowed_os_architectures =&gt; [OSARCH_x86, OSARCH_x64],
  allowed_regs =&gt; ['clc', 'virtual-clc', 'desktop', 'virtual-desktop', 'traveling'],
  install_sub =&gt; \&amp;install,
  exit_on_failure =&gt; 1,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\boost.1_67_0\prod\update.pl</FullName>
    <Length>3352</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-22T09:09:21.5171378-05:00</CreationTime>
    <CreationTimeUtc>2018-05-22T14:09:21.5171378Z</CreationTimeUtc>
    <LastWriteTime>2018-05-22T09:20:59.5992114-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-22T14:20:59.5992114Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-22T09:09:21.5171378-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-22T14:09:21.5171378Z</LastAccessTimeUtc>
    <Text># BoostCpp
# Package Created 2013-12-13
# Package by Joshua Hertlein
# Updated 2017-06-05 by Sergey Gruzdev
# Last Updated 2018-05-22 by Gavin Altermatt


=pod

Begin-Doc
Modified: $Date$
Name: $Name$
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use strict;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'BoostCpp.1_67_0',
        package_revision =&gt; '20180522T0913',
    );
}


use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;
use Getopt::Long;

my $src = get_pkg_sourcefiles();
my $dest = "C:\\Program Files (x86)\\Boost";
my $zip = "C:\\Program Files\\7-zip\\7z.exe";

GetOptions('uninstall' =&gt; sub{exit(uninstall())});

sub preinstall
{
  # Make sure 7zip is installed
  if(!(-e "\"$zip\""))
  {
    output("Critical Error! 7-Zip not installed at location: $zip");
	exit(0);
  }
}

sub install
{
  my $srcfile = build_path($src,"boost_1_67_0.zip");

  # Create directory to install boost (if one doesn't already exist)
  if(!(-e $dest))
  {
    # Attempt to create directory
	if(!run_command("mkdir \"$dest\""))
	{
	  output("Couldn't create install directory: $dest\n");
	}
	else
	{
	  output("Created install directory!\n");
	}
  }

  # Copy zip file
  if(!run_command("XCOPY \"$srcfile\" \"$dest\" /Q /Y /I /E"))
  {
    output("Couldn't copy $srcfile into install directory $dest!\n");
    return 0;
  }
  output("Copied archive to install directory!\n");

  # Unpack the archive
  if(!run_command("\"$zip\" x -o\"$dest\" \"$dest\\boost_1_67_0.zip\""))
  {
    output("Couldn't unarchive Boost 1.67.0! Please try again!\n");
	return 0;
  }
  output("Successfully installed Boost 1.67.0!\n");

  # Delete the archive
  if(!run_command("del /F \"$dest\\boost_1_67_0.zip\" /Q /S"))
  {
    output("Could not delete $dest\\boost_1_67_0.zip! Please try again!\n");
  }
  output("$dest\\boost_1_67_0.zip deleted successfully! Installation complete!\n");

  return 1;
}

sub uninstall
{
  # Make sure there's something there to delete
  if(-e $dest)
  {
    # Delete all the stuff in the boost folder
    if(!run_command("del /F \"$dest\\*\" /Q /S"))
    {
      output("Error: could not delete contents of $dest!\n");
	  return 0;
    }
    output("Deleted contents of $dest!\n");
    # Delete the folder itself
    if(!run_command("rmdir \"$dest\" /Q /S"))
    {
      output("Error: could not remove directory: $dest!\n");
	  return 0;
    }
    output("Deleted directory $dest!\n");
  }
  if(!delete_product_registry_key(get_package_name().".".get_version()))
  {
    output("Error: could not delete registry key! Try again!\n");
	return 0;
  }
  output("Deleted product registry key! Uninstallation complete!\n");
  return 1;
}

do_install
(
  allowed_versions =&gt; ['OSVER_WIN10_SP0', 'OSVER_WIN10_SP1'],
  allowed_os_architectures =&gt; [OSARCH_x86, OSARCH_x64],
  allowed_regs =&gt; ['clc', 'virtual-clc', 'desktop', 'virtual-desktop', 'traveling'],
  install_sub =&gt; \&amp;install,
  exit_on_failure =&gt; 1,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\carlson.2018\dev_newlicense\update.pl</FullName>
    <Length>3385</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-07-18T13:34:08.7493945-05:00</CreationTime>
    <CreationTimeUtc>2018-07-18T18:34:08.7493945Z</CreationTimeUtc>
    <LastWriteTime>2018-07-18T13:36:21.2064522-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-18T18:36:21.2064522Z</LastWriteTimeUtc>
    <LastAccessTime>2018-07-18T13:34:08.7493945-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-07-18T18:34:08.7493945Z</LastAccessTimeUtc>
    <Text># Package Created September 2017
# Package created by Alex Schrimpf
# Package updated July 2018

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS =
    (
        package_id =&gt; 'carlson.newlicensetest.2018',
        package_revision =&gt; '20180718T1336',
    );
}

use lib
(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

my %PREREQS = (
    'AUTOCAD 2018' =&gt;{
        INSTALL =&gt; 0,
        APPID =&gt; "{28B89EEF-1001-0000-0102-CF3F3A09B77D}"
    },
    'VC_REDIST_x86' =&gt; {
        INSTALL =&gt; 1,
        FILENAME =&gt; "vcredist_x86.exe",
        ARGS =&gt; "/quiet",
        APPID =&gt; "{f65db027-aff3-4070-886a-0d87064aabb1}"
    },
    'VC_REDIST_x64' =&gt; {
        INSTALL =&gt; 1,
        FILENAME =&gt; "vcredist_x64.exe",
        ARGS =&gt; "/quiet",
        APPID =&gt; "{050d4fc8-5d48-4b8f-8972-47c82c46020f}"
    }
);

sub preinstall
{
    foreach my $preqreq (sort keys %PREREQS){
        output("\nLOOKING FOR \"$preqreq\" ON SYSTEM...\n");
        if(!IsAppInstalled('AppID' =&gt; $PREREQS{$preqreq}{APPID})){
            output("FAILED TO FIND \"$preqreq\"\n");
            if($PREREQS{$preqreq}{INSTALL}){
                output("TRYING TO INSTALL...\n");
                if(!run_command("$srcfiles\\redist\\$PREREQS{$preqreq}{FILENAME} $PREREQS{$preqreq}{ARGS}")){
                    output("FAILED\n");
                    return 0;
                }
                output("SUCCESS\n");
            }
            else{
                return 0;
            }
        }else{
            output("FOUND\n\n");
        }
    }
    return 1;
}

sub install
{
    #for some reason the installer won't create a log in any subdirectories of system32
    output("INSTALLING...\n");
    if(!run_command("$srcfiles\\Carlson2018_64bit.exe -s -f1$srcfiles\\carlson.iss -f2$ENV{TEMP}\\carlson.log /v\"/quiet /norestart\"")){
        output("FAILED\n");
        return 0;
    }
    output("SUCCESS\n\n");
    return 1;
}

my $ALLUSERS_DESKTOP = get_allusers_desktop();

my @SHORTCUTS = (
    "Carlson Civil Suite 2018 with AutoCAD 2018 - English.lnk",
    "Carlson Mining 2018 with AutoCAD 2018 - English.lnk",
    "Carlson Projects.lnk"
);


sub postinstall
{
    foreach my $shortcut (@SHORTCUTS){
        output("DELETING SHORCTUT: $shortcut\n");
        if(run_command("del /q /f \"$ALLUSERS_DESKTOP\\$shortcut\"")){
            output("SUCCESS\n");
        }
        else{
            output("FAILED\n");
            return 0;
        }
    }
    return 1;
}

do_install
(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [ 'desktop', 'clc', 'traveling', 'virtual-desktop',
                        'virtual-clc' ],
    exit_on_failure =&gt; 1,
    install_sub     =&gt; \&amp;install,
    preinstall_sub =&gt; \&amp;preinstall,
    postinstall_sub =&gt; \&amp;postinstall,
);


IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\carlson.2018\prod\update.pl</FullName>
    <Length>3344</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-09-06T10:35:33.1210589-05:00</CreationTime>
    <CreationTimeUtc>2017-09-06T15:35:33.1210589Z</CreationTimeUtc>
    <LastWriteTime>2017-09-21T11:00:18.7634569-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-09-21T16:00:18.7634569Z</LastWriteTimeUtc>
    <LastAccessTime>2017-09-06T10:35:33.4960591-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-09-06T15:35:33.4960591Z</LastAccessTimeUtc>
    <Text># Package Created September 2017
# Package created by Alex Schrimpf

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS =
    (
        package_id =&gt; 'carlson.2018',
        package_revision =&gt; '20170810T1616',
    );
}

use lib
(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

my %PREREQS = (
    'AUTOCAD 2018' =&gt;{
        INSTALL =&gt; 0,
        APPID =&gt; "{28B89EEF-1001-0000-0102-CF3F3A09B77D}"
    },
    'VC_REDIST_x86' =&gt; {
        INSTALL =&gt; 1,
        FILENAME =&gt; "vcredist_x86.exe",
        ARGS =&gt; "/quiet",
        APPID =&gt; "{f65db027-aff3-4070-886a-0d87064aabb1}"
    },
    'VC_REDIST_x64' =&gt; {
        INSTALL =&gt; 1,
        FILENAME =&gt; "vcredist_x64.exe",
        ARGS =&gt; "/quiet",
        APPID =&gt; "{050d4fc8-5d48-4b8f-8972-47c82c46020f}"
    }
);

sub preinstall
{
    foreach my $preqreq (sort keys %PREREQS){
        output("\nLOOKING FOR \"$preqreq\" ON SYSTEM...\n");
        if(!IsAppInstalled('AppID' =&gt; $PREREQS{$preqreq}{APPID})){
            output("FAILED TO FIND \"$preqreq\"\n");
            if($PREREQS{$preqreq}{INSTALL}){
                output("TRYING TO INSTALL...\n");
                if(!run_command("$srcfiles\\redist\\$PREREQS{$preqreq}{FILENAME} $PREREQS{$preqreq}{ARGS}")){
                    output("FAILED\n");
                    return 0;
                }
                output("SUCCESS\n");
            }
            else{
                return 0;
            }
        }else{
            output("FOUND\n\n");    
        }
    }
    return 1; 
}

sub install
{
    #for some reason the installer won't create a log in any subdirectories of system32
    output("INSTALLING...\n");
    if(!run_command("$srcfiles\\Carlson2018_64bit.exe -s -f1$srcfiles\\carlson.iss -f2$ENV{TEMP}\\carlson.log /v\"/quiet /norestart\"")){
        output("FAILED\n");
        return 0;
    }
    output("SUCCESS\n\n");
    return 1;
}

my $ALLUSERS_DESKTOP = get_allusers_desktop();

my @SHORTCUTS = (
    "Carlson Civil Suite 2018 with AutoCAD 2018 - English.lnk",
    "Carlson Mining 2018 with AutoCAD 2018 - English.lnk",
    "Carlson Projects.lnk"
);


sub postinstall
{
    foreach my $shortcut (@SHORTCUTS){
        output("DELETING SHORCTUT: $shortcut\n");
        if(run_command("del /q /f \"$ALLUSERS_DESKTOP\\$shortcut\"")){
            output("SUCCESS\n");
        }
        else{
            output("FAILED\n");
            return 0;
        }
    }
    return 1;
}

do_install
(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [ 'desktop', 'clc', 'traveling', 'virtual-desktop',
                        'virtual-clc' ],
    exit_on_failure =&gt; 1,
    install_sub     =&gt; \&amp;install,
    preinstall_sub =&gt; \&amp;preinstall,
    postinstall_sub =&gt; \&amp;postinstall,
);


IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\chemofficepro.16\prod\update.pl</FullName>
    <Length>2294</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-20T13:15:13.8000684-06:00</CreationTime>
    <CreationTimeUtc>2017-11-20T19:15:13.8000684Z</CreationTimeUtc>
    <LastWriteTime>2017-12-05T14:36:53.1565335-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-12-05T20:36:53.1565335Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-20T13:15:13.8000684-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-20T19:15:13.8000684Z</LastAccessTimeUtc>
    <Text># ChemOffice Pro 16
# Package Created November 20, 2017
# Packaged by Wall, Austin
# Last Updated 2017-12-05

BEGIN {
    %::INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'chemofficepro.16',
        package_revision =&gt; '20171121T1539',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

sub preinstall {
    my $success = 0;
    if(get_machine_type() eq 'clc' or get_machine_type() eq 'virtual-clc'){
        output("Licensing for CLC use...\n");
        output("Applying registry changes...\n");
        $success = run_command("regedit.exe /s $srcfiles\\licenseoverride.reg");
        if (not $success) { warn output("Could not install license! $!\n"); }   
    } else { 
        output("Skipping license step... \nUser must activate the product before using.\n");
        $success = 1;
    }
    return $success;
}

sub install {
    output("Installing ChemOffice 64-bit\n");
    if(!run_command("$srcfiles\\Windows\\PerkinElmer\\ChemOffice\\PerkinElmer_ChemOffice_64-bit_Support_16.0.msi /qn"))
    {
        output("Installation failed!\n$!");
        return 0;
    }
    
    output("Installing ChemOffice\n");
    if(!run_command("$srcfiles\\Windows\\PerkinElmer\\ChemOffice\\PerkinElmer_ChemOffice_Professional_2016.msi /qn"))
    {
        output("Installation failed!\n$!");
        return 0;
    }
    
    output("Installing ChemScript\n");
    if(!run_command("$srcfiles\\Windows\\PerkinElmer\\ChemScript\\PerkinElmer_ChemScript_16.0.msi /qn"))
    {
        output("Installation failed!\n$!");
        return 0;
    }
    output("Installation successful!\n");
    return 1;
}


do_install( 
    exit_on_failure =&gt; 1,
    allowed_versions          =&gt; [ OSVER_WIN10_SP0 ],
    allowed_os_architectures  =&gt; [ OSARCH_x64 ],
    allowed_regs              =&gt; [ "clc", "desktop", "traveling", "virtual-desktop", "virtual-clc" ],
    install_sub               =&gt; \&amp;install,
    preinstall_sub           =&gt; \&amp;preinstall,

    
);

IM_Exit(EXIT_SUCCESS);

########################################################################</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\chrome.65_0_3325\prod\update.pl</FullName>
    <Length>10715</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-03-12T16:53:21.474019-05:00</CreationTime>
    <CreationTimeUtc>2018-03-12T21:53:21.474019Z</CreationTimeUtc>
    <LastWriteTime>2018-03-09T16:57:58.9546797-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-03-09T22:57:58.9546797Z</LastWriteTimeUtc>
    <LastAccessTime>2018-03-12T16:53:21.474019-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-03-12T21:53:21.474019Z</LastAccessTimeUtc>
    <Text># Chrome (for Business) Installer
# Package Created April 2014
# Packaged by Todd Hartman
# Last Updated 2018-03-09 by Sergey Gruzdev

=pod

Begin-Doc
Modified: $Date$
Name: Chrome Installer
Type: script
Description: Slight adaptation of the Chrome package by Billy Rhoades (nice work, Billy)
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

$|=1;
use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'chrome.x+',
        # app version, pkg? version, date downloaded
        package_revision =&gt; '43.0.2357.132m_65.205.49283__20150707T1135',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

use JSON;
use Win32::TieRegistry;
use File::Basename;
use Getopt::Long;

# ProductCode: {A7A76FD6-91B5-3C7F-B37D-DFDA03F5FBAE}
# ProductName: Google Chrome
# ProductVersion: 65.205.49283


########################################################################
# BEGIN Configuration

# https://wiki.mst.edu/deskinst/change/applications/packaging/chrome

# This will get converted to JSON later.
my $master_preferences = {
 homepage =&gt; "http://www.mst.edu",
 homepage_is_newtabpage =&gt; JSON::false,
 browser =&gt; 
 {
     show_home_button =&gt; JSON::true,
     check_default_browser =&gt; JSON::false,
 },
 bookmark_bar =&gt;
 {
     show_on_all_tabs =&gt; JSON::true,
 },
 distribution =&gt;
 {
   skip_first_run_ui =&gt; JSON::true,
   show_welcome_page =&gt; JSON::true,
   import_search_engine =&gt; JSON::true,
   import_history =&gt; JSON::false,
   do_not_create_taskbar_shortcut =&gt; JSON::true,
   do_not_create_quick_launch_shortcut =&gt; JSON::true,
   do_not_create_desktop_shortcut =&gt; JSON::true,
   do_not_launch_chrome =&gt; JSON::true,
   make_chrome_default =&gt; JSON::false,
   make_chrome_default_for_user =&gt; JSON::false,
   do_not_create_any_shortcuts =&gt; JSON::true
 },
 first_run_tabs =&gt; 
 [
  'http://www.mst.edu',
  'welcome_page',
 ],
};

my $desktop_shortcut = 'Google Chrome.lnk';
my $application_arch = OSARCH_x86; # Chrome is a 32-bit app.

# This is a Google App identifier, not the AppID used in the Windows Registry.
my $chrome_appid = '{8A69D345-D564-463C-AFF1-A69D9E530F96}';
my $chrome_binaries_appid = '{4DC8B4CA-1BDA-483E-B5FA-D3C12E15B62D}';
my $sourcefilesdir = get_pkg_sourcefiles();
my $updater = "C:\\Program Files (x86)\\Google\\Update\\GoogleUpdate.exe";

# Set up Chrome for Business
#   https://support.google.com/chrome/a/answer/188446?hl=en&amp;ref_topic=2936229
# Default User Preferences
#   https://support.google.com/chrome/a/answer/187948?hl=en
# Set Chrome policies for users
#   https://support.google.com/chrome/a/answer/2657289?hl=en&amp;ref_topic=2936229
# Chrome Updates
#   https://support.google.com/chrome/a/answer/3204698?hl=en&amp;ref_topic=2936229
#   Size: ~50MB (patches are 3-5MB)
#   

my $chrome_policies = {
    'HKEY_LOCAL_MACHINE\Software\Policies\Google' =&gt; {
        'Update' =&gt; {
            AutoUpdateCheckPeriodMinutes =&gt; dword(1400), # minutes (23h10m; default)

            # allow Chrome to be updated by Google Update
            'Install'.$chrome_appid =&gt; dword(1),
            'Install'.$chrome_binaries_appid =&gt; dword(1),
            # update either by period or manual check
            'Update'.$chrome_appid =&gt; dword(1),
            'Update'.$chrome_binaries_appid =&gt; dword(1),
        },

        # These parameters are documented in Chromium.
        # http://www.chromium.org/administrators/policy-list-3
        # Credit: Billy Rhoades
        'Chrome' =&gt; {
            # 32MB, a guideline. Chrome still flies over this, but it
            #   will clean up after a few minutes to go back down
            "DiskCacheSize" =&gt; dword(32 * 1024), 
            "MediaCacheSize" =&gt; dword(32 * 1024),
            # privacy
            "MetricsReportingEnabled" =&gt; dword(0),

            "Recommended" =&gt;
            {
                # branding
                "HomepageLocation" =&gt; "http://www.mst.edu/",
            },
        },
    },
};

# END Configuration
########################################################################

GetOptions(
    'help' =&gt; sub { usage(); exit(0); },
    'uninstall' =&gt; sub { exit(! uninstall()); },
    'code=s' =&gt; sub { eval($_[1]); if ($@) { output($@); } exit($!); },
);


# Begin-Doc
################################
# Name: configure()
# Description: Perform any post-install configuration.
# Returns: true/false on success/failure of all subcomponents (pass-through)
# LastUpdated: 2018-03-09
# LastUpdatedBy: Sergey Gruzdev
################################
# End-Doc
sub configure {
    my $success = remove_desktop_shortcut();
    #$success &amp;&amp;= configure_policies();
    $success &amp;&amp;= configure_settings();
	$success &amp;&amp;= update();
	return $success;
}

do_install( 
    allowed_versions =&gt; [
        OSVER_WIN7_SP0, OSVER_WIN7_SP1,
        OSVER_WIN81_SP0,
    ],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs =&gt; [ qw(clc desktop traveling virtual-clc virtual-desktop) ],
    exit_on_failure =&gt; 1,

    msi_name =&gt; 'GoogleChromeStandaloneEnterprise.msi',
    #msi_ignore_exit_codes =&gt; [ ],
    #additional_msi_properties =&gt; '',

    postinstall_sub =&gt; \&amp;configure,
);
IM_Exit(EXIT_SUCCESS);


### subroutine documentation block ###
# Begin-Doc
################################
# Name: 
# Description: 
# Returns: 
# Requires: 
# LastUpdated: 
# LastUpdatedBy: 
################################
# End-Doc


# Begin-Doc
################################
# Name: remove_desktop_shortcut()
# Description: 
# Returns: true if no desktop shortcut exists (including if the deletion
#    was successful.
# LastUpdated: 2014-04-30
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub remove_desktop_shortcut {
    my $lnk = build_path(get_allusers_desktop(),$desktop_shortcut);
    if (-f $lnk) {
        output("Removing desktop shortcut: ");
        my $outcome = unlink($lnk);
        output(($outcome?'OK':'(FAILED ('.$!.')')."\n");
        return $outcome;
    }

    # no shortcut exists
    return ! (-f $lnk );
}
 
# Begin-Doc
################################
# Name: configure_update()
# Description: Configure Google Update (for Chrome)
# Returns: true/false on success/failure
# Requires: Win32::TieRegistry
# LastUpdated: 2014-04-30
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub configure_policies {
    # We're going to use Group Policy to configure this behavior.

    my $success = 1;

    foreach my $key (keys(%$chrome_policies)) {
        my $data = $chrome_policies-&gt;{$key};
        create_ancestor_keys($key);
        $Registry-&gt;{$key} = $data;
        $success &amp;&amp;= verify_registry_data($key,$data);
    }

    return $success;
}

# Begin-Doc
################################
# Name: update()
# Description: Updates chrome to the latest version
# Returns: true/false on success/failure
# Requires: chrome must be installed, GoogleUpdate.exe must be available at location pointed to by $updater
# LastUpdated: 2018-03-09
# LastUpdatedBy: Sergey Gruzdev
################################
# End-Doc
sub update
{
	# Run updater
	print "Invoking updater....\n";
	if(!run_command("\"$updater\" /install \"bundlename=Chrome&amp;appguid={8A69D345-D564-463c-AFF1-A69D9E530F96}&amp;appname=Chrome&amp;needsadmin=True&amp;lang=en\" /silent"))
	{
		"Updater failed! D:\n";
		return 0;
	}
	print "Updater finished!\n";
	return 1;
}


# Begin-Doc
################################
# Name: configure_settings()
# Description: Configure default Chrome behavior.
# Returns: true/false on success/failure
# Requires: JSON
# LastUpdated: Todd Hartman
# LastUpdatedBy: 2014-04-30
################################
# End-Doc
sub configure_settings {
    my $master_preferences_file =
        build_path(get_arch_programfiles($application_arch),
                   'Google','Chrome','Application',
                   'master_preferences');
    my $install = "%PROGRAMFILES(x86)%\\Google\\Chrome\\Application\\43.0.2357.132\\default_apps";

    if (open(my $MASTER,'&gt;',$master_preferences_file)) {
        # The prefs we're setting are defined in the config section above.
        # This file must be in (strict) JSON format.
        print $MASTER encode_json($master_preferences);
        close($MASTER);
    } else {
        output("Error opening master preferences file '${master_preferences_file}': $!\n");
        return 0;
    }
    # install uBlock here
    if(!run_command("regedit.exe /s \"$sourcefilesdir\\uBlock.reg\"")) {
        output("Failed to install uBlock reg file\n");
        return 0;
    }
    # install Missouri S&amp;T theme
    #if(!run_command("COPY /y \"$sourcefilesdir\\external_extensions.json\" \"$install\\external_extensions.json\"")){
    #    output("Failed to install Missouri S&amp;T theme for Chrome\n");
    #}
    #run_command("COPY /y \"$sourcefilesdir\\Missouri_S&amp;T.crx\" \"$install\\Missouri_S&amp;T.crx\"");

    return 1;
}

# Begin-Doc
################################
# Name: dword()
# Returns: a piece of data suitable for setting a Registry REG_DWORD.
################################
# End-Doc
sub dword {
    my $numeric = shift;
    return [ sprintf('0x%04x', $numeric), 'REG_DWORD' ];
}


# Begin-Doc
################################
# Name: uninstall()
# Description: uninstall any application named 'Google Chrome'
# Returns: true/false on composite success/failure
# LastUpdated: 2014-04-30
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub uninstall {
    my $success = 1;

    foreach my $chrome_key (IsAppInstalled('DisplayName' =&gt; 'Google Chrome')) {
        my $app_id = basename($chrome_key);
        my $log = get_default_app_log();
        $log =~ s/\.txt$/__${app_id}_uninstall.txt/i;
        my $name = $Registry-&gt;{$chrome_key}-&gt;{'DisplayName'};
        my $version = $Registry-&gt;{$chrome_key}-&gt;{'DisplayVersion'};
        output("Uninstalling ${name} (v ${version}): ");
        my $outcome = install_msi( app_id =&gt; $app_id,
                                   msi_action_flag =&gt; 'x',
                                   logfile =&gt; $log );
        output(($outcome?'OK':'FAILED')."\n");
        $success &amp;&amp;= $outcome;
    }
    delete_product_registry_key(get_package_id());

    return $success;
}
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\CiscoPacketTracer.7_1\prod\update.pl</FullName>
    <Length>2748</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-17T19:16:18.4684801-06:00</CreationTime>
    <CreationTimeUtc>2017-11-18T01:16:18.4684801Z</CreationTimeUtc>
    <LastWriteTime>2018-01-24T15:01:06.4364205-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-24T21:01:06.4364205Z</LastWriteTimeUtc>
    <LastAccessTime>2018-01-12T22:37:21.9174065-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-01-13T04:37:21.9174065Z</LastAccessTimeUtc>
    <Text># Cisco Packet Tracer 7.1
# Package Created Fall 2017
# Packaged by Alex Schrimpf
# Last Updated Fall 2017 by Alex Schrimpf


=pod

Begin-Doc
Modified: 
Name: 
Type:
Description: 
Language: Perl
LastUpdatedBy:
Version:
Doc-Package-Info
Doc-SVN-Repository:
RCSId:
End-Doc

=cut

use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'CiscoPacketTracer.7_1',
        package_revision =&gt; '',
    );
}

use lib ( '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 'C:\temp' );

use InstallMonkey::Shared;

use IM_helper(
    \%INSTALLMONKEY_OPTIONS,
    v4.04,
    (
        "INSTALL" =&gt; [
            sub {
                IM_helper::run_command(
                    description =&gt; 'Cisco Packet Tracer 7.1 Installer',
                    command =&gt; "\"$IM_helper::source_files\\PacketTracer71_64bit_setup_signed.exe\" /VERYSILENT /NOICONS",
                    # When run as system the installer can't find the desktop so it hangs on an error dialogue box.
                    timeout=&gt;60*5, # Wait 5 minutes
                    fail_cb=&gt; sub{	
                    	return IM_helper::get_windows_with_text(
                    		text=&gt;"Internal error: Failed to expand shell folder constant \"userdesktop\"",
                    		succ_cb=&gt;sub{
                    			my $wid = @{{@_}-&gt;{results}}[0];
                    			if(!$wid){
                    				return 0;
                    			}
                    			return IM_helper::send_keys_to_window(
                    				window=&gt;$wid,
                    				keys=&gt;'{TAB}{TAB}{ENTER}'
                    			);
                    		}
                    	);
                    }
                );           
            }
        ],
        "UNINSTALL" =&gt; [
            sub{
               IM_helper::uninstall_using_programs_and_features(
                    display_name=&gt; "Cisco Packet Tracer 7.1 64Bit"
                );
            },
            sub {
                delete_product_registry_key(get_package_id());
            },
        ]

    )
);

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt;
      [ 'clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    no_install_check =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    no_product_key =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    install_sub =&gt; $IM_helper::exec_call_stack_override || sub{IM_helper::exec_call_stacks(ids=&gt;["INSTALL"])}
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\civil3d.2018\prod\update.pl</FullName>
    <Length>3328</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-15T13:58:40.2360126-05:00</CreationTime>
    <CreationTimeUtc>2017-06-15T18:58:40.2360126Z</CreationTimeUtc>
    <LastWriteTime>2017-06-16T10:57:41.4379142-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-16T15:57:41.4379142Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-15T13:58:40.2360126-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-15T18:58:40.2360126Z</LastAccessTimeUtc>
    <Text># Package Created June 15, 2017
# Packaged by Austin Wall
# Last Updated 

use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'civil3d.2018',
        package_revision =&gt; '20170615T1436',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Win32::TieRegistry;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

sub preinstall{
    output("Clearing reboot flag...\n");
    $Registry-&gt;Delimiter("/");
    # The setup will restart the machine first if this key exists
    delete $Registry-&gt;{"LMachine/Software/Microsoft/Windows/CurrentVersion/WindowsUpdate/Auto Update/RebootRequired/"};
}

sub install{
    # This is run from appdeploy to avoid copying over 6GB files.
    # The setup is generated with "Create Deployment" in the original install file.
    # More info available on wiki.
    my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\civil3d2018\\Img";
    my $command = "$appdeploy\\Setup.exe /W /qb /I $appdeploy\\civil3d2018.ini /language en-us";

    output("Installing Autodesk Civil 3D...\n");
    run_command($command, 'IgnoreReturnCode'=&gt;1);

    # The run_command spawns a separate process and returns immediately so this loop waits until setup.exe finishes running.
    my $index = 0;
    while($index &lt; 3600) # 3600*5sec = 5 hours
    {
        $_ = `tasklist`;
        if(/setup\.exe/gi){
            $index++;
            sleep(5);
        }
        else{
            output("Setup finished!\n");
            output("Install took ". $index/12 ." minutes.\n");
            return 1;
        }
    }

    output("Timed out...\n");

    return 0;
}

sub postinstall
{
    my $cwd = cwd();

    output("Copying License...\n");
    my $dest = get_arch_programfiles(OSARCH_x64).'\\Autodesk\\';
    run_command("copy \"$cwd\\LICPATH.LIC\" \"$dest\" /Y");
    run_command("setx ADSKFLEX_LICENSE_FILE \"C:\\Program Files\\Autodesk\\LICPATH.LIC\" \/m");

    output("Deleting desktop icons...\n");
    my $desk = get_allusers_desktop();
    run_command("DEL /Q \"$desk\\Autodesk 360.lnk\"");
    run_command("DEL /Q \"$desk\\A360 Desktop.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk Storm and Sanitary Analysis 2018.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk ReCap 360.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk ReCap.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk Desktop App.lnk\"");
    run_command("DEL /Q \"$desk\\Civil 3D 2018 Imperial.lnk\"");
    run_command("DEL /Q \"$desk\\Civil 3D 2018 Metric.lnk\"");
    return 1;
}

do_install(
    no_source_files  =&gt; "1",
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
#    prerequisite_sub =&gt; \&amp;prerequisite,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\civil3d.2019\prod\update.pl</FullName>
    <Length>3491</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-13T16:17:59.5540652-05:00</CreationTime>
    <CreationTimeUtc>2018-06-13T21:17:59.5540652Z</CreationTimeUtc>
    <LastWriteTime>2018-06-25T09:25:48.5282589-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-25T14:25:48.5282589Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-13T16:17:59.5540652-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-13T21:17:59.5540652Z</LastAccessTimeUtc>
    <Text># Package Created June 15, 2017
# Packaged by Austin Wall
# Last Updated by Gavin Altermatt

use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'civil3d.2019',
        package_revision =&gt; '20180613T1619',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Win32::TieRegistry;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

sub preinstall{
    output("Clearing reboot flag...\n");
    $Registry-&gt;Delimiter("/");
    # The setup will restart the machine first if this key exists
    delete $Registry-&gt;{"LMachine/Software/Microsoft/Windows/CurrentVersion/WindowsUpdate/Auto Update/RebootRequired/"};
}

sub install{
    # This is run from appdeploy to avoid copying over 6GB files.
    # The setup is generated with "Create Deployment" in the original install file.
    # More info available on wiki.
    my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\civil3d2019\\Img";
    my $command = "$appdeploy\\Setup.exe /W /qb /I $appdeploy\\civil3d.2019.ini /language en-us";

    output("Installing Autodesk Civil 3D...\n");
    run_command($command, 'IgnoreReturnCode'=&gt;1);

    # The run_command spawns a separate process and returns immediately so this loop waits until setup.exe finishes running.
    my $index = 0;
    while($index &lt; 3600) # 3600*5sec = 5 hours
    {
        $_ = `tasklist`;
        if(/setup\.exe/gi){
            $index++;
            sleep(5);
        }
        else{
            output("Setup finished!\n");
            output("Install took ". $index/12 ." minutes.\n");
            return 1;
        }
    }

    output("Timed out...\n");

    return 0;
}

sub postinstall
{
    my $cwd = cwd();

    output("Copying License...\n");
    my $dest = get_arch_programfiles(OSARCH_x64).'\\Autodesk\\';
    run_command("copy \"$cwd\\LICPATH.LIC\" \"$dest\" /Y");
    run_command("setx ADSKFLEX_LICENSE_FILE \"C:\\Program Files\\Autodesk\\LICPATH.LIC\" \/m");

    output("Deleting desktop icons...\n");
    my $desk = get_allusers_desktop();
    run_command("DEL /Q \"$desk\\Autodesk 360.lnk\"");
    run_command("DEL /Q \"$desk\\A360 Desktop.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk Storm and Sanitary Analysis 2019.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk ReCap 360.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk ReCap.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk Desktop App.lnk\"");
    run_command("DEL /Q \"$desk\\Civil 3D 2019 Imperial.lnk\"");
    run_command("DEL /Q \"$desk\\Civil 3D 2019 Metric.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk ReCap Photo.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk Storm and Sanitary Analysis.lnk\"");
    return 1;
}

do_install(
    no_source_files  =&gt; "1",
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
#    prerequisite_sub =&gt; \&amp;prerequisite,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\clangllvm.5_0_0\prod\update.pl</FullName>
    <Length>1105</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-10T13:50:19.7287943-06:00</CreationTime>
    <CreationTimeUtc>2017-11-10T19:50:19.7287943Z</CreationTimeUtc>
    <LastWriteTime>2017-11-13T12:30:32.0291073-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-11-13T18:30:32.0291073Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-10T13:50:19.7287943-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-10T19:50:19.7287943Z</LastAccessTimeUtc>
    <Text># Clang LLVM
# Package Created November 10, 2017
# Packaged by Wall, Austin
# Last Updated --

BEGIN {
    %::INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'clangllvm.5_0_0',
        package_revision =&gt; '20171110T1349',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

sub install {
    if(!run_command("$srcfiles\\LLVM-5.0.0-win64.exe /S"))
    {
        output("Installation failed!\n");
        return 0;
    }
    
    output("Installation successful!");
    return 1;
}

do_install( 
    exit_on_failure =&gt; 1,
    allowed_versions          =&gt; [ OSVER_WIN10_SP0 ],
    allowed_os_architectures  =&gt; [ OSARCH_x64 ],
    allowed_regs              =&gt; [ "clc", "desktop", "traveling", "virtual-desktop", "virtual-clc" ],
    install_sub               =&gt; \&amp;install,

    
);

IM_Exit(EXIT_SUCCESS);

########################################################################</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\clangllvm.6_0_0\prod\update.pl</FullName>
    <Length>1096</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-16T08:23:14.5863002-05:00</CreationTime>
    <CreationTimeUtc>2018-05-16T13:23:14.5863002Z</CreationTimeUtc>
    <LastWriteTime>2018-05-16T08:28:10.3128348-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-16T13:28:10.3128348Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-16T08:23:14.5863002-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-16T13:23:14.5863002Z</LastAccessTimeUtc>
    <Text># Clang LLVM
# Package Created May 16th, 2018
# Packaged by Cameron Loren
# Last Updated --

BEGIN {
    %::INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'clangllvm.6_0_0',
        package_revision =&gt; '20180516T0826',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

sub install {
    if(!run_command("$srcfiles\\LLVM-6.0.0-win64.exe /S"))
    {
        output("Installation failed!\n");
        return 0;
    }

    output("Installation successful!");
    return 1;
}

do_install(
    exit_on_failure =&gt; 1,
    allowed_versions          =&gt; [ OSVER_WIN10_SP0 ],
    allowed_os_architectures  =&gt; [ OSARCH_x64 ],
    allowed_regs              =&gt; [ "clc", "desktop", "traveling", "virtual-desktop", "virtual-clc" ],
    install_sub               =&gt; \&amp;install,


);

IM_Exit(EXIT_SUCCESS);

########################################################################
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\clion.2017_1_2\dev\update.pl</FullName>
    <Length>1317</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-05T16:15:13.9400915-05:00</CreationTime>
    <CreationTimeUtc>2017-06-05T21:15:13.9400915Z</CreationTimeUtc>
    <LastWriteTime>2017-06-05T16:16:37.9009061-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-05T21:16:37.9009061Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-05T16:15:13.9400915-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-05T21:15:13.9400915Z</LastAccessTimeUtc>
    <Text>
    # clion
    # Package Created June 05, 2017
    # Packaged by Krueger, Benjamin (S&amp;T IT Student Employee)
    # Last Updated --

    BEGIN {
        %::INSTALLMONKEY_OPTIONS = (
            package_id =&gt; 'clion.2017_1_2',
            package_revision =&gt; '20170605T1614',
        );
    }

    use lib (
        '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
        $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
        'C:\temp',
    );
    use InstallMonkey::Shared;

    my $srcfiles = get_pkg_sourcefiles();
    my $log_dir = get_applogs_dir();

    sub install {
        if(!run_command($srcfiles."\\CLion-2017.1.2.exe /S"))
        {
            output("Installation failed!\n");
            return 0;
        }
        
        output("Installation successful!");
        return 1;
    }

    do_install( 
        exit_on_failure =&gt; 1,
        allowed_versions          =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
        allowed_os_architectures  =&gt; [ OSARCH_x64 ],
        allowed_regs              =&gt; [ "clc", "desktop", "traveling", "virtual-desktop", "virtual-clc" ],
        install_sub               =&gt; \&amp;install,

        
    );

    IM_Exit(EXIT_SUCCESS);

    ########################################################################
    </Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\clion.2017_1_2\prod\update.pl</FullName>
    <Length>5634</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-07-20T08:46:10.1312488-05:00</CreationTime>
    <CreationTimeUtc>2017-07-20T13:46:10.1312488Z</CreationTimeUtc>
    <LastWriteTime>2017-07-26T13:13:30.3300507-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-07-26T18:13:30.3300507Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-24T16:10:14.3701379-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-24T21:10:14.3701379Z</LastAccessTimeUtc>
    <Text># CLion 2017.1.2
# Package Created 2017-07-2
# Packaged by Alex Schrimpf
# Updated 2017-07-24 by Alex Schrimpf

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'clion.2017_1_2',
        package_revision =&gt; '20170719T1433',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;
use Getopt::Long;
use File::Copy;
use File::Path qw(make_path remove_tree);
use File::Basename;

my $src = get_pkg_sourcefiles();

########################################################
# CONFIG
########################################################

my $INSTALLER = "$src\\CLion-2017.1.2.exe";

my %SHORTCUTS = (
  "x64" =&gt; "$src\\CLion.lnk",
  #"x86" =&gt; "$src\\CLion.lnk"
);

#Expected to be in %HOMEPATH% Dir
my $USER_CONFIG = '\\.CLion2017.1\\config';
my $KEY_LOC = $USER_CONFIG.'\\clion.key';

#key file binary dump
#EX: $ xxd -b -i example.key
my @KEY = (0xff, 0xff, 0x55, 0x00, 0x52, 0x00, 0x4c, 0x00, 0x3a, 0x00, 0x68, 0x00,
  0x74, 0x00, 0x74, 0x00, 0x70, 0x00, 0x3a, 0x00, 0x2f, 0x00, 0x2f, 0x00,
  0x70, 0x00, 0x79, 0x00, 0x63, 0x00, 0x68, 0x00, 0x61, 0x00, 0x72, 0x00,
  0x6d, 0x00, 0x2e, 0x00, 0x6c, 0x00, 0x69, 0x00, 0x63, 0x00, 0x2e, 0x00,
  0x6d, 0x00, 0x73, 0x00, 0x74, 0x00, 0x2e, 0x00, 0x65, 0x00, 0x64, 0x00,
  0x75, 0x00, 0x3a, 0x00, 0x38, 0x00, 0x30, 0x00, 0x38, 0x00, 0x30, 0x00,
  0x2f, 0x00);

########################################################

sub create_login_script
{
    my $script_dir = build_path(get_allusers_scripts(),'standard',get_package_id());
    
    my $script_file = build_path($script_dir,get_package_id().'_userlogin.pl');
   
    my $script_wrapper = build_path($script_dir,get_package_id().'_userlogin.cmd');

    if (-d $script_dir) {
      remove_tree($script_dir) or
      output(":: ERROR | REMOVING EXISTING LOGIN SCRIPT DIRECTORY '${script_dir}': $! |\n",
        LOG_ONLY);
    }
    
    make_path($script_dir);

    if (open(my $script,'&gt;',$script_file)) {
      print $script q|
  use strict;
  use File::Path qw (make_path remove_tree);
  
  my $home = $ENV{"HOMEPATH"};
  my $user_config = $home.'|.$USER_CONFIG.q|';
  my $key = $home.'|.$KEY_LOC.q|';

  print(": BUILDING DIRECTORY \| \"$user_config\" \|\n");
  if(!make_path($user_config)){
    print(":: FAILED\n\n");
  }
  print(": DONE\n\n");

  #key file binary dump
  #EX: $ xxd -b -i example.key

  my @key = (|.join(", ",@KEY).q|);

 print(": WRITING KEY FILE \| \"$key\" \|\n");
 if(open(KEY_FILE, "&gt;", $key)){
  foreach (@key){
   print KEY_FILE map { chr } $_;
  }
  close(KEY_FILE);
  print(": DONE\n\n");
  exit(0);
 }
 else{
  print(":: FAILED\n\n");
  exit(1);
 }
|;
      close($script);
      output(join("\n",get_package_id(),' Login Script:',('-' x 60),
        get_file_contents($script_file),('-' x 60),''), LOG_ONLY);
    } else {
      output(":: ERROR | COULD NOT OPEN LOGIN SCRIPT FILE '${script_file}': $! | \n");
      return 0;
    }

    if (open(my $script,'&gt;',$script_wrapper)) {
      my $log_dir = build_path('%APPDATA%','MST','Logs');
      print $script q|
C:
IF NOT EXIST |.$log_dir.q| mkdir "|.$log_dir.q|"
perl "%~dp0|.basename($script_file).q|" &gt; "|.
            build_path($log_dir,get_package_id().'-loginscript.txt').q|" 2&gt;&amp;1
|;

      close($script);
      output(join("\n",get_package_id(),' Login Script:',('-' x 60),
        get_file_contents($script_wrapper),('-' x 60),''), LOG_ONLY);
    } else {
      output(":: ERROR | COULD NOT OPEN LOGIN SCRIPT WRAPPER FILE '${script_wrapper}': $! |\n");
      return 0;
    }

    return $script_wrapper;
}

sub install
{
  output(": INSTALLING ".get_package_id()."\n");
  if(!run_command("\"$INSTALLER\" /S /NCRC"))
  {
    output ":: FAILED\n\n";
	  return 0;
  }
  output ": DONE\n\n";
  return 1;
}

sub postinstall
{
  foreach my $scut (keys %SHORTCUTS){
    output(": COPYING SHORTCUT \"$scut\" TO START MENU\n");
    if(!copy($SHORTCUTS{$scut},"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs")){
      output(":: FAILED\n\n");
      return 0;
    }
    output(": DONE\n\n");
  }

  output(": BUILDING LOGIN SCRIPT\n");
  my $script_wrapper = cmd_quote(create_login_script());
  output(": DONE\n\n");

  #this part can be disabled when not testing as system account won't ever run program
  if(!(`whoami` eq "nt authority\\system\n")){
    output(": RUNNING LOGIN SCRIPT FOR CURRENT USER\n");
    if(!run_command($script_wrapper)){
      output(":: FAILED\n\n");
      return 0;
    }
    output(": DONE\n\n");   
  }else{
    output(": DETECTED RUNNING AS SYSTEM\n")
  }

  create_activesetup_action(
	  'Identifier' =&gt; $INSTALLMONKEY_OPTIONS{'package_id'}.'_setup',
	  'ComponentID' =&gt; $INSTALLMONKEY_OPTIONS{'package_id'},
	  'Description' =&gt; 'add license server',
	  'Version' =&gt; '1.0',
	  'StubPath' =&gt; $script_wrapper);

  return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\clion.2018_1_2\dev\update.pl</FullName>
    <Length>1317</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-22T12:40:16.9429652-05:00</CreationTime>
    <CreationTimeUtc>2018-05-22T17:40:16.9429652Z</CreationTimeUtc>
    <LastWriteTime>2017-06-05T16:16:37-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-05T21:16:37Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-05T16:15:13-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-05T21:15:13Z</LastAccessTimeUtc>
    <Text>
    # clion
    # Package Created June 05, 2017
    # Packaged by Krueger, Benjamin (S&amp;T IT Student Employee)
    # Last Updated --

    BEGIN {
        %::INSTALLMONKEY_OPTIONS = (
            package_id =&gt; 'clion.2017_1_2',
            package_revision =&gt; '20170605T1614',
        );
    }

    use lib (
        '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
        $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
        'C:\temp',
    );
    use InstallMonkey::Shared;

    my $srcfiles = get_pkg_sourcefiles();
    my $log_dir = get_applogs_dir();

    sub install {
        if(!run_command($srcfiles."\\CLion-2017.1.2.exe /S"))
        {
            output("Installation failed!\n");
            return 0;
        }
        
        output("Installation successful!");
        return 1;
    }

    do_install( 
        exit_on_failure =&gt; 1,
        allowed_versions          =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
        allowed_os_architectures  =&gt; [ OSARCH_x64 ],
        allowed_regs              =&gt; [ "clc", "desktop", "traveling", "virtual-desktop", "virtual-clc" ],
        install_sub               =&gt; \&amp;install,

        
    );

    IM_Exit(EXIT_SUCCESS);

    ########################################################################
    </Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\clion.2018_1_2\prod\update.pl</FullName>
    <Length>5661</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-22T12:40:35.2242255-05:00</CreationTime>
    <CreationTimeUtc>2018-05-22T17:40:35.2242255Z</CreationTimeUtc>
    <LastWriteTime>2018-05-24T12:08:01.08763-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-24T17:08:01.08763Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-24T16:10:14-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-24T21:10:14Z</LastAccessTimeUtc>
    <Text># CLion 2018.1.2
# Package Created 2018-05-22
# Packaged by Benjamin Krueger
# Updated 2018-05-22 by Benjamin Krueger

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'clion.2018_1_2',
        package_revision =&gt; '20180522T1244',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;
use Getopt::Long;
use File::Copy;
use File::Path qw(make_path remove_tree);
use File::Basename;

my $src = get_pkg_sourcefiles();

########################################################
# CONFIG
########################################################

my $INSTALLER = "$src\\CLion-2018.1.2.exe";

my %SHORTCUTS = (
  "x64" =&gt; "$src\\CLion.lnk",
  #"x86" =&gt; "$src\\CLion.lnk"
);

#Expected to be in %HOMEPATH% Dir
my $USER_CONFIG = '\\.CLion2018.1\\config';
my $KEY_LOC = $USER_CONFIG.'\\clion.key';

#key file binary dump
#EX: $ xxd -b -i example.key
my @KEY = (0xff, 0xff, 0x55, 0x00, 0x52, 0x00, 0x4c, 0x00, 0x3a, 0x00, 0x68, 0x00,
  0x74, 0x00, 0x74, 0x00, 0x70, 0x00, 0x3a, 0x00, 0x2f, 0x00, 0x2f, 0x00,
  0x70, 0x00, 0x79, 0x00, 0x63, 0x00, 0x68, 0x00, 0x61, 0x00, 0x72, 0x00,
  0x6d, 0x00, 0x2e, 0x00, 0x6c, 0x00, 0x69, 0x00, 0x63, 0x00, 0x2e, 0x00,
  0x6d, 0x00, 0x73, 0x00, 0x74, 0x00, 0x2e, 0x00, 0x65, 0x00, 0x64, 0x00,
  0x75, 0x00, 0x3a, 0x00, 0x38, 0x00, 0x30, 0x00, 0x38, 0x00, 0x30, 0x00,
  0x2f, 0x00);

########################################################

sub create_login_script
{
    my $script_dir = build_path(get_allusers_scripts(),'standard',get_package_id());
    
    my $script_file = build_path($script_dir,get_package_id().'_userlogin.pl');
   
    my $script_wrapper = build_path($script_dir,get_package_id().'_userlogin.cmd');

    if (-d $script_dir) {
      remove_tree($script_dir) or
      output(":: ERROR | REMOVING EXISTING LOGIN SCRIPT DIRECTORY '${script_dir}': $! |\n",
        LOG_ONLY);
    }
    
    make_path($script_dir);

    if (open(my $script,'&gt;',$script_file)) {
      print $script q|
  use strict;
  use File::Path qw (make_path remove_tree);
  
  my $home = $ENV{"HOMEPATH"};
  my $user_config = $home.'|.$USER_CONFIG.q|';
  my $key = $home.'|.$KEY_LOC.q|';

  print(": BUILDING DIRECTORY \| \"$user_config\" \|\n");
  if(!make_path($user_config)){
    print(":: FAILED\n\n");
  }
  print(": DONE\n\n");

  #key file binary dump
  #EX: $ xxd -b -i example.key

  my @key = (|.join(", ",@KEY).q|);

 print(": WRITING KEY FILE \| \"$key\" \|\n");
 if(open(KEY_FILE, "&gt;", $key)){
  foreach (@key){
   print KEY_FILE map { chr } $_;
  }
  close(KEY_FILE);
  print(": DONE\n\n");
  exit(0);
 }
 else{
  print(":: FAILED\n\n");
  exit(1);
 }
|;
      close($script);
      output(join("\n",get_package_id(),' Login Script:',('-' x 60),
        get_file_contents($script_file),('-' x 60),''), LOG_ONLY);
    } else {
      output(":: ERROR | COULD NOT OPEN LOGIN SCRIPT FILE '${script_file}': $! | \n");
      return 0;
    }

    if (open(my $script,'&gt;',$script_wrapper)) {
      my $log_dir = build_path('%APPDATA%','MST','Logs');
      print $script q|
C:
IF NOT EXIST |.$log_dir.q| mkdir "|.$log_dir.q|"
perl "%~dp0|.basename($script_file).q|" &gt; "|.
            build_path($log_dir,get_package_id().'-loginscript.txt').q|" 2&gt;&amp;1
|;

      close($script);
      output(join("\n",get_package_id(),' Login Script:',('-' x 60),
        get_file_contents($script_wrapper),('-' x 60),''), LOG_ONLY);
    } else {
      output(":: ERROR | COULD NOT OPEN LOGIN SCRIPT WRAPPER FILE '${script_wrapper}': $! |\n");
      return 0;
    }
    
    return $script_wrapper;
}

sub install
{
  output(": INSTALLING ".get_package_id()."\n");
  if(!run_command("\"$INSTALLER\" /S /NCRC"))
  {
    output ":: FAILED\n\n";
	  return 0;
  }
  output ": DONE\n\n";
  return 1;
}

sub postinstall
{
  foreach my $scut (keys %SHORTCUTS){
    output(": COPYING SHORTCUT \"$scut\" TO START MENU\n");
    if(!copy($SHORTCUTS{$scut},"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs")){
      output(":: FAILED\n\n");
      return 0;
    }
    output(": DONE\n\n");
  }

  output(": BUILDING LOGIN SCRIPT\n");
  my $script_wrapper = cmd_quote(create_login_script());
  output(": DONE\n\n");

  #this part can be disabled when not testing as system account won't ever run program
  if(!(`whoami` eq "nt authority\\system\n")){
    output(": RUNNING LOGIN SCRIPT FOR CURRENT USER\n");
    if(!run_command($script_wrapper)){
      output(":: FAILED\n\n");
      return 0;
    }
    output(": DONE\n\n");   
  }else{
    output(": DETECTED RUNNING AS SYSTEM\n")
  }

  create_activesetup_action(
	  'Identifier' =&gt; $INSTALLMONKEY_OPTIONS{'package_id'}.'_setup',
	  'ComponentID' =&gt; $INSTALLMONKEY_OPTIONS{'package_id'},
	  'Description' =&gt; 'add license server',
	  'Version' =&gt; '1.0',
	  'StubPath' =&gt; $script_wrapper);

  return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\cloudpagingstudio.9_0\prod\update.pl</FullName>
    <Length>1465</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-05-25T13:29:42.7737277-05:00</CreationTime>
    <CreationTimeUtc>2017-05-25T18:29:42.7737277Z</CreationTimeUtc>
    <LastWriteTime>2017-05-25T13:26:35.8587788-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-05-25T18:26:35.8587788Z</LastWriteTimeUtc>
    <LastAccessTime>2017-05-25T13:29:42.7737277-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-05-25T18:29:42.7737277Z</LastAccessTimeUtc>
    <Text>#Jukebox Studio Packaging Platform
#Written 05/25/17 By Ben Krueger
#revision 890102116T1517

BEGIN{
    %INSTALLMONKEY_OPTIONS =(
        package_id =&gt; "cloudpagingstudio.9_0_1",
        package_revision =&gt; "05252017T1324"
    )
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;
GetOptions('uninstall' =&gt; sub{exit(!uninstall());});
do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN8_SP0,OSVER_WIN10_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['virtual-desktop','desktop','traveling','clc','virtual-clc'],
    exit_on_failure =&gt; 1,
    postinstall_sub =&gt; \&amp;postinstall,
    msi_name_x86 =&gt; 'cloudpagingstudio.msi',
    msi_name_x64 =&gt; 'cloudpagingstudio.msi',
    
);
IM_Exit(EXIT_SUCCESS);
sub postinstall {
    my $desk = get_allusers_desktop().'\\Cloudpaging Studio.lnk';
    print "\nDeleting desktop icon: ";
    if(!run_command("DEL /Q \"$desk\""))
    {
        print "FAILED!!\n"; 
    }
    else
    {
        print "Success\n";
    }
}
sub uninstall {
    output("Uninstalling Jukebox Studio");
    my $outcome = install_msi(app_id =&gt; '{6CAB7C30-E2F9-4A5E-8573-C017385F7EC1}',msi_action_flag =&gt; 'x');
    output(($outcome?'OK':'Failed')."\n");
    delete_product_registry_key(get_package_name().".".get_version());
}</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\cloudpaging_player.9_0_1\prod\update.pl</FullName>
    <Length>1452</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-03-13T14:01:56.4426587-05:00</CreationTime>
    <CreationTimeUtc>2017-03-13T19:01:56.4426587Z</CreationTimeUtc>
    <LastWriteTime>2017-03-13T14:21:33.0016844-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-03-13T19:21:33.0016844Z</LastWriteTimeUtc>
    <LastAccessTime>2017-03-13T14:01:56.4426587-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-03-13T19:01:56.4426587Z</LastAccessTimeUtc>
    <Text># Cloudpaging Player Version 9.0.1
# Created from previous version
# Created by Austin Wall
# Updated by Austin Wall
# Updated on 2017-03-13
BEGIN{
    %INSTALLMONKEY_OPTIONS =(
        package_id =&gt; "cloudpagingplayer.9_0_1",
        package_revision =&gt; "20170313T1420"
    )
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;
GetOptions('uninstall' =&gt; sub{exit(!uninstall());});
do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN8_SP0],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['virtual-desktop','desktop','traveling','clc','virtual-clc'],
    exit_on_failure =&gt; 1,
    postinstall_sub =&gt; \&amp;postinstall,
    msi_name_x86 =&gt; 'jukeboxplayerinstall.msi',
    msi_name_x64 =&gt; 'jukeboxplayerinstall.msi',
    
);
IM_Exit(EXIT_SUCCESS);
sub uninstall {
    output("Uninstalling ${NAME}");
    my $outcome = install_msi(app_id =&gt; '{23F6FB7C-C1E2-491B-91A1-0441D5191BC7}',msi_action_flag =&gt; 'x');
    delete_product_registry_key(get_package_name().".".get_version());
}
sub postinstall {
    my $desk = get_allusers_desktop().'\\Cloudpaging Player.lnk';
    print "\nDeleting desktop icon: ";
    if(!run_command("DEL /Q \"$desk\""))
    {
        print "FAILED!!\n"; 
    }
    else
    {
        print "Success\n";
    }
}</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\cmg.2016\prod\update.pl</FullName>
    <Length>2743</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-20T09:44:38.8375583-05:00</CreationTime>
    <CreationTimeUtc>2017-06-20T14:44:38.8375583Z</CreationTimeUtc>
    <LastWriteTime>2017-06-07T15:25:42.2902813-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-07T20:25:42.2902813Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-20T09:44:38.8375583-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-20T14:44:38.8375583Z</LastAccessTimeUtc>
    <Text># CMG 2016 General Release
# Package Created June 07, 2016
# Packaged by Alex Schrimpf
# Last Updated 06/07/2017 by Alex Schrimpf

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: .
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'cmg.2016',
        package_revision =&gt; '20160607T1017',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
my $srcfiles= get_pkg_sourcefiles();

use Getopt::Long;

GetOptions
(
    'uninstall' =&gt; sub {exit(!uninstall());},
);

sub install
{
  
  my $server = "1721\@cmg.lic.mst.edu";
  my $success = 1;
  push_dir($srcfiles);
  
  output( "Installing CMG: " );
  $success = install_msi( msi =&gt; "$srcfiles\\CMG 2016 General Release.msi",
    additional_msi_properties =&gt; "LICENSETYPE=NC CMGLICHOST=\"$server\" LAUNCHERMODE=SMODE",
      'IgnoreExitCodes' =&gt; [194],
    );
  if( $success != 1 )
  {
    output( "FAILED\n" );
    output( "$success code: \n" );
    return 0;
  }
  else
  {
    output( "DONE\n" );
    pop_dir();
  }
  return 1;
}

sub postinstall 
{
    print "Deleting desktop shortcuts: ";
    my $srcfiles= get_pkg_sourcefiles();
    my $desk = get_allusers_desktop();
    my $start = get_allusers_start_menu().'\\Programs\\CMG';

    run_command("DEL /Q \"$desk\\Launcher 2016.10.lnk\"");
    output( "DONE\n" );

    output( "Creating logon script for CMOST: " );
    my $outpath = build_path(get_allusers_scripts(),'standard');
    
    run_command( "XCOPY \"$srcfiles\\logon\" \"$outpath\\cmg.2016\" /Y /Q /I /E" );
    run_command( "regedit /s \"$outpath\\cmg.2016\\cmg_icon_fix.reg\"" );
    
    output("DONE\n");
    
    return 1;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);

sub uninstall
{
    output("Uninstalling CMG 2016: ");
    
    if(!run_command("msiexec.exe /qn /x \"$srcfiles\\CMG 2016 General Release.msi\""))
    {
        output("Failed\n");
    }
    else
    {
        output("Success\n");
        run_command("rmdir \"C:\\Program Files (x86)\\CMG\"");
        delete_product_registry_key(get_package_id());
    }
}</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\codeblocks.16_01\prod\update.pl</FullName>
    <Length>1289</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-07-13T15:13:19.9571298-05:00</CreationTime>
    <CreationTimeUtc>2016-07-13T20:13:19.9571298Z</CreationTimeUtc>
    <LastWriteTime>2016-07-14T14:31:58.740146-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-07-14T19:31:58.740146Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-13T15:13:20.0039307-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-13T20:13:20.0039307Z</LastAccessTimeUtc>
    <Text># Codeblocks 16.01
# Package Created July 2016
# Packaged by Ronith
# Last Updated ...

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'codeblocks.16_01',
        package_revision =&gt; '20140115T1200',
    );
}


use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();

 sub install {
	output("installing codeblocks 16.01\n");
	if(!run_command("$sourcefilesdir\\setup.exe /S")){
		output("Codeblocks did not install correctly\n");
		return 0;
	}
	else{
		output("installation successful\n");
	}

   return 1;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling','virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
	install_sub =&gt; \&amp;install,
);


IM_Exit(EXIT_SUCCESS);


</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\codeblocks.17_12\prod\update.pl</FullName>
    <Length>1893</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-22T09:28:45.2704321-05:00</CreationTime>
    <CreationTimeUtc>2018-05-22T14:28:45.2704321Z</CreationTimeUtc>
    <LastWriteTime>2018-05-22T09:30:27.0299838-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-22T14:30:27.0299838Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-22T09:28:45.2704321-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-22T14:28:45.2704321Z</LastAccessTimeUtc>
    <Text># Codeblocks 17.12
# Package Created 22 May 2018
# Packaged by Robert Smith
# Last Updated 22 May 2018

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'codeblocks.17_12',
        package_revision =&gt; '20180522T0930',
    );
}


use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();

 sub install {
	output("Installing CodeBlocks 17.12\n");
	if(!run_command("start /wait \"\" $sourcefilesdir\\codeblocks-17.12-setup.exe /S")){
		output("CodeBlocks did not install correctly\n");
		return 0;
	}
	else{
		output("Installation successful!\n");
	}

   return 1;
}

sub post {
    output("Removing icons from public: ");
    my $Remove1 = run_command("del \"%systemdrive%\\Users\\Public\\Desktop\\CodeBlocks.lnk\" /Q");
    output($Remove1 ? "Success!\n" : "FAILED: $!\n");

    output("Removing icons from user: ");
    my $current_user = getlogin || getpwuid($&lt;) || "Default";
    my $Remove2 = run_command("del \"%systemdrive%\\Users\\$current_user\\Desktop\\CodeBlocks.lnk\" /Q");
    output($Remove2 ? "Success!\n" : "FAILED: $!\n");

    return ($Remove1 || $Remove2);
}


do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling','virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
	  install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;post,
);


IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\Completion.ArchiTEX.1_1\dev.old\update.pl</FullName>
    <Length>2359</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-03-22T11:32:52.3375526-05:00</CreationTime>
    <CreationTimeUtc>2017-03-22T16:32:52.3375526Z</CreationTimeUtc>
    <LastWriteTime>2017-03-27T08:38:29.8791681-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-03-27T13:38:29.8791681Z</LastWriteTimeUtc>
    <LastAccessTime>2017-03-24T10:26:11.1885583-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-03-24T15:26:11.1885583Z</LastAccessTimeUtc>
    <Text># Completion ArchiTEX 1.1
# Package Created March 2017
# Packaged by Chris Schaaf
# Last Updated ...

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'completion.architex.1_1',
        package_revision =&gt; '20170322T1130',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $src = get_pkg_sourcefiles();

sub install{
	output("Installing ArchiTEX Client: ");
	if(!run_command("\"$src\\Completion ArchiTEX Client (1.1.11.1271).exe\" /S /v/qn/norestart")){
		output("FAILED: $!\n");
		return 0;
	}
	else{
		output("OK\n");
	}
	return 1;
}

sub postinstall{
	# Remove desktop icon
    output("Removing desktop shortcut: ");
    my $desktop_shortcut = build_path(get_allusers_desktop(),
                                      'Completion ArchiTEX.lnk');
    if (!run_command("del /q /f \"${desktop_shortcut}\""))
    {
        output("FAILED\n".
               "Deleting desktop icon (${desktop_shortcut}) failed: $?\n");
        # This isn't critical. Don't report failure.
    }
    output("OK\n");
	
	# Place autoit script in place of shortcut
	output("Placing script: ");
	my $startmenu = "%PROGRAMDATA%\\Microsoft\\Windows\\Start Menu\\Programs\\Baker Hughes\\Completion ArchiTEX";
	if(!run_command("copy /Y \"$src\\autoit\\Completion ArchiTEX.lnk\" \"$startmenu\\Completion ArchiTEX.lnk\"")){
		output("FAILED:$!\nProgram will not be licensed on first launch!\n");
		return 0;
	}
	output("OK\n");
	return 1;
}

do_install( 
    allowed_versions =&gt; [ OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2,
                          OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs =&gt; [ 'clc', 'desktop', 'traveling',
                      'virtual-clc','virtual-desktop' ],
    exit_on_failure =&gt; 1,
    #preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);
IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\Completion.ArchiTEX.1_1\prod\update.pl</FullName>
    <Length>2303</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-01-11T15:10:44.2311018-06:00</CreationTime>
    <CreationTimeUtc>2018-01-11T21:10:44.2311018Z</CreationTimeUtc>
    <LastWriteTime>2018-01-24T10:38:21.3808691-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-24T16:38:21.3808691Z</LastWriteTimeUtc>
    <LastAccessTime>2018-01-11T15:10:44.2823863-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-01-11T21:10:44.2823863Z</LastAccessTimeUtc>
    <Text># Completion ArchiTEX 1.1
# Package Created Winter 2016
# Last Updated 2017-1-5 by Alex Schrimpf

=pod

Begin-Doc
Modified: 
Name: 
Type:
Description: 
Language: Perl
LastUpdatedBy:
Version:
Doc-Package-Info
Doc-SVN-Repository:
RCSId:
End-Doc

=cut

use strict;
use warnings;
our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'completion.architex.1_1',
        package_revision =&gt; '',
    );
}

use lib ( '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 'C:\temp' );

use InstallMonkey::Shared;

use IM_helper(
   \%INSTALLMONKEY_OPTIONS,
    v4.04,
    (
        "INSTALL" =&gt; 
        [
            sub {
                IM_helper::run_command(
                    description=&gt;'Completion ArchiTEX Installer',
                    command=&gt;"\"$IM_helper::source_files\\Completion ArchiTEX Client (1.1.11.1271).exe\" /S /v/qn/norestart"
                );
            },
            sub {
                IM_helper::del_files(
                    files=&gt;["C:\\Users\\Public\\Desktop\\Completion ArchiTEX.lnk"]
                );
            },
            sub {
                IM_helper::push_to_system_var(
                    name=&gt;"LM_LICENSE_FILE",
                    value=&gt;"10000\@architex.lic.mst.edu"
                );
            }
        ],
        "UNINSTALL" =&gt;
        [
            sub {
                IM_helper::uninstall_using_programs_and_features(
                    display_name=&gt;'Completion ArchiTEX Client',
                );
            },
            sub{
                delete_product_registry_key($INSTALLMONKEY_OPTIONS{package_id});
            }
        ]
    )
);

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt;
      [ 'clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    no_install_check =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    no_product_key =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    install_sub =&gt; $IM_helper::exec_call_stack_override || sub{IM_helper::exec_call_stacks(ids=&gt;["INSTALL"])}
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\Completion.ArchiTEX.1_1\prod.old\update.pl</FullName>
    <Length>3361</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-03-27T08:56:22.7117991-05:00</CreationTime>
    <CreationTimeUtc>2017-03-27T13:56:22.7117991Z</CreationTimeUtc>
    <LastWriteTime>2017-09-08T13:46:51.0379902-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-09-08T18:46:51.0379902Z</LastWriteTimeUtc>
    <LastAccessTime>2017-03-27T08:56:22.7117991-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-03-27T13:56:22.7117991Z</LastAccessTimeUtc>
    <Text># Completion ArchiTEX 1.1
# Package Created March 2017
# Packaged by Chris Schaaf
# Updated 4/5/17 by Ryan Andrews
# Last Updated 2017-09-08 by Grayson Gratop

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'completion.architex.1_1',
    package_revision =&gt; '20170322T1130',
  );
}

use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV {'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use InstallMonkey::Shared;

my $src = get_pkg_sourcefiles();

sub install {
  output("Installing ArchiTEX Client: ");
  if (!run_command("\"$src\\Completion ArchiTEX Client (1.1.11.1271).exe\" /S /v/qn/norestart")){
    output("Failed, trying again for good measure: ");
    if (!run_command("\"$src\\Completion ArchiTEX Client (1.1.11.1271).exe\" /S /v/qn/norestart")) {
      output("FAILED: $!\n");
      return 0;
    }
    else {
      output("OK\n");
    }
  }
  else {
    output("OK\n");
  }
  return 1;
}

sub postinstall {
  # Remove desktop icon
  output("Removing desktop shortcut: ");
  my $desktop_shortcut = build_path(get_allusers_desktop(),
                                    'Completion ArchiTEX.lnk');
  if (!run_command("del /q /f \"${desktop_shortcut}\"")) {
    output("FAILED\n".
           "Deleting desktop icon (${desktop_shortcut}) failed: $?\n");
    # This isn't critical. Don't report failure.
  }
  output("OK\n");


  output('Appending 10000@architex.lic.mst.edu to LM_LICENSE_FILE: ');

  # check for LM_LICENSE_FILE existing before appending
  my $success = 1;
  my $runinfo = {};
  run_command('echo %LM_LICENSE_FILE%','ReturnCommandInfo'=&gt;$runinfo);

  # in both cases, sandwich the address in the semicolons just in case other programs expect other delimitters 
  if ($runinfo-&gt;{'Output'} eq "\%LM_LICENSE_FILE\%\n") {
    $success = run_command('setx /m LM_LICENSE_FILE ;10000@architex.lic.mst.edu;');
  }
  else {
    $success = run_command('setx /m LM_LICENSE_FILE %LM_LICENSE_FILE%;10000@architex.lic.mst.edu;');
  }

  if (!$success) {
    output("FAILED\n".
           "Couldn't set up license: $?\n");
  }
  output("OK\n");

  # # Place autoit script in place of shortcut (removed)
  # output("Placing script: ");
  # my $startmenu = "%PROGRAMDATA%\\Microsoft\\Windows\\Start Menu\\Programs\\Baker Hughes\\Completion ArchiTEX";
  # if (!run_command("copy /Y \"$src\\autoit\\Completion ArchiTEX.lnk\" \"$startmenu\\Completion ArchiTEX.lnk\"")){
  #   output("FAILED:$!\nProgram will not be licensed on first launch!\n");
  #   return 0;
  # }
  # output("OK\n");

  return 1;
}

do_install(
  allowed_versions =&gt; [ OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2,
                        OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
  allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
  allowed_regs =&gt; [ 'clc', 'desktop', 'traveling',
                    'virtual-clc','virtual-desktop' ],
  exit_on_failure =&gt; 1,
  #preinstall_sub =&gt; \&amp;preinstall,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postinstall,
);
IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\cppcheck.1_78\prod\update.pl</FullName>
    <Length>2135</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-05-25T12:36:28.0194913-05:00</CreationTime>
    <CreationTimeUtc>2017-05-25T17:36:28.0194913Z</CreationTimeUtc>
    <LastWriteTime>2017-05-25T13:02:08.5023154-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-05-25T18:02:08.5023154Z</LastWriteTimeUtc>
    <LastAccessTime>2017-05-25T12:36:28.0194913-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-05-25T17:36:28.0194913Z</LastAccessTimeUtc>
    <Text># Package Created 2016-07-13
# Packaged by Jason Mao

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS =
    (
        package_id =&gt; 'cppcheck.1_78',
        package_revision =&gt; '20170512T1335',
    );
}


use lib
(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);


use InstallMonkey::Shared;
use Getopt::Long;
GetOptions(
    'uninstall' =&gt; sub { exit(! uninstall()); },
);
sub uninstall {
    my $srcfiles = get_pkg_sourcefiles();
    
    output("Uninstalling Cppcheck: ");
    my $Success = install_msi(
        msi =&gt; "$srcfiles\\cppcheck-1.78-x64-Setup.msi",
        msi_action_flag =&gt; 'x',
    );
    
    output($Success ? "Success!\n" : "FAILED: $!\n");
    
    if ($Success) { delete_product_registry_key('cppcheck.1_73'); }
    
    return $Success;
}

sub install
{
    my $srcfiles = get_pkg_sourcefiles();
    
    run_command("$srcfiles\\vc_redist.x64.exe /q");
    
    output("Installing cppcheck 1.73: ");
    my $Success = install_msi(
        msi =&gt; "$srcfiles\\cppcheck-1.78-x64-Setup.msi",
        'IgnoreExitCodes' =&gt; [ 3010, 194],
    );
    
    output($Success ? "Success!\n" : "FAILED: $!\n");
    return $Success;
}

sub postinstall
{
    my $langfile = get_pkg_sourcefiles().'\\cppcheck_en.qm';
    my $langdir = "C:\\Program Files\\Cppcheck\\lang";
    run_command("move /y $langfile \"$langdir\"");
    return 1;
}


do_install
( 
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [ 'desktop', 'clc', 'traveling', 'virtual-desktop', 
                        'virtual-clc' ],
    exit_on_failure =&gt; 1,
    postinstall_sub =&gt; \&amp;postinstall,
    install_sub =&gt; \&amp;install,

);


IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\cppcheck.1_83\prod\update.pl</FullName>
    <Length>2138</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-22T12:40:45.766597-05:00</CreationTime>
    <CreationTimeUtc>2018-05-22T17:40:45.766597Z</CreationTimeUtc>
    <LastWriteTime>2018-05-22T12:44:53.4577508-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-22T17:44:53.4577508Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-22T12:40:45.7822267-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-22T17:40:45.7822267Z</LastAccessTimeUtc>
    <Text># Package Created 2018-05-22
# Packaged by Kade Wessels

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS =
    (
        package_id =&gt; 'cppcheck.1_83',
        package_revision =&gt; '20180522T1243',
    );
}


use lib
(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);


use InstallMonkey::Shared;
use Getopt::Long;
GetOptions(
    'uninstall' =&gt; sub { exit(! uninstall()); },
);
sub uninstall {
    my $srcfiles = get_pkg_sourcefiles();
    
    output("Uninstalling Cppcheck: ");
    my $Success = install_msi(
        msi =&gt; "$srcfiles\\cppcheck-1.83-x64-Setup.msi",
        msi_action_flag =&gt; 'x',
    );
    
    output($Success ? "Success!\n" : "FAILED: $!\n");
    
    if ($Success) { delete_product_registry_key('cppcheck.1_83'); }
    
    return $Success;
}

sub install
{
    my $srcfiles = get_pkg_sourcefiles();
    
    run_command("$srcfiles\\vc_redist.x64.exe /q");
    
    output("Installing cppcheck 1.73: ");
    my $Success = install_msi(
        msi =&gt; "$srcfiles\\cppcheck-1.83-x64-Setup.msi",
        'IgnoreExitCodes' =&gt; [ 3010, 194],
    );
    
    output($Success ? "Success!\n" : "FAILED: $!\n");
    return $Success;
}

sub postinstall
{
    my $langfile = get_pkg_sourcefiles().'\\cppcheck_en.qm';
    my $langdir = "C:\\Program Files\\Cppcheck\\lang";
    run_command("move /y $langfile \"$langdir\"");
    return 1;
}


do_install
( 
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [ 'desktop', 'clc', 'traveling', 'virtual-desktop', 
                        'virtual-clc' ],
    exit_on_failure =&gt; 1,
    postinstall_sub =&gt; \&amp;postinstall,
    install_sub =&gt; \&amp;install,

);


IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>default.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\cst.2017\dev\default.pl</FullName>
    <Length>6624</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-01-10T09:34:20.5676383-06:00</CreationTime>
    <CreationTimeUtc>2018-01-10T15:34:20.5676383Z</CreationTimeUtc>
    <LastWriteTime>2018-01-10T12:20:53.9141917-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-10T18:20:53.9141917Z</LastWriteTimeUtc>
    <LastAccessTime>2018-01-10T09:34:20.5676383-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-01-10T15:34:20.5676383Z</LastAccessTimeUtc>
    <Text>(
    "TEST"=&gt;
    [
        sub {
            IM_helper::run_command(
                name =&gt; 'CST 2017 Service Pack',
                command =&gt; "\"C:\\Program Files (x86)\\CST STUDIO SUITE 2017\\AutoUpdate\" --quiet --install \"$IM_helper::source_files\\CST_STUDIO_SUITE_2017_Windows_Latest_SP\\CST_STUDIO_SUITE_2017_Windows_130120172100040820172100_SP5.sup\"",
            );
        }
    ],
    "EXTRACTION" =&gt;
    [
        sub {
            IM_helper::extract_files(
                from=&gt; [$IM_helper::source_files.'\\CST_DATA.zip'],
                to =&gt; $IM_helper::source_files
            );
        }
        
    ],
    "INSTALL" =&gt;
    [
        #Run main installer
        sub {
            IM_helper::run_command(
                name =&gt;'CST 2017',
                command =&gt;"msiexec /i \"$IM_helper::source_files\\CST-STUDIO-SUITE-2017-Windows_DVD\\Program\\Full Package\\Release\\DiskImages\\DISK1\\CST STUDIO SUITE 2017.msi\" /qn ADDLOCAL=CST_STUDIO_SERIES_Files,Examples,CS,DS,EMS,MPS,MWS,PCBS,PS,Distributed_Computing_Main_Controller",
            );
        },
        #Set license server location
        sub {
            return (
                #x86
                IM_helper::set_reg_subkey(
                    key =&gt; 'HKEY_LOCAL_MACHINE/SOFTWARE/FLEXlm License Manager/', 
                    subkey =&gt; ["CSTD_LICENSE_FILE"=&gt;['27010@cst.lic.mst.edu','REG_SZ']],
                    succ_cb =&gt; sub { 
                           IM_helper::set_reg_subkey(
                                key =&gt; 'HKEY_LOCAL_MACHINE/SOFTWARE/CST AG/CST DESIGN ENVIRONMENT/2017/', 
                                subkey =&gt; ["LICENSESERVER"=&gt;['27010@cst.lic.mst.edu','REG_SZ']]
                            );
                        }
                ) 
                | #Bitwise to run both
                #x64
                IM_helper::set_reg_subkey(
                    key =&gt; 'HKEY_LOCAL_MACHINE/SOFTWARE/Wow6432Node/FLEXlm License Manager/', 
                    subkey =&gt; ["CSTD_LICENSE_FILE"=&gt;['27010@cst.lic.mst.edu','REG_SZ']],
                    succ_cb =&gt; sub { 
                            IM_helper::set_reg_subkey(
                                key =&gt; 'HKEY_LOCAL_MACHINE/SOFTWARE/Wow6432Node/CST AG/CST DESIGN ENVIRONMENT/2017/', 
                                subkey =&gt; ["LICENSESERVER"=&gt;['27010@cst.lic.mst.edu','REG_SZ']]
                            );
                        }
                )                 
            );
        },
        #Create activesetup
        sub {
            my $activesetup_script_loc = "C:\\Windows\\System32\\UMRInst\\scripts\\CST_NO_PROMPT.reg"; 
            return IM_helper::write_file(
                file =&gt; $activesetup_script_loc,
                data =&gt; IM_helper::normalize_text(
                            text=&gt;
                                qq|
                                    Windows Registry Editor Version 5.00

                                    [HKEY_CURRENT_USER\\Software\\CST AG\\CST DESIGN ENVIRONMENT 2017\\Usersettings]
                                    "ShowLicenseExpire"=dword:00000000
                                    "ShowMaintenanceExpire"=dword:00000000
                                    "ShowQuickStart"=dword:00000000

                                    [HKEY_CURRENT_USER\\Software\\CST AG\\CST STUDIO SUITE\\Usersettings]
                                    "ShowQuickIntroductionVideoDialogBox"=dword:00000000
                                    "ShowQuickStart"=dword:00000000
                                    "SupportLogin"=""
                                |
                ),
                succ_cb =&gt; sub {
                        IM_helper::set_perms(
                            file=&gt;$activesetup_script_loc,
                            user=&gt;"Users",
                            permissions=&gt;"F", #Full permisions
                            succ_cb =&gt; sub {
                                IM_helper::create_activesetup(
                                    command =&gt; "REG IMPORT \"$activesetup_script_loc\"",
                                    description =&gt; "Disable prompts and support login for CST 2017",
						        );
                            }
                        );
                    }
            );   
        },
        #Copy shortcuts to startmenu
        sub {
            return (
                IM_helper::run_command(
                        name=&gt; 'Copying shortcut icon cache',
                        command =&gt; "xcopy /Y /S /I /R \"$IM_helper::source_files\\{4A11C292-6FD0-4B9A-B838-20058F213786}\" \"%appdata%\\Microsoft\\Installer\\{4A11C292-6FD0-4B9A-B838-20058F213786}\"",
                )
                &amp;&amp;            
                IM_helper::run_command(
                        name=&gt; 'Copying shortcuts to startmenu',
                        command =&gt; "xcopy /Y /S /I /R \"$IM_helper::source_files\\CST STUDIO SUITE 2017\" \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\CST STUDIO SUITE 2017\"",
					)
            );
        },
        #Update to latest service pack
        sub {
            IM_helper::run_command(
                name =&gt; 'CST 2017 Service Pack',
                command =&gt; "\"C:\\Program Files (x86)\\CST STUDIO SUITE 2017\\AutoUpdate\" --quiet --install \"$IM_helper::source_files\\CST_STUDIO_SUITE_2017_Windows_Latest_SP\\CST_STUDIO_SUITE_2017_Windows_130120172100040820172100_SP5.sup\"",
            );
        }
    ],

    "UNINSTALL" =&gt; 
    [
        sub {
            IM_helper::get_uninstall_strings(
                display_name=&gt; "CST STUDIO SUITE 2017",
                succ_cb =&gt; sub {
                    my $uninst_str = @{{@_}-&gt;{x86}}[0];
                    $uninst_str=~ s/\QI\E/X/g;
                    return IM_helper::run_command(
                        name=&gt;"Uninstalling CST",
                        command=&gt;$uninst_str." /quiet /qn",
                    );
                }
            );
        },
        sub {
            IM_helper::rm_dirs(
                    dirs =&gt; [
                        "C:\\Program Files (x86)\\CST STUDIO SUITE 2017\\",
                        "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\CST STUDIO SUITE 2017",
                        "%appdata%\\Microsoft\\Installer\\{4A11C292-6FD0-4B9A-B838-20058F213786}"
                    ],
               );
            return 1;
        },
        sub {
            delete_product_registry_key(get_package_id());
        }
    ]
);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\cst.2017\dev\update.pl</FullName>
    <Length>2262</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-01-10T09:34:04.8478911-06:00</CreationTime>
    <CreationTimeUtc>2018-01-10T15:34:04.8478911Z</CreationTimeUtc>
    <LastWriteTime>2018-01-10T13:00:43.1813681-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-10T19:00:43.1813681Z</LastWriteTimeUtc>
    <LastAccessTime>2018-01-10T09:34:04.8478911-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-01-10T15:34:04.8478911Z</LastAccessTimeUtc>
    <Text># CST 2017
# Package Created Fall 2017
# Packaged by Alex Schrimpf
# Last Updated Fall 2017 by Alex Schrimpf


=pod

Begin-Doc
Modified: 
Name: 
Type:
Description: 
Language: Perl
LastUpdatedBy:
Version:
Doc-Package-Info
Doc-SVN-Repository:
RCSId:
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'CST.2017',
        package_revision =&gt; '',
    );
}

use lib ( '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 'C:\temp' );

use InstallMonkey::Shared;

use IM_helper(
    \%INSTALLMONKEY_OPTIONS,
    v2.01,
    do "default.pl"
);

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt;
      [ 'clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    no_install_check =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL'),
    no_product_key =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL'),
    install_sub =&gt; sub {
        if(scalar @{$IM_helper::IM_HELPER_OPTIONS{call_stack_override}}){
            foreach my $call_stack (@{$IM_helper::IM_HELPER_OPTIONS{call_stack_override}}){
                if(!IM_helper::exec_call_stack(id=&gt;$call_stack)){
                   return 0;
                }
            }
            return 1;
        }else{
            my $counter = 0;
            IM_helper::flush_msg(msg=&gt;"COUNTER $counter\n");
            return 0 unless IM_helper::exec_call_stack(id=&gt;"EXTRACTION");
            while(1){
                IM_helper::flush_msg(msg=&gt;"COUNTER $counter\n");
                return 0 unless IM_helper::exec_call_stack(id=&gt;"INSTALL");
                IM_helper::flush_msg(msg=&gt;"COUNTER $counter\n");
                return 0 unless IM_helper::exec_call_stack(id=&gt;"UNINSTALL");    
                $counter++;            
            }
            return (
                IM_helper::exec_call_stack(id=&gt;"EXTRACTION") &amp;&amp;
                IM_helper::exec_call_stack(id=&gt;"INSTALL") &amp;&amp; 
                IM_helper::exec_call_stack(id=&gt;"UNINSTALL")
            );
        }
    }
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\cst.2017\prod\update.pl</FullName>
    <Length>7700</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-21T17:04:38.7446706-06:00</CreationTime>
    <CreationTimeUtc>2017-11-21T23:04:38.7446706Z</CreationTimeUtc>
    <LastWriteTime>2018-06-19T14:56:57.584163-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-19T19:56:57.584163Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-21T17:04:38.7446706-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-21T23:04:38.7446706Z</LastAccessTimeUtc>
    <Text># CST 2017
# Package Created Fall 2017
# Packaged by Alex Schrimpf
# Last Updated Fall 2017 by Alex Schrimpf


=pod

Begin-Doc
Modified: 
Name: 
Type:
Description: 
Language: Perl
LastUpdatedBy:
Version:
Doc-Package-Info
Doc-SVN-Repository:
RCSId:
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'CST.2017',
        package_revision =&gt; '',
    );
}

use lib ( '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 'C:\temp' );

use InstallMonkey::Shared;

use IM_helper(
    \%INSTALLMONKEY_OPTIONS,
    v5.01,
    (
        "EXTRACTION" =&gt;
        [
            sub {
                IM_helper::extract_files(
                    from=&gt; [$IM_helper::source_files.'\\CST_DATA.zip'],
                    to =&gt; $IM_helper::source_files
                );
            }
        ],
        "INSTALL" =&gt;
        [
            #Run main installer
            sub {
                IM_helper::run_command(
                    description =&gt;'CST 2017',
                    command =&gt;"msiexec /i \"$IM_helper::source_files\\CST-STUDIO-SUITE-2017-Windows_DVD\\Program\\Full Package\\Release\\DiskImages\\DISK1\\CST STUDIO SUITE 2017.msi\" /qn ADDLOCAL=CST_STUDIO_SERIES_Files,Examples,CS,DS,EMS,MPS,MWS,PCBS,PS,Distributed_Computing_Main_Controller",
                );
            },
            #Set license server location
            sub {
                return (
                    #x86
                    IM_helper::set_reg_key_values(
                        key =&gt; 'HKEY_LOCAL_MACHINE/SOFTWARE/FLEXlm License Manager/', 
                        values =&gt; ["CSTD_LICENSE_FILE"=&gt;['27010@cst.lic.mst.edu','REG_SZ']],
                        succ_cb =&gt; sub { 
                               IM_helper::set_reg_key_values(
                                    key =&gt; 'HKEY_LOCAL_MACHINE/SOFTWARE/CST AG/CST DESIGN ENVIRONMENT/2017/', 
                                    values =&gt; ["LICENSESERVER"=&gt;['27010@cst.lic.mst.edu','REG_SZ']]
                                );
                            }
                    ) 
                    | #Bitwise to run both
                    #x64
                    IM_helper::set_reg_key_values(
                        key =&gt; 'HKEY_LOCAL_MACHINE/SOFTWARE/Wow6432Node/FLEXlm License Manager/', 
                        values =&gt; ["CSTD_LICENSE_FILE"=&gt;['27010@cst.lic.mst.edu','REG_SZ']],
                        succ_cb =&gt; sub { 
                                IM_helper::set_reg_key_values(
                                    key =&gt; 'HKEY_LOCAL_MACHINE/SOFTWARE/Wow6432Node/CST AG/CST DESIGN ENVIRONMENT/2017/', 
                                    values =&gt; ["LICENSESERVER"=&gt;['27010@cst.lic.mst.edu','REG_SZ']]
                                );
                            }
                    )                 
                );
            },
            #Create activesetup
            sub {
                my $activesetup_script_loc = "C:\\Windows\\System32\\UMRInst\\scripts\\CST_NO_PROMPT.reg"; 
                return IM_helper::write_file(
                    file =&gt; $activesetup_script_loc,
                    data =&gt; IM_helper::normalize_text(
                                text=&gt;
                                    qq|
                                        Windows Registry Editor Version 5.00

                                        [HKEY_CURRENT_USER\\Software\\CST AG\\CST DESIGN ENVIRONMENT 2017\\Usersettings]
                                        "ShowLicenseExpire"=dword:00000000
                                        "ShowMaintenanceExpire"=dword:00000000
                                        "ShowQuickStart"=dword:00000000

                                        [HKEY_CURRENT_USER\\Software\\CST AG\\CST STUDIO SUITE\\Usersettings]
                                        "ShowQuickIntroductionVideoDialogBox"=dword:00000000
                                        "ShowQuickStart"=dword:00000000
                                        "SupportLogin"=""
                                    |
                    ),
                    succ_cb =&gt; sub {
                            IM_helper::set_perms(
                                file=&gt;$activesetup_script_loc,
                                user=&gt;"Users",
                                permissions=&gt;"F", #Full permisions
                                succ_cb =&gt; sub {
                                    IM_helper::create_activesetup(
                                        command =&gt; "REG IMPORT \"$activesetup_script_loc\"",
                                        description =&gt; "Disable prompts and support login for CST 2017",
                                    );
                                }
                            );
                        }
                );   
            },
            #Copy shortcuts to startmenu
            sub {
                return (
                    IM_helper::run_command(
                            description=&gt; 'Copying shortcut icon cache',
                            command =&gt; "xcopy /Y /S /I /R \"$IM_helper::source_files\\{4A11C292-6FD0-4B9A-B838-20058F213786}\" \"%appdata%\\Microsoft\\Installer\\{4A11C292-6FD0-4B9A-B838-20058F213786}\"",
                    )
                    &amp;&amp;            
                    IM_helper::run_command(
                            description=&gt; 'Copying shortcuts to startmenu',
                            command =&gt; "xcopy /Y /S /I /R \"$IM_helper::source_files\\CST STUDIO SUITE 2017\" \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\CST STUDIO SUITE 2017\"",
                        )
                );
            },
            #Update to latest service pack
            sub {
                IM_helper::run_command(
                    description =&gt; 'CST 2017 Service Pack',
                    command =&gt; "\"C:\\Program Files (x86)\\CST STUDIO SUITE 2017\\AutoUpdate\" --quiet --install \"$IM_helper::source_files\\CST_STUDIO_SUITE_2017_Windows_Latest_SP\\CST_STUDIO_SUITE_2017_Windows_130120172100040820172100_SP5.sup\"",       
                );
            }
        ],
        "UNINSTALL" =&gt; 
        [
            sub {
                IM_helper::uninstall_using_programs_and_features(
                    display_name=&gt; "CST STUDIO SUITE 2017"
                );
            },
            sub {
                return IM_helper::rm_dirs(
                        dirs =&gt; [
                            "C:\\Program Files (x86)\\CST STUDIO SUITE 2017\\",
                            "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\CST STUDIO SUITE 2017",
                        ],
                   );
            },
            sub {
                IM_helper::delete_activesetup(id=&gt;$INSTALLMONKEY_OPTIONS{package_id});
            },
            sub {
                delete_product_registry_key(get_package_id());
            }
        ]
    )
);

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt;
      [ 'clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    no_install_check =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    no_product_key =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    install_sub =&gt; $IM_helper::exec_call_stack_override || sub{IM_helper::exec_call_stacks(ids=&gt;["EXTRACTION","INSTALL"])}
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\deepsoil.6_1_7\prod\update.pl</FullName>
    <Length>2421</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-06T14:32:23.8451846-05:00</CreationTime>
    <CreationTimeUtc>2017-06-06T19:32:23.8451846Z</CreationTimeUtc>
    <LastWriteTime>2017-06-14T14:42:13.6614654-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-14T19:42:13.6614654Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-06T14:32:23.8451846-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-06T19:32:23.8451846Z</LastAccessTimeUtc>
    <Text># Package Created April 2015
# Packaged by Sam Pilla
# Last Updated 2017-6-6 by Sergey Gruzdev

=pod

Begin-Doc
Modified: $Date$
Name: $Name$
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'deepsoil.6_0',
        package_revision =&gt; '20170606T1445',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

my $src = get_pkg_sourcefiles();

GetOptions(
    'uninstall' =&gt; sub { exit(!uninstall()); },
);

sub uninstall
{
  # Uninstalling
  print "Uninstalling DeepSoil 6.1.7...";
  # Uninstall via msi
  my $success = install_msi(app_id =&gt; "$src\\DeepSoil_6 Installer x64.msi",
                            msi_action_flag =&gt; 'x');
  # Wait a lil
  sleep(20);
  print(($success ? "OK":"FAILED")."\n");
  
  # Delete reg key
  if($success)
  {
    $success = delete_product_registry_key(get_package_name().".".get_version());
  }  
  
  print($success ? "Uninstall complete!\n" : "Uninstall failed, try again!\n");
  
  exit($success ? 1 : 0);  
}

sub postinstall
{
  # Delete desktop icon
  print "Deleting Desktop icons..";
  my $desk = get_allusers_desktop();
  
  if(!run_command("DEL /q \"$desk\\DEEPSOIL v6.1.lnk\""))
  {
    print "FAILED!\n";
	return 0;
  }
  else
  {
    print "SUCCESS!\n";
  }
  # Overwrite config file
  my $dest = $ENV{"ProgramFiles"}."\\UIUC\\DeepSoil 6.1\\";
  if(!run_command("copy \"$src\\DeepSoil_v6.exe.config\" \"$dest\" /y"))
  {
    print "Couldn't copy DeepSoil_v6.exe.config to \"$dest\"\n";
	return 0;
  }
  else
  {
    print "Updated DeepSoil_v6.exe.config!\n";
  }
  
  print "Postinstall complete!\n";
  return 1;
}

do_install
(
  allowed_versions =&gt; ['OSVER_WIN7_SP0', 'OSVER_WIN7_SP1', 'OSVER_WIN10_SP0'],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'virtual-clc', 'virtual-desktop', 'desktop', 'traveling'],
  exit_on_failure =&gt; 1,
  msi_name =&gt; 'DeepSoil_6 Installer x64.msi',
  additional_msi_properties =&gt; '/norestart',
  postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\defaultprograms.1\dev\update.pl</FullName>
    <Length>1226</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-08-01T08:59:24.6798191-05:00</CreationTime>
    <CreationTimeUtc>2017-08-01T13:59:24.6798191Z</CreationTimeUtc>
    <LastWriteTime>2017-08-01T09:05:48.4536602-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-08-01T14:05:48.4536602Z</LastWriteTimeUtc>
    <LastAccessTime>2017-08-01T08:59:24.6798191-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-08-01T13:59:24.6798191Z</LastAccessTimeUtc>
    <Text># Set Default Programs
# Package Created August 01, 2017
# Packaged by Wall, Austin (Student Employee)
# Last Updated --

BEGIN {
    %::INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'defaultprograms.1',
        package_revision =&gt; '20170801T0858',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

sub install {
    if(!run_command("xcopy $srcfiles\\AppAssoc_Modified.xml C:\\Windows\\System32\\OEMDefaultAssociations.xml /H /Y"))
    {
        output("Installation failed!\n");
        return 0;
    }
    
    output("Installation successful!");
    return 1;
}

do_install( 
    exit_on_failure =&gt; 1,
    allowed_versions          =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures  =&gt; [ OSARCH_x64 ],
    allowed_regs              =&gt; [ "clc", "desktop", "traveling", "virtual-desktop", "virtual-clc" ],
    install_sub               =&gt; \&amp;install,

    
);

IM_Exit(EXIT_SUCCESS);

########################################################################</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\dlang.2_074\prod\update.pl</FullName>
    <Length>2542</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-01-29T11:29:08.1040957-06:00</CreationTime>
    <CreationTimeUtc>2018-01-29T17:29:08.1040957Z</CreationTimeUtc>
    <LastWriteTime>2017-05-09T13:52:48.9295794-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-05-09T18:52:48.9295794Z</LastWriteTimeUtc>
    <LastAccessTime>2018-01-29T11:29:08.1040957-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-01-29T17:29:08.1040957Z</LastAccessTimeUtc>
    <Text># Package Created 2016-07-14
# Packaged by Jason Mao
# Updated by Grayson Gratop on 2016-08-31
# Updated by Grayson Gratop on 2017-05-08

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;
use Win32::TieRegistry;
use Getopt::Long;
print "Started PERL script...\n";

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'dlang.2.074',
        package_revision =&gt; '20170508T1526',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;
print "Loaded InstallMonkey...\n";
#my $srcfiles = get_pkg_sourcefiles();
#my $log_dir = get_applogs_dir();

GetOptions(
    'uninstall' =&gt; sub { exit(! uninstall()); },
);


sub install
{
  my $srcfiles = get_pkg_sourcefiles();
  my $command = "$srcfiles\\dmd-2.074.0.exe /S";

  output("Installing dlang with command: $command");
  run_command($command, 'IgnoreReturnCode'=&gt;1);

  # The run_command spawns a separate process and returns immediately so this loop waits until setup.exe finishes running.
  my $index = 0;
  my $success = 0;
  while($index &lt; 3600) # 3600*5sec = 5 hours
  {
    $_ = `tasklist`;
    if(/dmd-2\.071\.1\.exe/gi){
        $index++;
        sleep(5);
    }
    else{
        output("\n  Setup finished!\n");
        $success = 1;
        last;
    }
  }

  if (!$success) { 
    output("Timed out...\n");
    return 0;
  }

  #install LDC as an alternate compiler (and DUB too)

  output("Extracting LDC to C:\\D\\ldc and setting path...\n");

  $success &amp;&amp;= run_command("\"C:\\Program Files\\7-Zip\\7z\" x $srcfiles\\ldc.7z -oC:\\D");
  $success &amp;&amp;= run_command("setx /M PATH \"\%PATH\%;C:\\D\\ldc\\bin\"");

  if (!$success) { 
    output("Something went wrong when installing LDC...\n");
    return 0;
  }

  output("Done!\n");

  return 1;
}

do_install(
    no_os_version_check =&gt; 1,
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\dlang.2_074\prod - Copy\update.pl</FullName>
    <Length>2708</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-01-29T11:29:06.9645313-06:00</CreationTime>
    <CreationTimeUtc>2018-01-29T17:29:06.9645313Z</CreationTimeUtc>
    <LastWriteTime>2017-08-15T17:01:45.2065924-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-08-15T22:01:45.2065924Z</LastWriteTimeUtc>
    <LastAccessTime>2018-01-29T11:29:06.9645313-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-01-29T17:29:06.9645313Z</LastAccessTimeUtc>
    <Text># Package Created 2016-07-14
# Packaged by Jason Mao
# Updated by Grayson Gratop on 2016-08-31
# Updated by Grayson Gratop on 2017-05-08

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;
use Win32::TieRegistry;
use Getopt::Long;
print "Started PERL script...\n";

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'dlang.2.074',
        package_revision =&gt; '20170508T1526',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;
print "Loaded InstallMonkey...\n";
my $srcfiles = get_pkg_sourcefiles();
my $vs17appd = "\\\\minerfiles.mst.edu\\dfs\\software\\itwindist\\appdeploy\\visual_studio.2017";
my $vs17loc = "C:\\VS2017";
my $vsstart = "$ENV{'PROGRAMDATA'}\\Microsoft\\Windows\\Start Menu\\Programs";

GetOptions(
    'uninstall' =&gt; sub { exit(! uninstall()); },
);

sub install {

  my $command = "$srcfiles\\dmd-2.074.0.exe /S";

  output("Installing dlang with command: $command");
  run_command($command, 'IgnoreReturnCode'=&gt;1);

  # The run_command spawns a separate process and returns immediately so this loop waits until setup.exe finishes running.
  my $index = 0;
  my $success = 0;
  while($index &lt; 3600) # 3600*5sec = 5 hours
  {
    $_ = `tasklist`;
    if(/dmd-2\.071\.1\.exe/gi){
        $index++;
        sleep(5);
    }
    else{
        output("\n  Setup finished!\n");
        $success = 1;
        last;
    }
  }

  if (!$success) { 
    output("Timed out...\n");
    return 0;
  }

  #install LDC as an alternate compiler (and DUB too)

  output("Extracting LDC to C:\\D\\ldc and setting path...\n");

  $success &amp;&amp;= run_command("\"C:\\Program Files\\7-Zip\\7z\" x $srcfiles\\ldc.7z -oC:\\D");
  $success &amp;&amp;= run_command("setx /M PATH \"\%PATH\%;C:\\D\\ldc\\bin\"");

  if (!$success) { 
    output("Something went wrong when installing LDC...\n");
    return 0;
  }

  output("Done!\n");

  return 1;
}

do_install(
    no_os_version_check =&gt; 1,
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
	#preinstall_sub =&gt; \&amp;pre_install,
    install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\dlang.2_074\prod.notasold\update.pl</FullName>
    <Length>3256</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-01-29T11:29:09.687347-06:00</CreationTime>
    <CreationTimeUtc>2018-01-29T17:29:09.687347Z</CreationTimeUtc>
    <LastWriteTime>2017-08-08T14:09:20.3607967-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-08-08T19:09:20.3607967Z</LastWriteTimeUtc>
    <LastAccessTime>2018-01-29T11:29:09.687347-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-01-29T17:29:09.687347Z</LastAccessTimeUtc>
    <Text># Package Created 2016-07-14
# Packaged by Jason Mao
# Updated by Grayson Gratop on 2016-08-31
# Updated by Grayson Gratop on 2017-05-08

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;
use Win32::TieRegistry;
use Getopt::Long;
print "Started PERL script...\n";

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'dlang.2.074',
        package_revision =&gt; '20170508T1526',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;
print "Loaded InstallMonkey...\n";
my $srcfiles = get_pkg_sourcefiles();
my $vs17appd = "\\\\minerfiles.mst.edu\\dfs\\software\\appdeploy\\visual_studio.2017";
my $vs17loc = "C:\\VS2017";
my $vsstart = "$ENV{'PROGRAMDATA'}\\Microsoft\\Windows\\Start Menu\\Programs";

GetOptions(
    'uninstall' =&gt; sub { exit(! uninstall()); },
);

sub pre_install {
    output("OK\nAdding components to Visual Studio 2017: ");
	#This will install the Win10 SDK and the Visual Studio 2015 C++ Toolchain.
	if(!run_command("\"$vs17appd\\vs_professional.exe\" --installPath \"$vs17loc\" --includeRecommended --add Microsoft.VisualStudio.Component.VC.140 --add Microsoft.VisualStudio.Component.Windows10SDK.15063 --quiet --wait", 'IgnoreExitCodes' =&gt; [3010])) {
		output("FAILED: $!\n");
		return 0;
	}
	output("OK\n");
	run_command("DEL /Q \"$vsstart\\Visual Studio Installer.lnk\"");
    return 1;
}
sub install {

  my $command = "$srcfiles\\dmd-2.074.0.exe /S";

  output("Installing dlang with command: $command");
  run_command($command, 'IgnoreReturnCode'=&gt;1);

  # The run_command spawns a separate process and returns immediately so this loop waits until setup.exe finishes running.
  my $index = 0;
  my $success = 0;
  while($index &lt; 3600) # 3600*5sec = 5 hours
  {
    $_ = `tasklist`;
    if(/dmd-2\.071\.1\.exe/gi){
        $index++;
        sleep(5);
    }
    else{
        output("\n  Setup finished!\n");
        $success = 1;
        last;
    }
  }

  if (!$success) { 
    output("Timed out...\n");
    return 0;
  }

  #install LDC as an alternate compiler (and DUB too)

  output("Extracting LDC to C:\\D\\ldc and setting path...\n");

  $success &amp;&amp;= run_command("\"C:\\Program Files\\7-Zip\\7z\" x $srcfiles\\ldc.7z -oC:\\D");
  $success &amp;&amp;= run_command("setx /M PATH \"\%PATH\%;C:\\D\\ldc\\bin\"");

  if (!$success) { 
    output("Something went wrong when installing LDC...\n");
    return 0;
  }

  output("Done!\n");

  return 1;
}

do_install(
    no_os_version_check =&gt; 1,
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
	preinstall_sub =&gt; \&amp;pre_install,
    install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\dlang.2_078_1\prod\update.pl</FullName>
    <Length>2739</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-08-15T11:39:17.6818389-05:00</CreationTime>
    <CreationTimeUtc>2017-08-15T16:39:17.6818389Z</CreationTimeUtc>
    <LastWriteTime>2018-01-30T14:34:27.4960241-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-30T20:34:27.4960241Z</LastWriteTimeUtc>
    <LastAccessTime>2017-08-15T11:39:17.6818389-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-08-15T16:39:17.6818389Z</LastAccessTimeUtc>
    <Text># Package Created 2016-07-14
# Packaged by Jason Mao
# Updated by Grayson Gratop on 2016-08-31
# Updated by Grayson Gratop on 2017-05-08
# Updated by Grayson Gratop on 2018-01-29

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;
use Win32::TieRegistry;
use Getopt::Long;
print "Started PERL script...\n";

our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'dlang.2.078_1',
    package_revision =&gt; '20180129T1124',
  );
}

# Add InstallMonkey Library to the path
use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);

use InstallMonkey::Shared;
print "Loaded InstallMonkey...\n";
my $srcfiles = get_pkg_sourcefiles();
my $vs17appd = "\\\\minerfiles.mst.edu\\dfs\\software\\itwindist\\appdeploy\\visual_studio.2017";
my $vs17loc  = "C:\\VS2017";
my $vsstart  = "$ENV{'PROGRAMDATA'}\\Microsoft\\Windows\\Start Menu\\Programs";

GetOptions(
  'uninstall' =&gt; sub { exit(! uninstall()); },
);

sub install {
  my $command = "$srcfiles\\dmd-2.078.1.exe /S";

  output("Installing dlang with command: $command");
  run_command($command, 'IgnoreReturnCode'=&gt;1);

  # The run_command spawns a separate process and returns immediately so this loop waits until setup.exe finishes running.
  my $index   = 0;
  my $success = 0;
  while($index &lt; 3600) { # 3600*5sec = 5 hours
    $_ = `tasklist`;
    if (/dmd-2\.071\.1\.exe/gi) {
      $index++;
      sleep(5);
    }
    else{
      output("\n  Setup finished!\n");
      $success = 1;
      last;
    }
  }

  if (!$success) { 
    output("Timed out...\n");
    return 0;
  }

  #install LDC as an alternate compiler (and DUB too)

  output("Extracting LDC to C:\\D\\ldc and setting path...\n");

  $success &amp;&amp;= run_command("\"C:\\Program Files\\7-Zip\\7z\" x $srcfiles\\ldc.7z -oC:\\D");
  $success &amp;&amp;= run_command("setx /M PATH \"\%PATH\%;C:\\D\\ldc\\bin;C:\\D\\dmd2\\windows\\bin\"");

  if (!$success) { 
    output("Something went wrong when installing LDC...\n");
    return 0;
  }

  output("Done!\n");

  return 1;
}

do_install(
  no_os_version_check =&gt; 1,
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  #preinstall_sub =&gt; \&amp;pre_install,
  install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\dlang.2_078_3\prod\update.pl</FullName>
    <Length>2782</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-02-28T10:46:23.1438774-06:00</CreationTime>
    <CreationTimeUtc>2018-02-28T16:46:23.1438774Z</CreationTimeUtc>
    <LastWriteTime>2018-02-28T10:48:30.8249255-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-02-28T16:48:30.8249255Z</LastWriteTimeUtc>
    <LastAccessTime>2018-02-28T10:46:23.1438774-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-02-28T16:46:23.1438774Z</LastAccessTimeUtc>
    <Text># Package Created 2016-07-14
# Packaged by Jason Mao
# Updated by Grayson Gratop on 2016-08-31
# Updated by Grayson Gratop on 2017-05-08
# Updated by Grayson Gratop on 2018-01-29
# Updated by Grayson Gratop on 2018-02-28

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;
use Win32::TieRegistry;
use Getopt::Long;
print "Started PERL script...\n";

our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'dlang.2.078_3',
    package_revision =&gt; '20180228T1047',
  );
}

# Add InstallMonkey Library to the path
use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);

use InstallMonkey::Shared;
print "Loaded InstallMonkey...\n";
my $srcfiles = get_pkg_sourcefiles();
my $vs17appd = "\\\\minerfiles.mst.edu\\dfs\\software\\itwindist\\appdeploy\\visual_studio.2017";
my $vs17loc  = "C:\\VS2017";
my $vsstart  = "$ENV{'PROGRAMDATA'}\\Microsoft\\Windows\\Start Menu\\Programs";

GetOptions(
  'uninstall' =&gt; sub { exit(! uninstall()); },
);

sub install {
  my $command = "$srcfiles\\dmd-2.078.3.exe /S";

  output("Installing dlang with command: $command");
  run_command($command, 'IgnoreReturnCode'=&gt;1);

  # The run_command spawns a separate process and returns immediately so this loop waits until setup.exe finishes running.
  my $index   = 0;
  my $success = 0;
  while($index &lt; 3600) { # 3600*5sec = 5 hours
    $_ = `tasklist`;
    if (/dmd-2\.078\.3\.exe/gi) {
      $index++;
      sleep(5);
    }
    else{
      output("\n  Setup finished!\n");
      $success = 1;
      last;
    }
  }

  if (!$success) { 
    output("Timed out...\n");
    return 0;
  }

  #install LDC as an alternate compiler (and DUB too)

  output("Extracting LDC to C:\\D\\ldc and setting path...\n");

  $success &amp;&amp;= run_command("\"C:\\Program Files\\7-Zip\\7z\" x $srcfiles\\ldc.7z -oC:\\D");
  $success &amp;&amp;= run_command("setx /M PATH \"\%PATH\%;C:\\D\\ldc\\bin;C:\\D\\dmd2\\windows\\bin\"");

  if (!$success) { 
    output("Something went wrong when installing LDC...\n");
    return 0;
  }

  output("Done!\n");

  return 1;
}

do_install(
  no_os_version_check =&gt; 1,
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  #preinstall_sub =&gt; \&amp;pre_install,
  install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\dlang.2_079_1\prod\update.pl</FullName>
    <Length>2631</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-22T15:20:58.6705736-05:00</CreationTime>
    <CreationTimeUtc>2018-05-22T20:20:58.6705736Z</CreationTimeUtc>
    <LastWriteTime>2018-05-23T08:23:46.947589-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-23T13:23:46.947589Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-22T15:20:58.6705736-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-22T20:20:58.6705736Z</LastAccessTimeUtc>
    <Text># Package Created 2016-07-14
# Packaged by Jason Mao
# Updated by Grayson Gratop on 2016-08-31
# Updated by Grayson Gratop on 2017-05-08
# Updated by Grayson Gratop on 2018-01-29
# Updated by Grayson Gratop on 2018-02-28
# Updated by Cameron Loren on 2018-05-22

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;
use Win32::TieRegistry;
use Getopt::Long;
print "Started PERL script...\n";

our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'dlang.2.079_1',
    package_revision =&gt; '20180522T1521',
  );
}

# Add InstallMonkey Library to the path
use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);

use InstallMonkey::Shared;
print "Loaded InstallMonkey...\n";
my $srcfiles = get_pkg_sourcefiles();

GetOptions(
  'uninstall' =&gt; sub { exit(! uninstall()); },
);

sub install {
  my $command = "$srcfiles\\dmd-2.079.1.exe /S";

  output("Installing dlang with command: $command");
  run_command($command, 'IgnoreReturnCode'=&gt;1);

  # The run_command spawns a separate process and returns immediately so this loop waits until setup.exe finishes running.
  my $index   = 0;
  my $success = 0;
  while($index &lt; 3600) { # 3600*5sec = 5 hours
    $_ = `tasklist`;
    if (/dmd-2\.078\.3\.exe/gi) {
      $index++;
      sleep(5);
    }
    else{
      output("\n  Setup finished!\n");
      $success = 1;
      last;
    }
  }

  if (!$success) {
    output("Timed out...\n");
    return 0;
  }

  #install LDC as an alternate compiler (and DUB too)

  output("Extracting LDC to C:\\D\\ldc and setting path...\n");

  $success &amp;&amp;= run_command("\"C:\\Program Files\\7-Zip\\7z\" x $srcfiles\\ldc.7z -oC:\\D");
  $success &amp;&amp;= run_command("setx /M PATH \"\%PATH\%;C:\\D\\ldc\\bin;C:\\D\\dmd2\\windows\\bin\"");

  if (!$success) {
    output("Something went wrong when installing LDC...\n");
    return 0;
  }

  output("Done!\n");

  return 1;
}

do_install(
  no_os_version_check =&gt; 1,
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  #preinstall_sub =&gt; \&amp;pre_install,
  install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\dotnet.2_0_sp1\prod\update.pl</FullName>
    <Length>1045</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-07-13T12:49:51.9705047-05:00</CreationTime>
    <CreationTimeUtc>2017-07-13T17:49:51.9705047Z</CreationTimeUtc>
    <LastWriteTime>2017-07-13T13:56:54.9921396-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-07-13T18:56:54.9921396Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-13T13:56:46.2106157-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-13T18:56:46.2106157Z</LastAccessTimeUtc>
    <Text># .Net 2.0 sp 1
# Package Created July, 2017
# Packaged by Alex Schrimpf
# Last Updated 07/13/2017 by Alex Schrimpf

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: .
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'dotnet.2_0_sp1',
        package_revision =&gt; '20170713T1017'
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;

do_install( 
    msi_name =&gt; "NETCFSetupv2.msi",
    quiet =&gt; "/qn",
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update-software2.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\eagle.7_7_0\prod\update-software2.pl</FullName>
    <Length>2585</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-11-21T13:26:05.6836232-06:00</CreationTime>
    <CreationTimeUtc>2016-11-21T19:26:05.6836232Z</CreationTimeUtc>
    <LastWriteTime>2016-10-13T16:37:38.4050581-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-10-13T21:37:38.4050581Z</LastWriteTimeUtc>
    <LastAccessTime>2016-11-21T13:26:05.6836232-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-11-21T19:26:05.6836232Z</LastAccessTimeUtc>
    <Text># Eagle 6.5.0
# Package Created August 2012
# Packaged by Jason Iverson
# Last Updated 2016-07-25 by Christopher Schaaf

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS = 
    (
        package_id =&gt; 'eagle.7_6_0',
        package_revision =&gt; '20160725T1020',
    );
}


use lib
(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);


use InstallMonkey::Shared;

sub install
{
    my $sourcefiles = get_pkg_sourcefiles();
    my $start_menu = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\EAGLE Layout Editor 7.6.0';
    my $regfile = "${sourcefiles}\\eagle.reg";

    if(!run_command("XCOPY /Y /E /I \"${sourcefiles}\\program\" \"%PROGRAMFILES(x86)%\\\""))
    {
        output("\n");
        output("Failed to copy program files.  Please check the logs.");
        output("\n");

        return 0;
    }

    run_command("MKDIR \"${start_menu}\"");

    if(!run_command("XCOPY /Y /E /I \"${sourcefiles}\\EAGLE Layout Editor 7.6.0\" \"${start_menu}\""))
    {
        output("\n");
        output("Failed to copy shortcuts.  Please check the logs.");
        output("\n");

        return 0;
    }

    if( !run_command( "icacls \"C:\\Program Files (x86)\\EAGLE-7.6.0\\bin\\eagle.key\" /grant Users:M" ) ||
        !run_command( "icacls \"$start_menu\" /grant Users:(OI)(CI)M" ) )
    {
        output("Could not grant permissions to license file!\n");
        return 0;
    }
    
    if(!run_command("regedit.exe /s $regfile"))
    {
        output("\n");
        output("Failed to import \"${regfile}\".  Please check the logs.");
        output("\n");

        return 0;
    }

    run_command("xcopy /y \"${sourcefiles}\\autoit\\eagle-software2.exe\" \"C:\\Program Files (x86)\\EAGLE-7.6.0\\bin\\\"");
    run_command("xcopy /y \"${sourcefiles}\\EAGLE_LICENSE\\6C0681A7B3.key\" \"C:\\Program Files (x86)\\EAGLE-7.6.0\\bin\\\"");

    return 1;
}


do_install
(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [ 'clc', 'desktop', 'traveling', 'virtual-clc', 
                        'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
);


IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\eagle.7_7_0\prod\update.pl</FullName>
    <Length>3109</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-11-21T13:26:05.714824-06:00</CreationTime>
    <CreationTimeUtc>2016-11-21T19:26:05.714824Z</CreationTimeUtc>
    <LastWriteTime>2016-11-21T14:28:08.9374888-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-11-21T20:28:08.9374888Z</LastWriteTimeUtc>
    <LastAccessTime>2016-11-21T13:26:05.714824-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-11-21T19:26:05.714824Z</LastAccessTimeUtc>
    <Text># Eagle 6.5.0
# Package Created August 2012
# Packaged by Jason Iverson
# Last Updated 2016-07-25 by Christopher Schaaf

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS = 
    (
        package_id =&gt; 'eagle.7_7_0',
        package_revision =&gt; '20161121T1435',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;

sub install
{
    my $sourcefiles = get_pkg_sourcefiles();
    my $start_menu = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\EAGLE Layout Editor 7.7.0';
    my $regfile = "${sourcefiles}\\eagle.reg";

    if(!run_command("XCOPY /Y /E /I \"${sourcefiles}\\program\" \"%SYSTEMDRIVE%\\\"")) {
        output("\n");
        output("Failed to copy program files.  Please check the logs.");
        output("\n");
        return 0;
    }

    run_command("MKDIR \"${start_menu}\"");

    if(!run_command("XCOPY /Y /E /I \"${sourcefiles}\\EAGLE Layout Editor 7.7.0\" \"${start_menu}\"")) {
        output("\n");
        output("Failed to copy shortcuts.  Please check the logs.");
        output("\n");
        return 0;
    }
	#eagle.key file not present in 7.7, copied from 7.6.
    if( !run_command( "icacls \"C:\\EAGLE-7.7.0\\bin\\eagle.key\" /grant Users:M" ) ||
        !run_command( "icacls \"$start_menu\" /grant Users:(OI)(CI)M" ) ) {
        output("Could not grant permissions to license file!\n");
        return 0;
    }
    
    if(!run_command("regedit.exe /s $regfile")) {
        output("\n");
        output("Failed to import \"${regfile}\".  Please check the logs.");
        output("\n");
        return 0;
    }   
	if (!run_command("REG ADD HKCU\\Software\\Sysinternals\\VolumeID /v EulaAccepted /t REG_DWORD /d 1 /f")) {
        output("\n");
        output("Failed to accept EULA for \'SysInternals - VolumeID\'.  ");
        output("Please check the logs.");
        output("\n");
        return 0;
    }

    if (!run_command("\"${sourcefiles}\\VolumeID.exe\" %SystemDrive% 580A-5506")) {
        output("\n");
        output("Failed to set Volume ID \'1234-1234\' for %SystemDrive%.  ");
        output("Please check the logs.");
        output("\n");
        return 0;
    }

    if(!run_command("DEL /F \"${sourcefiles}\\VolumeID.exe\"")) {
        output("\n");
        output("Failed to delete \'VolumeID.exe\'.  Please check the logs.");
        output("\n");
    }

    return 1;
}


do_install (
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [ 'clc', 'desktop', 'traveling', 'virtual-clc', 
                        'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
);


IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\eagle.8_2_2\prod\update.pl</FullName>
    <Length>1745</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-01T16:15:54.7756524-05:00</CreationTime>
    <CreationTimeUtc>2017-06-01T21:15:54.7756524Z</CreationTimeUtc>
    <LastWriteTime>2017-07-31T09:05:35.9977026-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-07-31T14:05:35.9977026Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-01T16:15:54.7756524-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-01T21:15:54.7756524Z</LastAccessTimeUtc>
    <Text># Eagle 8.2.1
# Package Created June 2017
# Packaged by cts28d

#This has changed significantly since v7. Autodesk purchased the product and did a pretty
#thourough rewrite of the installer, so no more AutoIT needed. Licensing is way different though,
#no more license server for campus, just an autodesk signin. Also will potentially update
#pretty frequently. This may need to be handled better in the future. See win7\appdist\notepadapp.x for ideas
#Updates avaliable here: https://s3.amazonaws.com/eagle-updates/downloads/latest.html


=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS = 
    (
        package_id =&gt; 'eagle.8_2_1',
        package_revision =&gt; '20170607T1300',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;

sub install
{
    my $src = get_pkg_sourcefiles();

    if(!run_command("\"$src\\Autodesk_EAGLE_8.2.2_English_Win_64bit.exe\" /VERYSILENT /NORESTART")) {
        output("\n");
        output("Failed to install EAGLE.");
        output("\n");
    }

    return 1;
}


do_install (
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [ 'clc', 'desktop', 'traveling', 'virtual-clc', 
                        'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
);


IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\eagle.8_4\prod\update.pl</FullName>
    <Length>1284</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-14T13:24:35.8657564-06:00</CreationTime>
    <CreationTimeUtc>2017-11-14T19:24:35.8657564Z</CreationTimeUtc>
    <LastWriteTime>2017-11-14T13:09:44.0451854-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-11-14T19:09:44.0451854Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-14T13:24:35.8657564-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-14T19:24:35.8657564Z</LastAccessTimeUtc>
    <Text># Package created 11/13/2017
# Package created by Sergey Gruzdev
# Last Updated 11/13/2017 by Sergey Gruzdev

=pod

Begin-Doc
Modified: $Date$
Name: $Name$
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'eagle.8_4',
        package_revision =&gt; '20171311T1635',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $src = get_pkg_sourcefiles();

sub install
{
  if(!run_command("$src\\Autodesk_EAGLE_8.4.1_English_Win_64Bit.exe /VERYSILENT /NORESTART"))
  {
    print "FATAL ERROR: installation failed!\n";
	return 0;
  }
  print "EAGLE 8.4.1 install complete!\n";
  return 1;
}

do_install
(
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x86, OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  install_sub =&gt;\&amp;install,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\eagle.9_0_0\prod\update.pl</FullName>
    <Length>1944</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-23T08:55:03.0772954-05:00</CreationTime>
    <CreationTimeUtc>2018-05-23T13:55:03.0772954Z</CreationTimeUtc>
    <LastWriteTime>2018-05-30T08:39:45.3677273-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-30T13:39:45.3677273Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-23T08:55:03.0929426-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-23T13:55:03.0929426Z</LastAccessTimeUtc>
    <Text># EAGLE Layout Editor 9.0.0
# Package Created May 23th, 2018
# Packaged by Kade Wessels
# Last updated by Kade Wessels

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'eagle.9_0_0',
        package_revision =&gt; '20180523T0837',
    );
}

# Add InstallMonkey Library to the path
use lib (
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
my $applogs=get_applogs_dir();
my $programfiles = get_arch_programfiles(OSARCH_x64);

sub install{
	output("Installing EAGLE Layout Editor 9.0.0 (x64)\n");
    if(!run_command("$sourcefilesdir\\Autodesk_EAGLE_9.0.0_English_Win_64bit.exe /VERYSILENT /NORESTART"))
    {
        output("EAGLE Layout Editor 9.0.0 (x64) installation did not complete!\n");
        return 0;
    }
    else{
        output("EAGLE Layout Editor 9.0.0 (x64) installation was successful!\n");
    }
    return 1;
}

sub postinstall
{
    my $cwd = cwd();

    print("Copying License...\n");
    my $dest = get_arch_programfiles(OSARCH_x64).'\\Autodesk\\';
    run_command("copy \"$cwd\\LICPATH.LIC\" \"$dest\" /Y");
    run_command("setx ADSKFLEX_LICENSE_FILE \"C:\\Program Files\\Autodesk\\LICPATH.LIC\" \/m");
    return 1;
}

do_install(
    allowed_versions =&gt; [ OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                     'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
	  need_reboot =&gt; 0,
    install_sub =&gt; \&amp;install,
	postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\eclipse.cpp.ide.4_5_2\prod\update.pl</FullName>
    <Length>4096</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-07-12T15:57:01.8279597-05:00</CreationTime>
    <CreationTimeUtc>2016-07-12T20:57:01.8279597Z</CreationTimeUtc>
    <LastWriteTime>2016-08-02T09:58:22.8644527-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-08-02T14:58:22.8644527Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-12T15:57:01.8747606-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-12T20:57:01.8747606Z</LastAccessTimeUtc>
    <Text># Eclipse C/C++ IDE 4.5.2
# Package Created July 2016
# Packaged by Ronith (based on Charlie Hendricks' 2013 package)
# Last Updated 08/02/2016 By Benjamin Krueger

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'eclipse.cpp.ide.4_5_2',
        package_revision =&gt; '20160713T1022',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Archive::Extract;

my $sourcefilesdir = get_pkg_sourcefiles();

sub install 
{
  my $eclipse = "$sourcefilesdir\\install";
  my $zip = "C:\\Program Files\\7-zip";
  my $workdir = "C:\\Users\\Public\\Documents\\Cpp_Workspace";
  my $installdir = "C:\\eclipse.cpp\\";
  my $startmenu = get_allusers_start_menu()."\\programs";
  
  if(!run_command("\"$zip\\7z.exe\" x  -o\"$installdir\" \"$eclipse\\eclipse-cpp-mars-2-win32-x86_64.zip\""))
  {
    output("Eclipse did not unarchive! Please try again!\n");
    return 0;
  }

  if(!(-e $workdir))
  {
    if(!run_command("md $workdir"))
    {
      output("Making new directory failed!\n");
      return 0;
    }
  }

	output("Eclipse should be launched from C:\eclipse.cpp or create a shortcut manually\n");
}

sub postinstall
{
  my $mingwinst = "C:\\MinGW";
  my $msysinst = "C:\\MinGW\\msys\\1.0\\bin";
  my $path = $ENV{'path'};
  #make sure the MinGW path gets created
  if(!(-e $mingwinst))
  {
    if(!run_command("mkdir $mingwinst"))
    {
      output("Making new directory failed!\n");
      return 0;
    }
  }
  #copy all of the MinGW files so the downloader doesnt have to do its job
  if(!run_command("XCOPY \"$sourcefilesdir\\mingw\" \"$mingwinst\" /Q /Y /I /E"))
  {
    output("Copying MinGW to local machine failed!\n");
    return 0;
  }
  output("Files have been copied to the local drive!\n");
  #"install" mingw and all of its components
  if(!run_command("$sourcefilesdir\\mingw\\bin\\mingw-get.exe install gcc g++ mingw32-make msys-base"))
  {
    output("MinGW didn't seem to like whatever I was doing here...guess we will try again later.\n");
    return 0;
  }
  output("Made sure MinGW + Friends were installed!\n");
  #set environmental variables!!!
	#Have to have different strings for the directories...not sure why but regex looks at things differently.
  my $mingwdir = fixBackslash($mingwinst);
  my $msysdir = fixBackslash($msysinst);
  if($path !~ /$mingwdir/)
	{
    $ENV{"path"} = "$ENV{\"path\"};$mingwinst\\bin";
		output("Path environment variable has been edited to include MinGW directory\n");
	}
  if($path !~ /$msysdir/)
	{
		if(!run_command("setx Path \"%Path%;$msysinst\" -m"))
		{
			output("Failed to set Msys bin folder in path environment\n");
			return 0;
		}
		output("Path environment variable has been edited to include the msys directory\n");
	}
  #All I had to do was create a directory and shortcut...
  my $exename = 'C:\\eclipse.cpp\\eclipse\\eclipse.exe';
  mkdir(get_allusers_start_menu.'\\Programs\\Eclipse');
  my $smlnk = get_allusers_start_menu().'\\Programs\\Eclipse\\Eclipse.lnk';
    create_shortcut(
        'target' =&gt;$exename,
        'link' =&gt; $smlnk,
        'description' =&gt; 'Launches Eclipse',
    );
	return 1;
 }

sub fixBackslash()
{
	my $fixed = shift;
	# add escape characters to each \ (needed so regex in postinst will work)
	$fixed =~ s/\\/\\\\/g;
	return $fixed;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
	 postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\eclipse.cpp.ide.4_6_1\prod\update.pl</FullName>
    <Length>4093</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-12-13T13:45:29.9352539-06:00</CreationTime>
    <CreationTimeUtc>2016-12-13T19:45:29.9352539Z</CreationTimeUtc>
    <LastWriteTime>2016-12-13T13:48:59.3380808-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-12-13T19:48:59.3380808Z</LastWriteTimeUtc>
    <LastAccessTime>2016-12-13T13:45:29.9352539-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-12-13T19:45:29.9352539Z</LastAccessTimeUtc>
    <Text># Eclipse C/C++ IDE 4.6.1
# Package Created July 2016
# Packaged by Ronith (based on Charlie Hendricks' 2013 package)
# Last Updated 12/13/2016 By Chris Schaaf

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'eclipse.cpp.ide.4_6_1',
        package_revision =&gt; '20161213T1348',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Archive::Extract;

my $sourcefilesdir = get_pkg_sourcefiles();

sub install 
{
  my $eclipse = "$sourcefilesdir\\install";
  my $zip = "C:\\Program Files\\7-zip";
  my $workdir = "C:\\Users\\Public\\Documents\\Cpp_Workspace";
  my $installdir = "C:\\eclipse.cpp\\";
  my $startmenu = get_allusers_start_menu()."\\programs";
  
  if(!run_command("\"$zip\\7z.exe\" x  -o\"$installdir\" \"$eclipse\\eclipse-cpp-neon-1a-win32-x86_64.zip\""))
  {
    output("Eclipse did not unarchive! Please try again!\n");
    return 0;
  }

  if(!(-e $workdir))
  {
    if(!run_command("md $workdir"))
    {
      output("Making new directory failed!\n");
      return 0;
    }
  }

	output("Eclipse should be launched from C:\eclipse.cpp or create a shortcut manually\n");
}

sub postinstall
{
  my $mingwinst = "C:\\MinGW";
  my $msysinst = "C:\\MinGW\\msys\\1.0\\bin";
  my $path = $ENV{'path'};
  #make sure the MinGW path gets created
  if(!(-e $mingwinst))
  {
    if(!run_command("mkdir $mingwinst"))
    {
      output("Making new directory failed!\n");
      return 0;
    }
  }
  #copy all of the MinGW files so the downloader doesnt have to do its job
  if(!run_command("XCOPY \"$sourcefilesdir\\mingw\" \"$mingwinst\" /Q /Y /I /E"))
  {
    output("Copying MinGW to local machine failed!\n");
    return 0;
  }
  output("Files have been copied to the local drive!\n");
  #"install" mingw and all of its components
  if(!run_command("$sourcefilesdir\\mingw\\bin\\mingw-get.exe install gcc g++ mingw32-make msys-base"))
  {
    output("MinGW didn't seem to like whatever I was doing here...guess we will try again later.\n");
    return 0;
  }
  output("Made sure MinGW + Friends were installed!\n");
  #set environmental variables!!!
	#Have to have different strings for the directories...not sure why but regex looks at things differently.
  my $mingwdir = fixBackslash($mingwinst);
  my $msysdir = fixBackslash($msysinst);
  if($path !~ /$mingwdir/)
	{
    $ENV{"path"} = "$ENV{\"path\"};$mingwinst\\bin";
		output("Path environment variable has been edited to include MinGW directory\n");
	}
  if($path !~ /$msysdir/)
	{
		if(!run_command("setx Path \"%Path%;$msysinst\" -m"))
		{
			output("Failed to set Msys bin folder in path environment\n");
			return 0;
		}
		output("Path environment variable has been edited to include the msys directory\n");
	}
  #All I had to do was create a directory and shortcut...
  my $exename = 'C:\\eclipse.cpp\\eclipse\\eclipse.exe';
  mkdir(get_allusers_start_menu.'\\Programs\\Eclipse');
  my $smlnk = get_allusers_start_menu().'\\Programs\\Eclipse\\Eclipse.lnk';
    create_shortcut(
        'target' =&gt;$exename,
        'link' =&gt; $smlnk,
        'description' =&gt; 'Launches Eclipse',
    );
	return 1;
 }

sub fixBackslash()
{
	my $fixed = shift;
	# add escape characters to each \ (needed so regex in postinst will work)
	$fixed =~ s/\\/\\\\/g;
	return $fixed;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
	 postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\eclipse.jee.ide.4_6_1\prod\update.pl</FullName>
    <Length>3748</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-12-14T14:56:05.807546-06:00</CreationTime>
    <CreationTimeUtc>2016-12-14T20:56:05.807546Z</CreationTimeUtc>
    <LastWriteTime>2016-12-16T15:26:06.2371187-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-12-16T21:26:06.2371187Z</LastWriteTimeUtc>
    <LastAccessTime>2016-12-15T16:25:13.9914901-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-12-15T22:25:13.9914901Z</LastAccessTimeUtc>
    <Text># Eclipse IDE for Java EE Developers 4.6.1
# InstallMonkey Template
# Package Created August 2012
# Packaged by Sam Pilla (some code borrowed El Don)
# Updated December 2016 by Chris Schaaf

=begin
Begin-Doc
Modified:
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: Sam Pilla
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc
=cut

# Global InstallMonkey options that must be specified before you load the
#   module.
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'eclipse.ee.ide.4_6_1',

        # some unique id that's updated any time the package undergoes
        #  any sort of minor revision
        package_revision =&gt; '20161215T1625',

#         # if different from default location
#         output_log =&gt; 'path_to_output_log',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

GetOptions(
  'uninstall' =&gt; sub { exit(!uninstall()); },
);

# Be sure that any custom install subs (install_sub, preinstall_sub, or 
# postinstall_sub) return a success/failure value.
# If you don't do any error checking, at least return 1 so that the
# install will continue. The installer aborts (nicely) on failure.

my $src = get_pkg_sourcefiles();
my $cwd = cwd();
my $applogs=get_applogs_dir();

sub install 
{
	my ($eclipse, $workdir, $installdir);

	$zip = "$src\\7z\\x64\\7za.exe";
	$eclipse = "$src\\install\\eclipse-jee-neon-1a-win32-x86_64.zip";
	$workdir = "C:\\Users\\Public\\Documents\\Eclipsejava_Workspace";
	$installdir = "C:\\eclipse\\java";
  
	if(!(-e $installdir)) {
		if(!run_command("md $installdir")) {
		  output("Making new directory failed!\n");
		  return 0;
		}
	}
  
	if(!(-e $workdir)) {
		if(!run_command("md $workdir")) {
			  output("Making new directory failed!\n");
			  return 0;
		}
	}
	output("Unzipping archive...\n");
	if(!run_command("\"$zip\" x \"$eclipse\" -o\"$installdir\"")) {
		output("Eclipse IDE for Java EE Developers did not unarchive! Please try again!\n");
		return 0;
	}
	output("Eclipse IDE for Java EE Developers unarchive success!\n");

  output("Eclipse IDE for Java EE Developers install success!\n");
  
  return 1;
}
 
sub postinstall {
	my $startmenu = get_allusers_start_menu()."\\programs";
	if(!run_command("XCOPY /Y/E/F/I \"$src\\shortcut\" \"$startmenu\"")) {
		output("The start menu shortcut was not placed correctly! Please try installing again!\n");
		return 0;
	}
	output("Start menu shortcut has been created\n");
	return 1;
}

sub uninstall {
	output("Uninstalling Eclipse for Java EE... ");
	my $success = run_command("rmdir /q /S C:\\eclipse\\java");
	output($success ? "Success!\n" : "FAILED!!\n");

	if ($success) {
		delete_product_registry_key(get_package_name().".".get_version());
	}

	output("Removing shortcuts... ");
	my $shortcuts = run_command("rmdir /q /S \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Eclipse\"");
	output($shortcuts ? "Success!" : "FAILED!!");

	return $success;
}

do_install( 
    allowed_versions =&gt; [ OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_XP_32 ],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\eclipse.jee.ide.4_7_1\prod\update.pl</FullName>
    <Length>3770</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-16T09:46:27.0338017-06:00</CreationTime>
    <CreationTimeUtc>2017-11-16T15:46:27.0338017Z</CreationTimeUtc>
    <LastWriteTime>2017-11-16T10:09:06.696687-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-11-16T16:09:06.696687Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-16T09:46:27.0338017-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-16T15:46:27.0338017Z</LastAccessTimeUtc>
    <Text># Eclipse IDE for Java EE Developers 4.6.1
# InstallMonkey Template
# Package Created August 2012
# Packaged by Sam Pilla (some code borrowed El Don)
# Updated December 2017 by Benjamin Krueger

=begin
Begin-Doc
Modified:
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: Sam Pilla
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc
=cut

# Global InstallMonkey options that must be specified before you load the
#   module.
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'eclipse.ee.ide.4_7_1',

        # some unique id that's updated any time the package undergoes
        #  any sort of minor revision
        package_revision =&gt; '20171116T0951',

#         # if different from default location
#         output_log =&gt; 'path_to_output_log',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

GetOptions(
  'uninstall' =&gt; sub { exit(!uninstall()); },
);

# Be sure that any custom install subs (install_sub, preinstall_sub, or 
# postinstall_sub) return a success/failure value.
# If you don't do any error checking, at least return 1 so that the
# install will continue. The installer aborts (nicely) on failure.

my $src = get_pkg_sourcefiles();
my $cwd = cwd();
my $applogs=get_applogs_dir();

sub install 
{
	my ($eclipse, $workdir, $installdir);

	$zip = "$src\\7z\\x64\\7za.exe";
	$eclipse = "$src\\install\\eclipse-jee-oxygen-1a-win32-x86_64.zip";
	$workdir = "C:\\Users\\Public\\Documents\\Eclipsejava_Workspace";
	$installdir = "C:\\eclipse\\java";
  
	if(!(-e $installdir)) {
		if(!run_command("md $installdir")) {
		  output("Making new directory failed!\n");
		  return 0;
		}
	}
  
	if(!(-e $workdir)) {
		if(!run_command("md $workdir")) {
			  output("Making new directory failed!\n");
			  return 0;
		}
	}
	output("Unzipping archive...\n");
	if(!run_command("\"$zip\" x \"$eclipse\" -o\"$installdir\"")) {
		output("Eclipse IDE for Java EE Developers did not unarchive! Please try again!\n");
		return 0;
	}
	output("Eclipse IDE for Java EE Developers unarchive success!\n");

  output("Eclipse IDE for Java EE Developers install success!\n");
  
  return 1;
}
 
sub postinstall {
	my $startmenu = get_allusers_start_menu()."\\programs";
	if(!run_command("XCOPY /Y/E/F/I \"$src\\shortcut\" \"$startmenu\"")) {
		output("The start menu shortcut was not placed correctly! Please try installing again!\n");
		return 0;
	}
	output("Start menu shortcut has been created\n");
	return 1;
}

sub uninstall {
	output("Uninstalling Eclipse for Java EE... ");
	my $success = run_command("rmdir /q /S C:\\eclipse\\java");
	output($success ? "Success!\n" : "FAILED!!\n");

	if ($success) {
		delete_product_registry_key(get_package_name().".".get_version());
	}

	output("Removing shortcuts... ");
	my $shortcuts = run_command("rmdir /q /S \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Eclipse\"");
	output($shortcuts ? "Success!" : "FAILED!!");

	return $success;
}

do_install( 
    allowed_versions =&gt; [ OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_XP_32, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\ees.10_263\prod\update.pl</FullName>
    <Length>2434</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-20T11:48:39.7786317-05:00</CreationTime>
    <CreationTimeUtc>2017-06-20T16:48:39.7786317Z</CreationTimeUtc>
    <LastWriteTime>2017-06-20T11:44:32.872347-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-20T16:44:32.872347Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-20T11:48:39.7786317-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-20T16:48:39.7786317Z</LastAccessTimeUtc>
    <Text># EES v10.263
# Package created by Sergey Gruzdev
# Package created 6/20/2017
# Package last edited 6/20/2017 by Sergey Gruzdev

# Bruh this thing is a dinosaur

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'ees.10_263',
		package_revision =&gt; '20170620T1059',
	);
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

my $src = get_pkg_sourcefiles();
my $dest = "C:\\EES32";

GetOptions('uninstall' =&gt; sub{exit(uninstall())});

sub uninstall
{
  print "Uninstalling EES v10.263...\n";
  # The only time it is wise to run "Unwise.exe" :D
  if(!run_command("\"$dest\\Unwise.exe\" /s $dest\\INSTALL.LOG"))
  {
    print "Could not uninstall EES!\n";
	return 0;
  }
  # Delete the EES files and directory
  run_command("del \"$dest\" /f /s /q");
  run_command("rmdir \"$dest\" /q /s");
  print "Removing registry key...\n";
  delete_product_registry_key(get_package_name().".".get_version());
  print "Reg key deleted! Uninstallation complete!\n";
  return 1;
}

sub install
{
  # Easy peasy
  print "Installing EES v10.263...\n";
  if(!run_command("\"$src\\setup_ees_acad.exe\" /s"))
  {
    print "Error: fossil crumbled during installation :(\n";
	print "But for real, something went wrong\n";
	return 0;
  }
  
  print "EES installed successfully!\n";
  return 1;
}

sub postinstall
{
  # Copy EES.dft so it doesn't complain
  if(!run_command("copy /y \"$src\\EES.dft\" \"$dest\""))
  {
    print "Error: could not copy over EES.dtf, EES will not run without it!\n";
	print "Try again or manually copy EES.dft from \"$src\" to \"$dest\"\n";
	return 0;
  }
  print "Installation complete!\n";
  return 1;
}

do_install
(
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x86, OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\ees.10_268\prod\update.pl</FullName>
    <Length>2434</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-07-17T08:23:40.055542-05:00</CreationTime>
    <CreationTimeUtc>2017-07-17T13:23:40.055542Z</CreationTimeUtc>
    <LastWriteTime>2017-07-17T08:22:35.0270144-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-07-17T13:22:35.0270144Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-17T08:23:40.055542-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-17T13:23:40.055542Z</LastAccessTimeUtc>
    <Text># EES v10.268
# Package created by Sergey Gruzdev
# Package created 7/17/2017
# Package last edited 7/17/2017 by Sergey Gruzdev

# Bruh this thing is a dinosaur

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'ees.10_268',
		package_revision =&gt; '20170717T0822',
	);
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

my $src = get_pkg_sourcefiles();
my $dest = "C:\\EES32";

GetOptions('uninstall' =&gt; sub{exit(uninstall())});

sub uninstall
{
  print "Uninstalling EES v10.268...\n";
  # The only time it is wise to run "Unwise.exe" :D
  if(!run_command("\"$dest\\Unwise.exe\" /s $dest\\INSTALL.LOG"))
  {
    print "Could not uninstall EES!\n";
	return 0;
  }
  # Delete the EES files and directory
  run_command("del \"$dest\" /f /s /q");
  run_command("rmdir \"$dest\" /q /s");
  print "Removing registry key...\n";
  delete_product_registry_key(get_package_name().".".get_version());
  print "Reg key deleted! Uninstallation complete!\n";
  return 1;
}

sub install
{
  # Easy peasy
  print "Installing EES v10.268...\n";
  if(!run_command("\"$src\\setup_ees_acad.exe\" /s"))
  {
    print "Error: fossil crumbled during installation :(\n";
	print "But for real, something went wrong\n";
	return 0;
  }
  
  print "EES installed successfully!\n";
  return 1;
}

sub postinstall
{
  # Copy EES.dft so it doesn't complain
  if(!run_command("copy /y \"$src\\EES.dft\" \"$dest\""))
  {
    print "Error: could not copy over EES.dtf, EES will not run without it!\n";
	print "Try again or manually copy EES.dft from \"$src\" to \"$dest\"\n";
	return 0;
  }
  print "Installation complete!\n";
  return 1;
}

do_install
(
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x86, OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\emacs.25_1\prod\update.pl</FullName>
    <Length>2396</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-05-25T13:47:23.7501307-05:00</CreationTime>
    <CreationTimeUtc>2017-05-25T18:47:23.7501307Z</CreationTimeUtc>
    <LastWriteTime>2017-05-12T13:48:08.4343271-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-05-12T18:48:08.4343271Z</LastWriteTimeUtc>
    <LastAccessTime>2017-05-25T13:47:23.7501307-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-05-25T18:47:23.7501307Z</LastAccessTimeUtc>
    <Text>use File::Basename;

########################################################################
# BEGIN Configuration

$INSTALL_DIR = $ENV{'SystemDrive'}.'\\emacs-25.1';

# END Configuration
########################################################################

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'emacs.25_1',
        package_revision =&gt; '20170512T1340',
    );

}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

use Getopt::Long;
GetOptions(
    'register' =&gt; sub { IM_Exit(!(register_program())); },
);

sub install_emacs {
    my $success = 1;

    $success &amp;= move_files();
    $success &amp;= register_program();

    return $success;
}


do_install( 
    allowed_versions =&gt; [OSVER_WIN10_SP0, OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_XP_32 ],
    allowed_os_architectures =&gt; [ OSARCH_x64, OSARCH_x86 ],
    allowed_regs =&gt; [ 'clc', 'desktop', 'traveling',
                      'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    application_architecture =&gt; OSARCH_x86,
    install_sub =&gt; \&amp;install_emacs,
);

IM_Exit(EXIT_SUCCESS);

########################################################################

sub move_files {
    my $src = get_pkg_sourcefiles().'\\emacs-25.1';
    my $dest = dirname($INSTALL_DIR);

    mkdir_im($dest);

    my $cmd = "move \"${src}\" \"${dest}\\\"";
    return run_command($cmd,
                       'Description' =&gt; "Moving EMACS files to '${dest}'");
}

sub register_program {
    my $addpm = "${INSTALL_DIR}\\bin\\addpm.exe";
    my $addpm_short = get_short_path_name($addpm);
    my $cmd = "${addpm_short} \"${INSTALL_DIR}\"";
    return 0
	if (!run_command($cmd,
			 'Description' =&gt; 'Registering Emacs with Windows'));

    # Create the GNU Emacs start menu programs folder.
    my $gnu_emacs_sm = get_allusers_start_menu().'\\Programs\\GNU Emacs';
    return 0
	if (!mkdir_im($gnu_emacs_sm));
    
    # Create a shortcut for all users.
    return 0
	if (!create_shortcut(
		 'target' =&gt; "${INSTALL_DIR}\\bin\\runemacs.exe",
		 'link' =&gt; "${gnu_emacs_sm}\\Emacs.lnk",
		 'working' =&gt; $INSTALL_DIR,
		 'description' =&gt; 'GNU Emacs 24.5'
	    ));

    return 1;
}

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\emacs.25_3\prod\update.pl</FullName>
    <Length>2389</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-01T10:22:41.53843-05:00</CreationTime>
    <CreationTimeUtc>2018-05-01T15:22:41.53843Z</CreationTimeUtc>
    <LastWriteTime>2018-05-01T11:04:14.4595063-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-01T16:04:14.4595063Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-01T10:22:41.53843-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-01T15:22:41.53843Z</LastAccessTimeUtc>
    <Text>use File::Basename;

########################################################################
# BEGIN Configuration

$INSTALL_DIR = $ENV{'SystemDrive'}.'\\emacs-25.3';

# END Configuration
########################################################################

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'emacs.25_3',
        package_revision =&gt; '20180501T1023',
    );

}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

use Getopt::Long;
GetOptions(
    'register' =&gt; sub { IM_Exit(!(register_program())); },
);

sub install_emacs {
    my $success = 1;

    $success &amp;= move_files();
    $success &amp;= register_program();

    return $success;
}


do_install(
    allowed_versions =&gt; [OSVER_WIN10_SP0, OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_XP_32 ],
    allowed_os_architectures =&gt; [ OSARCH_x64, OSARCH_x86 ],
    allowed_regs =&gt; [ 'clc', 'desktop', 'traveling',
                      'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    application_architecture =&gt; OSARCH_x86,
    install_sub =&gt; \&amp;install_emacs,
);

IM_Exit(EXIT_SUCCESS);

########################################################################

sub move_files {
    my $src = get_pkg_sourcefiles().'\\emacs-25.3';
    my $dest = dirname($INSTALL_DIR);

    mkdir_im($dest);

    my $cmd = "move \"${src}\" \"${dest}\\\"";
    return run_command($cmd,
                       'Description' =&gt; "Moving EMACS files to '${dest}'");
}

sub register_program {
    my $addpm = "${INSTALL_DIR}\\bin\\addpm.exe";
    my $addpm_short = get_short_path_name($addpm);
    my $cmd = "${addpm_short} \"${INSTALL_DIR}\"";
    return 0
	if (!run_command($cmd,
			 'Description' =&gt; 'Registering Emacs with Windows'));

    # Create the GNU Emacs start menu programs folder.
    my $gnu_emacs_sm = get_allusers_start_menu().'\\Programs\\GNU Emacs';
    return 0
	if (!mkdir_im($gnu_emacs_sm));

    # Create a shortcut for all users.
    return 0
	if (!create_shortcut(
		 'target' =&gt; "${INSTALL_DIR}\\bin\\runemacs.exe",
		 'link' =&gt; "${gnu_emacs_sm}\\Emacs.lnk",
		 'working' =&gt; $INSTALL_DIR,
		 'description' =&gt; 'GNU Emacs 25.3'
	    ));

    return 1;
}
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\endnote.x8_2\prod\update.pl</FullName>
    <Length>1799</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-07-09T09:27:23.8932757-05:00</CreationTime>
    <CreationTimeUtc>2018-07-09T14:27:23.8932757Z</CreationTimeUtc>
    <LastWriteTime>2018-07-30T16:18:14.0598695-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-30T21:18:14.0598695Z</LastWriteTimeUtc>
    <LastAccessTime>2018-07-09T09:27:23.8932757-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-07-09T14:27:23.8932757Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Package Created August 2012
# Packaged by Sam Pilla (some code borrowed El Don)
# Updated 2018-7-09 by Robert Smith

=begin
Begin-Doc
Modified:
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy:
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc
=cut

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'endnote.x8_2',
        package_revision =&gt; '20180709T0931',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $CDrive = $ENV{'SYSTEMDRIVE'};

sub install
{

  output("\nInstalling EndNote X8.2: ");
  if(!install_msi(
        msi =&gt; "$srcfiles\\ENX8Inst.msi",
        logging =&gt; '/lxv* '.get_default_app_log(),
        ReturnCommandInfo =&gt; \%install_info,
		additional_msi_properties =&gt; 'USERCANAPPLYUPDATES=F',))
  {
    output("Failed!\n");
    return 0;
  }

  output("Success!\n");

  return 1;
}

sub postinstall
{
  output( "\nCopying license file: " );
  if( !run_command( "XCOPY /Y /S /I \"$srcfiles\\EndNote X8\" \"$CDrive\\Program Files (x86)\\EndNote X8\" " ) )
  {
    output( "ERROR\n" );
  }
  output( "done\n" );
}


do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\EndNoteX8\dev\update.pl</FullName>
    <Length>2015</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-16T14:22:26.2846744-06:00</CreationTime>
    <CreationTimeUtc>2017-11-16T20:22:26.2846744Z</CreationTimeUtc>
    <LastWriteTime>2018-04-06T09:34:35.7436253-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-04-06T14:34:35.7436253Z</LastWriteTimeUtc>
    <LastAccessTime>2017-12-01T16:23:09.6580755-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-12-01T22:23:09.6580755Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Package Created August 2012
# Packaged by Sam Pilla (some code borrowed El Don)
# Updated 2014-07-02 by Dillon Lustick

=begin
Begin-Doc
Modified:
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy:
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc
=cut

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'endnote.x8',
        package_revision =&gt; '20171201T1128',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();

sub install 
{
 
  output("\nInstalling EndNote X8: ");
  if(!install_msi(
        msi =&gt; "$srcfiles\\ENX8Inst.msi",
        logging =&gt; '/lxv* '.get_default_app_log(),
        ReturnCommandInfo =&gt; \%install_info,
		additional_msi_properties =&gt; 'USERCANAPPLYUPDATES=F',))
  {
    output("Failed!\n");
    return 0;
  }

  output("Success!\n");

  output("\nAdding ActiveSetup Registry Key: ");
  if(!create_activesetup_action
  (
      'Identifier' =&gt; get_package_id(),
      'ComponentID' =&gt; get_package_id(),
      'Description' =&gt; 'Reg mod for ignoring updates',
      'Version' =&gt; '1,0',
      'StubPath' =&gt; "regedit.exe /s C:\\SourceFiles\\endnote.x8\\endnote.reg",))

  {
      output("\nFailed to create ActiveSetup action - please check the log(s)\n");

      return 0;
  }
  output("Success\n");

  return 1;
}


do_install( 
    allowed_versions =&gt; [ OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_XP_32 ],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update-imflextest.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\envi.5_3\prod\update-imflextest.pl</FullName>
    <Length>1484</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-02-01T09:53:43.096847-06:00</CreationTime>
    <CreationTimeUtc>2017-02-01T15:53:43.096847Z</CreationTimeUtc>
    <LastWriteTime>2017-02-01T10:07:36.1943276-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-02-01T16:07:36.1943276Z</LastWriteTimeUtc>
    <LastAccessTime>2017-02-01T09:53:43.096847-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-02-01T15:53:43.096847Z</LastAccessTimeUtc>
    <Text># ENVI 5.3 SP1
# Package created 5 June 2015
# Package created by Chris Schaaf

=pod

Begin-Doc
Modified: $5 June 2015$
Name: ENVI 5.3 SP1
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Chris Schaaf$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN {
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'envi.5_3',
		package_revision =&gt; '20161128T1122',
	);
}


use lib (
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);
use InstallMonkey::FlexLM;

my $getapplogsdir = get_applogs_dir();
my $src = get_pkg_sourcefiles();


sub install {
	#Run extracted EXE, installer blocks running MSI directly. Standard InstallShield stuff.
	output("\Installing ENVI 5.3 SP1: ");
	if(!run_command("$src\\program\\setup64.exe /S /f1$src\\silent.iss")) {
		output("FAIL: $!\n");
		return 0;
	}
	output("OK\n");
	return 1;
}

sub postinstall {
	return set_flexlm_environment_variable('1708', 'envi');
}


do_install ( 
	allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
	allowed_os_architectures =&gt; [ OSARCH_x64 ],
	allowed_regs =&gt; [ 'clc', 'desktop', 'traveling', 'virtual-clc', 
					'virtual-desktop' ],
	exit_on_failure =&gt; 1,
	#preinstall_sub =&gt; \&amp;preinstall,
	install_sub =&gt; \&amp;install,
	postinstall_sub =&gt; \&amp;postinstall,
);


IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\envi.5_3\prod\update.pl</FullName>
    <Length>3125</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-02-01T09:53:43.096847-06:00</CreationTime>
    <CreationTimeUtc>2017-02-01T15:53:43.096847Z</CreationTimeUtc>
    <LastWriteTime>2017-02-06T11:30:52.4182431-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-02-06T17:30:52.4182431Z</LastWriteTimeUtc>
    <LastAccessTime>2017-02-02T15:47:08.0601938-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-02-02T21:47:08.0601938Z</LastAccessTimeUtc>
    <Text># ENVI 5.3 SP1
# Package created 5 June 2015
# Package created by Chris Schaaf

=pod

Begin-Doc
Modified: $5 June 2015$
Name: ENVI 5.3 SP1
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Chris Schaaf$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN {
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'envi.5_3',
		package_revision =&gt; '20161128T1122',
	);
}


use lib (
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);
use InstallMonkey::Shared;

use Win32::TieRegistry;

my $getapplogsdir = get_applogs_dir();
my $src = get_pkg_sourcefiles();


sub install {
	#Run extracted EXE, installer blocks running MSI directly. Standard InstallShield stuff.
	output("\Installing ENVI 5.3 SP1: ");
	if(!run_command("$src\\program\\setup64.exe /S /f1$src\\silent.iss")) {
		output("FAIL: $!\n");
		return 0;
	}
	output("OK\n");
	return 1;
}

sub postinstall {
	flexlm(); #Place FlexLM Environment Variable
	output("Removing IDL shortcuts...\n");	# Remove IDL Icons. We're not licensed for it but there's no way to exclude IDL from the install.
	my $IDLstartmenu = $ENV{'ALLUSERSPROFILE'}.'\Microsoft\Windows\Start Menu\Programs\IDL 8.5';
	my $ENVIstartmenu = $ENV{'ALLUSERSPROFILE'}.'\Microsoft\Windows\Start Menu\Programs\ENVI 5.3';
	#This first shortcut is under a folder with the  symbol, but cmd doesn't like that.
	my @IDLshortcuts = ("ENVI for ArcGIS\x{00AE}\\ENVI 5.3 + IDL 8.5 (32-bit).lnk", '64-bit\ENVI 5.3 + IDL 8.5 (64-bit).lnk',
		'Tools\ENVI Classic 5.3 + IDL 8.5 (32-bit).lnk', 'Tools\ENVI Classic 5.3 + IDL 8.5 (64-bit).lnk');
	if(!run_command("RD \"$IDLstartmenu\" /S /Q")){
		output("Could not remove IDL icons - please remove them manually.\n");
	}
	foreach my $shortcut (@IDLshortcuts) {
		if(!run_command("DEL /Q /F \"$ENVIstartmenu\\$shortcut\"")){
			output("Could not remove $shortcut - please remove manually.\n");
		}
	}
	return 1;
}

sub flexlm {
	my $port = '1708';
	my $product = 'envi';
    output("Adding $product License Variable...\n");
    my $lm_reg = checkReg('LM_LICENSE_FILE');

     if (!defined($lm_reg) || ($lm_reg !~ m/\b$port\@$product\.lic\.mst\.edu\b/i))
    {
        output("Adding $port\@$product.lic.mst.edu to LM_LICENSE_FILE\n");
		add_environment_variable('LM_LICENSE_FILE', "$port\@$product.lic.mst.edu");
    }
	else {
		output("License already configured.\n");
	}
	return 1;
}

sub checkReg {
	my $env_var = shift;
	return $Registry-&gt;{"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment\\\\".$env_var};
}


do_install ( 
	allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
	allowed_os_architectures =&gt; [ OSARCH_x64 ],
	allowed_regs =&gt; [ 'clc', 'desktop', 'traveling', 'virtual-clc', 
					'virtual-desktop' ],
	exit_on_failure =&gt; 1,
	#preinstall_sub =&gt; \&amp;preinstall,
	install_sub =&gt; \&amp;install,
	postinstall_sub =&gt; \&amp;postinstall,
);


IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>test.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\envi.5_3\prod.old\test.pl</FullName>
    <Length>902</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-11-28T16:30:06.1728546-06:00</CreationTime>
    <CreationTimeUtc>2016-11-28T22:30:06.1728546Z</CreationTimeUtc>
    <LastWriteTime>2016-11-28T16:00:44.0920742-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-11-28T22:00:44.0920742Z</LastWriteTimeUtc>
    <LastAccessTime>2016-11-28T16:30:06.1728546-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-11-28T22:30:06.1728546Z</LastAccessTimeUtc>
    <Text>#! perl

use warnings;
use strict;

use Win32::OLE qw(in);

sub matching_processes {
	my($pattern) = "notepad.exe";

	my $objWMI = Win32::OLE-&gt;GetObject('winmgmts://./root/cimv2');
	my $procs = $objWMI-&gt;InstancesOf('Win32_Process');

	my @hits;
	foreach my $p (in $procs) {
		return $p-&gt;Name and push @hits =&gt; [ $p-&gt;Name, $p-&gt;ProcessID ]
			if $p-&gt;Name =~ /$pattern/;
	}
	my $result = pop @hits;
	print "$result\n";
}

if(&amp;matching_processes=="notepad.exe"){
	print("found");
}
else{
	print("not found");
}


=pod
#original
sub matching_processes {
	my($pattern) = "IDL_ENVI53SP1win64.exe";

	my $objWMI = Win32::OLE-&gt;GetObject('winmgmts://./root/cimv2');
	my $procs = $objWMI-&gt;InstancesOf('Win32_Process');

	my @hits;
	foreach my $p (in $procs) {
		push @hits =&gt; [ $p-&gt;Name, $p-&gt;ProcessID ]
			if $p-&gt;Name =~ /$pattern/;
	}

	wantarray ? @hits : \@hits;
}</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\envi.5_3\prod.old\update.pl</FullName>
    <Length>1862</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-11-28T16:30:06.2040554-06:00</CreationTime>
    <CreationTimeUtc>2016-11-28T22:30:06.2040554Z</CreationTimeUtc>
    <LastWriteTime>2016-11-29T12:04:47.9303026-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-11-29T18:04:47.9303026Z</LastWriteTimeUtc>
    <LastAccessTime>2016-11-28T16:30:06.2040554-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-11-28T22:30:06.2040554Z</LastAccessTimeUtc>
    <Text># ENVI 5.3 SP1
# Package created 5 June 2015
# Package created by Chris Schaaf

=pod

Begin-Doc
Modified: $5 June 2015$
Name: ENVI 5.3 SP1
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Chris Schaaf$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN {
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'envi.5_3',
		package_revision =&gt; '20161128T1122',
	);
}


use lib (
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);
use InstallMonkey::Shared;

my $getapplogsdir = get_applogs_dir();
my $src = get_pkg_sourcefiles();


sub install {
	#Run extracted EXE, installer blocks running MSI directly. Standard InstallShield stuff.
	output("\Installing ENVI 5.3 SP1: ");
	if(!run_command("$src\\program\\setup64.exe /S /f1$src\\silent.iss")) {
		output("FAIL: $!\n");
		return 0;
	}
	output("OK\n");
	return 1;
}

sub postinstall {
	my $currentuser = $ENV{'public'}."\\desktop";
	my $path = "\"".$ENV{'PROGRAMFILES'}."\\Exelis\\License\"";
	my $log = "$getapplogsdir\\envi.5_1.txt";

	#Copy license file to program folder
	output("\nInstalling License Files: ");
	if(!run_command("copy /y $src\\license.dat $path\\license.dat")) {
		output("\n");
		output("Failed to copy license file.  Please check the logs.");
		output("\n");
		return 0;
	}
	return 1;
}


do_install ( 
	allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
	allowed_os_architectures =&gt; [ OSARCH_x64 ],
	allowed_regs =&gt; [ 'clc', 'desktop', 'traveling', 'virtual-clc', 
					'virtual-desktop' ],
	exit_on_failure =&gt; 1,
	#preinstall_sub =&gt; \&amp;preinstall,
	install_sub =&gt; \&amp;install,
	postinstall_sub =&gt; \&amp;postinstall,
);


IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update1.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\envi.5_3\prod.old\update1.pl</FullName>
    <Length>2106</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-11-28T16:30:06.2040554-06:00</CreationTime>
    <CreationTimeUtc>2016-11-28T22:30:06.2040554Z</CreationTimeUtc>
    <LastWriteTime>2016-11-28T16:01:05.4022206-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-11-28T22:01:05.4022206Z</LastWriteTimeUtc>
    <LastAccessTime>2016-11-28T16:30:06.2040554-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-11-28T22:30:06.2040554Z</LastAccessTimeUtc>
    <Text># ENVI 5.3 SP1
# Package created 5 June 2015
# Package created by Chris Schaaf

=pod

Begin-Doc
Modified: $5 June 2015$
Name: ENVI 5.3 SP1
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Chris Schaaf$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN {
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'envi.5_3',
		package_revision =&gt; '20161128T1122',
	);
}


use lib (
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);
use InstallMonkey::Shared;

my $getapplogsdir = get_applogs_dir();
my $src = get_pkg_sourcefiles();


sub install
{
	#Can't suppress initial message box, using AutoIT.
	output("\nStarting ENVI 5.3 SP1 Installer via AutoIT: ");
	if(!run_command("$src\\autoit\\envi.exe")) {
		output("FAIL: $!\n");
		return 0;
	}
	output("OK\nWaiting on installer: ");
	#wait for installer process to finish with timeout period
	sleep(600);
	output("OK\n");
	return 1;
}

sub postinstall {
	my $currentuser = $ENV{'public'}."\\desktop";
	my $path = "\"".$ENV{'PROGRAMFILES'}."\\Exelis\\License\"";
	my $log = "$getapplogsdir\\envi.5_1.txt";

	#######################################################################
	#Copy license file to program folder                                  #
	#######################################################################

	output("\nInstalling License Files: ");
	if(!run_command("copy /y $src\\license.dat $path\\license.dat")) {
		output("\n");
		output("Failed to copy license file.  Please check the logs.");
		output("\n");
		return 0;
	}
}


do_install
( 
	allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
	allowed_os_architectures =&gt; [ OSARCH_x64 ],
	allowed_regs =&gt; [ 'clc', 'desktop', 'traveling', 'virtual-clc', 
					'virtual-desktop' ],
	exit_on_failure =&gt; 1,
	#preinstall_sub =&gt; \&amp;preinstall,
	install_sub =&gt; \&amp;install,
	postinstall_sub =&gt; \&amp;postinstall,
);


IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update-imflextest.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\envi.5_4_1\prod\update-imflextest.pl</FullName>
    <Length>1484</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-15T13:26:16.4702486-06:00</CreationTime>
    <CreationTimeUtc>2017-11-15T19:26:16.4702486Z</CreationTimeUtc>
    <LastWriteTime>2017-02-01T10:07:36.1943276-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-02-01T16:07:36.1943276Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-15T13:26:16.4702486-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-15T19:26:16.4702486Z</LastAccessTimeUtc>
    <Text># ENVI 5.3 SP1
# Package created 5 June 2015
# Package created by Chris Schaaf

=pod

Begin-Doc
Modified: $5 June 2015$
Name: ENVI 5.3 SP1
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Chris Schaaf$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN {
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'envi.5_3',
		package_revision =&gt; '20161128T1122',
	);
}


use lib (
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);
use InstallMonkey::FlexLM;

my $getapplogsdir = get_applogs_dir();
my $src = get_pkg_sourcefiles();


sub install {
	#Run extracted EXE, installer blocks running MSI directly. Standard InstallShield stuff.
	output("\Installing ENVI 5.3 SP1: ");
	if(!run_command("$src\\program\\setup64.exe /S /f1$src\\silent.iss")) {
		output("FAIL: $!\n");
		return 0;
	}
	output("OK\n");
	return 1;
}

sub postinstall {
	return set_flexlm_environment_variable('1708', 'envi');
}


do_install ( 
	allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
	allowed_os_architectures =&gt; [ OSARCH_x64 ],
	allowed_regs =&gt; [ 'clc', 'desktop', 'traveling', 'virtual-clc', 
					'virtual-desktop' ],
	exit_on_failure =&gt; 1,
	#preinstall_sub =&gt; \&amp;preinstall,
	install_sub =&gt; \&amp;install,
	postinstall_sub =&gt; \&amp;postinstall,
);


IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\envi.5_4_1\prod\update.pl</FullName>
    <Length>4125</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-15T13:26:16.5327412-06:00</CreationTime>
    <CreationTimeUtc>2017-11-15T19:26:16.5327412Z</CreationTimeUtc>
    <LastWriteTime>2018-02-01T15:39:30.743432-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-02-01T21:39:30.743432Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-15T13:26:16.5327412-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-15T19:26:16.5327412Z</LastAccessTimeUtc>
    <Text># ENVI 5.4.1 SP1
# Package created 5 June 2016 for ENVI 5.3 by Chris Schaaf
# Packaged updated 15 November 2017 by Chris Schaaf

=pod

Begin-Doc
Modified: $5 June 2015$
Name: ENVI 5.4.1 SP1
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Chris Schaaf$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN {
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'envi.5_4_1',
		package_revision =&gt; '20171115T1530',
	);
}


use lib (
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);
use InstallMonkey::Shared;

use Win32::TieRegistry;

my $getapplogsdir = get_applogs_dir();
my $src = get_pkg_sourcefiles();


sub install {
	#Packaging Notes: Must first run with $executable /SAVEINF="$fullPathForCreatedINI\file.ini"
	#http://www.harrisgeospatial.com/Support/SelfHelpTools/HelpArticles/HelpArticles-Detail/TabId/2718/ArtMID/10220/ArticleID/15065/Install-and-License-ENVI-54-includes-IDL-86.aspx#Silent
	output("\Installing ENVI 5.4.1 SP1: ");
	if(!run_command("$src\\envi541-win.exe /LOADINF=\".\\envi_only.ini\" /SP /VERYSILENT /SUPPRESSMSGBOXES /NOCANCEL /NORESTART /FORCECLOSEAPPLICATIONS")) {
		output("FAIL: $!\n");
		return 0;
	}
	output("OK\n");
	return 1;
}

sub postinstall {
	flexlm(); #Place FlexLM Environment Variable
	
	my $licloc = "$ENV{'PROGRAMFILES'}\\Harris\\license";
	output("Placing License file: ");
	if(!run_command("copy \"$src\\o_licenseserverurl.txt\" \"$licloc\\o_licenseserverurl.txt\" /Y")) {
		output("FAIL: $!\n");
		output("PRODUCT NOT LICENSED!\nRun The Harris License Administrator to manually license to server: 1708\@envi.lic.mst.edu\n");
		return 0;
	}
	
	output("OK\nRemoving IDL shortcuts...\n");	# Remove IDL Icons. We're not licensed for it but there's no way to exclude IDL from the install
	my $ENVIstartmenu = $ENV{'ALLUSERSPROFILE'}.'\Microsoft\Windows\Start Menu\Programs\ENVI 5.4';
	#This first shortcut is under a folder with the  symbol, but cmd doesn't like that.
	#Check the actual Start Menu\Programs\ENVI folder - the Win10 start menu doesn't represent actual folder structure
	my @IDLshortcuts = ("ENVI for ArcGIS\x{00AE}\\ENVI 5.4 + IDL 8.6 (32-bit).lnk", '64-bit\ENVI 5.4 + IDL 8.6 (64-bit).lnk',
		'Tools\ENVI Classic 5.4 + IDL 8.6 (32-bit).lnk', 'Tools\ENVI Classic 5.4 + IDL 8.6 (64-bit).lnk', 'IDL 8.6\IDL 8.6 Help.lnk',
		'IDL 8.6\IDL 8.6.lnk', 'IDL 8.6\32-bit\IDL 8.6 (32-bit).lnk', 'IDL 8.6\Tools\IDL 8.6 Command Line.lnk', 'IDL 8.6\32-bit\IDL 8.6 Command Line (32-bit).lnk',
		'IDL 8.6\Tools\IDL 8.6 Virtual Machine.lnk', 'IDL 8.6\32-bit\IDL 8.6 Virtual Machine (32-bit).lnk', 'Tools\Harris License Administrator.lnk', 
		'IDL 8.6\Tools\Harris License Administrator.lnk');
	foreach my $shortcut (@IDLshortcuts) {
		if(!run_command("DEL /Q /F \"$ENVIstartmenu\\$shortcut\"")){
			output("Could not remove $shortcut - please remove manually.\n");
		}
	}
	return 1;
}

sub flexlm {
	my $port = '7070';
	my $product = 'envi';
    output("Adding $product License Variable...\n");
    my $lm_reg = checkReg('LM_LICENSE_FILE');

     if (!defined($lm_reg) || ($lm_reg !~ m/\b$port\@$product\.lic\.mst\.edu\b/i))
    {
        output("Adding $port\@$product.lic.mst.edu to LM_LICENSE_FILE\n");
		add_environment_variable('LM_LICENSE_FILE', "$port\@$product.lic.mst.edu");
    }
	else {
		output("License already configured.\n");
	}
	return 1;
}

sub checkReg {
	my $env_var = shift;
	return $Registry-&gt;{"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment\\\\".$env_var};
}


do_install ( 
	allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
	allowed_os_architectures =&gt; [ OSARCH_x64 ],
	allowed_regs =&gt; [ 'clc', 'desktop', 'traveling', 'virtual-clc', 
					'virtual-desktop' ],
	exit_on_failure =&gt; 1,
	need_reboot =&gt; 1,
	#preinstall_sub =&gt; \&amp;preinstall,
	install_sub =&gt; \&amp;install,
	postinstall_sub =&gt; \&amp;postinstall,
);


IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\epson_eit.4_11\prod\update.pl</FullName>
    <Length>1877</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-13T12:17:54.6568807-05:00</CreationTime>
    <CreationTimeUtc>2017-06-13T17:17:54.6568807Z</CreationTimeUtc>
    <LastWriteTime>2017-06-13T14:17:21.2483819-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-13T19:17:21.2483819Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-13T12:17:54.6568807-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-13T17:17:54.6568807Z</LastAccessTimeUtc>
    <Text># Epson Easy Interactive Tools
# Package Created June 14th, 2016
# Packaged by Daniel T. Holtzclaw

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'epson_eit.4_11',
        package_revision =&gt; '20160614T1129',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles= get_pkg_sourcefiles();

sub install
{
    my $log = "C:\\WINDOWS\\System32\\UMRInst\\AppLogs";
    my $command = "$srcfiles\\setup.exe /s /f2 \"$log\\epson_eit-setup.log\"";
    output("\nInstalling Epson Easy Interactive Tools -\n");
    output("\tCommand: $command\n");
    output("\tResult: ");
    if(!run_command($command))
    {
        output("Failed - $_\n");
        return 0;
    }
    output("Success\n");
}

sub postinstall 
{
    my $audesktop=$ENV{"public"}."\\desktop";
    run_command("copy /Y \"$srcfiles\\Epson Doc Cam.lnk\" \"$audesktop\\Epson Doc Cam.lnk\"") or output("Unable to copy desktop shortcut!\n$!\n");
    
    }
do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    # preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    # msi_name =&gt; 'installer.msi',
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\epson_eit.4_11\prod.old\update.pl</FullName>
    <Length>1649</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-06-14T11:25:32.7458197-05:00</CreationTime>
    <CreationTimeUtc>2016-06-14T16:25:32.7458197Z</CreationTimeUtc>
    <LastWriteTime>2016-06-14T11:56:25.7999765-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-06-14T16:56:25.7999765Z</LastWriteTimeUtc>
    <LastAccessTime>2016-06-14T11:25:32.7458197-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-06-14T16:25:32.7458197Z</LastAccessTimeUtc>
    <Text># Epson Easy Interactive Tools
# Package Created June 14th, 2016
# Packaged by Daniel T. Holtzclaw

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'epson_eit.4_11',
        package_revision =&gt; '20160614T1129',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles= get_pkg_sourcefiles();

sub install
{
    my $log = "C:\\WINDOWS\\System32\\UMRInst\\AppLogs";
    my $command = "$srcfiles\\setup.exe /s /f2 \"$log\\epson_eit-setup.log\"";
    output("\nInstalling Epson Easy Interactive Tools -\n");
    output("\tCommand: $command\n");
    output("\tResult: ");
    if(!run_command($command))
    {
        output("Failed - $_\n");
        return 0;
    }
    output("Success\n");
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    # preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    #postinstall_sub =&gt; \&amp;postinstall,
    # msi_name =&gt; 'installer.msi',
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\factsage.7_1\prod\update.pl</FullName>
    <Length>3200</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-16T09:28:34.3291906-05:00</CreationTime>
    <CreationTimeUtc>2017-06-16T14:28:34.3291906Z</CreationTimeUtc>
    <LastWriteTime>2017-06-20T09:12:02.4944914-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-20T14:12:02.4944914Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-16T09:28:34.3291906-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-16T14:28:34.3291906Z</LastAccessTimeUtc>
    <Text># FactSage 7.1
# Package Created March 2012
# Packaged by Charlie Hendricks
# Last Updated by Sergey Gruzdev
# 06/16/2017 9:30

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'FactSage.7_1',
        package_revision =&gt; '20170616T0930',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
my $allusersdesktop = get_allusers_desktop();
my $allusersstart = get_allusers_start_menu();
my $CDrive = $ENV{'SYSTEMDRIVE'};

sub preinstall
{
  #Move the .ini file containing the network location info to this directory
  #this has to be in the user's temp directory
  output( "Setting up network install: " );
  output(".$ENV{'temp'}.");
  if( !run_command("XCOPY \"$sourcefilesdir\\factsageServer.ini\" \"".$ENV{'temp'}."\" /Y /Q /I") )
  {
    output( "FAILED\n" );
    return 0;
  }
  output( "done\n" );

  if( -e "$CDrive\\Factsage" )
  {
    output( "Factsage previously installed, removing directory: " );

    if( !run_command( "cmd /c rmdir /S /Q $CDrive\\Factsage" ) )
    {
      output( "FAILED\n" );
      return 0;
    }
    output( "done\n" );
  }

  return 1;
}
sub install
{
  #Call the autoIT script
  output( "Automating install: " );
  if( !run_command( "$sourcefilesdir\\FactSageHelper.exe $sourcefilesdir\\CD-FactSage71\\Setup-FactSage71.exe" ) )
  {
    run_command( "$sourcefilesdir\\WinList_x64.exe" );
    output( "FAILED\n" );
    return 0;
  }
  output( "done\n" );

  return 1;
}

sub postinstall
{
  #Delete desktop icon
  output( "Cleaning up shortcuts: " );
  if( !run_command("del /Q \"$allusersdesktop\\FactSage 7.1.lnk\" " )
      || !run_command("del /Q \"$allusersstart\\Programs\\FactSage 7.1\\Uninstall FactSage.lnk\" ") )
  {
    output( "FAILED\n" );
    return 0;
  }
  output( "done\n" );

  output( "Updating install: " );
  #Copy over an already updated FactSage folder in order to reduce first time launch.
  if( !run_command( "XCOPY /Y /S /I \"$sourcefilesdir\\FactSage\" \"$CDrive\\FactSage\" " ) )
  {
    output( "ERROR\n" );
  }
  output( "done\n" );

  #Give users permissions on the installation folder
  output( "Granting users installation access: " );
  if( !run_command( "icacls \"$CDrive\\FactSage\" /T /C /grant Users:(OI)(CI)M" ) )
  {
    output( "FAILED\n" );
    return 0;
  }
  output( "done" );

  return 1;
}


do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
   preinstall_sub =&gt; \&amp;preinstall,
   install_sub =&gt; \&amp;install,
   postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\factsage.7_1(old)\prod\update.pl</FullName>
    <Length>3184</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-05-26T14:47:18.1256028-05:00</CreationTime>
    <CreationTimeUtc>2017-05-26T19:47:18.1256028Z</CreationTimeUtc>
    <LastWriteTime>2017-05-26T15:42:10.4927787-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-05-26T20:42:10.4927787Z</LastWriteTimeUtc>
    <LastAccessTime>2017-05-26T14:47:18.1256028-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-05-26T19:47:18.1256028Z</LastAccessTimeUtc>
    <Text># FactSage 7.1
# Package Created March 2012
# Packaged by Charlie Hendricks
# Last Updated by cts28d
# 05/26/2017 14:00

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'FactSage.7_1',
        package_revision =&gt; '20170526T1449',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
my $allusersdesktop = get_allusers_desktop();
my $allusersstart = get_allusers_start_menu();
my $CDrive = $ENV{'SYSTEMDRIVE'};

sub preinstall
{
  #Move the .ini file containing the network location info to this directory
  #this has to be in the user's temp directory
  output( "Setting up network install: " );
  output(".$ENV{'temp'}.");
  if( !run_command("XCOPY \"$sourcefilesdir\\factsageServer.ini\" \"".$ENV{'temp'}."\" /Y /Q /I") )
  {
    output( "FAILED\n" );
    return 0;
  }
  output( "done\n" );

  if( -e "$CDrive\\Factsage" )
  {
    output( "Factsage previously installed, removing directory: " );

    if( !run_command( "cmd /c rmdir /S /Q $CDrive\\Factsage" ) )
    {
      output( "FAILED\n" );
      return 0;
    }
    output( "done\n" );
  }

  return 1;
}
sub install
{
  #Call the autoIT script
  output( "Automating install: " );
  if( !run_command( "$sourcefilesdir\\FactSageHelper.exe $sourcefilesdir\\CD-FactSage71\\Setup-FactSage71.exe" ) )
  {
    run_command( "$sourcefilesdir\\WinList_x64.exe" );
    output( "FAILED\n" );
    return 0;
  }
  output( "done\n" );

  return 1;
}

sub postinstall
{
  #Delete desktop icon
  output( "Cleaning up shortcuts: " );
  if( !run_command("del /Q \"$allusersdesktop\\FactSage 7.1.lnk\" " )
      || !run_command("del /Q \"$allusersstart\\Programs\\FactSage 7.1\\Uninstall FactSage.lnk\" ") )
  {
    output( "FAILED\n" );
    return 0;
  }
  output( "done\n" );

  #output( "Updating install: " );
  ##Copy over an already updated FactSage folder in order to reduce first time launch.
  #if( !run_command( "XCOPY /Y /S /I \"$sourcefilesdir\\FactSage\" \"$CDrive\\FactSage\" " ) )
  #{
  #  output( "ERROR\n" );
  #}
  #output( "done\n" );

  #Give users permissions on the installation folder
  output( "Granting users installation access: " );
  if( !run_command( "icacls \"$CDrive\\FactSage\" /T /C /grant Users:(OI)(CI)M" ) )
  {
    output( "FAILED\n" );
    return 0;
  }
  output( "done" );

  return 1;
}


do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
   preinstall_sub =&gt; \&amp;preinstall,
   install_sub =&gt; \&amp;install,
   postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\factsage.7_1(old)\prod.old\update.pl</FullName>
    <Length>3196</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-05-26T14:44:13.740579-05:00</CreationTime>
    <CreationTimeUtc>2017-05-26T19:44:13.740579Z</CreationTimeUtc>
    <LastWriteTime>2016-01-21T11:50:13.5050606-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-01-21T17:50:13.5050606Z</LastWriteTimeUtc>
    <LastAccessTime>2017-05-26T14:44:13.740579-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-05-26T19:44:13.740579Z</LastAccessTimeUtc>
    <Text># FactSage 7.0
# Package Created March 2012
# Packaged by Charlie Hendricks
# Last Updated by Matthew Specker
# 10/26/2015 12:00 PM

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'FactSage.7_0',
        package_revision =&gt; '20151026T1501',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
my $allusersdesktop = get_allusers_desktop();
my $allusersstart = get_allusers_start_menu();
my $CDrive = $ENV{'SYSTEMDRIVE'};

sub preinstall
{
  #Move the .ini file containing the network location info to this directory
  #this has to be in the user's temp directory
  output( "Setting up network install: " );
  output(".$ENV{'temp'}.");
  if( !run_command("XCOPY \"$sourcefilesdir\\factsageServer.ini\" \"".$ENV{'temp'}."\" /Y /Q /I") )
  {
    output( "FAILED\n" );
    return 0;
  }
  output( "done\n" );

  if( -e "$CDrive\\Factsage" )
  {
    output( "Factsage previously installed, removing directory: " );

    if( !run_command( "cmd /c rmdir /S /Q $CDrive\\Factsage" ) )
    {
      output( "FAILED\n" );
      return 0;
    }
    output( "done\n" );
  }

  return 1;
}
sub install
{
  #Call the autoIT script
  output( "Automating install: " );
  if( !run_command( "$sourcefilesdir\\FactSageHelper.exe $sourcefilesdir\\CD-FactSage70\\Setup-FactSage70.exe" ) )
  {
    run_command( "$sourcefilesdir\\WinList_x64.exe" );
    output( "FAILED\n" );
    return 0;
  }
  output( "done\n" );

  return 1;
}

sub postinstall
{
  #Delete desktop icon
  output( "Cleaning up shortcuts: " );
  if( !run_command("del /Q \"$allusersdesktop\\FactSage 7.0.lnk\" " )
      || !run_command("del /Q \"$allusersstart\\Programs\\FactSage 7.0\\Uninstall FactSage.lnk\" ") )
  {
    output( "FAILED\n" );
    return 0;
  }
  output( "done\n" );

  #output( "Updating install: " );
  ##Copy over an already updated FactSage folder in order to reduce first time launch.
  #if( !run_command( "XCOPY /Y /S /I \"$sourcefilesdir\\FactSage\" \"$CDrive\\FactSage\" " ) )
  #{
  #  output( "ERROR\n" );
  #}
  #output( "done\n" );

  #Give users permissions on the installation folder
  output( "Granting users installation access: " );
  if( !run_command( "icacls \"$CDrive\\FactSage\" /T /C /grant Users:(OI)(CI)M" ) )
  {
    output( "FAILED\n" );
    return 0;
  }
  output( "done" );

  return 1;
}


do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
   preinstall_sub =&gt; \&amp;preinstall,
   install_sub =&gt; \&amp;install,
   postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\factsage.7_2\prod\update.pl</FullName>
    <Length>3320</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-23T08:29:21.1723736-05:00</CreationTime>
    <CreationTimeUtc>2018-05-23T13:29:21.1723736Z</CreationTimeUtc>
    <LastWriteTime>2018-06-14T12:43:47.2697412-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-14T17:43:47.2697412Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-23T08:29:21.1723736-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-23T13:29:21.1723736Z</LastAccessTimeUtc>
    <Text># FactSage 7.2
# Package Created June 2018
# Packaged by Robert Smith, based on Charlie's 7.1 package
# Last Updated by Robert Smith
# 06/14/2018 12:42

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'factsage.7_2',
        package_revision =&gt; '20180614T1242',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
my $allusersdesktop = get_allusers_desktop();
my $allusersstart = get_allusers_start_menu();
my $CDrive = $ENV{'SYSTEMDRIVE'};

sub preinstall
{
  #Move the .ini file containing the network location info to this directory
  #this has to be in the user's temp directory
  output( "Setting up network install: " );
  output(".$ENV{'temp'}.");
  if( !run_command("XCOPY \"$sourcefilesdir\\factsageServer.ini\" \"".$ENV{'temp'}."\" /Y /Q /I") )
  {
    output( "FAILED\n" );
    return 0;
  }
  output( "done\n" );

  if( -e "$CDrive\\FactSage" )
  {
    output( "FactSage previously installed, removing directory: " );

    if( !run_command( "cmd /c rmdir /S /Q $CDrive\\FactSage" ) )
    {
      output( "FAILED\n" );
      return 0;
    }
    output( "done\n" );
  }

  return 1;
}
sub install
{
  #Call the autoIT script
  output( "Automating install: " );
  if( !run_command( "$sourcefilesdir\\FactSageHelper.exe $sourcefilesdir\\CD-FactSage72\\Setup-FactSage72.exe" ) )
  {
    run_command( "$sourcefilesdir\\WinList_x64.exe" );
    output( "FAILED\n" );
    return 0;
  }
  output( "done\n" );

  return 1;
}

sub postinstall
{
  #Delete desktop icon
  output( "Cleaning up shortcuts: " );
  if( !run_command("del /Q \"$allusersdesktop\\FactSage 7.2.lnk\" " )
      || !run_command("del /Q \"$allusersstart\\Programs\\FactSage 7.2\\Uninstall FactSage.lnk\" ") )
  {
    output( "FAILED\n" );
    return 0;
  }
  output( "done\n" );

  #Remember to copy over C:\FactSage\ to \prod\data\FactSage\ after installing the Network Client
  output( "Updating install: " );
  #This copies over an already updated FactSage folder in order to reduce first time launch.
  if( !run_command( "XCOPY /Y /S /I \"$sourcefilesdir\\FactSage\" \"$CDrive\\FactSage\" " ) )
  {
    output( "ERROR\n" );
  }
  output( "done\n" );

  #Give users permissions on the installation folder
  output( "Granting users installation access: " );
  if( !run_command( "icacls \"$CDrive\\FactSage\" /T /C /grant Users:(OI)(CI)M" ) )
  {
    output( "FAILED\n" );
    return 0;
  }
  output( "done" );

  return 1;
}


do_install(
  allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
  allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
  exit_on_failure =&gt; 1,
  preinstall_sub =&gt; \&amp;preinstall,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\firefox.60_0\prod(don't use)\update.pl</FullName>
    <Length>16157</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-10T14:10:48.1796191-05:00</CreationTime>
    <CreationTimeUtc>2018-05-10T19:10:48.1796191Z</CreationTimeUtc>
    <LastWriteTime>2018-06-13T11:53:36.6418381-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-13T16:53:36.6418381Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-10T14:10:48.1796191-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-10T19:10:48.1796191Z</LastAccessTimeUtc>
    <Text># Package for Firefox 52.2.0 ESR
# Package Created June 22, 2017
# Packaged by Austin Wall
# Last Updated June 12, 2018 by Kade Wessels

# Update notes:
#   I've written this to be as easy to update in the future as
#   possible. Worst case, the extension needs to be updated. This
#   script should just need a few lines updated in it and the rest
#   shouldn't be too awful. Also, make sure you update the setup.exe.
#   There's extensive notes in the wiki page for firefox.x. This is
#   the ESR release of Firefox.

=pod
Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Comments:
    Known Issues:
    http://www.mozilla.org/en-US/firefox/24.2.0/releasenotes/

    Current Vulnerabilities:
    http://www.mozilla.org/security/known-vulnerabilities/firefox.html

Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc
=cut


# Browser Command-Line Options:
#   https://developer.mozilla.org/en-US/docs/Mozilla/Command_Line_Options
#

use strict;
use warnings;
use Win32::TieRegistry(Delimiter =&gt; "\\");
use File::Path;
use Getopt::Long;
use File::Basename;
use Archive::Extract;
use File::Copy;
use File::Path qw(make_path);

our %INSTALLMONKEY_OPTIONS;
BEGIN
{
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'firefox.60_0',
        package_revision =&gt; '20180612T0927',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im', 
    $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 
    'C:\temp',
);
use InstallMonkey::Shared;


my $sourcefilesdir   = get_pkg_sourcefiles();
my $programfiles     = get_arch_programfiles(OSARCH_x86);


# CUSTOM SETTINGS:
#   \ffsetup\core\defaults\pref\channel-prefs.js
#   \ffsetup\core\defaults\pref\local-settings.js
#   \ffsetup\core\defaults\pref\user.js
#   \ffsetup\core\browser\override.ini
#   \ffsetup\core\mst.mozilla.cfg

# To Update:
#   1. Download the FF installer (an exe), and extract the contents.
#   2. If needed, make customizations using CCK2 (firefox extension)
#   3. Choose autoconfig, copy files from zip into \ffsetup\core

# This Package:
#   Copies the SourceFiles
#   Invokes the installer.
#   Preinstalls extensions.

# Mozilla Maintenance (Service)
#   https://wiki.mozilla.org/Windows_Service_Silent_Update
#   Log Dir: C:\ProgramData\Mozilla\logs


########################################################################
# BEGIN Configuration

my $APP_ARCH = OSARCH_x64;

# The directory with the extracted contents of the downloaded exe.
my $install_source = build_path($sourcefilesdir,'ffsetup.60.0esr');
my $install_ini_file = build_path($sourcefilesdir,'mst_install.ini');

# This is the default, but the customization needs to know.
my $install_dir = build_path(get_arch_programfiles($APP_ARCH),
                             'Mozilla Firefox');
my $distribution_ext_dir = build_path($install_dir,'distribution','extensions');

###################
# UPDATE 2016-03-09
# Extensions are installed using CCK2 now,
# IGNORE BELOW
# UPDATE 2017-09-20
# Extensions are installed using this again,
# UNIGNORE BELOW
###################

# This method of installation isn't perfect, but it seems like the most
#   supportable strategy.
#  * Add-ons get installed in the user profile.
#  * Add-ons get updated (by the user).
#  * Add-ons ONLY get installed into new profiles.
my $distribution_extensions = {
    'uBlock0@raymondhill.net' =&gt; {
        em_id =&gt; 'uBlock0@raymondhill.net',
        xpi   =&gt; '\\\\minerfiles.mst.edu\dfs\software\loginscripts\firefox\uBlock0@raymondhill.net.xpi'
    },
};


########################################################################
# UNINSTALL DECLARATIONS

# Regular Expressions used to discern if something is related to 
#   Firefox (or the application install).
my $ffRegex     = qr/firefox\.([0-9]+)?x?/i;
my $ffNameRegex = qr/Mozilla Firefox|Nightly/;

# Array of locations where we can find old firefox keys or files (any found are deleted)
# These keys and directories are checked to see if they contain a
#   child that matches one of the regexes.
my $sw_key = 'HKEY_LOCAL_MACHINE\SOFTWARE';
my $sw32_key = 'HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node';
my @ffRegKeys = (
    ( map { $sw_key . $_ }
      '\Microsoft\Active Setup\Installed Components',
      '\UMR\Install\Product_List',
    ),
    ( map { $sw32_key . $_ }
      '\Microsoft\Active Setup\Installed Components',
    ),
);

my @ffFiles = (
    ( map { build_path(get_arch_programfiles($APP_ARCH),$_) }
      '\Mozilla Firefox',
      '\Mozilla Maintenance Service',
    ),
    ( map { build_path(get_allusers_scripts(),$_) }
      '\standard\firefox',
      '\standard\firefox15',
      '\standard\firefox.21x',
      '\standard\firefox.x',
      '\standard\firefox.24',
    ),
);
# END DECLARATIONS
########################################################################


# END Configuration
########################################################################

sub usage {
    print qq(
usage: $0 [--help] [--uninstall] [--[no-]-autoupdate]
          [--install-source &lt;path_to_install_media&gt;]
          [--system-default-browser]

--install-source
  Use an alternate directory as the install media.
  It can be relative to the &lt;data&gt; directory or an absolute path.

--system-default-browser
  Make Firefox the system default web browser.
  This should only be done after Firefox is already installed.

);
}

Getopt::Long::Configure(qw(pass_through));
GetOptions(
    'help'       =&gt; sub { usage(); exit(0); },

    'uninstall'  =&gt; sub { exit(! uninstall()) },

    'system-default-browser' =&gt; sub {
        exit( ! make_system_default_browser() );
    },

    'code=s' =&gt; sub {
        eval {
            exit( ! eval($_[1]) );
        };
        if ($@) {
            output($@);
            exit($@);
        }
    },
);

sub install {
    output("   Installing Firefox: ");

    # The install media is just the files extracted from the FF installer.
    # Installer Command-Line Options:
    #   https://wiki.mozilla.org/Installer:Command_Line_Arguments
    my @command = (
        'cmd','/c','start','/wait','""',
        cmd_quote(build_path($install_source,'FirefoxSetup60.0.2esr.exe')),
        '/INI='.cmd_quote($install_ini_file),
        );

    if(! run_command(join(' ',@command))) {
        output("FAILED\n");
        return 0;
    }
    output("OK\n");
    
    # Copy the default log file.
    sleep(5); # It doesn't get copied to the install dir right away.
    my $log_file = build_path($install_dir,'install.log');
    if ( -f $log_file ) {
        copy($log_file,get_default_app_log()) ||
            output("Error copying log file '${log_file}': $!\n", LOG_ONLY);
    } else {
        output("No install log found: '${log_file}'!", LOG_ONLY);
    }
    
    return 1;
}

do_install(
    allowed_versions         =&gt; [ OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2,
                                  OSVER_WIN7_SP0, OSVER_WIN7_SP1,
                                  OSVER_WIN81_SP0, ],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs             =&gt; [ qw(clc desktop traveling
                                     virtual-clc virtual-desktop) ],
    exit_on_failure          =&gt; 1,
    no_install_check         =&gt; 1, # autoupdating makes this less meaningful

    preinstall_sub           =&gt; \&amp;uninstall,
    install_sub              =&gt; \&amp;install,
    postinstall_sub          =&gt; \&amp;install_extensions,
);
IM_Exit(EXIT_SUCCESS);

# Begin-Doc
################################
# Name: uninstall()
# Description: Uninstalls Firefox or cleans up directories depending
#    on stage chosen. Each stage chosen always progresses to next
#    during check.
# Returns: true/false on respective success/failure of uninstalling
# Requires: Win32::TieRegistry, File::Path
# OrigionallyWrittenBy: Billy Rhoades
# LastUpdated: 2014-05-08
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub uninstall
{
    output('   Killing any running Firefox processes: ');
    my $tries = 10; # Give FF 10 seconds to shut down.
    while (!KillProcess('firefox.exe')) {
        last if (--$tries == 0);
        sleep(1);
    }
    if ($tries == 0) {
        output("FAILED\n");
        return 0;
    }
    output("OK\n");

    # Uninstall the program using the registry uninstall keys and then proceed
    my $i        = 0;
    my $retval   = 1;
    my @app_keys = IsAppInstalled('DisplayName' =&gt; $ffNameRegex);

    # This gets a bit complicated. We're just running the add or
    # remove program command and if the exe it needs isn't there or
    # isn't working, removing the entry and letting the rest of the
    # script clean up.
    foreach my $app_key (@app_keys)
    {
      my $uninst = $Registry-&gt;{$app_key};
      my $result;
      
      print "\tUninstalling " . $uninst-&gt;{'DisplayName'} . ": ";
      if($uninst-&gt;{'UninstallString'} =~ /^C\:\\.*\.[A-Za-z0-9]+$/
         &amp;&amp; !(-e $uninst-&gt;{'UninstallString'}))
      {
        output("broken install\n");
        delete $Registry-&gt;{$app_key};
        next;
      }
      
      #Older versions lack the quotes. 22+ seems to have them, 
      #and it gets angry if you use double quotes.
      if( $uninst-&gt;{'UninstallString'} =~ m/"/ )
      {
        $result = run_command($uninst-&gt;{'UninstallString'}." -ms");
      }
      else
      {
        $result = run_command("\"".$uninst-&gt;{'UninstallString'}."\" -ms");
      }
      
      sleep(5);    #Firefox's helper.exe forks, give it a chance to uninstall

      if($result)
      {
        output("done\n");
      }
      else
      {
        output("failed! Manually removing!\n");
      }
    }

    # Delete keys we created.
    my $moz_kloc =
        get_arch_software_key($APP_ARCH).'\Mozilla';
    if (exists($Registry-&gt;{$moz_kloc})) {
        foreach my $subkey ($Registry-&gt;{$moz_kloc}-&gt;SubKeyNames) {
            if ($subkey =~ /^(?:Mozilla )?Firefox/) {
                delete_keys_recursive($moz_kloc.'\\'.$subkey);
            }
        }
    }
    if (exists($Registry-&gt;{get_arch_software_key($APP_ARCH).'\mozilla.org'})) {
        delete_keys_recursive(get_arch_software_key($APP_ARCH).'\mozilla.org');
    }


    # Remove ActiveSetup keys and any UMRInst keys.
    my $count = 0;
    output("\tFinding hanging registry keys: ");

    foreach my $loc (@ffRegKeys)
    {
      my $key = $Registry-&gt;{$loc};

      foreach my $name (keys(%$key))
      {
        if($name =~ $ffRegex)
        {
          delete $Registry-&gt;{$loc}-&gt;{$name};
          $count++;
        }
      }
    }

    if($count &gt; 0)
    {
      output("deleted $count\n");
    }
    else
    {
      output("found none\n");
    }


    # Remove left over "boot" scripts used by ActiveSetup and any left
    #   over preferences from Firefox / Moz. Main. Service
    $count = 0;
    output("\tFinding old files: ");

    foreach my $loc (@ffFiles)
    {
      if(-e $loc)
      {
        $count += FileCount($loc);
        if($count &gt; 100)
        {
          output("\nWarning: One directory was loaded with files! Not deleting due to safeguard!\n");
          next;
        }

        rmtree($loc);
      }
    }

    if($count &gt; 0)
    {
      output("deleted $count\n");
    }
    else
    {
      output("found none\n");
    }


    return 1;
}

# Begin-Doc
################################
# Name: filecount(string)
# Description: Counts the files in a directory recursively.
# Returns: # of files
# Requires:
# OrigionallyWrittenBy: Billy Rhoades
# LastUpdated: 7/17/2013
################################
# End-Doc
sub FileCount
{
  my $loc   = $_[0];
  my $count = 0;
  my @files = glob("\"$loc\\*\"");

  foreach my $file (@files)
  {
    if(!($file =~ m/\.[A-Za-z0-9]+$/))
    {
      $count += FileCount($file);
      next;
    }
    $count++;
  }
  return $count;
}


# I'm torn about how to do this.
#   System-Wide:
#     * I suspect that system-wide extensions won't get autoupdated.
#     * They are disabled by default. (extensions.sqlite)
#
#   Distribution Extensions
#     * They only get used when a profile is created?
#
#
#   Update: Austin Wall 9-20-2017
#       Using this to install extensions again. We needed to be able to manage the uBlock Origin extension's whitelist
#       and this was the best way I could find to make sure everyone is using a version that supports that.
sub install_extensions {
    my $success = 1;

    # https://developer.mozilla.org/en-US/docs/Adding_Extensions_using_the_Windows_Registry
    # Summary:
    #   &lt;em:id&gt; =&gt; &lt;path_to_unpacked_xpi&gt;
    my $ff_ext_kloc =
        get_arch_software_key($APP_ARCH).'\Mozilla\Firefox\Extensions';
    if (! create_ancestor_keys($ff_ext_kloc)) {
        output("Error creating Firefox extension registry key: $!\n");
        return 0
    }
    my $ff_ext_key = $Registry-&gt;{$ff_ext_kloc};

    # Tell Firefox to install these extensions (for all users).

    foreach my $ext_name (keys(%$distribution_extensions)) {
        my $ext = $distribution_extensions-&gt;{$ext_name};
        my $em_id = $ext-&gt;{em_id};
        my $xpi = $ext-&gt;{xpi};

        output("[DISTRIBUTION_EXTENSION] '${ext_name}' (em:id ${em_id}): ${xpi}\n", LOG_ONLY);

        
        # Create a Registry value to tell Firefox to install the extension.
        # This must be a REG_SZ value.
        $ff_ext_key-&gt;{$em_id} = $xpi;
    }

    
    
    #This will append a line to the system's logon.cmd script to run a perl script that will 
    # remove any existing version of uBlock or uBlock Origin from each user's profiles
    # and also copy over our default settings file for uBlock Origin.
    # These items are stored in:
    # \\minerfiles.mst.edu\dfs\software\loginscripts\firefox\
    output("Appending logon.cmd...\n");
    my $logon_path = 'C:\ProgramData\mst\standard\login\logon.cmd';
    open(my $fh, '&gt;&gt;', $logon_path) or warn "Could not open '$logon_path'";
    print $fh "\n".'perl \\\\minerfiles.mst.edu\dfs\software\loginscripts\firefox\manage_firefox_extensions.pl'."\n";
    close $fh;
    output("Done!\n");
    
    return $success;
}


# Begin-Doc
################################
# Name: make_system_default_browser()
# Description: Attempt to detect the installed version of Firefox and make
#   it the (default) default browser.
# Returns: true if FF is detected and the command to make it the system default
#   succeeds (as best we can tell).
# LastUpdated: 2014-05-21
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub make_system_default_browser {
    foreach my $ff_key (IsAppInstalled( AppID =&gt; qr/^Mozilla Firefox /)) {
        # Take the first one that is found as the default.
        # It is assumed that there's only one.
        my $helper = $Registry-&gt;{$ff_key}-&gt;{UninstallString};
        $helper =~ s/"//g; # strip the quotes.
        output("Making Firefox (".dirname(dirname($helper)).
               ") the system default browser.\n");
        my @command = (
            cmd_quote($helper),
            '/SetAsDefaultAppGlobal',
            );
        my $outcome =
            run_command(join(' ',@command),
                        # I don't know why, but it always returns 2
                        #   (file not found), even when it succeeds.
                        IgnoreExitCodes =&gt; [ 2 ]);

        # Create a separate, detectable side effect.
        # For the sake of the SCCM detection.
        create_product_registry_key('default_browser.FF.1');

        return $outcome;
    }

    # If we didn't find Firefox, it can't be the default.
    output("No Firefox installation was detected. Not changing defaults...\n");
    return 0;
}
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\firefox.60_0\prod(new(new))\update.pl</FullName>
    <Length>16141</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-19T11:41:08.1372909-05:00</CreationTime>
    <CreationTimeUtc>2018-06-19T16:41:08.1372909Z</CreationTimeUtc>
    <LastWriteTime>2018-06-19T11:46:39.3335552-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-19T16:46:39.3335552Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-19T11:41:08.1372909-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-19T16:41:08.1372909Z</LastAccessTimeUtc>
    <Text># Package for Firefox 52.2.0 ESR
# Package Created June 22, 2017
# Packaged by Austin Wall
# Last Updated June 12, 2018 by Kade Wessels

# Update notes:
#   I've written this to be as easy to update in the future as
#   possible. Worst case, the extension needs to be updated. This
#   script should just need a few lines updated in it and the rest
#   shouldn't be too awful. Also, make sure you update the setup.exe.
#   There's extensive notes in the wiki page for firefox.x. This is
#   the ESR release of Firefox.

=pod
Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Comments:
    Known Issues:
    http://www.mozilla.org/en-US/firefox/24.2.0/releasenotes/

    Current Vulnerabilities:
    http://www.mozilla.org/security/known-vulnerabilities/firefox.html

Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc
=cut


# Browser Command-Line Options:
#   https://developer.mozilla.org/en-US/docs/Mozilla/Command_Line_Options
#

use strict;
use warnings;
use Win32::TieRegistry(Delimiter =&gt; "\\");
use File::Path;
use Getopt::Long;
use File::Basename;
use Archive::Extract;
use File::Copy;
use File::Path qw(make_path);

our %INSTALLMONKEY_OPTIONS;
BEGIN
{
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'firefox.60_0',
        package_revision =&gt; '20180612T0927',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im', 
    $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 
    'C:\temp',
);
use InstallMonkey::Shared;


my $sourcefilesdir   = get_pkg_sourcefiles();
my $programfiles     = get_arch_programfiles(OSARCH_x86);


# CUSTOM SETTINGS:
#   \ffsetup\core\defaults\pref\channel-prefs.js
#   \ffsetup\core\defaults\pref\local-settings.js
#   \ffsetup\core\defaults\pref\user.js
#   \ffsetup\core\browser\override.ini
#   \ffsetup\core\mst.mozilla.cfg

# To Update:
#   1. Download the FF installer (an exe), and extract the contents.
#   2. If needed, make customizations using CCK2 (firefox extension)
#   3. Choose autoconfig, copy files from zip into \ffsetup\core

# This Package:
#   Copies the SourceFiles
#   Invokes the installer.
#   Preinstalls extensions.

# Mozilla Maintenance (Service)
#   https://wiki.mozilla.org/Windows_Service_Silent_Update
#   Log Dir: C:\ProgramData\Mozilla\logs


########################################################################
# BEGIN Configuration

my $APP_ARCH = OSARCH_x64;

# The directory with the extracted contents of the downloaded exe.
my $install_source = build_path($sourcefilesdir,'ffsetup.60.0esr');
my $install_ini_file = build_path($sourcefilesdir,'mst_install.ini');

# This is the default, but the customization needs to know.
my $install_dir = build_path(get_arch_programfiles($APP_ARCH),
                             'Mozilla Firefox');
my $distribution_ext_dir = build_path($install_dir,'distribution','extensions');

###################
# UPDATE 2016-03-09
# Extensions are installed using CCK2 now,
# IGNORE BELOW
# UPDATE 2017-09-20
# Extensions are installed using this again,
# UNIGNORE BELOW
###################

# This method of installation isn't perfect, but it seems like the most
#   supportable strategy.
#  * Add-ons get installed in the user profile.
#  * Add-ons get updated (by the user).
#  * Add-ons ONLY get installed into new profiles.
my $distribution_extensions = {
    'uBlock0@raymondhill.net' =&gt; {
        em_id =&gt; 'uBlock0@raymondhill.net',
        xpi   =&gt; '\\\\minerfiles.mst.edu\dfs\software\loginscripts\firefox\uBlock0@raymondhill.net.xpi'
    },
};


########################################################################
# UNINSTALL DECLARATIONS

# Regular Expressions used to discern if something is related to 
#   Firefox (or the application install).
my $ffRegex     = qr/firefox\.([0-9]+)?x?/i;
my $ffNameRegex = qr/Mozilla Firefox|Nightly/;

# Array of locations where we can find old firefox keys or files (any found are deleted)
# These keys and directories are checked to see if they contain a
#   child that matches one of the regexes.
my $sw_key = 'HKEY_LOCAL_MACHINE\SOFTWARE';
my $sw32_key = 'HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node';
my @ffRegKeys = (
    ( map { $sw_key . $_ }
      '\Microsoft\Active Setup\Installed Components',
      '\UMR\Install\Product_List',
    ),
    ( map { $sw32_key . $_ }
      '\Microsoft\Active Setup\Installed Components',
    ),
);

my @ffFiles = (
    ( map { build_path(get_arch_programfiles($APP_ARCH),$_) }
      '\Mozilla Firefox',
      '\Mozilla Maintenance Service',
    ),
    ( map { build_path(get_allusers_scripts(),$_) }
      '\standard\firefox',
      '\standard\firefox15',
      '\standard\firefox.21x',
      '\standard\firefox.x',
      '\standard\firefox.24',
    ),
);
# END DECLARATIONS
########################################################################


# END Configuration
########################################################################

sub usage {
    print qq(
usage: $0 [--help] [--uninstall] [--[no-]-autoupdate]
          [--install-source &lt;path_to_install_media&gt;]
          [--system-default-browser]

--install-source
  Use an alternate directory as the install media.
  It can be relative to the &lt;data&gt; directory or an absolute path.

--system-default-browser
  Make Firefox the system default web browser.
  This should only be done after Firefox is already installed.

);
}

Getopt::Long::Configure(qw(pass_through));
GetOptions(
    'help'       =&gt; sub { usage(); exit(0); },

    'uninstall'  =&gt; sub { exit(! uninstall()) },

    'system-default-browser' =&gt; sub {
        exit( ! make_system_default_browser() );
    },

    'code=s' =&gt; sub {
        eval {
            exit( ! eval($_[1]) );
        };
        if ($@) {
            output($@);
            exit($@);
        }
    },
);

sub install {
    output("   Installing Firefox: ");

    # The install media is just the files extracted from the FF installer.
    # Installer Command-Line Options:
    #   https://wiki.mozilla.org/Installer:Command_Line_Arguments
    my @command = (
        'cmd','/c','start','/wait','""',
        cmd_quote(build_path($install_source,'setup.exe')),
        '/INI='.cmd_quote($install_ini_file),
        );

    if(! run_command(join(' ',@command))) {
        output("FAILED\n");
        return 0;
    }
    output("OK\n");
    
    # Copy the default log file.
    sleep(5); # It doesn't get copied to the install dir right away.
    my $log_file = build_path($install_dir,'install.log');
    if ( -f $log_file ) {
        copy($log_file,get_default_app_log()) ||
            output("Error copying log file '${log_file}': $!\n", LOG_ONLY);
    } else {
        output("No install log found: '${log_file}'!", LOG_ONLY);
    }
    
    return 1;
}

do_install(
    allowed_versions         =&gt; [ OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2,
                                  OSVER_WIN7_SP0, OSVER_WIN7_SP1,
                                  OSVER_WIN81_SP0, ],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs             =&gt; [ qw(clc desktop traveling
                                     virtual-clc virtual-desktop) ],
    exit_on_failure          =&gt; 1,
    no_install_check         =&gt; 1, # autoupdating makes this less meaningful

    preinstall_sub           =&gt; \&amp;uninstall,
    install_sub              =&gt; \&amp;install,
    postinstall_sub          =&gt; \&amp;install_extensions,
);
IM_Exit(EXIT_SUCCESS);

# Begin-Doc
################################
# Name: uninstall()
# Description: Uninstalls Firefox or cleans up directories depending
#    on stage chosen. Each stage chosen always progresses to next
#    during check.
# Returns: true/false on respective success/failure of uninstalling
# Requires: Win32::TieRegistry, File::Path
# OrigionallyWrittenBy: Billy Rhoades
# LastUpdated: 2014-05-08
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub uninstall
{
    output('   Killing any running Firefox processes: ');
    my $tries = 10; # Give FF 10 seconds to shut down.
    while (!KillProcess('firefox.exe')) {
        last if (--$tries == 0);
        sleep(1);
    }
    if ($tries == 0) {
        output("FAILED\n");
        return 0;
    }
    output("OK\n");

    # Uninstall the program using the registry uninstall keys and then proceed
    my $i        = 0;
    my $retval   = 1;
    my @app_keys = IsAppInstalled('DisplayName' =&gt; $ffNameRegex);

    # This gets a bit complicated. We're just running the add or
    # remove program command and if the exe it needs isn't there or
    # isn't working, removing the entry and letting the rest of the
    # script clean up.
    foreach my $app_key (@app_keys)
    {
      my $uninst = $Registry-&gt;{$app_key};
      my $result;
      
      print "\tUninstalling " . $uninst-&gt;{'DisplayName'} . ": ";
      if($uninst-&gt;{'UninstallString'} =~ /^C\:\\.*\.[A-Za-z0-9]+$/
         &amp;&amp; !(-e $uninst-&gt;{'UninstallString'}))
      {
        output("broken install\n");
        delete $Registry-&gt;{$app_key};
        next;
      }
      
      #Older versions lack the quotes. 22+ seems to have them, 
      #and it gets angry if you use double quotes.
      if( $uninst-&gt;{'UninstallString'} =~ m/"/ )
      {
        $result = run_command($uninst-&gt;{'UninstallString'}." -ms");
      }
      else
      {
        $result = run_command("\"".$uninst-&gt;{'UninstallString'}."\" -ms");
      }
      
      sleep(5);    #Firefox's helper.exe forks, give it a chance to uninstall

      if($result)
      {
        output("done\n");
      }
      else
      {
        output("failed! Manually removing!\n");
      }
    }

    # Delete keys we created.
    my $moz_kloc =
        get_arch_software_key($APP_ARCH).'\Mozilla';
    if (exists($Registry-&gt;{$moz_kloc})) {
        foreach my $subkey ($Registry-&gt;{$moz_kloc}-&gt;SubKeyNames) {
            if ($subkey =~ /^(?:Mozilla )?Firefox/) {
                delete_keys_recursive($moz_kloc.'\\'.$subkey);
            }
        }
    }
    if (exists($Registry-&gt;{get_arch_software_key($APP_ARCH).'\mozilla.org'})) {
        delete_keys_recursive(get_arch_software_key($APP_ARCH).'\mozilla.org');
    }


    # Remove ActiveSetup keys and any UMRInst keys.
    my $count = 0;
    output("\tFinding hanging registry keys: ");

    foreach my $loc (@ffRegKeys)
    {
      my $key = $Registry-&gt;{$loc};

      foreach my $name (keys(%$key))
      {
        if($name =~ $ffRegex)
        {
          delete $Registry-&gt;{$loc}-&gt;{$name};
          $count++;
        }
      }
    }

    if($count &gt; 0)
    {
      output("deleted $count\n");
    }
    else
    {
      output("found none\n");
    }


    # Remove left over "boot" scripts used by ActiveSetup and any left
    #   over preferences from Firefox / Moz. Main. Service
    $count = 0;
    output("\tFinding old files: ");

    foreach my $loc (@ffFiles)
    {
      if(-e $loc)
      {
        $count += FileCount($loc);
        if($count &gt; 100)
        {
          output("\nWarning: One directory was loaded with files! Not deleting due to safeguard!\n");
          next;
        }

        rmtree($loc);
      }
    }

    if($count &gt; 0)
    {
      output("deleted $count\n");
    }
    else
    {
      output("found none\n");
    }


    return 1;
}

# Begin-Doc
################################
# Name: filecount(string)
# Description: Counts the files in a directory recursively.
# Returns: # of files
# Requires:
# OrigionallyWrittenBy: Billy Rhoades
# LastUpdated: 7/17/2013
################################
# End-Doc
sub FileCount
{
  my $loc   = $_[0];
  my $count = 0;
  my @files = glob("\"$loc\\*\"");

  foreach my $file (@files)
  {
    if(!($file =~ m/\.[A-Za-z0-9]+$/))
    {
      $count += FileCount($file);
      next;
    }
    $count++;
  }
  return $count;
}


# I'm torn about how to do this.
#   System-Wide:
#     * I suspect that system-wide extensions won't get autoupdated.
#     * They are disabled by default. (extensions.sqlite)
#
#   Distribution Extensions
#     * They only get used when a profile is created?
#
#
#   Update: Austin Wall 9-20-2017
#       Using this to install extensions again. We needed to be able to manage the uBlock Origin extension's whitelist
#       and this was the best way I could find to make sure everyone is using a version that supports that.
sub install_extensions {
    my $success = 1;

    # https://developer.mozilla.org/en-US/docs/Adding_Extensions_using_the_Windows_Registry
    # Summary:
    #   &lt;em:id&gt; =&gt; &lt;path_to_unpacked_xpi&gt;
    my $ff_ext_kloc =
        get_arch_software_key($APP_ARCH).'\Mozilla\Firefox\Extensions';
    if (! create_ancestor_keys($ff_ext_kloc)) {
        output("Error creating Firefox extension registry key: $!\n");
        return 0
    }
    my $ff_ext_key = $Registry-&gt;{$ff_ext_kloc};

    # Tell Firefox to install these extensions (for all users).

    foreach my $ext_name (keys(%$distribution_extensions)) {
        my $ext = $distribution_extensions-&gt;{$ext_name};
        my $em_id = $ext-&gt;{em_id};
        my $xpi = $ext-&gt;{xpi};

        output("[DISTRIBUTION_EXTENSION] '${ext_name}' (em:id ${em_id}): ${xpi}\n", LOG_ONLY);

        
        # Create a Registry value to tell Firefox to install the extension.
        # This must be a REG_SZ value.
        $ff_ext_key-&gt;{$em_id} = $xpi;
    }

    
    
    #This will append a line to the system's logon.cmd script to run a perl script that will 
    # remove any existing version of uBlock or uBlock Origin from each user's profiles
    # and also copy over our default settings file for uBlock Origin.
    # These items are stored in:
    # \\minerfiles.mst.edu\dfs\software\loginscripts\firefox\
    output("Appending logon.cmd...\n");
    my $logon_path = 'C:\ProgramData\mst\standard\login\logon.cmd';
    open(my $fh, '&gt;&gt;', $logon_path) or warn "Could not open '$logon_path'";
    print $fh "\n".'perl \\\\minerfiles.mst.edu\dfs\software\loginscripts\firefox\manage_firefox_extensions.pl'."\n";
    close $fh;
    output("Done!\n");
    
    return $success;
}


# Begin-Doc
################################
# Name: make_system_default_browser()
# Description: Attempt to detect the installed version of Firefox and make
#   it the (default) default browser.
# Returns: true if FF is detected and the command to make it the system default
#   succeeds (as best we can tell).
# LastUpdated: 2014-05-21
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub make_system_default_browser {
    foreach my $ff_key (IsAppInstalled( AppID =&gt; qr/^Mozilla Firefox /)) {
        # Take the first one that is found as the default.
        # It is assumed that there's only one.
        my $helper = $Registry-&gt;{$ff_key}-&gt;{UninstallString};
        $helper =~ s/"//g; # strip the quotes.
        output("Making Firefox (".dirname(dirname($helper)).
               ") the system default browser.\n");
        my @command = (
            cmd_quote($helper),
            '/SetAsDefaultAppGlobal',
            );
        my $outcome =
            run_command(join(' ',@command),
                        # I don't know why, but it always returns 2
                        #   (file not found), even when it succeeds.
                        IgnoreExitCodes =&gt; [ 2 ]);

        # Create a separate, detectable side effect.
        # For the sake of the SCCM detection.
        create_product_registry_key('default_browser.FF.1');

        return $outcome;
    }

    # If we didn't find Firefox, it can't be the default.
    output("No Firefox installation was detected. Not changing defaults...\n");
    return 0;
}
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\firefox.60_0\prod(new)\update.pl</FullName>
    <Length>16141</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-15T10:46:24.4815396-05:00</CreationTime>
    <CreationTimeUtc>2018-06-15T15:46:24.4815396Z</CreationTimeUtc>
    <LastWriteTime>2018-06-19T11:42:07.0041277-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-19T16:42:07.0041277Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-15T10:46:24.5130423-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-15T15:46:24.5130423Z</LastAccessTimeUtc>
    <Text># Package for Firefox 52.2.0 ESR
# Package Created June 22, 2017
# Packaged by Austin Wall
# Last Updated June 12, 2018 by Kade Wessels

# Update notes:
#   I've written this to be as easy to update in the future as
#   possible. Worst case, the extension needs to be updated. This
#   script should just need a few lines updated in it and the rest
#   shouldn't be too awful. Also, make sure you update the setup.exe.
#   There's extensive notes in the wiki page for firefox.x. This is
#   the ESR release of Firefox.

=pod
Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Comments:
    Known Issues:
    http://www.mozilla.org/en-US/firefox/24.2.0/releasenotes/

    Current Vulnerabilities:
    http://www.mozilla.org/security/known-vulnerabilities/firefox.html

Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc
=cut


# Browser Command-Line Options:
#   https://developer.mozilla.org/en-US/docs/Mozilla/Command_Line_Options
#

use strict;
use warnings;
use Win32::TieRegistry(Delimiter =&gt; "\\");
use File::Path;
use Getopt::Long;
use File::Basename;
use Archive::Extract;
use File::Copy;
use File::Path qw(make_path);

our %INSTALLMONKEY_OPTIONS;
BEGIN
{
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'firefox.60_0',
        package_revision =&gt; '20180612T0927',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im', 
    $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 
    'C:\temp',
);
use InstallMonkey::Shared;


my $sourcefilesdir   = get_pkg_sourcefiles();
my $programfiles     = get_arch_programfiles(OSARCH_x86);


# CUSTOM SETTINGS:
#   \ffsetup\core\defaults\pref\channel-prefs.js
#   \ffsetup\core\defaults\pref\local-settings.js
#   \ffsetup\core\defaults\pref\user.js
#   \ffsetup\core\browser\override.ini
#   \ffsetup\core\mst.mozilla.cfg

# To Update:
#   1. Download the FF installer (an exe), and extract the contents.
#   2. If needed, make customizations using CCK2 (firefox extension)
#   3. Choose autoconfig, copy files from zip into \ffsetup\core

# This Package:
#   Copies the SourceFiles
#   Invokes the installer.
#   Preinstalls extensions.

# Mozilla Maintenance (Service)
#   https://wiki.mozilla.org/Windows_Service_Silent_Update
#   Log Dir: C:\ProgramData\Mozilla\logs


########################################################################
# BEGIN Configuration

my $APP_ARCH = OSARCH_x64;

# The directory with the extracted contents of the downloaded exe.
my $install_source = build_path($sourcefilesdir,'ffsetup.60.0esr');
my $install_ini_file = build_path($sourcefilesdir,'mst_install.ini');

# This is the default, but the customization needs to know.
my $install_dir = build_path(get_arch_programfiles($APP_ARCH),
                             'Mozilla Firefox');
my $distribution_ext_dir = build_path($install_dir,'distribution','extensions');

###################
# UPDATE 2016-03-09
# Extensions are installed using CCK2 now,
# IGNORE BELOW
# UPDATE 2017-09-20
# Extensions are installed using this again,
# UNIGNORE BELOW
###################

# This method of installation isn't perfect, but it seems like the most
#   supportable strategy.
#  * Add-ons get installed in the user profile.
#  * Add-ons get updated (by the user).
#  * Add-ons ONLY get installed into new profiles.
my $distribution_extensions = {
    'uBlock0@raymondhill.net' =&gt; {
        em_id =&gt; 'uBlock0@raymondhill.net',
        xpi   =&gt; '\\\\minerfiles.mst.edu\dfs\software\loginscripts\firefox\uBlock0@raymondhill.net.xpi'
    },
};


########################################################################
# UNINSTALL DECLARATIONS

# Regular Expressions used to discern if something is related to 
#   Firefox (or the application install).
my $ffRegex     = qr/firefox\.([0-9]+)?x?/i;
my $ffNameRegex = qr/Mozilla Firefox|Nightly/;

# Array of locations where we can find old firefox keys or files (any found are deleted)
# These keys and directories are checked to see if they contain a
#   child that matches one of the regexes.
my $sw_key = 'HKEY_LOCAL_MACHINE\SOFTWARE';
my $sw32_key = 'HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node';
my @ffRegKeys = (
    ( map { $sw_key . $_ }
      '\Microsoft\Active Setup\Installed Components',
      '\UMR\Install\Product_List',
    ),
    ( map { $sw32_key . $_ }
      '\Microsoft\Active Setup\Installed Components',
    ),
);

my @ffFiles = (
    ( map { build_path(get_arch_programfiles($APP_ARCH),$_) }
      '\Mozilla Firefox',
      '\Mozilla Maintenance Service',
    ),
    ( map { build_path(get_allusers_scripts(),$_) }
      '\standard\firefox',
      '\standard\firefox15',
      '\standard\firefox.21x',
      '\standard\firefox.x',
      '\standard\firefox.24',
    ),
);
# END DECLARATIONS
########################################################################


# END Configuration
########################################################################

sub usage {
    print qq(
usage: $0 [--help] [--uninstall] [--[no-]-autoupdate]
          [--install-source &lt;path_to_install_media&gt;]
          [--system-default-browser]

--install-source
  Use an alternate directory as the install media.
  It can be relative to the &lt;data&gt; directory or an absolute path.

--system-default-browser
  Make Firefox the system default web browser.
  This should only be done after Firefox is already installed.

);
}

Getopt::Long::Configure(qw(pass_through));
GetOptions(
    'help'       =&gt; sub { usage(); exit(0); },

    'uninstall'  =&gt; sub { exit(! uninstall()) },

    'system-default-browser' =&gt; sub {
        exit( ! make_system_default_browser() );
    },

    'code=s' =&gt; sub {
        eval {
            exit( ! eval($_[1]) );
        };
        if ($@) {
            output($@);
            exit($@);
        }
    },
);

sub install {
    output("   Installing Firefox: ");

    # The install media is just the files extracted from the FF installer.
    # Installer Command-Line Options:
    #   https://wiki.mozilla.org/Installer:Command_Line_Arguments
    my @command = (
        'cmd','/c','start','/wait','""',
        cmd_quote(build_path($install_source,'setup.exe')),
        '/INI='.cmd_quote($install_ini_file),
        );

    if(! run_command(join(' ',@command))) {
        output("FAILED\n");
        return 0;
    }
    output("OK\n");
    
    # Copy the default log file.
    sleep(5); # It doesn't get copied to the install dir right away.
    my $log_file = build_path($install_dir,'install.log');
    if ( -f $log_file ) {
        copy($log_file,get_default_app_log()) ||
            output("Error copying log file '${log_file}': $!\n", LOG_ONLY);
    } else {
        output("No install log found: '${log_file}'!", LOG_ONLY);
    }
    
    return 1;
}

do_install(
    allowed_versions         =&gt; [ OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2,
                                  OSVER_WIN7_SP0, OSVER_WIN7_SP1,
                                  OSVER_WIN81_SP0, ],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs             =&gt; [ qw(clc desktop traveling
                                     virtual-clc virtual-desktop) ],
    exit_on_failure          =&gt; 1,
    no_install_check         =&gt; 1, # autoupdating makes this less meaningful

    preinstall_sub           =&gt; \&amp;uninstall,
    install_sub              =&gt; \&amp;install,
    postinstall_sub          =&gt; \&amp;install_extensions,
);
IM_Exit(EXIT_SUCCESS);

# Begin-Doc
################################
# Name: uninstall()
# Description: Uninstalls Firefox or cleans up directories depending
#    on stage chosen. Each stage chosen always progresses to next
#    during check.
# Returns: true/false on respective success/failure of uninstalling
# Requires: Win32::TieRegistry, File::Path
# OrigionallyWrittenBy: Billy Rhoades
# LastUpdated: 2014-05-08
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub uninstall
{
    output('   Killing any running Firefox processes: ');
    my $tries = 10; # Give FF 10 seconds to shut down.
    while (!KillProcess('firefox.exe')) {
        last if (--$tries == 0);
        sleep(1);
    }
    if ($tries == 0) {
        output("FAILED\n");
        return 0;
    }
    output("OK\n");

    # Uninstall the program using the registry uninstall keys and then proceed
    my $i        = 0;
    my $retval   = 1;
    my @app_keys = IsAppInstalled('DisplayName' =&gt; $ffNameRegex);

    # This gets a bit complicated. We're just running the add or
    # remove program command and if the exe it needs isn't there or
    # isn't working, removing the entry and letting the rest of the
    # script clean up.
    foreach my $app_key (@app_keys)
    {
      my $uninst = $Registry-&gt;{$app_key};
      my $result;
      
      print "\tUninstalling " . $uninst-&gt;{'DisplayName'} . ": ";
      if($uninst-&gt;{'UninstallString'} =~ /^C\:\\.*\.[A-Za-z0-9]+$/
         &amp;&amp; !(-e $uninst-&gt;{'UninstallString'}))
      {
        output("broken install\n");
        delete $Registry-&gt;{$app_key};
        next;
      }
      
      #Older versions lack the quotes. 22+ seems to have them, 
      #and it gets angry if you use double quotes.
      if( $uninst-&gt;{'UninstallString'} =~ m/"/ )
      {
        $result = run_command($uninst-&gt;{'UninstallString'}." -ms");
      }
      else
      {
        $result = run_command("\"".$uninst-&gt;{'UninstallString'}."\" -ms");
      }
      
      sleep(5);    #Firefox's helper.exe forks, give it a chance to uninstall

      if($result)
      {
        output("done\n");
      }
      else
      {
        output("failed! Manually removing!\n");
      }
    }

    # Delete keys we created.
    my $moz_kloc =
        get_arch_software_key($APP_ARCH).'\Mozilla';
    if (exists($Registry-&gt;{$moz_kloc})) {
        foreach my $subkey ($Registry-&gt;{$moz_kloc}-&gt;SubKeyNames) {
            if ($subkey =~ /^(?:Mozilla )?Firefox/) {
                delete_keys_recursive($moz_kloc.'\\'.$subkey);
            }
        }
    }
    if (exists($Registry-&gt;{get_arch_software_key($APP_ARCH).'\mozilla.org'})) {
        delete_keys_recursive(get_arch_software_key($APP_ARCH).'\mozilla.org');
    }


    # Remove ActiveSetup keys and any UMRInst keys.
    my $count = 0;
    output("\tFinding hanging registry keys: ");

    foreach my $loc (@ffRegKeys)
    {
      my $key = $Registry-&gt;{$loc};

      foreach my $name (keys(%$key))
      {
        if($name =~ $ffRegex)
        {
          delete $Registry-&gt;{$loc}-&gt;{$name};
          $count++;
        }
      }
    }

    if($count &gt; 0)
    {
      output("deleted $count\n");
    }
    else
    {
      output("found none\n");
    }


    # Remove left over "boot" scripts used by ActiveSetup and any left
    #   over preferences from Firefox / Moz. Main. Service
    $count = 0;
    output("\tFinding old files: ");

    foreach my $loc (@ffFiles)
    {
      if(-e $loc)
      {
        $count += FileCount($loc);
        if($count &gt; 100)
        {
          output("\nWarning: One directory was loaded with files! Not deleting due to safeguard!\n");
          next;
        }

        rmtree($loc);
      }
    }

    if($count &gt; 0)
    {
      output("deleted $count\n");
    }
    else
    {
      output("found none\n");
    }


    return 1;
}

# Begin-Doc
################################
# Name: filecount(string)
# Description: Counts the files in a directory recursively.
# Returns: # of files
# Requires:
# OrigionallyWrittenBy: Billy Rhoades
# LastUpdated: 7/17/2013
################################
# End-Doc
sub FileCount
{
  my $loc   = $_[0];
  my $count = 0;
  my @files = glob("\"$loc\\*\"");

  foreach my $file (@files)
  {
    if(!($file =~ m/\.[A-Za-z0-9]+$/))
    {
      $count += FileCount($file);
      next;
    }
    $count++;
  }
  return $count;
}


# I'm torn about how to do this.
#   System-Wide:
#     * I suspect that system-wide extensions won't get autoupdated.
#     * They are disabled by default. (extensions.sqlite)
#
#   Distribution Extensions
#     * They only get used when a profile is created?
#
#
#   Update: Austin Wall 9-20-2017
#       Using this to install extensions again. We needed to be able to manage the uBlock Origin extension's whitelist
#       and this was the best way I could find to make sure everyone is using a version that supports that.
sub install_extensions {
    my $success = 1;

    # https://developer.mozilla.org/en-US/docs/Adding_Extensions_using_the_Windows_Registry
    # Summary:
    #   &lt;em:id&gt; =&gt; &lt;path_to_unpacked_xpi&gt;
    my $ff_ext_kloc =
        get_arch_software_key($APP_ARCH).'\Mozilla\Firefox\Extensions';
    if (! create_ancestor_keys($ff_ext_kloc)) {
        output("Error creating Firefox extension registry key: $!\n");
        return 0
    }
    my $ff_ext_key = $Registry-&gt;{$ff_ext_kloc};

    # Tell Firefox to install these extensions (for all users).

    foreach my $ext_name (keys(%$distribution_extensions)) {
        my $ext = $distribution_extensions-&gt;{$ext_name};
        my $em_id = $ext-&gt;{em_id};
        my $xpi = $ext-&gt;{xpi};

        output("[DISTRIBUTION_EXTENSION] '${ext_name}' (em:id ${em_id}): ${xpi}\n", LOG_ONLY);

        
        # Create a Registry value to tell Firefox to install the extension.
        # This must be a REG_SZ value.
        $ff_ext_key-&gt;{$em_id} = $xpi;
    }

    
    
    #This will append a line to the system's logon.cmd script to run a perl script that will 
    # remove any existing version of uBlock or uBlock Origin from each user's profiles
    # and also copy over our default settings file for uBlock Origin.
    # These items are stored in:
    # \\minerfiles.mst.edu\dfs\software\loginscripts\firefox\
    output("Appending logon.cmd...\n");
    my $logon_path = 'C:\ProgramData\mst\standard\login\logon.cmd';
    open(my $fh, '&gt;&gt;', $logon_path) or warn "Could not open '$logon_path'";
    print $fh "\n".'perl \\\\minerfiles.mst.edu\dfs\software\loginscripts\firefox\manage_firefox_extensions.pl'."\n";
    close $fh;
    output("Done!\n");
    
    return $success;
}


# Begin-Doc
################################
# Name: make_system_default_browser()
# Description: Attempt to detect the installed version of Firefox and make
#   it the (default) default browser.
# Returns: true if FF is detected and the command to make it the system default
#   succeeds (as best we can tell).
# LastUpdated: 2014-05-21
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub make_system_default_browser {
    foreach my $ff_key (IsAppInstalled( AppID =&gt; qr/^Mozilla Firefox /)) {
        # Take the first one that is found as the default.
        # It is assumed that there's only one.
        my $helper = $Registry-&gt;{$ff_key}-&gt;{UninstallString};
        $helper =~ s/"//g; # strip the quotes.
        output("Making Firefox (".dirname(dirname($helper)).
               ") the system default browser.\n");
        my @command = (
            cmd_quote($helper),
            '/SetAsDefaultAppGlobal',
            );
        my $outcome =
            run_command(join(' ',@command),
                        # I don't know why, but it always returns 2
                        #   (file not found), even when it succeeds.
                        IgnoreExitCodes =&gt; [ 2 ]);

        # Create a separate, detectable side effect.
        # For the sake of the SCCM detection.
        create_product_registry_key('default_browser.FF.1');

        return $outcome;
    }

    # If we didn't find Firefox, it can't be the default.
    output("No Firefox installation was detected. Not changing defaults...\n");
    return 0;
}
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\firefox.esr\dev\update.pl</FullName>
    <Length>34775</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-08-31T13:15:27.0164593-05:00</CreationTime>
    <CreationTimeUtc>2017-08-31T18:15:27.0164593Z</CreationTimeUtc>
    <LastWriteTime>2015-08-12T13:17:29.7131074-05:00</LastWriteTime>
    <LastWriteTimeUtc>2015-08-12T18:17:29.7131074Z</LastWriteTimeUtc>
    <LastAccessTime>2017-08-31T13:15:27.0164593-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-08-31T18:15:27.0164593Z</LastAccessTimeUtc>
    <Text># Package for Firefox 24.2 ESR
# Package Created July 16th, 2013
# Packaged by Billy Rhoades
# Last Updated 2014-05-20 by Todd Hartman

# Update notes:
#   I've written this to be as easy to update in the future as
#   possible. Worst case, the extension needs to be updated. This
#   script should just need a few lines updated in it and the rest
#   shouldn't be too awful. Also, make sure you update the setup.exe.
#   There's extensive notes in the wiki page for firefox.x. This is
#   the ESR release of Firefox.

=pod
Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Comments:
    Known Issues:
    http://www.mozilla.org/en-US/firefox/24.2.0/releasenotes/

    Current Vulnerabilities:
    http://www.mozilla.org/security/known-vulnerabilities/firefox.html

Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc
=cut


# Browser Command-Line Options:
#   https://developer.mozilla.org/en-US/docs/Mozilla/Command_Line_Options
#

use strict;
use warnings;
use Win32::TieRegistry(Delimiter =&gt; "\\");
use File::Path;
use Getopt::Long;
use File::Basename;
use Archive::Extract;
use File::Copy;
use File::Path qw(make_path);

our %INSTALLMONKEY_OPTIONS;
BEGIN
{
  %INSTALLMONKEY_OPTIONS = (package_id       =&gt; 'firefox.esr',
                            package_revision =&gt; '20140520T1200',);
}

use lib('\\\\minerfiles.mst.edu\dfs\software\loginscripts\im', $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 'C:\temp',);
use InstallMonkey::Shared;


my $sourcefilesdir   = get_pkg_sourcefiles();
my $programfiles     = get_arch_programfiles(OSARCH_x86);
my $certutil_exe     = build_path('certutil', 'certutil.exe');

#
# To Update:
#   1. Download the FF installer (a SFX), and extract the contents.
#   2. Run the CCK2 tool to package the standard customizations.
#      * default home page
#      * certificates
#        - MU Root CA
#      * standard add-ins
#        - AdBlock Plus
#   3. Make other customizations in the &lt;install_media&gt;\core\defaults\pref
#      directory.
#      * Some of these customizations are stored in this script and
#        generated in the sourcefiles directory.
#

# This Package:
#   Copies the SourceFiles
#   Creates config files in the 'install_source'
#   Invokes the installer.
#   Preinstalls extensions.

# Mozilla Maintenance (Service)
#   https://wiki.mozilla.org/Windows_Service_Silent_Update
#   Log Dir: C:\ProgramData\Mozilla\logs

# Monitor Application Updates
#   Tools / Web Developer / Browser Console
#     (Pay attention to the JS events that happen.)
#   about:config
#     (These settings will reduce the amount of waiting you have to do
#      in order to "watch" an update happen.)
#     app.update.log: true
#       (add update messages to the log, including the browser console)
#     app.update.interval: 30
#       (seconds between checks for updates)
#     app.update.download.backgroundInterval: 1
#       (seconds between background downloading of 600KB chunks)
#     app.update.idletime: 5
#       (browser idle time before background operations)
#     app.update.promptWaitTime: 30
#       (Don't wait long between user-notifications. When any form of
#        silent is enabled, this setting will be meaningless.)
#
#     app.update.lastUpdateTime.background-update-timer
#       (Reset this to 0 to check soon.)
#
# Trigger an Update.
#  * Help / About
#
#  * (in the Browser Console)
#     Components.classes["@mozilla.org/updates/update-prompt;1"].createInstance(Components.interfaces.nsIUpdatePrompt).checkForUpdates();
#


########################################################################
# BEGIN Configuration

my $APP_ARCH = OSARCH_x86;

# When automatic updating is working in an ESR version. We'll use that one.

# The directory with the extracted contents of the downloaded SFX.
my $install_source = 'ffsetup.38.0.1'; 
#$install_source = 'ffsetup.29.0.0'; # use an older version to test updates
#$install_source = 'ffsetup.24.4.0esr'; 
#$install_source = 'ffsetup.24.5.0esr';

# Ensure that Firefox can update without admin user intervention.
my $autoupdating = 1;
my $install_extensions = 1;
# Other command-line arguments are processed later.
Getopt::Long::Configure(qw(pass_through));
GetOptions(
    # We need to know this very early on.
    'autoupdate!' =&gt; \$autoupdating,
    'install-source=s' =&gt; \$install_source,
);


if (! -f $install_source) {
    # If it's an absolute path to an existing directory, use it
    #   as-is. Otherwise, assume it's in the &lt;data&gt; directory.
    $install_source = build_path($sourcefilesdir,$install_source);
}

# This is the default, but the customization needs to know.
my $install_dir = build_path(get_arch_programfiles($APP_ARCH),
                             'Mozilla Firefox');
my $distribution_ext_dir = build_path($install_dir,'distribution','extensions');

# INI file doc: https://wiki.mozilla.org/Installer:Command_Line_Arguments
my $install_ini_file = build_path($sourcefilesdir,'mst_install.ini');
my $install_ini_data = {
    'Install' =&gt; {
        # 'InstallDirectoryName' =&gt; basename($install_dir),
        'InstallDirectoryPath' =&gt; $install_dir,
        'QuickLaunchShortcut'  =&gt; 'false',

        #'DesktopShortcut'      =&gt; 'true', # default
        #'StartMenuShortcuts'   =&gt; 'true', # default

        #'StartMenuDirectoryName' =&gt; 'Mozilla Firefox',
        'MaintenanceService'   =&gt; 'true', # default
    },
};

# Add any important trusted root CA certificates, like the one for UM System's
#   CA, from which the university's CA inherits trust.
my %certs_to_add = (
    # This one is added by our CCK.
    'muroot.der' =&gt; 'University of Missouri Root Authority - University of Missouri',
);

# CCK2 (1.0.3) Settings Configured
# ------------------------
#   About
#     Description, Version
#   Web Pages
#     Default Home Page URL
#     Do not display the welcome page
#     Do not display the upgrade page
#
#   Preferences
#     These items are here because we want to enforce them in a standard
#       install.
#
#     app.update.auto     : true (locked)
#        http://kb.mozillazine.org/App.update.auto
#        true: "download and install updates automatically, possibly
#               with a warning if incompatible extensions are
#               installed (see app.update.mode)"
#     app.update.enabled  : true (locked)
#        http://kb.mozillazine.org/App.update.idletime
#        true: "Auto-update the application"
#     app.update.mode     : 0    (locked)
#        http://kb.mozillazine.org/App.update.mode
#        0: "download all updates without any prompt"
#     app.update.silent   : true (locked)
#        http://kb.mozillazine.org/App.update.silent
#        true: "All UI prompts for updates are suppressed"
#     app.update.download.backgroundInterval: 1
#        http://kb.mozillazine.org/App.update.download.backgroundInterval
#        1: wait 1 second between downloading 300KB chunks of FF update
#           (This should mean that it takes ~1.5 minutes to download
#            a FF update. ~22MB; The default setting, 60 sec, would require
#            leaving the browser open for 75+ minutes in order to download
#            an update in the background.)
#           We _want_ the browser to update ASAP, so don't require
#             leaving the browser open for tens of minutes.
#     app.update.log      : true (locked)
#        https://wiki.mozilla.org/Software_Update:Testing (non-canonical doc)
#        true: "enables logging for the Application Update Service components"
#     browser.places.importBookmarksHTML : false (locked)
#        http://kb.mozillazine.org/Browser.places.importBookmarksHTML
#        false: "Do not import the contents of bookmarks.html."
#
#   Certificates
#     muroot.der
#   Network
#     Don't change
#   Miscellaneous
#     Don't show the rights notification
#   Extension Only
#     Unique ID: ffcust@mst.edu
#     Name: Missouri S&amp;T Firefox Customization
#     Description: Customizes Firefox to fit Missouri S&amp;T standards
#     Filename: mstcck.3_2

# Other config options
#   app.update.idletime
#      http://kb.mozillazine.org/App.update.idletime
#      

my $cck_archive = build_path($sourcefilesdir,'mstcck.3_2','extension','autoconfig.zip');

# Install Add-ons System-wide.
#   http://kb.mozillazine.org/Installing_extensions#Global_installation
#   Extract them to the &lt;installdir&gt;\browser\extensions\ directory with
#     the extension ID as the directory name.
#  HOW DO I TELL FIREFOX NOT TO ASK ABOUT ENABLING THEM?
# The em:id comes from install.rdf in the .XPI (a Zip archive).
#   This could be obtained programmatically from the XPI, but it's
#   not too dangerous to copy/paste.
# http://mike.kaply.com/2012/02/09/integrating-add-ons-into-firefox/
my $systemwide_extensions = {
};

# This method of installation isn't perfect, but it seems like the most
#   supportable strategy.
#  * Add-ons get installed in the user profile.
#  * Add-ons get updated (by the user).
#  * Add-ons ONLY get installed into new profiles.
my $distribution_extensions = {
    'uBlock' =&gt; {
        em_id =&gt; '{2b10c1c8-a11f-4bad-fe9c-1c11e82cac42}',
        xpi   =&gt; 'uBlock.0_9_5_0.xpi' # rel to srcfiles
    },
};


my $prefs_dir = build_path($install_source,'core','defaults','pref');

# Default Preferences
# The functions invoked return strings appropriate for that file.
#   pref(), lockPref(), ...
# These files get created in the install_directory after the application
#   is installed.
my %preferences = (
    # We don't want people to be able to change these, even for themselves.
    # If they really want that much control, they can download Firefox
    #   portable.

    # Using this file is overridden by the CCK2 autoconfig.
    ## build_path($prefs_dir,'local-settings.js') =&gt; [
    ##     # If this is on, the config file must be shifted by 13 bytes.
    ##     # It's designed to keep novices from succeeding.
    ##     pref('general.config.obscure_value', js_int(0)),
    ## 
    ##     # Define the autoconfig filename. We'll generate this, too.
    ##     pref('general.config.filename',
    ##          js_str('defaults/pref/mst.mozilla.cfg')),
    ## ],

    # This has a slightly different format.

    # autoDisableScopes
    #   Disabling certain install locations.
    #   https://developer.mozilla.org/en-US/Add-ons/Installing_extensions
    # extensions.installDistroAddons
    #   (Automatically) install add-ons bundled with this install.
    #   https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/Customizing_Firefox
    # extensions.shownSelectionUI
    #   Disable the Add-on Control Wizard
    #   http://blog.ffextensionguru.com/2011/11/09/disable-firefox-8-add-on-controls/

    # Using this file is overridden by the CCK2 autoconfig.
    ## build_path($prefs_dir,'mst.mozilla.cfg') =&gt; [
    ##     # description/documentation?
    ##     lockPref('extensions.installDistroAddons', js_bool(1)),
    ##     lockPref('extensions.autoDisableScopes', js_int(0)),
    ##     lockPref('extensions.enabledScopes', js_int(15)),
    ## 
    ##     lockPref('app.update.silent', js_bool(1)),
    ##     lockPref('app.update.enabled', js_bool($autoupdating)),
    ##     # Where is the log??
    ##     lockPref('app.update.log', js_bool(1)),
    ##     lockPref('app.update.auto', js_bool($autoupdating)),
    ##     # http://kb.mozillazine.org/App.update.mode
    ##     #   0: download all updates without any prompt
    ##     #   1 (default): download all updates only if there are no incompatibilities with enabled extensions, prompt otherwise
    ##     #   2: download minor updates only, prompt for major updates, regardless of whether or not all enabled extensions are compatible.
    ##     lockPref('app.update.mode', js_int($autoupdating?0:2)),
    ## ],

    # things that the user should be able to change.
    build_path($prefs_dir,'user.js') =&gt; [
        user_pref('extensions.shownSelectionUI', js_bool(1)),
        #user_pref('extensions.autoDisableScopes', js_int(0)),
        user_pref('extensions.enabledScopes', js_int(15)),
    ],

    # update streams/sources
    build_path($prefs_dir,'channel-prefs.js') =&gt; [
        # Because FF 24 ESR doesn't do silent updating, we're going
        #   to use a newer version that does autoupdate. It must use
        #   the release channel. Leave this setting at the default.
        #pref('app.update.channel', js_str('esr')),

        pref('extensions.enabledScopes', js_int(15)),
        #user_pref('extensions.autoDisableScopes', js_int(0)),
    ],

);

my %ini_files = (
    build_path($install_source,'core','browser','override.ini') =&gt; {
        'XRE' =&gt; {
            # Don't ask about importing settings.
            'EnableProfileMigrator' =&gt; 'false',
        },
    },
);


# Regular Expressions used to discern if something is related to 
#   Firefox (or the application install).
my $ffRegex     = qr/firefox\.([0-9]+)?x?/i;
my $ffNameRegex = qr/Mozilla Firefox/;


# Array of locations where we can find old firefox keys or files (any found are deleted)

# These keys and directories are checked to see if they contain a
#   child that matches one of the regexes.
my $sw_key = 'HKEY_LOCAL_MACHINE\SOFTWARE';
my $sw32_key = 'HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node';
my @ffRegKeys = (
    ( map { $sw_key . $_ }
      '\Microsoft\Active Setup\Installed Components',
      '\UMR\Install\Product_List',
    ),
    ( map { $sw32_key . $_ }
      '\Microsoft\Active Setup\Installed Components',
    ),
);

my @ffFiles = (
    ( map { build_path(get_arch_programfiles($APP_ARCH),$_) }
      '\Mozilla Firefox',
      '\Mozilla Maintenance Service',
    ),
    ( map { build_path(get_allusers_scripts(),$_) }
      '\standard\firefox',
      '\standard\firefox15',
      '\standard\firefox.21x',
      '\standard\firefox.x',
      '\standard\firefox.24',
    ),
);

# END Configuration
########################################################################

sub usage {
    print qq(
usage: $0 [--help] [--uninstall] [--[no-]-autoupdate]
          [--install-source &lt;path_to_install_media&gt;]
          [--system-default-browser]

--install-source
  Use an alternate directory as the install media.
  It can be relative to the &lt;data&gt; directory or an absolute path.

--system-default-browser
  Make Firefox the system default web browser.
  This should only be done after Firefox is already installed.

);
}
Getopt::Long::Configure(qw(pass_through));
GetOptions(
    'help'       =&gt; sub { usage(); exit(0); },

    'uninstall'  =&gt; sub { exit(! uninstall()) },

    'extensions!' =&gt; \$install_extensions,

    'system-default-browser' =&gt; sub {
        exit( ! make_system_default_browser() );
    },

    'code=s' =&gt; sub {
        eval {
            exit( ! eval($_[1]) );
        };
        if ($@) {
            output($@);
            exit($@);
        }
    },
);

if (! $install_extensions) {
    output("[CONFIG] Not installing any extensions.\n");
}


sub prepare_for_install {
    # Remove any trace of a Firefox install on this machine.
    my $success = uninstall();

    # Generate the install INI file.
    # This file is critical to the app install.
    generate_ini_file($install_ini_file,$install_ini_data)
        or return 0;
    
    # Generate the config files.
    foreach my $js_file (keys(%preferences)) {
        $success &amp;&amp;= generate_js_file($js_file,$preferences{$js_file});
    }
    # INI file(s)
    foreach my $ini_file (keys(%ini_files)) {
        $success &amp;&amp;= generate_ini_file($ini_file,$ini_files{$ini_file});
    }

    # Unpack the CCK2 autoconfig.
    output("Extracting CCK2 package (${cck_archive}).\n", LOG_ONLY);
    my $cck2 = Archive::Extract-&gt;new( archive =&gt; $cck_archive );
    $cck2-&gt;extract( to =&gt; build_path($install_source,'core') );

    return $success;
}




sub install {
    output("   Installing Firefox: ");

    # The install media is just the files extracted from the FF installer.
    # Installer Command-Line Options:
    #   https://wiki.mozilla.org/Installer:Command_Line_Arguments
    my @command = (
        'cmd','/c','start','/wait','""',
        cmd_quote(build_path($install_source,'setup.exe')),
#        '-ma', # ??
        '/INI='.cmd_quote($install_ini_file),
        );

    # Copy the default log file.
    sleep(5); # It doesn't get copied to the install dir right away.
    my $log_file = build_path($install_dir,'install.log');
    if ( -f $log_file ) {
        copy($log_file,get_default_app_log()) ||
            output("Error copying log file '${log_file}': $!\n", LOG_ONLY);
    } else {
        output("No install log found: '${log_file}'!", LOG_ONLY);
    }

    if(! run_command(join(' ',@command))) {
        output("FAILED\n");
        return 0;
    }
    output("OK\n");
    return 1;
}

sub postinstall
{
    my $success = 1;

    if ($install_extensions) {
        $success &amp;&amp;= install_extensions();
    }

  # my $base = $Registry-&gt;{'HKEY_LOCAL_MACHINE\\SOFTWARE'};
  # my $ffExt;

  #The override.ini file disables the bookmark import wizard on startup
  #This was moved in FF21
  # output("Disabling prompts: ");
  # if(!run_command("xcopy \"$sourcefilesdir\\override.ini\" \"$programfiles\\Mozilla Firefox\\browser\\\" /E /Y /I /C"))
  # {
  #   output("failed\n");
  #   return 0;
  # }
  # else
  # {
  #   output("done\n");
  # }

  # Auto updating changing
  #updating( );
  
  #This loads our extension which has some basic settings and our certificate in it
  # output("Installing extension: ");
  
  # mkdir "$programfiles\\Mozilla Firefox\\extensions";
  # if(!run_command("copy \"$sourcefilesdir\\mstcck.3\\mstcck.xpi\" \"$programfiles\\Mozilla Firefox\\browser\\extensions\\\" "))
  # {
  #   output("failed to copy extension\n");
  # }
  
  # if(detect_os_architecture() eq "x64")
  # {
  #   $ffExt = $base-&gt;{'Wow6432Node\\Mozilla\\Firefox'};
  # }
  # else
  # {
  #   $ffExt = $base-&gt;{'Mozilla\\Firefox'};
  # }

  # $ffExt-&gt;{''} = 
  # {
  #   'Extensions\\' =&gt; 
  #   {
  #     '\\ffcust@mst.edu' =&gt; 'C:\\Program Files (x86)\\Mozilla Firefox\\browser\\extensions\\mstcck.xpi',    #This may change if the extension is repackaged, see install.rdf's first em:id field
  #   }, 
  # };

  # if(defined $ffExt-&gt;{'Extensions\\ffcust@mst.edu'})
  # {
  #   output("done\n");
  # }
  # else
  # {
  #   output("failed to install extension\n");
  #   return 0;
  # }

  # # Installs muroot.der
  # if(!install_custom_certificates())
  # {
  #   output("failed\n");
  #   return 0;
  # }
  # else
  # {
  #   output("done\n");
  # }

  return $success;
}

do_install(
    allowed_versions         =&gt; [ OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2,
                                  OSVER_WIN7_SP0, OSVER_WIN7_SP1,
                                  OSVER_WIN81_SP0, ],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs             =&gt; [ qw(clc desktop traveling
                                     virtual-clc virtual-desktop) ],
    exit_on_failure          =&gt; 1,
    no_install_check         =&gt; 1, # autoupdating makes this less meaningful

    preinstall_sub           =&gt; \&amp;prepare_for_install,
    install_sub              =&gt; \&amp;install,
    postinstall_sub          =&gt; \&amp;postinstall,
);
IM_Exit(EXIT_SUCCESS);


# Begin-Doc
################################
# Name: install_custom_certificates()
# Description: Install any certificates specified by %certs_to_add.
# Returns: true/false on success/failure of installig ALL certificates
# Requires: certutil.exe (copied into the data directory), File::Path (mkpath)
# OrigionallyWrittenBy: Todd Hartman
# LastUpdated: 7/17/2013
# LastUpdatedBy: Billy Rhoades
#	Copied from the Firefox 15.0 script and cleaned up
# Changed many directories due to Mozilla adding a "browser/" before everything
# Had to rewrite some of the function to accept the new folder names (some aren't created on install)
################################
# End-Doc
sub install_custom_certificates
{
  my $success = 1;
  my $certutil_exe_short = build_path_short($sourcefilesdir, $certutil_exe);
  mkpath "$install_dir\\browser\\defaults\\profile";
  my $default_profile_dir = build_path_short($install_dir, 'browser', 'defaults', 'profile');

  if(%certs_to_add)
  {
    output("Installing custom certificates: ");
    foreach my $cert (keys %certs_to_add)
    {
      my $nick      = $certs_to_add{$cert};
      my $cert_file = $sourcefilesdir . '\\' . $cert;
      my $cmd = join(
        ' ',
        $certutil_exe_short,
        '-A',
        '-i', "\"$cert_file\"",
        '-n', "\"${nick}\"",
        '-t "TCu,TCu,TCu"',    # encryption uses
        '-d', "\"$default_profile_dir\"",);
      $success &amp;= run_command($cmd);
    }
  }

  return $success;
}

# Begin-Doc
################################
# Name: uninstall()
# Description: Uninstalls Firefox or cleans up directories depending
#    on stage chosen. Each stage chosen always progresses to next
#    during check.
# Returns: true/false on respective success/failure of uninstalling
# Requires: Win32::TieRegistry, File::Path
# OrigionallyWrittenBy: Billy Rhoades
# LastUpdated: 2014-05-08
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub uninstall
{
    output('   Killing any running Firefox processes: ');
    my $tries = 10; # Give FF 10 seconds to shut down.
    while (!KillProcess('firefox.exe')) {
        last if (--$tries == 0);
        sleep(1);
    }
    if ($tries == 0) {
        output("FAILED\n");
        return 0;
    }
    output("OK\n");

    # Uninstall the program using the registry uninstall keys and then proceed
    my $i        = 0;
    my $retval   = 1;
    my @app_keys = IsAppInstalled('DisplayName' =&gt; $ffNameRegex);

    # This gets a bit complicated. We're just running the add or
    # remove program command and if the exe it needs isn't there or
    # isn't working, removing the entry and letting the rest of the
    # script clean up.
    foreach my $app_key (@app_keys)
    {
      my $uninst = $Registry-&gt;{$app_key};
      my $result;
      
      print "\tUninstalling " . $uninst-&gt;{'DisplayName'} . ": ";
      if($uninst-&gt;{'UninstallString'} =~ /^C\:\\.*\.[A-Za-z0-9]+$/
         &amp;&amp; !(-e $uninst-&gt;{'UninstallString'}))
      {
        output("broken install\n");
        delete $Registry-&gt;{$app_key};
        next;
      }
      
      #Older versions lack the quotes. 22+ seems to have them, 
      #and it gets angry if you use double quotes.
      if( $uninst-&gt;{'UninstallString'} =~ m/"/ )
      {
        $result = run_command($uninst-&gt;{'UninstallString'}." -ms");
      }
      else
      {
        $result = run_command("\"".$uninst-&gt;{'UninstallString'}."\" -ms");
      }
      
      sleep(5);    #Firefox's helper.exe forks, give it a chance to uninstall

      if($result)
      {
        output("done\n");
      }
      else
      {
        output("failed! Manually removing!\n");
      }
    }

    # Delete keys we created.
    my $moz_kloc =
        get_arch_software_key($APP_ARCH).'\Mozilla';
    if (exists($Registry-&gt;{$moz_kloc})) {
        foreach my $subkey ($Registry-&gt;{$moz_kloc}-&gt;SubKeyNames) {
            if ($subkey =~ /^(?:Mozilla )?Firefox/) {
                delete_keys_recursive($moz_kloc.'\\'.$subkey);
            }
        }
    }
    if (exists($Registry-&gt;{get_arch_software_key($APP_ARCH).'\mozilla.org'})) {
        delete_keys_recursive(get_arch_software_key($APP_ARCH).'\mozilla.org');
    }


    # Remove ActiveSetup keys and any UMRInst keys.
    my $count = 0;
    output("\tFinding hanging registry keys: ");

    foreach my $loc (@ffRegKeys)
    {
      my $key = $Registry-&gt;{$loc};

      foreach my $name (keys(%$key))
      {
        if($name =~ $ffRegex)
        {
          delete $Registry-&gt;{$loc}-&gt;{$name};
          $count++;
        }
      }
    }

    if($count &gt; 0)
    {
      output("deleted $count\n");
    }
    else
    {
      output("found none\n");
    }


    # Remove left over "boot" scripts used by ActiveSetup and any left
    #   over preferences from Firefox / Moz. Main. Service
    $count = 0;
    output("\tFinding old files: ");

    foreach my $loc (@ffFiles)
    {
      if(-e $loc)
      {
        $count += FileCount($loc);
        if($count &gt; 100)
        {
          output("\nWarning: One directory was loaded with files! Not deleting due to safeguard!\n");
          next;
        }

        rmtree($loc);
      }
    }

    if($count &gt; 0)
    {
      output("deleted $count\n");
    }
    else
    {
      output("found none\n");
    }


    return 1;
}

# Begin-Doc
################################
# Name: filecount(string)
# Description: Counts the files in a directory recursively.
# Returns: # of files
# Requires:
# OrigionallyWrittenBy: Billy Rhoades
# LastUpdated: 7/17/2013
################################
# End-Doc
sub FileCount
{
  my $loc   = $_[0];
  my $count = 0;
  my @files = glob("\"$loc\\*\"");

  foreach my $file (@files)
  {
    if(!($file =~ m/\.[A-Za-z0-9]+$/))
    {
      $count += FileCount($file);
      next;
    }
    $count++;
  }
  return $count;
}

# Begin-Doc
################################
# Name: updating()
# Description: Decides whether or not to do auto updating based on arguments.
# Returns: Success or failure boolean
# Requires:
# OrigionallyWrittenBy: Billy Rhoades
# LastUpdated: 1/7/2014
################################
# End-Doc
sub updating
{
  output( "Auto updating: " );
  # global variable set by command-line.
  if( $autoupdating )
  {
    if(run_command("copy \"$programfiles\\Mozilla Firefox\\defaults\\pref\\mozilla.au.cfg\" \"$programfiles\\Mozilla Firefox\\defaults\\pref\\mozilla.cfg\" "))
    {
      output( "Enabled\n" );
    }
    else
    {
      output( "Disabled! Could not enable!\n" );
      return 0;
    }
  }
  else
  {
    #Do nothing as, by default, our Firefox is packaged for no auto updates.
    output( "Disabled\n" );
  }

  return 1;
}


# Begin-Doc
################################
# Name: *pref()
# Description: generate a JavaScript *pref() statement for use in FF JS config files.
# Returns: string of the form 'pref(key,value);'
# LastUpdated: 2014-05-08
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub js_str {
    return '"'.$_[0].'"';
}
sub js_int {
    return $_[0];
}
sub js_bool {
    return $_[0]?'true':'false';
}
sub _pref {
    my $func = shift;
    my $key = shift;
    my $value = @_?(','.shift()):'';
    return sprintf('%s("%s"%s);',$func,$key,$value);
}
sub pref { return _pref('pref',@_); }
sub user_pref { return _pref('user_pref',@_); }
sub lockPref { return _pref('lockPref',@_); }
sub defaultPref { return _pref('defaultPref',@_); }
sub clearPref { return _pref('clearPref',@_); }

# Begin-Doc
################################
# Name: generate_js_file()
# Description: create a JavaScript file using the specified path and
#   array of JavaScript statements.
# Returns: true if the file is created and written to, false otherwise
# LastUpdated: 2014-05-08
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub generate_js_file {
    my $file = shift;
    my $js_stmts = shift; # arrayref

    output("Creating JavaScript file '${file}': ",LOG_ONLY);
    if (open(my $JS_FILE,'&gt;',$file)) {
        print $JS_FILE join("\n",@$js_stmts);
        close($JS_FILE);
    } else {
        output("FAILED\n",LOG_ONLY);
        output("FATAL ERROR: Cannot open JavaScript file for writing ".
               "'${file}': $!\n");
        return 0;
    }
    output("OK\n",LOG_ONLY);
    return 1;
    
}


# Begin-Doc
################################
# Name: build_ini()
# Description: generate data for an INI file given a hashref of
#   section/value/data.
# Returns: a string to write to an INI file.
# LastUpdated: 2014-05-08
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub build_ini_data {
    my $ini_prefs = shift;

    my $ini_data = '';
    foreach my $section (keys(%$ini_prefs)) {
        $ini_data .= sprintf("[\%s]\n",$section);
        my $section_data = $ini_prefs-&gt;{$section};
        foreach my $value (keys(%$section_data)) {
            my $data = $section_data-&gt;{$value};
            $ini_data .= sprintf("\%s=\%s\n",$value,$data);
        }
        $ini_data .= "\n";
    }

    return $ini_data;
}



# Begin-Doc
################################
# Name: generate_ini_file()
# Description: create an INI file using the specified path and (Perl) data.
# Returns: true if the file is created and written to, false otherwise
# LastUpdated: 2014-05-08
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub generate_ini_file {
    my $file = shift;
    my $data = shift;

    output("Creating INI file '${file}': ",LOG_ONLY);
    if (open(my $INSTALL_INI,'&gt;',$file)) {
        print $INSTALL_INI build_ini_data($data);
        close($INSTALL_INI);
    } else {
        output("FAILED\n",LOG_ONLY);
        output("FATAL ERROR: Cannot open INI file for writing ".
               "'${file}': $!\n");
        return 0;
    }
    output("OK\n",LOG_ONLY);
    return 1;
}


# I'm torn about how to do this.
#   System-Wide:
#     * I suspect that system-wide extensions won't get autoupdated.
#     * They are disabled by default. (extensions.sqlite)
#
#   Distribution Extensions
#     * They only get used when a profile is created?
#
sub install_extensions {
    my $success = 1;

    # https://developer.mozilla.org/en-US/docs/Adding_Extensions_using_the_Windows_Registry
    # Summary:
    #   &lt;em:id&gt; =&gt; &lt;path_to_unpacked_xpi&gt;
    my $ff_ext_kloc =
        get_arch_software_key($APP_ARCH).'\Mozilla\Firefox\Extensions';
    if (! create_ancestor_keys($ff_ext_kloc)) {
        output("Error creating Firefox extension registry key: $!\n");
        return 0
    }
    my $ff_ext_key = $Registry-&gt;{$ff_ext_kloc};

    # This is probably not fully functional.
    foreach my $ext_name (keys(%$systemwide_extensions)) {
        my $ext = $systemwide_extensions-&gt;{$ext_name};

        my $em_id = $ext-&gt;{em_id};
        my $xpi = build_path($sourcefilesdir,$ext-&gt;{xpi});

        output("[SYSTEM_EXTENSION] '${ext_name}' (em:id ${em_id}): ${xpi}\n", LOG_ONLY);

        # Extract the XPI.
        my $xpi_dest = build_path($install_dir,'browser','extensions',$em_id);
        my $xpi_archive =
            Archive::Extract-&gt;new( archive =&gt; $xpi, type =&gt; 'zip' );
        if (!$xpi_archive or $!) {
            output("Error opening archive '${xpi}': $!\n");
            $success = 0;
            next;
        }
        output("Extracting XPI (${xpi_archive}) to '${xpi_dest}': ", LOG_ONLY);
        my $outcome = $xpi_archive-&gt;extract( to =&gt; $xpi_dest );
        output(($outcome?'OK':('FAILED '.$!))."\n", LOG_ONLY);

        # Register the extension.
        $ff_ext_key-&gt;{$em_id} = $xpi_dest;

        # This might not be enough!
        # extensions.sqlite has info about extensions.
    }


    # Tell Firefox to install these extensions (for all users).
    #   The user will be prompted (once!) to choose to enable them.
    foreach my $ext_name (keys(%$distribution_extensions)) {
        my $ext = $distribution_extensions-&gt;{$ext_name};
        my $em_id = $ext-&gt;{em_id};
        my $xpi = build_path($sourcefilesdir,$ext-&gt;{xpi});

        output("[DISTRIBUTION_EXTENSION] '${ext_name}' (em:id ${em_id}): ${xpi}\n", LOG_ONLY);

        my $xpi_dest = build_path($distribution_ext_dir,$em_id.'.xpi');
        if (! -d $distribution_ext_dir &amp;&amp; ! make_path($distribution_ext_dir)) {
            output("Error creating XPI target dir '${distribution_ext_dir}': $!\n");
            $success = 0;
            next;
        }
        # Place the XPI where users can access it.
        if (!copy($xpi,$xpi_dest)) {
            output("   FAILED copying '${xpi}' to '${xpi_dest}': $!\n");
            $success = 0;
            next;
        }

        # Create a Registry value to tell Firefox to install the extension.
        # This must be a REG_SZ value.
        # Test without this. The file in the distribution\extensions dir
        #   ought to be enough.
        $ff_ext_key-&gt;{$em_id} = $xpi_dest;
    }

    return $success;
}


# Begin-Doc
################################
# Name: make_system_default_browser()
# Description: Attempt to detect the installed version of Firefox and make
#   it the (default) default browser.
# Returns: true if FF is detected and the command to make it the system default
#   succeeds (as best we can tell).
# LastUpdated: 2014-05-21
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub make_system_default_browser {
    foreach my $ff_key (IsAppInstalled( AppID =&gt; qr/^Mozilla Firefox /)) {
        # Take the first one that is found as the default.
        # It is assumed that there's only one.
        my $helper = $Registry-&gt;{$ff_key}-&gt;{UninstallString};
        $helper =~ s/"//g; # strip the quotes.
        output("Making Firefox (".dirname(dirname($helper)).
               ") the system default browser.\n");
        my @command = (
            cmd_quote($helper),
            '/SetAsDefaultAppGlobal',
            );
        my $outcome =
            run_command(join(' ',@command),
                        # I don't know why, but it always returns 2
                        #   (file not found), even when it succeeds.
                        IgnoreExitCodes =&gt; [ 2 ]);

        # Create a separate, detectable side effect.
        # For the sake of the SCCM detection.
        create_product_registry_key('default_browser.FF.1');

        return $outcome;
    }

    # If we didn't find Firefox, it can't be the default.
    output("No Firefox installation was detected. Not changing defaults...\n");
    return 0;
}
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\firefox.esr\prod\update.pl</FullName>
    <Length>15788</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-08-31T13:15:44.2199515-05:00</CreationTime>
    <CreationTimeUtc>2017-08-31T18:15:44.2199515Z</CreationTimeUtc>
    <LastWriteTime>2017-08-31T12:35:13.303441-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-08-31T17:35:13.303441Z</LastWriteTimeUtc>
    <LastAccessTime>2017-08-31T13:15:44.2199515-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-08-31T18:15:44.2199515Z</LastAccessTimeUtc>
    <Text># Package for Firefox 45.0 ESR
# Package Created July 16th, 2013
# Packaged by Billy Rhoades
# Last Updated 2015-09-08 by Ian Summers

# Update notes:
#   I've written this to be as easy to update in the future as
#   possible. Worst case, the extension needs to be updated. This
#   script should just need a few lines updated in it and the rest
#   shouldn't be too awful. Also, make sure you update the setup.exe.
#   There's extensive notes in the wiki page for firefox.x. This is
#   the ESR release of Firefox.

=pod
Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Comments:
    Known Issues:
    http://www.mozilla.org/en-US/firefox/24.2.0/releasenotes/

    Current Vulnerabilities:
    http://www.mozilla.org/security/known-vulnerabilities/firefox.html

Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc
=cut


# Browser Command-Line Options:
#   https://developer.mozilla.org/en-US/docs/Mozilla/Command_Line_Options
#

use strict;
use warnings;
use Win32::TieRegistry(Delimiter =&gt; "\\");
use File::Path;
use Getopt::Long;
use File::Basename;
use Archive::Extract;
use File::Copy;
use File::Path qw(make_path);

our %INSTALLMONKEY_OPTIONS;
BEGIN
{
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'firefox.esr',
        package_revision =&gt; '20160309T1200',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im', 
    $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 
    'C:\temp',
);
use InstallMonkey::Shared;


my $sourcefilesdir   = get_pkg_sourcefiles();
my $programfiles     = get_arch_programfiles(OSARCH_x86);


# CUSTOM SETTINGS:
#   \ffsetup\core\defaults\pref\channel-prefs.js
#   \ffsetup\core\defaults\pref\local-settings.js
#   \ffsetup\core\defaults\pref\user.js
#   \ffsetup\core\browser\override.ini
#   \ffsetup\core\mst.mozilla.cfg

# To Update:
#   1. Download the FF installer (an exe), and extract the contents.
#   2. If needed, make customizations using CCK2 (firefox extension)
#   3. Choose autoconfig, copy files from zip into \ffsetup\core

# This Package:
#   Copies the SourceFiles
#   Invokes the installer.
#   Preinstalls extensions.

# Mozilla Maintenance (Service)
#   https://wiki.mozilla.org/Windows_Service_Silent_Update
#   Log Dir: C:\ProgramData\Mozilla\logs


########################################################################
# BEGIN Configuration

my $APP_ARCH = OSARCH_x86;

# The directory with the extracted contents of the downloaded exe.
my $install_source = build_path($sourcefilesdir,'ffsetup.52.0esr');
my $install_ini_file = build_path($sourcefilesdir,'mst_install.ini');

# This is the default, but the customization needs to know.
my $install_dir = build_path(get_arch_programfiles($APP_ARCH),
                             'Mozilla Firefox');
my $distribution_ext_dir = build_path($install_dir,'distribution','extensions');

###################
# UPDATE 2016-03-09
# Extensions are installed using CCK2 now,
# IGNORE BELOW
###################

# This method of installation isn't perfect, but it seems like the most
#   supportable strategy.
#  * Add-ons get installed in the user profile.
#  * Add-ons get updated (by the user).
#  * Add-ons ONLY get installed into new profiles.
my $distribution_extensions = {
    'uBlock' =&gt; {
        em_id =&gt; '{2b10c1c8-a11f-4bad-fe9c-1c11e82cac42}',
        xpi   =&gt; 'uBlock.0_9_5_0.xpi' # rel to srcfiles
    },
};


########################################################################
# UNINSTALL DECLARATIONS

# Regular Expressions used to discern if something is related to 
#   Firefox (or the application install).
my $ffRegex     = qr/firefox\.([0-9]+)?x?/i;
my $ffNameRegex = qr/Mozilla Firefox|Nightly/;

# Array of locations where we can find old firefox keys or files (any found are deleted)
# These keys and directories are checked to see if they contain a
#   child that matches one of the regexes.
my $sw_key = 'HKEY_LOCAL_MACHINE\SOFTWARE';
my $sw32_key = 'HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node';
my @ffRegKeys = (
    ( map { $sw_key . $_ }
      '\Microsoft\Active Setup\Installed Components',
      '\UMR\Install\Product_List',
    ),
    ( map { $sw32_key . $_ }
      '\Microsoft\Active Setup\Installed Components',
    ),
);

my @ffFiles = (
    ( map { build_path(get_arch_programfiles($APP_ARCH),$_) }
      '\Mozilla Firefox',
      '\Mozilla Maintenance Service',
    ),
    ( map { build_path(get_allusers_scripts(),$_) }
      '\standard\firefox',
      '\standard\firefox15',
      '\standard\firefox.21x',
      '\standard\firefox.x',
      '\standard\firefox.24',
    ),
);
# END DECLARATIONS
########################################################################


# END Configuration
########################################################################

sub usage {
    print qq(
usage: $0 [--help] [--uninstall] [--[no-]-autoupdate]
          [--install-source &lt;path_to_install_media&gt;]
          [--system-default-browser]

--install-source
  Use an alternate directory as the install media.
  It can be relative to the &lt;data&gt; directory or an absolute path.

--system-default-browser
  Make Firefox the system default web browser.
  This should only be done after Firefox is already installed.

);
}

Getopt::Long::Configure(qw(pass_through));
GetOptions(
    'help'       =&gt; sub { usage(); exit(0); },

    'uninstall'  =&gt; sub { exit(! uninstall()) },

    'system-default-browser' =&gt; sub {
        exit( ! make_system_default_browser() );
    },

    'code=s' =&gt; sub {
        eval {
            exit( ! eval($_[1]) );
        };
        if ($@) {
            output($@);
            exit($@);
        }
    },
);

sub install {
    output("   Installing Firefox: ");

    # The install media is just the files extracted from the FF installer.
    # Installer Command-Line Options:
    #   https://wiki.mozilla.org/Installer:Command_Line_Arguments
    my @command = (
        'cmd','/c','start','/wait','""',
        cmd_quote(build_path($install_source,'setup.exe')),
        '/INI='.cmd_quote($install_ini_file),
        );

    if(! run_command(join(' ',@command))) {
        output("FAILED\n");
        return 0;
    }
    output("OK\n");
    
    # Copy the default log file.
    sleep(5); # It doesn't get copied to the install dir right away.
    my $log_file = build_path($install_dir,'install.log');
    if ( -f $log_file ) {
        copy($log_file,get_default_app_log()) ||
            output("Error copying log file '${log_file}': $!\n", LOG_ONLY);
    } else {
        output("No install log found: '${log_file}'!", LOG_ONLY);
    }
    
    return 1;
}

do_install(
    allowed_versions         =&gt; [ OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2,
                                  OSVER_WIN7_SP0, OSVER_WIN7_SP1,
                                  OSVER_WIN81_SP0, ],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs             =&gt; [ qw(clc desktop traveling
                                     virtual-clc virtual-desktop) ],
    exit_on_failure          =&gt; 1,
    no_install_check         =&gt; 1, # autoupdating makes this less meaningful

    preinstall_sub           =&gt; \&amp;uninstall,
    install_sub              =&gt; \&amp;install,
    
    # Handling extensions using CCK2 now
    # postinstall_sub          =&gt; \&amp;install_extensions,
);
IM_Exit(EXIT_SUCCESS);

# Begin-Doc
################################
# Name: uninstall()
# Description: Uninstalls Firefox or cleans up directories depending
#    on stage chosen. Each stage chosen always progresses to next
#    during check.
# Returns: true/false on respective success/failure of uninstalling
# Requires: Win32::TieRegistry, File::Path
# OrigionallyWrittenBy: Billy Rhoades
# LastUpdated: 2014-05-08
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub uninstall
{
    output('   Killing any running Firefox processes: ');
    my $tries = 10; # Give FF 10 seconds to shut down.
    while (!KillProcess('firefox.exe')) {
        last if (--$tries == 0);
        sleep(1);
    }
    if ($tries == 0) {
        output("FAILED\n");
        return 0;
    }
    output("OK\n");

    # Uninstall the program using the registry uninstall keys and then proceed
    my $i        = 0;
    my $retval   = 1;
    my @app_keys = IsAppInstalled('DisplayName' =&gt; $ffNameRegex);

    # This gets a bit complicated. We're just running the add or
    # remove program command and if the exe it needs isn't there or
    # isn't working, removing the entry and letting the rest of the
    # script clean up.
    foreach my $app_key (@app_keys)
    {
      my $uninst = $Registry-&gt;{$app_key};
      my $result;
      
      print "\tUninstalling " . $uninst-&gt;{'DisplayName'} . ": ";
      if($uninst-&gt;{'UninstallString'} =~ /^C\:\\.*\.[A-Za-z0-9]+$/
         &amp;&amp; !(-e $uninst-&gt;{'UninstallString'}))
      {
        output("broken install\n");
        delete $Registry-&gt;{$app_key};
        next;
      }
      
      #Older versions lack the quotes. 22+ seems to have them, 
      #and it gets angry if you use double quotes.
      if( $uninst-&gt;{'UninstallString'} =~ m/"/ )
      {
        $result = run_command($uninst-&gt;{'UninstallString'}." -ms");
      }
      else
      {
        $result = run_command("\"".$uninst-&gt;{'UninstallString'}."\" -ms");
      }
      
      sleep(5);    #Firefox's helper.exe forks, give it a chance to uninstall

      if($result)
      {
        output("done\n");
      }
      else
      {
        output("failed! Manually removing!\n");
      }
    }

    # Delete keys we created.
    my $moz_kloc =
        get_arch_software_key($APP_ARCH).'\Mozilla';
    if (exists($Registry-&gt;{$moz_kloc})) {
        foreach my $subkey ($Registry-&gt;{$moz_kloc}-&gt;SubKeyNames) {
            if ($subkey =~ /^(?:Mozilla )?Firefox/) {
                delete_keys_recursive($moz_kloc.'\\'.$subkey);
            }
        }
    }
    if (exists($Registry-&gt;{get_arch_software_key($APP_ARCH).'\mozilla.org'})) {
        delete_keys_recursive(get_arch_software_key($APP_ARCH).'\mozilla.org');
    }


    # Remove ActiveSetup keys and any UMRInst keys.
    my $count = 0;
    output("\tFinding hanging registry keys: ");

    foreach my $loc (@ffRegKeys)
    {
      my $key = $Registry-&gt;{$loc};

      foreach my $name (keys(%$key))
      {
        if($name =~ $ffRegex)
        {
          delete $Registry-&gt;{$loc}-&gt;{$name};
          $count++;
        }
      }
    }

    if($count &gt; 0)
    {
      output("deleted $count\n");
    }
    else
    {
      output("found none\n");
    }


    # Remove left over "boot" scripts used by ActiveSetup and any left
    #   over preferences from Firefox / Moz. Main. Service
    $count = 0;
    output("\tFinding old files: ");

    foreach my $loc (@ffFiles)
    {
      if(-e $loc)
      {
        $count += FileCount($loc);
        if($count &gt; 100)
        {
          output("\nWarning: One directory was loaded with files! Not deleting due to safeguard!\n");
          next;
        }

        rmtree($loc);
      }
    }

    if($count &gt; 0)
    {
      output("deleted $count\n");
    }
    else
    {
      output("found none\n");
    }


    return 1;
}

# Begin-Doc
################################
# Name: filecount(string)
# Description: Counts the files in a directory recursively.
# Returns: # of files
# Requires:
# OrigionallyWrittenBy: Billy Rhoades
# LastUpdated: 7/17/2013
################################
# End-Doc
sub FileCount
{
  my $loc   = $_[0];
  my $count = 0;
  my @files = glob("\"$loc\\*\"");

  foreach my $file (@files)
  {
    if(!($file =~ m/\.[A-Za-z0-9]+$/))
    {
      $count += FileCount($file);
      next;
    }
    $count++;
  }
  return $count;
}


# I'm torn about how to do this.
#   System-Wide:
#     * I suspect that system-wide extensions won't get autoupdated.
#     * They are disabled by default. (extensions.sqlite)
#
#   Distribution Extensions
#     * They only get used when a profile is created?
#
sub install_extensions {
    my $success = 1;

    # https://developer.mozilla.org/en-US/docs/Adding_Extensions_using_the_Windows_Registry
    # Summary:
    #   &lt;em:id&gt; =&gt; &lt;path_to_unpacked_xpi&gt;
    my $ff_ext_kloc =
        get_arch_software_key($APP_ARCH).'\Mozilla\Firefox\Extensions';
    if (! create_ancestor_keys($ff_ext_kloc)) {
        output("Error creating Firefox extension registry key: $!\n");
        return 0
    }
    my $ff_ext_key = $Registry-&gt;{$ff_ext_kloc};

    # Tell Firefox to install these extensions (for all users).
    #   The user will be prompted (once!) to choose to enable them.
    foreach my $ext_name (keys(%$distribution_extensions)) {
        my $ext = $distribution_extensions-&gt;{$ext_name};
        my $em_id = $ext-&gt;{em_id};
        my $xpi = build_path($sourcefilesdir,$ext-&gt;{xpi});

        output("[DISTRIBUTION_EXTENSION] '${ext_name}' (em:id ${em_id}): ${xpi}\n", LOG_ONLY);

        my $xpi_dest = build_path($distribution_ext_dir,$em_id.'.xpi');
        if (! -d $distribution_ext_dir &amp;&amp; ! make_path($distribution_ext_dir)) {
            output("Error creating XPI target dir '${distribution_ext_dir}': $!\n");
            $success = 0;
            next;
        }
        # Place the XPI where users can access it.
        if (!copy($xpi,$xpi_dest)) {
            output("   FAILED copying '${xpi}' to '${xpi_dest}': $!\n");
            $success = 0;
            next;
        }

        # Create a Registry value to tell Firefox to install the extension.
        # This must be a REG_SZ value.
        # Test without this. The file in the distribution\extensions dir
        #   ought to be enough.
        $ff_ext_key-&gt;{$em_id} = $xpi_dest;
    }

    return $success;
}


# Begin-Doc
################################
# Name: make_system_default_browser()
# Description: Attempt to detect the installed version of Firefox and make
#   it the (default) default browser.
# Returns: true if FF is detected and the command to make it the system default
#   succeeds (as best we can tell).
# LastUpdated: 2014-05-21
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub make_system_default_browser {
    foreach my $ff_key (IsAppInstalled( AppID =&gt; qr/^Mozilla Firefox /)) {
        # Take the first one that is found as the default.
        # It is assumed that there's only one.
        my $helper = $Registry-&gt;{$ff_key}-&gt;{UninstallString};
        $helper =~ s/"//g; # strip the quotes.
        output("Making Firefox (".dirname(dirname($helper)).
               ") the system default browser.\n");
        my @command = (
            cmd_quote($helper),
            '/SetAsDefaultAppGlobal',
            );
        my $outcome =
            run_command(join(' ',@command),
                        # I don't know why, but it always returns 2
                        #   (file not found), even when it succeeds.
                        IgnoreExitCodes =&gt; [ 2 ]);

        # Create a separate, detectable side effect.
        # For the sake of the SCCM detection.
        create_product_registry_key('default_browser.FF.1');

        return $outcome;
    }

    # If we didn't find Firefox, it can't be the default.
    output("No Firefox installation was detected. Not changing defaults...\n");
    return 0;
}
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\firefox.esr\prod-52\update.pl</FullName>
    <Length>16131</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-09-14T15:49:00.3026004-05:00</CreationTime>
    <CreationTimeUtc>2017-09-14T20:49:00.3026004Z</CreationTimeUtc>
    <LastWriteTime>2017-09-21T15:41:22.0456877-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-09-21T20:41:22.0456877Z</LastWriteTimeUtc>
    <LastAccessTime>2017-09-14T15:49:00.3026004-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-09-14T20:49:00.3026004Z</LastAccessTimeUtc>
    <Text># Package for Firefox 52.2.0 ESR
# Package Created June 22, 2017
# Packaged by Austin Wall
# Last Updated September 19, 2017

# Update notes:
#   I've written this to be as easy to update in the future as
#   possible. Worst case, the extension needs to be updated. This
#   script should just need a few lines updated in it and the rest
#   shouldn't be too awful. Also, make sure you update the setup.exe.
#   There's extensive notes in the wiki page for firefox.x. This is
#   the ESR release of Firefox.

=pod
Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Comments:
    Known Issues:
    http://www.mozilla.org/en-US/firefox/24.2.0/releasenotes/

    Current Vulnerabilities:
    http://www.mozilla.org/security/known-vulnerabilities/firefox.html

Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc
=cut


# Browser Command-Line Options:
#   https://developer.mozilla.org/en-US/docs/Mozilla/Command_Line_Options
#

use strict;
use warnings;
use Win32::TieRegistry(Delimiter =&gt; "\\");
use File::Path;
use Getopt::Long;
use File::Basename;
use Archive::Extract;
use File::Copy;
use File::Path qw(make_path);

our %INSTALLMONKEY_OPTIONS;
BEGIN
{
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'firefox.esr',
        package_revision =&gt; '20170622T1359',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im', 
    $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 
    'C:\temp',
);
use InstallMonkey::Shared;


my $sourcefilesdir   = get_pkg_sourcefiles();
my $programfiles     = get_arch_programfiles(OSARCH_x86);


# CUSTOM SETTINGS:
#   \ffsetup\core\defaults\pref\channel-prefs.js
#   \ffsetup\core\defaults\pref\local-settings.js
#   \ffsetup\core\defaults\pref\user.js
#   \ffsetup\core\browser\override.ini
#   \ffsetup\core\mst.mozilla.cfg

# To Update:
#   1. Download the FF installer (an exe), and extract the contents.
#   2. If needed, make customizations using CCK2 (firefox extension)
#   3. Choose autoconfig, copy files from zip into \ffsetup\core

# This Package:
#   Copies the SourceFiles
#   Invokes the installer.
#   Preinstalls extensions.

# Mozilla Maintenance (Service)
#   https://wiki.mozilla.org/Windows_Service_Silent_Update
#   Log Dir: C:\ProgramData\Mozilla\logs


########################################################################
# BEGIN Configuration

my $APP_ARCH = OSARCH_x64;

# The directory with the extracted contents of the downloaded exe.
my $install_source = build_path($sourcefilesdir,'ffsetup.52.2.0esr');
my $install_ini_file = build_path($sourcefilesdir,'mst_install.ini');

# This is the default, but the customization needs to know.
my $install_dir = build_path(get_arch_programfiles($APP_ARCH),
                             'Mozilla Firefox');
my $distribution_ext_dir = build_path($install_dir,'distribution','extensions');

###################
# UPDATE 2016-03-09
# Extensions are installed using CCK2 now,
# IGNORE BELOW
# UPDATE 2017-09-20
# Extensions are installed using this again,
# UNIGNORE BELOW
###################

# This method of installation isn't perfect, but it seems like the most
#   supportable strategy.
#  * Add-ons get installed in the user profile.
#  * Add-ons get updated (by the user).
#  * Add-ons ONLY get installed into new profiles.
my $distribution_extensions = {
    'uBlock0@raymondhill.net' =&gt; {
        em_id =&gt; 'uBlock0@raymondhill.net',
        xpi   =&gt; '\\\\minerfiles.mst.edu\dfs\software\loginscripts\firefox\uBlock0@raymondhill.net.xpi'
    },
};


########################################################################
# UNINSTALL DECLARATIONS

# Regular Expressions used to discern if something is related to 
#   Firefox (or the application install).
my $ffRegex     = qr/firefox\.([0-9]+)?x?/i;
my $ffNameRegex = qr/Mozilla Firefox|Nightly/;

# Array of locations where we can find old firefox keys or files (any found are deleted)
# These keys and directories are checked to see if they contain a
#   child that matches one of the regexes.
my $sw_key = 'HKEY_LOCAL_MACHINE\SOFTWARE';
my $sw32_key = 'HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node';
my @ffRegKeys = (
    ( map { $sw_key . $_ }
      '\Microsoft\Active Setup\Installed Components',
      '\UMR\Install\Product_List',
    ),
    ( map { $sw32_key . $_ }
      '\Microsoft\Active Setup\Installed Components',
    ),
);

my @ffFiles = (
    ( map { build_path(get_arch_programfiles($APP_ARCH),$_) }
      '\Mozilla Firefox',
      '\Mozilla Maintenance Service',
    ),
    ( map { build_path(get_allusers_scripts(),$_) }
      '\standard\firefox',
      '\standard\firefox15',
      '\standard\firefox.21x',
      '\standard\firefox.x',
      '\standard\firefox.24',
    ),
);
# END DECLARATIONS
########################################################################


# END Configuration
########################################################################

sub usage {
    print qq(
usage: $0 [--help] [--uninstall] [--[no-]-autoupdate]
          [--install-source &lt;path_to_install_media&gt;]
          [--system-default-browser]

--install-source
  Use an alternate directory as the install media.
  It can be relative to the &lt;data&gt; directory or an absolute path.

--system-default-browser
  Make Firefox the system default web browser.
  This should only be done after Firefox is already installed.

);
}

Getopt::Long::Configure(qw(pass_through));
GetOptions(
    'help'       =&gt; sub { usage(); exit(0); },

    'uninstall'  =&gt; sub { exit(! uninstall()) },

    'system-default-browser' =&gt; sub {
        exit( ! make_system_default_browser() );
    },

    'code=s' =&gt; sub {
        eval {
            exit( ! eval($_[1]) );
        };
        if ($@) {
            output($@);
            exit($@);
        }
    },
);

sub install {
    output("   Installing Firefox: ");

    # The install media is just the files extracted from the FF installer.
    # Installer Command-Line Options:
    #   https://wiki.mozilla.org/Installer:Command_Line_Arguments
    my @command = (
        'cmd','/c','start','/wait','""',
        cmd_quote(build_path($install_source,'setup.exe')),
        '/INI='.cmd_quote($install_ini_file),
        );

    if(! run_command(join(' ',@command))) {
        output("FAILED\n");
        return 0;
    }
    output("OK\n");
    
    # Copy the default log file.
    sleep(5); # It doesn't get copied to the install dir right away.
    my $log_file = build_path($install_dir,'install.log');
    if ( -f $log_file ) {
        copy($log_file,get_default_app_log()) ||
            output("Error copying log file '${log_file}': $!\n", LOG_ONLY);
    } else {
        output("No install log found: '${log_file}'!", LOG_ONLY);
    }
    
    return 1;
}

do_install(
    allowed_versions         =&gt; [ OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2,
                                  OSVER_WIN7_SP0, OSVER_WIN7_SP1,
                                  OSVER_WIN81_SP0, ],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs             =&gt; [ qw(clc desktop traveling
                                     virtual-clc virtual-desktop) ],
    exit_on_failure          =&gt; 1,
    no_install_check         =&gt; 1, # autoupdating makes this less meaningful

    preinstall_sub           =&gt; \&amp;uninstall,
    install_sub              =&gt; \&amp;install,
    postinstall_sub          =&gt; \&amp;install_extensions,
);
IM_Exit(EXIT_SUCCESS);

# Begin-Doc
################################
# Name: uninstall()
# Description: Uninstalls Firefox or cleans up directories depending
#    on stage chosen. Each stage chosen always progresses to next
#    during check.
# Returns: true/false on respective success/failure of uninstalling
# Requires: Win32::TieRegistry, File::Path
# OrigionallyWrittenBy: Billy Rhoades
# LastUpdated: 2014-05-08
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub uninstall
{
    output('   Killing any running Firefox processes: ');
    my $tries = 10; # Give FF 10 seconds to shut down.
    while (!KillProcess('firefox.exe')) {
        last if (--$tries == 0);
        sleep(1);
    }
    if ($tries == 0) {
        output("FAILED\n");
        return 0;
    }
    output("OK\n");

    # Uninstall the program using the registry uninstall keys and then proceed
    my $i        = 0;
    my $retval   = 1;
    my @app_keys = IsAppInstalled('DisplayName' =&gt; $ffNameRegex);

    # This gets a bit complicated. We're just running the add or
    # remove program command and if the exe it needs isn't there or
    # isn't working, removing the entry and letting the rest of the
    # script clean up.
    foreach my $app_key (@app_keys)
    {
      my $uninst = $Registry-&gt;{$app_key};
      my $result;
      
      print "\tUninstalling " . $uninst-&gt;{'DisplayName'} . ": ";
      if($uninst-&gt;{'UninstallString'} =~ /^C\:\\.*\.[A-Za-z0-9]+$/
         &amp;&amp; !(-e $uninst-&gt;{'UninstallString'}))
      {
        output("broken install\n");
        delete $Registry-&gt;{$app_key};
        next;
      }
      
      #Older versions lack the quotes. 22+ seems to have them, 
      #and it gets angry if you use double quotes.
      if( $uninst-&gt;{'UninstallString'} =~ m/"/ )
      {
        $result = run_command($uninst-&gt;{'UninstallString'}." -ms");
      }
      else
      {
        $result = run_command("\"".$uninst-&gt;{'UninstallString'}."\" -ms");
      }
      
      sleep(5);    #Firefox's helper.exe forks, give it a chance to uninstall

      if($result)
      {
        output("done\n");
      }
      else
      {
        output("failed! Manually removing!\n");
      }
    }

    # Delete keys we created.
    my $moz_kloc =
        get_arch_software_key($APP_ARCH).'\Mozilla';
    if (exists($Registry-&gt;{$moz_kloc})) {
        foreach my $subkey ($Registry-&gt;{$moz_kloc}-&gt;SubKeyNames) {
            if ($subkey =~ /^(?:Mozilla )?Firefox/) {
                delete_keys_recursive($moz_kloc.'\\'.$subkey);
            }
        }
    }
    if (exists($Registry-&gt;{get_arch_software_key($APP_ARCH).'\mozilla.org'})) {
        delete_keys_recursive(get_arch_software_key($APP_ARCH).'\mozilla.org');
    }


    # Remove ActiveSetup keys and any UMRInst keys.
    my $count = 0;
    output("\tFinding hanging registry keys: ");

    foreach my $loc (@ffRegKeys)
    {
      my $key = $Registry-&gt;{$loc};

      foreach my $name (keys(%$key))
      {
        if($name =~ $ffRegex)
        {
          delete $Registry-&gt;{$loc}-&gt;{$name};
          $count++;
        }
      }
    }

    if($count &gt; 0)
    {
      output("deleted $count\n");
    }
    else
    {
      output("found none\n");
    }


    # Remove left over "boot" scripts used by ActiveSetup and any left
    #   over preferences from Firefox / Moz. Main. Service
    $count = 0;
    output("\tFinding old files: ");

    foreach my $loc (@ffFiles)
    {
      if(-e $loc)
      {
        $count += FileCount($loc);
        if($count &gt; 100)
        {
          output("\nWarning: One directory was loaded with files! Not deleting due to safeguard!\n");
          next;
        }

        rmtree($loc);
      }
    }

    if($count &gt; 0)
    {
      output("deleted $count\n");
    }
    else
    {
      output("found none\n");
    }


    return 1;
}

# Begin-Doc
################################
# Name: filecount(string)
# Description: Counts the files in a directory recursively.
# Returns: # of files
# Requires:
# OrigionallyWrittenBy: Billy Rhoades
# LastUpdated: 7/17/2013
################################
# End-Doc
sub FileCount
{
  my $loc   = $_[0];
  my $count = 0;
  my @files = glob("\"$loc\\*\"");

  foreach my $file (@files)
  {
    if(!($file =~ m/\.[A-Za-z0-9]+$/))
    {
      $count += FileCount($file);
      next;
    }
    $count++;
  }
  return $count;
}


# I'm torn about how to do this.
#   System-Wide:
#     * I suspect that system-wide extensions won't get autoupdated.
#     * They are disabled by default. (extensions.sqlite)
#
#   Distribution Extensions
#     * They only get used when a profile is created?
#
#
#   Update: Austin Wall 9-20-2017
#       Using this to install extensions again. We needed to be able to manage the uBlock Origin extension's whitelist
#       and this was the best way I could find to make sure everyone is using a version that supports that.
sub install_extensions {
    my $success = 1;

    # https://developer.mozilla.org/en-US/docs/Adding_Extensions_using_the_Windows_Registry
    # Summary:
    #   &lt;em:id&gt; =&gt; &lt;path_to_unpacked_xpi&gt;
    my $ff_ext_kloc =
        get_arch_software_key($APP_ARCH).'\Mozilla\Firefox\Extensions';
    if (! create_ancestor_keys($ff_ext_kloc)) {
        output("Error creating Firefox extension registry key: $!\n");
        return 0
    }
    my $ff_ext_key = $Registry-&gt;{$ff_ext_kloc};

    # Tell Firefox to install these extensions (for all users).

    foreach my $ext_name (keys(%$distribution_extensions)) {
        my $ext = $distribution_extensions-&gt;{$ext_name};
        my $em_id = $ext-&gt;{em_id};
        my $xpi = $ext-&gt;{xpi};

        output("[DISTRIBUTION_EXTENSION] '${ext_name}' (em:id ${em_id}): ${xpi}\n", LOG_ONLY);

        
        # Create a Registry value to tell Firefox to install the extension.
        # This must be a REG_SZ value.
        $ff_ext_key-&gt;{$em_id} = $xpi;
    }

    
    
    #This will append a line to the system's logon.cmd script to run a perl script that will 
    # remove any existing version of uBlock or uBlock Origin from each user's profiles
    # and also copy over our default settings file for uBlock Origin.
    # These items are stored in:
    # \\minerfiles.mst.edu\dfs\software\loginscripts\firefox\
    output("Appending logon.cmd...\n");
    my $logon_path = 'C:\ProgramData\mst\standard\login\logon.cmd';
    open(my $fh, '&gt;&gt;', $logon_path) or warn "Could not open '$logon_path'";
    print $fh "\n".'perl \\\\minerfiles.mst.edu\dfs\software\loginscripts\firefox\manage_firefox_extensions.pl'."\n";
    close $fh;
    output("Done!\n");
    
    return $success;
}


# Begin-Doc
################################
# Name: make_system_default_browser()
# Description: Attempt to detect the installed version of Firefox and make
#   it the (default) default browser.
# Returns: true if FF is detected and the command to make it the system default
#   succeeds (as best we can tell).
# LastUpdated: 2014-05-21
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub make_system_default_browser {
    foreach my $ff_key (IsAppInstalled( AppID =&gt; qr/^Mozilla Firefox /)) {
        # Take the first one that is found as the default.
        # It is assumed that there's only one.
        my $helper = $Registry-&gt;{$ff_key}-&gt;{UninstallString};
        $helper =~ s/"//g; # strip the quotes.
        output("Making Firefox (".dirname(dirname($helper)).
               ") the system default browser.\n");
        my @command = (
            cmd_quote($helper),
            '/SetAsDefaultAppGlobal',
            );
        my $outcome =
            run_command(join(' ',@command),
                        # I don't know why, but it always returns 2
                        #   (file not found), even when it succeeds.
                        IgnoreExitCodes =&gt; [ 2 ]);

        # Create a separate, detectable side effect.
        # For the sake of the SCCM detection.
        create_product_registry_key('default_browser.FF.1');

        return $outcome;
    }

    # If we didn't find Firefox, it can't be the default.
    output("No Firefox installation was detected. Not changing defaults...\n");
    return 0;
}
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\firefox.esr\prod-hyperion\update.pl</FullName>
    <Length>15283</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-08-31T13:15:55.079565-05:00</CreationTime>
    <CreationTimeUtc>2017-08-31T18:15:55.079565Z</CreationTimeUtc>
    <LastWriteTime>2016-06-09T16:44:53.1330479-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-06-09T21:44:53.1330479Z</LastWriteTimeUtc>
    <LastAccessTime>2017-08-31T13:15:55.079565-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-08-31T18:15:55.079565Z</LastAccessTimeUtc>
    <Text># Package for Firefox 45.0 ESR
# Package Created July 16th, 2013
# Packaged by Billy Rhoades
# Last Updated 09-06-2016 by Austin Wall

# Update notes:
#   I've written this to be as easy to update in the future as
#   possible. Worst case, the extension needs to be updated. This
#   script should just need a few lines updated in it and the rest
#   shouldn't be too awful. Also, make sure you update the setup.exe.
#   There's extensive notes in the wiki page for firefox.x. This is
#   the ESR release of Firefox.

=pod
Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Comments:
    Known Issues:
    http://www.mozilla.org/en-US/firefox/24.2.0/releasenotes/

    Current Vulnerabilities:
    http://www.mozilla.org/security/known-vulnerabilities/firefox.html

Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc
=cut


# Browser Command-Line Options:
#   https://developer.mozilla.org/en-US/docs/Mozilla/Command_Line_Options
#

use strict;
use warnings;
use Win32::TieRegistry(Delimiter =&gt; "\\");
use File::Path;
use Getopt::Long;
use File::Basename;
use Archive::Extract;
use File::Copy;
use File::Path qw(make_path);

our %INSTALLMONKEY_OPTIONS;
BEGIN
{
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'firefox.esr',
        package_revision =&gt; '20160609T1636',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im', 
    $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 
    'C:\temp',
);
use InstallMonkey::Shared;


my $sourcefilesdir   = get_pkg_sourcefiles();
my $programfiles     = get_arch_programfiles(OSARCH_x86);


# CUSTOM SETTINGS:
#   \ffsetup\core\defaults\pref\channel-prefs.js
#   \ffsetup\core\defaults\pref\local-settings.js
#   \ffsetup\core\defaults\pref\user.js
#   \ffsetup\core\browser\override.ini
#   \ffsetup\core\mst.mozilla.cfg

# To Update:
#   1. Download the FF installer (an exe), and extract the contents.
#   2. If needed, make customizations using CCK2 (firefox extension)
#   3. Choose autoconfig, copy files from zip into \ffsetup\core

# This Package:
#   Copies the SourceFiles
#   Invokes the installer.
#   Preinstalls extensions.

# Mozilla Maintenance (Service)
#   https://wiki.mozilla.org/Windows_Service_Silent_Update
#   Log Dir: C:\ProgramData\Mozilla\logs


########################################################################
# BEGIN Configuration

my $APP_ARCH = OSARCH_x86;

# The directory with the extracted contents of the downloaded exe.
my $install_source = build_path($sourcefilesdir,'ffsetup.45.0esr');
my $install_ini_file = build_path($sourcefilesdir,'mst_install.ini');

# This is the default, but the customization needs to know.
my $install_dir = build_path(get_arch_programfiles($APP_ARCH),
                             'Mozilla Firefox');
my $distribution_ext_dir = build_path($install_dir,'distribution','extensions');

###################
# UPDATE 2016-03-09
# Extensions are installed using CCK2 now,
# IGNORE BELOW
###################

# This method of installation isn't perfect, but it seems like the most
#   supportable strategy.
#  * Add-ons get installed in the user profile.
#  * Add-ons get updated (by the user).
#  * Add-ons ONLY get installed into new profiles.
my $distribution_extensions = {
    'uBlock' =&gt; {
        em_id =&gt; '{2b10c1c8-a11f-4bad-fe9c-1c11e82cac42}',
        xpi   =&gt; 'uBlock.0_9_5_0.xpi' # rel to srcfiles
    },
};


########################################################################
# UNINSTALL DECLARATIONS

# Regular Expressions used to discern if something is related to 
#   Firefox (or the application install).
my $ffRegex     = qr/firefox\.(?!24)([0-9]+)?x?/i;
my $ffNameRegex = qr/(Mozilla Firefox|Nightly)(?!.*Hyperion|.*24.8)/i;

# Array of locations where we can find old firefox keys or files (any found are deleted)
# These keys and directories are checked to see if they contain a
#   child that matches one of the regexes.
my $sw_key = 'HKEY_LOCAL_MACHINE\SOFTWARE';
my $sw32_key = 'HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node';
my @ffRegKeys = (
    ( map { $sw_key . $_ }
      '\Microsoft\Active Setup\Installed Components',
      '\UMR\Install\Product_List',
    ),
    ( map { $sw32_key . $_ }
      '\Microsoft\Active Setup\Installed Components',
    ),
);

my @ffFiles = (
    ( map { build_path(get_arch_programfiles($APP_ARCH),$_) }
      '\Mozilla Firefox',
      '\Mozilla Maintenance Service',
    ),
    ( map { build_path(get_allusers_scripts(),$_) }
      '\standard\firefox',
      '\standard\firefox15',
      '\standard\firefox.21x',
      '\standard\firefox.x',
      '\standard\firefox.24',
    ),
);
# END DECLARATIONS
########################################################################


# END Configuration
########################################################################

sub usage {
    print qq(
usage: $0 [--help] [--uninstall] [--[no-]-autoupdate]
          [--install-source &lt;path_to_install_media&gt;]
          [--system-default-browser]

--install-source
  Use an alternate directory as the install media.
  It can be relative to the &lt;data&gt; directory or an absolute path.

--system-default-browser
  Make Firefox the system default web browser.
  This should only be done after Firefox is already installed.

);
}

Getopt::Long::Configure(qw(pass_through));
GetOptions(
    'help'       =&gt; sub { usage(); exit(0); },

    'uninstall'  =&gt; sub { exit(! uninstall()) },

    'system-default-browser' =&gt; sub {
        exit( ! make_system_default_browser() );
    },

    'code=s' =&gt; sub {
        eval {
            exit( ! eval($_[1]) );
        };
        if ($@) {
            output($@);
            exit($@);
        }
    },
);

sub install {
    output("   Installing Firefox: ");

    # The install media is just the files extracted from the FF installer.
    # Installer Command-Line Options:
    #   https://wiki.mozilla.org/Installer:Command_Line_Arguments
    my @command = (
        'cmd','/c','start','/wait','""',
        cmd_quote(build_path($install_source,'setup.exe')),
        '/INI='.cmd_quote($install_ini_file),
        );

    if(! run_command(join(' ',@command))) {
        output("FAILED\n");
        return 0;
    }
    output("OK\n");
    
    # Copy the default log file.
    sleep(5); # It doesn't get copied to the install dir right away.
    my $log_file = build_path($install_dir,'install.log');
    if ( -f $log_file ) {
        copy($log_file,get_default_app_log()) ||
            output("Error copying log file '${log_file}': $!\n", LOG_ONLY);
    } else {
        output("No install log found: '${log_file}'!", LOG_ONLY);
    }
    
    return 1;
}

do_install(
    allowed_versions         =&gt; [ OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2,
                                  OSVER_WIN7_SP0, OSVER_WIN7_SP1,
                                  OSVER_WIN81_SP0, ],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs             =&gt; [ qw(clc desktop traveling
                                     virtual-clc virtual-desktop) ],
    exit_on_failure          =&gt; 1,
    no_install_check         =&gt; 1, # autoupdating makes this less meaningful

    preinstall_sub           =&gt; \&amp;uninstall,
    install_sub              =&gt; \&amp;install,
    
    # Handling extensions using CCK2 now
    # postinstall_sub          =&gt; \&amp;install_extensions,
);
IM_Exit(EXIT_SUCCESS);

# Begin-Doc
################################
# Name: uninstall()
# Description: Uninstalls Firefox or cleans up directories depending
#    on stage chosen. Each stage chosen always progresses to next
#    during check.
# Returns: true/false on respective success/failure of uninstalling
# Requires: Win32::TieRegistry, File::Path
# OrigionallyWrittenBy: Billy Rhoades
# LastUpdated: 06-09-2016
# LastUpdatedBy: Austin Wall
################################
# End-Doc
sub uninstall
{
    output('   Killing any running Firefox processes: ');
    my $tries = 10; # Give FF 10 seconds to shut down.
    while (!KillProcess('firefox.exe')) {
        last if (--$tries == 0);
        sleep(1);
    }
    if ($tries == 0) {
        output("FAILED\n");
        return 0;
    }
    output("OK\n");

    # Uninstall the program using the registry uninstall keys and then proceed
    my $i        = 0;
    my $retval   = 1;
    my @app_keys = IsAppInstalled('DisplayName' =&gt; $ffNameRegex);

    # This gets a bit complicated. We're just running the add or
    # remove program command and if the exe it needs isn't there or
    # isn't working, removing the entry and letting the rest of the
    # script clean up.
    foreach my $app_key (@app_keys)
    {
      my $uninst = $Registry-&gt;{$app_key};
      my $result;
      
      print "\tUninstalling " . $uninst-&gt;{'DisplayName'} . ": ";
      if($uninst-&gt;{'UninstallString'} =~ /^C\:\\.*\.[A-Za-z0-9]+$/
         &amp;&amp; !(-e $uninst-&gt;{'UninstallString'}))
      {
        output("broken install\n");
        delete $Registry-&gt;{$app_key};
        next;
      }
      
      #Older versions lack the quotes. 22+ seems to have them, 
      #and it gets angry if you use double quotes.
      if( $uninst-&gt;{'UninstallString'} =~ m/"/ )
      {
        $result = run_command($uninst-&gt;{'UninstallString'}." -ms");
      }
      else
      {
        $result = run_command("\"".$uninst-&gt;{'UninstallString'}."\" -ms");
      }
      
      sleep(5);    #Firefox's helper.exe forks, give it a chance to uninstall

      if($result)
      {
        output("done\n");
      }
      else
      {
        output("failed! Manually removing!\n");
      }
    }
   


    # Remove ActiveSetup keys and any UMRInst keys.
    my $count = 0;
    output("\tFinding hanging registry keys: ");

    foreach my $loc (@ffRegKeys)
    {
      my $key = $Registry-&gt;{$loc};

      foreach my $name (keys(%$key))
      {
        if($name =~ $ffRegex)
        {
          delete $Registry-&gt;{$loc}-&gt;{$name};
          $count++;
        }
      }
    }

    if($count &gt; 0)
    {
      output("deleted $count\n");
    }
    else
    {
      output("found none\n");
    }


    # Remove left over "boot" scripts used by ActiveSetup and any left
    #   over preferences from Firefox / Moz. Main. Service
    $count = 0;
    output("\tFinding old files: ");

    foreach my $loc (@ffFiles)
    {
      if(-e $loc)
      {
        $count += FileCount($loc);
        if($count &gt; 100)
        {
          output("\nWarning: One directory was loaded with files! Not deleting due to safeguard!\n");
          next;
        }

        rmtree($loc);
      }
    }

    if($count &gt; 0)
    {
      output("deleted $count\n");
    }
    else
    {
      output("found none\n");
    }


    return 1;
}

# Begin-Doc
################################
# Name: filecount(string)
# Description: Counts the files in a directory recursively.
# Returns: # of files
# Requires:
# OrigionallyWrittenBy: Billy Rhoades
# LastUpdated: 7/17/2013
################################
# End-Doc
sub FileCount
{
  my $loc   = $_[0];
  my $count = 0;
  my @files = glob("\"$loc\\*\"");

  foreach my $file (@files)
  {
    if(!($file =~ m/\.[A-Za-z0-9]+$/))
    {
      $count += FileCount($file);
      next;
    }
    $count++;
  }
  return $count;
}


# I'm torn about how to do this.
#   System-Wide:
#     * I suspect that system-wide extensions won't get autoupdated.
#     * They are disabled by default. (extensions.sqlite)
#
#   Distribution Extensions
#     * They only get used when a profile is created?
#
sub install_extensions {
    my $success = 1;

    # https://developer.mozilla.org/en-US/docs/Adding_Extensions_using_the_Windows_Registry
    # Summary:
    #   &lt;em:id&gt; =&gt; &lt;path_to_unpacked_xpi&gt;
    my $ff_ext_kloc =
        get_arch_software_key($APP_ARCH).'\Mozilla\Firefox\Extensions';
    if (! create_ancestor_keys($ff_ext_kloc)) {
        output("Error creating Firefox extension registry key: $!\n");
        return 0
    }
    my $ff_ext_key = $Registry-&gt;{$ff_ext_kloc};

    # Tell Firefox to install these extensions (for all users).
    #   The user will be prompted (once!) to choose to enable them.
    foreach my $ext_name (keys(%$distribution_extensions)) {
        my $ext = $distribution_extensions-&gt;{$ext_name};
        my $em_id = $ext-&gt;{em_id};
        my $xpi = build_path($sourcefilesdir,$ext-&gt;{xpi});

        output("[DISTRIBUTION_EXTENSION] '${ext_name}' (em:id ${em_id}): ${xpi}\n", LOG_ONLY);

        my $xpi_dest = build_path($distribution_ext_dir,$em_id.'.xpi');
        if (! -d $distribution_ext_dir &amp;&amp; ! make_path($distribution_ext_dir)) {
            output("Error creating XPI target dir '${distribution_ext_dir}': $!\n");
            $success = 0;
            next;
        }
        # Place the XPI where users can access it.
        if (!copy($xpi,$xpi_dest)) {
            output("   FAILED copying '${xpi}' to '${xpi_dest}': $!\n");
            $success = 0;
            next;
        }

        # Create a Registry value to tell Firefox to install the extension.
        # This must be a REG_SZ value.
        # Test without this. The file in the distribution\extensions dir
        #   ought to be enough.
        $ff_ext_key-&gt;{$em_id} = $xpi_dest;
    }

    return $success;
}


# Begin-Doc
################################
# Name: make_system_default_browser()
# Description: Attempt to detect the installed version of Firefox and make
#   it the (default) default browser.
# Returns: true if FF is detected and the command to make it the system default
#   succeeds (as best we can tell).
# LastUpdated: 2014-05-21
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub make_system_default_browser {
    foreach my $ff_key (IsAppInstalled( AppID =&gt; qr/^Mozilla Firefox /)) {
        # Take the first one that is found as the default.
        # It is assumed that there's only one.
        my $helper = $Registry-&gt;{$ff_key}-&gt;{UninstallString};
        $helper =~ s/"//g; # strip the quotes.
        output("Making Firefox (".dirname(dirname($helper)).
               ") the system default browser.\n");
        my @command = (
            cmd_quote($helper),
            '/SetAsDefaultAppGlobal',
            );
        my $outcome =
            run_command(join(' ',@command),
                        # I don't know why, but it always returns 2
                        #   (file not found), even when it succeeds.
                        IgnoreExitCodes =&gt; [ 2 ]);

        # Create a separate, detectable side effect.
        # For the sake of the SCCM detection.
        create_product_registry_key('default_browser.FF.1');

        return $outcome;
    }

    # If we didn't find Firefox, it can't be the default.
    output("No Firefox installation was detected. Not changing defaults...\n");
    return 0;
}
</Text>
  </Script>
  <Script>
    <Name>update-test.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\Flash Player\prod\update-test.pl</FullName>
    <Length>229</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-10-16T15:04:38.3542158-05:00</CreationTime>
    <CreationTimeUtc>2017-10-16T20:04:38.3542158Z</CreationTimeUtc>
    <LastWriteTime>2011-04-19T16:39:29.0689907-05:00</LastWriteTime>
    <LastWriteTimeUtc>2011-04-19T21:39:29.0689907Z</LastWriteTimeUtc>
    <LastAccessTime>2017-10-16T15:04:38.3542158-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-10-16T20:04:38.3542158Z</LastAccessTimeUtc>
    <Text>use File::Basename;
use File::Spec;
my $cmd = 
    join(' ',
         'perl.exe',
         File::Spec-&gt;canonpath(File::Spec-&gt;catfile(dirname($0),'update.pl')),
         map { '"'.$_.'"' } @ARGV,
    );
system($cmd);


</Text>
  </Script>
  <Script>
    <Name>update-wrapper.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\Flash Player\prod\update-wrapper.pl</FullName>
    <Length>229</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-10-16T15:04:38.3698382-05:00</CreationTime>
    <CreationTimeUtc>2017-10-16T20:04:38.3698382Z</CreationTimeUtc>
    <LastWriteTime>2011-04-19T16:39:29.0689907-05:00</LastWriteTime>
    <LastWriteTimeUtc>2011-04-19T21:39:29.0689907Z</LastWriteTimeUtc>
    <LastAccessTime>2017-10-16T15:04:38.3698382-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-10-16T20:04:38.3698382Z</LastAccessTimeUtc>
    <Text>use File::Basename;
use File::Spec;
my $cmd = 
    join(' ',
         'perl.exe',
         File::Spec-&gt;canonpath(File::Spec-&gt;catfile(dirname($0),'update.pl')),
         map { '"'.$_.'"' } @ARGV,
    );
system($cmd);


</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\Flash Player\prod\update.pl</FullName>
    <Length>9604</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-10-16T15:04:38.3854568-05:00</CreationTime>
    <CreationTimeUtc>2017-10-16T20:04:38.3854568Z</CreationTimeUtc>
    <LastWriteTime>2017-10-17T16:28:25.2932441-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-10-17T21:28:25.2932441Z</LastWriteTimeUtc>
    <LastAccessTime>2017-10-16T15:04:38.3854568-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-10-16T20:04:38.3854568Z</LastAccessTimeUtc>
    <Text># Adobe Flash Player 11.x (latest)
# Package Created April 2009
# Packaged by Shanky Bhandari
# Last Updated 2014-04-28 by Todd Hartman

=pod

Begin-Doc
Modified: $Date: 2012-09-21 08:15:00 -0500 (Fri, 21 Sept 2012) $
Name: FlashPlayer 11 installer
Type: script
Description: install the latest revision of version 11 of Flash Player
Language: Perl
LastUpdatedBy: $Author: thartman $
Version: $Revision: 783 $
Doc-Package-Info: https://wiki.mst.edu/deskinst/change/applications/packaging/flashplayer.11
Doc-SVN-Repository: $URL: https://svn.mst.edu/project/itwindist/trunk/win7/appdist/flashplayer.11/prod/update.pl $
RCSId: $Id: update.pl 783 2011-08-22 11:40:48Z thartman $
End-Doc

=cut

# http://wwwimages.adobe.com/www.adobe.com/content/dam/Adobe/en/devnet/flashplayer/pdfs/flash_player_11_9_admin_guide.pdf

# "Latest Required" Version
#    http://fpdownload2.macromedia.com/get/flashplayer/update/current/xml/version_en_win_ax.xml

# Safe Versions Key:
#   HKLM\SOFTWARE\Macromedia\FlashPlayer\SafeVersions
#   HKLM\SOFTWARE\WOW6432NodeMacromedia\FlashPlayer\SafeVersions

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'flashplayer.27_0_0_170',
        #  version_releasedate_downloaddate
        # http://helpx.adobe.com/security/products/flash-player/apsb14-13.html
        package_revision =&gt; '27_0_0_170_20171016_20171016',
    );
}

use lib ( '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 'C:\temp', );
use InstallMonkey::Shared '1.6.0'; # requires some newer features
use File::Basename;
use File::Spec;
use File::Copy;
use File::Path;
use Getopt::Long;
use POSIX qw(strftime);
use Win32::TieRegistry;

my $sourceFiles = get_pkg_sourcefiles();

my $appver = get_version();

my $warn = 0;

########################################################################
# BEGIN Configuration

my @installers_x64 = (
    #'install_flash_player_27_active_x.msi', No longer needed, windows manages flash player updates for IE/Edge
    'install_flash_player_27_plugin.msi'
);

# The "warn user" code is here so that the update packages are
#   essentially the same as the app package.
# IE and Chrome didn't break in my testing, but let's kill them
#   off just to be on the safe side.
# As of v11.4.402.278, this no longer seems to be necessary, 
#   but I'll leave it just to be safe
my @must_kill_processes =
    qw(iexplore.exe firefox.exe opera.exe safari.exe chrome.exe);


# It is assumed that these files are each copied to each of the @fp_dirs
#   directories (without any underlying directory structure).
my @config_files = (
    'mms.cfg',
);

my @fp_dirs = (
    build_path( $ENV{WINDIR},'System32','Macromed','Flash' ),
    build_path( $ENV{WINDIR},'SysWOW64','Macromed','Flash' ),
);

#
# As of 11.2 (?), the installer creates a service (AdobeFlashPlayerUpdateSvc)
#   that checks the config file, then (optionally) checks and installs
#   any updates.
# It also creates a scheduled task that runs every hour.
#
# Manually starting the service will force an update check.
#


# END Configuration
########################################################################

my %app_architecture;
foreach my $i (@installers_x64) { $app_architecture{$i} = OSARCH_x64; }


GetOptions(
    'warn' =&gt; \$warn,

    'config' =&gt; sub { exit(!configure_flashplayer_settings()); }
);



# Begin-Doc
################################
# Name: preinstall
# Description: Prepare the machine for the install.
################################
# End-Doc
sub preinstall {
    if($warn){
        my $title = "-title \"Close Internet Browsers\" ";
        my $message = "-message \"Flash player is scheduled to be updated on this computer. This update will force close all internet browsers. Please close all internet browsers now.\" ";
        my $messageHeight = "-message-height 80 ";
        my $windowHeight = "-height 230 ";
        run_command("$sourceFiles\\countdown.exe ".$title.$message.$messageHeight.$windowHeight);
    }

    # The plug-in cannot install if any browser is using it.
    output("   Closing browser windows...\n");
    KillProcess(@must_kill_processes);
    return 1;
}



sub install_x64 {
    return install(\@installers_x64);
}

# Begin-Doc
################################
# Name: install()
# Description: installs flash player.
# Returns: true/false on success/failure (pass-through, AND-ed)
# LastUpdated: 2011-10-05
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub install {
    my $installers = shift;

    my $success = 1;

    foreach my $installer (@$installers) {
        my $srcInstaller = build_path($sourceFiles,$installer);

        my $logfile_name = $installer;
        $logfile_name =~ s/[.\s-]/_/g;
        $logfile_name .= '-'.$appver.'.txt';
        $logfile_name = get_package_id().'-'.$logfile_name;

        my $os_arch = detect_os_architecture();
        my $app_arch = $app_architecture{$installer};

        output("     ${installer}: ");
        my $outcome =
            install_msi(
                'msi'                       =&gt; $srcInstaller,
                'additional_msi_properties' =&gt; '',
                'logfile_name'              =&gt; $logfile_name,
                'logfile_indirection'       =&gt; ($app_arch ne $os_arch),
            );
        output(($outcome?'OK':'FAILED')."\n");

        $success &amp;= $outcome;
    }

    return $success;
}

do_install(
    allowed_versions =&gt; [ OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs     =&gt; [ 'clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    no_install_check =&gt; 1, # allow over-installs
    preinstall_sub   =&gt; \&amp;preinstall,
    install_sub_x64  =&gt; \&amp;install_x64,
    postinstall_sub  =&gt; \&amp;configure_flashplayer_settings,
    data_dir         =&gt; testing_data_dir(),
);
IM_Exit(EXIT_SUCCESS);


########################################################################

# Begin-Doc
################################
# Name: configure_flashplayer_settings()
# Description: Do any application/plugin configuration
#   Create the mms.cfg file that governs FlashPlayer behavior (including
#   security concerns).
# Returns: true/false on complete success/(partial) failure
# Requires: File::Copy
# LastUpdated: 2013-12-03
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub configure_flashplayer_settings {
    output("   Configuring FlashPlayer global settings:\n");

    my $success = 1;

    # We want this to be able to work even if the package isn't installed.
    # See if the SourceFiles directory exists. If not, try to use the 'data'
    #   directory.
    my $config_dir = get_pkg_sourcefiles();
    if (! -d $config_dir) {
        $config_dir = build_path(dirname(__FILE__),'data');
    }
    if (! -d $config_dir) {
        output("Error cannot locate a configuration file directory!\n");
        return 0;
    }

    my @_config_files = map { build_path($config_dir,$_) } @config_files;

    foreach my $dir (@fp_dirs) {
        foreach my $src_file (@_config_files) {
            my $target = build_path($dir,basename($src_file));
            output(sprintf("      Copying '\%s':\n    (from) \%s\n      (to) \%s\n",
                           basename($src_file),$src_file,$target));
            if (! copy($src_file,$target)) {
                output("   ERROR: $! $?\n");
                $success = 0;
            }
        }
    }

    return $success;
}        



# Begin-Doc
################################
# Name: testing_data_dir
# Description: choose a data dir based on the name of this script
# Returns: the name of the data directory to use
#   If the script is named 'update-test.pl', use the directory matching
#     'data.*' that is lexically the highest.
# Comments:
#   This subroutine is designed to ease the frequent necessity of updating
#     the package. Rather than have to copy lots of things or manually
#     specify the data directory when testing updates on the command line
#     (which is not possible in a template install) or hardcoding the name
#     into the script (which frequently gets promoted and I forget to change
#     it), if the script is detected to be a "test" script, a good candidate
#     for the data dir is chosen. This should make it easier (and less error-
#     prone) to test and promote updates to the package.
# Requires:
#   File::Basename
#   File::Spec
# LastUpdated: 2011-03-24
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub testing_data_dir {
    if (basename(__FILE__) eq 'update-test.pl') {
        my $dir = dirname(__FILE__);
        if (opendir(my $DIR,$dir)) {
            my @candidates;
            while (defined(my $entry = readdir($DIR))) {
                my $target = build_path($dir,$entry);
                next if (! -d $target);
                next if ($entry !~ /^data\./);
                push(@candidates,$entry);
            }
            closedir($DIR);
            my @sorted = sort { $b cmp $a } @candidates;
            return $sorted[0];
        } else {
            output("Cannot open cwd '${dir}': $!\n");
            return undef; # This should cause an error, resulting in an abort.
        }
    } else {
        return 'data';
    }
}
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\forge.1_1\prod\update.pl</FullName>
    <Length>3639</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-07-20T11:05:30.5997234-05:00</CreationTime>
    <CreationTimeUtc>2016-07-20T16:05:30.5997234Z</CreationTimeUtc>
    <LastWriteTime>2016-07-20T14:11:11.9907768-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-07-20T19:11:11.9907768Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-20T11:05:30.5997234-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-20T16:05:30.5997234Z</LastAccessTimeUtc>
    <Text># Package Created May 2015
# Packaged by Billy Rhoades
# Last Updated 2015-05-28

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'forge.1_1_0.8_2_1', # This is a concatenation of NXT's version and THERCAST. 
        package_revision =&gt; '20160720T1445',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

GetOptions(
    'uninstall' =&gt; sub { exit(!uninstall()); },
);

sub uninstall {
    output("Uninstalling Forge Suite: ");

    if(!run_command("C:\\Windows\\SysWOW64\\msiexec.exe /x {6C8BC5EE-5E45-411B-B6EF-2637EADF0A9A} /quiet"))
    {
        output("Failed to uninstall Forge\n");
        return 0;
    }
    elsif(!run_command("C:\\Windows\\SysWOW64\\msiexec.exe /x {6135BAEB-63D7-441E-AF95-5B2EAE510490} /quiet"))
    {
        output("Failed to uninstall Thercast\n");
        return 0;
    }
    else
    {
        delete_product_registry_key(get_package_name().".".get_version());
        run_command("RD /Q /S C:\\Transvalor_Solutions");
        run_command("RD /Q /S %ProgramData%\\Microsoft\\Windows\\\"Start Menu\"\\Programs\\\"Transvalor Solutions\"");
        output("SUCCESS\n");
    }

    return 1;
}

my $srcfiles =  get_pkg_sourcefiles();

sub preinstall
{
  # Unzipping Forge and Thercast because some of the file names are really long
  # and this is a packaged program for the same company
  output( "Unzipping Files: " );
  if( !run_command("\"C:\\Program Files\\7-Zip\\7z.exe\" x -o\"$srcfiles\" \"$srcfiles\\forge_thercast.7z\"") )
  {
    output( "FAILED\n" );
    return 0;
  }
  output( "DONE\n" );
  output( "Removing Zipped File: ");
  if( !run_command("DEL /Q \"$srcfiles\\forge_thercast.7z\"") )
  {
    output( "FAILED\n");
  }
  output( "DONE\n");
  
  return 1;
}

sub install
{
    output("Installing Forge NxT: ");
    my $success = install_msi('msi' =&gt; $srcfiles.'\Forge NxT 1.1.0\Master_Installation\Forge_NxT_1.1.msi');
    output($success?"Done\n":"Failed\n");
    
    #output("Installing NxT Update: ");
    #KillProcess("guardbarrier.exe");
    #$success &amp;&amp;= run_command("$srcfiles\\Patch_Forge_NxT_1.0.1_x64.exe /S /v\"/qn\"");
    #output($success?"Done\n":"Failed\n");
    
    output("Installing Thercast: ");
    $success &amp;&amp;= run_command("\"$srcfiles\\THERCAST 8.2.1\\Master_Installation\\Thercast_8.2_x64.exe\" /S /v\"/qn\"");
    output($success?"Done\n":"Failed\n");
    
    return $success;
}

sub postinstall
{
    output("\nDeleting Desktop icons...");
    my $desk = get_allusers_desktop();
    my $start_menu = get_allusers_start_menu();
    run_command("del /q $desk\\FORGE*.lnk");
    run_command("del /q $desk\\THERCAST*.lnk");
    
    run_command("copy $srcfiles\\license.dat \"C:\\Program Files (x86)\\Common Files\\Transvalor Solutions\\Licenses\\license.dat\" /y");
    run_command("xcopy \"$srcfiles\\Start Menu\" \"$start_menu\" /Y/Q/I/E");
    
    return 1;
}

do_install( 
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [ 'clc', 'desktop', 'traveling',
                      'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
   # msi_name =&gt; 'deepsoil.msi',
   # additional_msi_properties =&gt; 'REBOOT="ReallySuppress"',
    postinstall_sub =&gt; \&amp;postinstall,
);
IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\freepascal.3_0_2\prod\update.pl</FullName>
    <Length>2125</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-05-26T10:35:41.5348917-05:00</CreationTime>
    <CreationTimeUtc>2017-05-26T15:35:41.5348917Z</CreationTimeUtc>
    <LastWriteTime>2017-05-26T10:38:28.0524939-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-05-26T15:38:28.0524939Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-14T15:16:29-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-14T20:16:29Z</LastAccessTimeUtc>
    <Text># FreePascal 3.0.2
# Package Created May 26, 2017
# Packaged by Austin Wall
# Last Updated May 26, 2017 by Austin Wall

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'freepascal.3_0_2',
        package_revision =&gt; '20170526T1036',
    );

}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

use Getopt::Long;
GetOptions(
    'uninstall' =&gt; sub { exit(!uninstall()); },
);

my $installer = build_path(get_pkg_sourcefiles(), 'fpc-3.0.2.i386-win32.exe');
my $uninstaller = build_path("C:\\FPC\\3.0.2", "unins000.exe");
my $moddir = "C:\\FPC\\3.0.2\\bin\\i386-win32";

do_install( 
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [ OSARCH_x64, OSARCH_x86 ],
    allowed_regs =&gt; [ 'clc', 'desktop', 'traveling',
                      'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    application_architecture =&gt; OSARCH_x86,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;post_install,
    uninstall_sub =&gt; \&amp;uninstall,
);

IM_Exit(EXIT_SUCCESS);

sub install {
    my $success = run_command("\"$installer\" /VERYSILENT /NOCANCEL /TASKS=\"!desktopicon\""); #http://www.jrsoftware.org/ishelp/index.php?topic=setupcmdline
    if($success) {
        output("Free Pascal 3 Installed.\n");
    }
    else {
        output("Free Pascal could not be installed.\n");
        return 0;
    }
    return $success;
}

sub post_install {
    my $success = run_command("icacls \"$moddir\" /grant Users:(OI)(CI)M");
    if($success) {
        output("Permissions set.\n");
    }
    else { 
        output("Unable to set permissions.\n");
    }
    return $success;
}

sub uninstall {
    output("Trying to uninstall...\n");
    my $success = run_command("\"$uninstaller\" /VERYSILENT");
    output($success ? "success!\n" : "FAILED: $!\n");
    if ($success) {
        delete_product_registry_key(get_package_name().".".get_version());
    }
    return $success;
}</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\freepascal.3_0_4\prod\update.pl</FullName>
    <Length>2217</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-02T10:23:31.3671438-05:00</CreationTime>
    <CreationTimeUtc>2018-05-02T15:23:31.3671438Z</CreationTimeUtc>
    <LastWriteTime>2018-05-08T10:42:48.9079485-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-08T15:42:48.9079485Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-02T10:23:31.3671438-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-02T15:23:31.3671438Z</LastAccessTimeUtc>
    <Text># FreePascal 3.0.2
# Package Created May 2, 2018
# Packaged by Cameron Loren
# Last Updated May 2, 2018 by Cameron Loren

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'freepascal.3_0_4',
        package_revision =&gt; '20180502T1027',
    );

}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

use Getopt::Long;
GetOptions(
    'uninstall' =&gt; sub { exit(!uninstall()); },
);

my $installer = build_path(get_pkg_sourcefiles(), 'fpc-3.0.4.i386-win32.exe');
my $uninstaller = build_path("C:\\FPC\\3.0.4", "unins000.exe");
my $moddir = "C:\\FPC\\3.0.4\\bin\\i386-win32";

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [ OSARCH_x64, OSARCH_x86 ],
    allowed_regs =&gt; [ 'clc', 'desktop', 'traveling',
                      'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    application_architecture =&gt; OSARCH_x86,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;post_install,
    uninstall_sub =&gt; \&amp;uninstall,
);

IM_Exit(EXIT_SUCCESS);


sub install {
    #Call exe with /VERYSILENT /NOCANCEL /TASKS=\"!desktopicon\"
    my $success = run_command("\"$installer\" /VERYSILENT /NOCANCEL /TASKS=\"!desktopicon\""); #http://www.jrsoftware.org/ishelp/index.php?topic=setupcmdline
    if($success) {
        output("Free Pascal 3 Installed.\n");
    }
    else {
        output("Free Pascal could not be installed.\n");
        return 0;
    }
    return $success;
}

sub post_install {
    #Set permissions
    my $success = run_command("icacls \"$moddir\" /grant Users:(OI)(CI)M");
    if($success) {
        output("Permissions set.\n");
    }
    else {
        output("Unable to set permissions.\n");
    }
    return $success;
}

sub uninstall {
    output("Trying to uninstall...\n");
    my $success = run_command("\"$uninstaller\" /VERYSILENT");
    output($success ? "success!\n" : "FAILED: $!\n");
    if ($success) {
        delete_product_registry_key(get_package_name().".".get_version());
    }
    return $success;
}
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\geany.1_2\prod\update.pl</FullName>
    <Length>2294</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-15T10:19:00.3502025-05:00</CreationTime>
    <CreationTimeUtc>2017-06-15T15:19:00.3502025Z</CreationTimeUtc>
    <LastWriteTime>2017-05-24T15:53:28-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-05-24T20:53:28Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-14T10:28:26-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-14T15:28:26Z</LastAccessTimeUtc>
    <Text># Geany 1.30.1
# Packaged May 24, 2017 by Austin Wall
# Last updated May 24, 2017 by Austin Wall

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'geany.1_30_1',
        package_revision =&gt; '20170524T1548',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfilesdir = get_pkg_sourcefiles();
my $allUsersDesktop = get_allusers_desktop();
my $allUsersStartmenu = get_allusers_start_menu();

sub install {
  ##################################
  # Install the program!
  ##################################
  if(!run_command("\"$srcfilesdir\\geany-1.30.1_setup.exe\" /S")){
    output("Geany text editor was not installed correctly!\n");
    return 0;
  } else {
     output("Geany 1.30.1 has been installed!\n");
  }
  return 1;
}

sub postInstall {
  ##################################
  # Remove the desktop icon (.lnk)
  ##################################
  if(!run_command("DEL /q \"$allUsersDesktop\\Geany.lnk\"")){
    output("Could not delete desktop icon!\n");
    #return 0; # No reason to really stop on something like this
  } else {
    output("Removed desktop shortcut!\n");
  }
  ##############################################
  # Remove the uninstall from the start menu.
  ##############################################
  if(!run_command("DEL /q \"$allUsersStartmenu\\Programs\\Geany\\Uninstall.lnk\"")){
    output("Could not delete uninstall shortcut!\n");
    #return 0;
  } else {
    output("Removed uninstall shortcut!\n");
  }
  return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postInstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\geany.1_28\dev\update.pl</FullName>
    <Length>2457</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-07-14T09:37:18.0933401-05:00</CreationTime>
    <CreationTimeUtc>2016-07-14T14:37:18.0933401Z</CreationTimeUtc>
    <LastWriteTime>2016-07-14T14:46:34.0261781-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-07-14T19:46:34.0261781Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-14T09:37:18.0933401-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-14T14:37:18.0933401Z</LastAccessTimeUtc>
    <Text># Daniel T. Holtzclaw 7/14/16
# Geany 1.28

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'geany.1_28',
        package_revision =&gt; '20160714T0938',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfilesdir = get_pkg_sourcefiles();
my $allUsersDesktop = get_allusers_desktop();
my $allUsersStartmenu = get_allusers_start_menu();

sub install {
  ##################################
  # Install the program!
  ##################################
  if(!run_command("\"$srcfilesdir\\geany-1.28_setup.exe\" /S")){
    output("Geany text editor was not installed correctly!\n");
    return 0;
  } else {
     output("Geany 1.28 (with GTK 2.24) has been installed!\n");
  }
  return 1;
}

sub postInstall {
  ##################################
  # Remove the desktop icon (.lnk)
  ##################################
  if(!run_command("DEL /q \"$allUsersDesktop\\Geany.lnk\"")){
    output("Could not delete desktop icon!\n");
    #return 0; # No reason to really stop on something like this
  } else {
    output("Removed desktop shortcut!\n");
  }
  ##############################################
  # Remove the uninstall from the start menu.
  ##############################################
  if(!run_command("DEL /q \"$allUsersStartmenu\\Programs\\Geany\\Uninstall.lnk\"")){
    output("Could not delete uninstall shortcut!\n");
    #return 0;
  } else {
    output("Removed uninstall shortcut!\n");
  }
  return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postInstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\geany.1_28\prod\update.pl</FullName>
    <Length>2457</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-07-14T10:28:26.7503516-05:00</CreationTime>
    <CreationTimeUtc>2016-07-14T15:28:26.7503516Z</CreationTimeUtc>
    <LastWriteTime>2016-07-14T10:13:49.4362805-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-07-14T15:13:49.4362805Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-14T10:28:26.7503516-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-14T15:28:26.7503516Z</LastAccessTimeUtc>
    <Text># Daniel T. Holtzclaw 7/14/16
# Geany 1.28

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'geany.1_28',
        package_revision =&gt; '20160714T0938',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfilesdir = get_pkg_sourcefiles();
my $allUsersDesktop = get_allusers_desktop();
my $allUsersStartmenu = get_allusers_start_menu();

sub install {
  ##################################
  # Install the program!
  ##################################
  if(!run_command("\"$srcfilesdir\\geany-1.28_setup.exe\" /S")){
    output("Geany text editor was not installed correctly!\n");
    return 0;
  } else {
     output("Geany 1.28 (with GTK 2.24) has been installed!\n");
  }
  return 1;
}

sub postInstall {
  ##################################
  # Remove the desktop icon (.lnk)
  ##################################
  if(!run_command("DEL /q \"$allUsersDesktop\\Geany.lnk\"")){
    output("Could not delete desktop icon!\n");
    #return 0; # No reason to really stop on something like this
  } else {
    output("Removed desktop shortcut!\n");
  }
  ##############################################
  # Remove the uninstall from the start menu.
  ##############################################
  if(!run_command("DEL /q \"$allUsersStartmenu\\Programs\\Geany\\Uninstall.lnk\"")){
    output("Could not delete uninstall shortcut!\n");
    #return 0;
  } else {
    output("Removed uninstall shortcut!\n");
  }
  return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postInstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\geany.1_30_1\prod\update.pl</FullName>
    <Length>2294</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-05-24T15:43:49.4947535-05:00</CreationTime>
    <CreationTimeUtc>2017-05-24T20:43:49.4947535Z</CreationTimeUtc>
    <LastWriteTime>2017-05-24T15:53:28.2970841-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-05-24T20:53:28.2970841Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-14T10:28:26-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-14T15:28:26Z</LastAccessTimeUtc>
    <Text># Geany 1.30.1
# Packaged May 24, 2017 by Austin Wall
# Last updated May 24, 2017 by Austin Wall

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'geany.1_30_1',
        package_revision =&gt; '20170524T1548',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfilesdir = get_pkg_sourcefiles();
my $allUsersDesktop = get_allusers_desktop();
my $allUsersStartmenu = get_allusers_start_menu();

sub install {
  ##################################
  # Install the program!
  ##################################
  if(!run_command("\"$srcfilesdir\\geany-1.30.1_setup.exe\" /S")){
    output("Geany text editor was not installed correctly!\n");
    return 0;
  } else {
     output("Geany 1.30.1 has been installed!\n");
  }
  return 1;
}

sub postInstall {
  ##################################
  # Remove the desktop icon (.lnk)
  ##################################
  if(!run_command("DEL /q \"$allUsersDesktop\\Geany.lnk\"")){
    output("Could not delete desktop icon!\n");
    #return 0; # No reason to really stop on something like this
  } else {
    output("Removed desktop shortcut!\n");
  }
  ##############################################
  # Remove the uninstall from the start menu.
  ##############################################
  if(!run_command("DEL /q \"$allUsersStartmenu\\Programs\\Geany\\Uninstall.lnk\"")){
    output("Could not delete uninstall shortcut!\n");
    #return 0;
  } else {
    output("Removed uninstall shortcut!\n");
  }
  return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postInstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\geany.1_33\prod\update.pl</FullName>
    <Length>2294</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-17T08:47:29.6686032-05:00</CreationTime>
    <CreationTimeUtc>2018-05-17T13:47:29.6686032Z</CreationTimeUtc>
    <LastWriteTime>2018-05-17T08:49:30.72651-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-17T13:49:30.72651Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-17T08:47:29.6686032-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-17T13:47:29.6686032Z</LastAccessTimeUtc>
    <Text># Geany 1.30.1
# Packaged May 17, 2018 by Gavin Altermatt
# Last updated May 17, 2018 by Gavin Altermatt

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'geany.1_33',
        package_revision =&gt; '20180517T0848',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfilesdir = get_pkg_sourcefiles();
my $allUsersDesktop = get_allusers_desktop();
my $allUsersStartmenu = get_allusers_start_menu();

sub install {
  ##################################
  # Install the program!
  ##################################
  if(!run_command("\"$srcfilesdir\\geany-1.33_setup.exe\" /S")){
    output("Geany text editor was not installed correctly!\n");
    return 0;
  } else {
     output("Geany 1.33 has been installed!\n");
  }
  return 1;
}

sub postInstall {
  ##################################
  # Remove the desktop icon (.lnk)
  ##################################
  if(!run_command("DEL /q \"$allUsersDesktop\\Geany.lnk\"")){
    output("Could not delete desktop icon!\n");
    #return 0; # No reason to really stop on something like this
  } else {
    output("Removed desktop shortcut!\n");
  }
  ##############################################
  # Remove the uninstall from the start menu.
  ##############################################
  if(!run_command("DEL /q \"$allUsersStartmenu\\Programs\\Geany\\Uninstall.lnk\"")){
    output("Could not delete uninstall shortcut!\n");
    #return 0;
  } else {
    output("Removed uninstall shortcut!\n");
  }
  return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postInstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\geographics.2014\prod\update.pl</FullName>
    <Length>3623</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-02-13T13:38:22.0340606-06:00</CreationTime>
    <CreationTimeUtc>2018-02-13T19:38:22.0340606Z</CreationTimeUtc>
    <LastWriteTime>2018-03-08T14:48:09.1828179-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-03-08T20:48:09.1828179Z</LastWriteTimeUtc>
    <LastAccessTime>2018-03-05T10:26:49.8258446-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-03-05T16:26:49.8258446Z</LastAccessTimeUtc>
    <Text># GeoGraphics 2014
# Package Created February 13, 2018
# Packaged by Austin Wall and Grayson Gratop
# Last Updated --

BEGIN {
    %::INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'geographics.2014',
        package_revision =&gt; '20180213T1338',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Win32::GuiTest;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

sub get_window {
    my $window_title = shift;
    foreach my $window (Win32::GuiTest::GetChildWindows(Win32::GuiTest::GetDesktopWindow())) {
        my $text = Win32::GuiTest::GetWindowText($window);
        if ($text =~ /$window_title/) {
            return $window;
        }
    }
}

sub install {
    $| = 1; # i'd like to view things as i print them thank you

    output("Launching installer...\n");

    # launch installer in background
    run_command("start $srcfiles\\geo2014setup.exe /S");
    
    output("Waiting for the window to appear...\n");
    my $window_title = 'OnDemand'; 
    Win32::GuiTest::WaitWindow($window_title, 600);
    sleep(10);

    # if (!$results) {
    #     output("ERROR: Can't find the OnDemand Dashboard Setup window!\n");
    #     return 0;
    # }

    # only one window should have this title
    output("Clicking through the installer...\n");
    Win32::GuiTest::PushChildButton(get_window($window_title), 502);
    sleep(4);
    Win32::GuiTest::PushChildButton(get_window($window_title), 502);
    sleep(4);
    Win32::GuiTest::PushChildButton(get_window($window_title), 502);
    sleep(4);
    Win32::GuiTest::PushChildButton(get_window($window_title), 518);
    sleep(60);
    Win32::GuiTest::PushChildButton(get_window($window_title), 602);

    output("Waiting for the rest of the installer to finish...\n");
    sleep(60);
    
    output("Installation successful!");
    return 1;
}

sub postinstall {
# License info is stored in the registry under the current user. An active setup action is used to run a .reg file to import the keys. 
    output("Creating ActiveSetup action...\n");
    
    my $success = 1;

    $success &amp;&amp;= create_activesetup_action(
        'Identifier' =&gt; 'GeoGraphics.2014_License',
        'ComponentID' =&gt; 'GeoGraphics',
        'Description' =&gt; 'Import registry keys to activate GeoGraphics 2014',
        'Version' =&gt; '1',
        'StubPath' =&gt; "C:\\windows\\regedit.exe /S $srcfiles\\license.reg" 
    );

    if (!$success) {
        output("Failed to create ActiveSetup action for License!");
        return 0;
    }

    output("Creating Start Menu shortcut...\n");
    my $icon_dir = "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\mtech2014";

    if (!(-d $icon_dir)) {
        $success &amp;&amp;= run_command("mkdir \"$icon_dir\"");
    }

    $success &amp;&amp;= run_command("copy /Y \"$srcfiles\\GeoGraphics 2014.lnk\" \"$icon_dir\"");
    
    if (!$success) {
        output("Failed to create Start Menu shortcut!");
        return 0;
    }

    return $success;
}

do_install( 
    exit_on_failure =&gt; 1,
    allowed_versions          =&gt; [ OSVER_WIN10_SP0 ],
    allowed_os_architectures  =&gt; [ OSARCH_x64 ],
    allowed_regs              =&gt; [ "clc", "desktop", "traveling", "virtual-desktop", "virtual-clc" ],
    install_sub               =&gt; \&amp;install,
    postinstall_sub           =&gt; \&amp;postinstall,
    
);

IM_Exit(EXIT_SUCCESS);

########################################################################</Text>
  </Script>
  <Script>
    <Name>update_didntwork.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\geographics.2014\prod\update_didntwork.pl</FullName>
    <Length>1876</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-02-13T13:38:22.0340606-06:00</CreationTime>
    <CreationTimeUtc>2018-02-13T19:38:22.0340606Z</CreationTimeUtc>
    <LastWriteTime>2018-03-02T13:01:16.3114912-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-03-02T19:01:16.3114912Z</LastWriteTimeUtc>
    <LastAccessTime>2018-02-13T13:38:22.0340606-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-02-13T19:38:22.0340606Z</LastAccessTimeUtc>
    <Text># GeoGraphics 2014
# Package Created February 13, 2018
# Packaged by Austin Wall and Grayson Gratop
# Last Updated --

BEGIN {
    %::INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'geographics.2014',
        package_revision =&gt; '20180213T1338',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

sub install {
    output("Running AutoIt installer...\n");

    # this is awful but it's my only hope
    `$srcfiles\\install.exe"`;
    sleep(180);
    run_command("taskkill /IM install.exe /F");
    
    output("Installation successful!");
    return 1;
}

sub postinstall {
# License info is stored in the registry under the current user. An active setup action is used to run a .reg file to import the keys. 
    if(!create_activesetup_action(
            'Identifier' =&gt; 'GeoGraphics.2014_License',
            'ComponentID' =&gt; 'GeoGraphics',
            'Description' =&gt; 'Import registry keys to activate GeoGraphics 2014',
            'Version' =&gt; '1',
            'StubPath' =&gt; "C:\\windows\\regedit.exe /S $srcfiles\\license.reg" 
            )
        ) {
            output("Failed to create ActiveSetup action for License!");
            return 0;
        }
    return 1;

}

do_install( 
    exit_on_failure =&gt; 1,
    allowed_versions          =&gt; [ OSVER_WIN10_SP0 ],
    allowed_os_architectures  =&gt; [ OSARCH_x64 ],
    allowed_regs              =&gt; [ "clc", "desktop", "traveling", "virtual-desktop", "virtual-clc" ],
    install_sub               =&gt; \&amp;install,
    postinstall_sub           =&gt; \&amp;postinstall,
    
);

IM_Exit(EXIT_SUCCESS);

########################################################################</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\gimp.2_8_22\prod\update.pl</FullName>
    <Length>1599</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-11T14:12:19.0390848-05:00</CreationTime>
    <CreationTimeUtc>2018-05-11T19:12:19.0390848Z</CreationTimeUtc>
    <LastWriteTime>2018-05-11T14:51:24.9309061-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-11T19:51:24.9309061Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-11T14:12:19.0390848-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-11T19:12:19.0390848Z</LastAccessTimeUtc>
    <Text>#GIMP 2.8.22
# Package Created May 11th, 2018
# Packaged by Robert Smith
# Last updated by Robert Smith

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'gimp.2_8_22',
        package_revision =&gt; '20180511T1418',
    );
}

# Add InstallMonkey Library to the path
use lib (
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
my $applogs=get_applogs_dir();
my $programfiles = get_arch_programfiles(OSARCH_x64);

sub install{
	output("Installing GIMP 2.8.22\n");
    if(!run_command("start /wait \"\" $sourcefilesdir\\gimp-2.8.22-setup.exe /verysilent /norestart /SUPPRESSMSGBOXES /MERGETASKS=\"!desktopicon\" /S"))
    {
        output("GIMP 2.8.22 installation did not complete!\n");
        return 0;
    }
    else{
        output("GIMP 2.8.22 installation was successful!\n");
    }
    return 1;
}

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x86, OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                     'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
	  need_reboot =&gt; 0,
    install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\git.2_12_2_2\prod\update.pl</FullName>
    <Length>1354</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-22T08:34:41.7610127-05:00</CreationTime>
    <CreationTimeUtc>2017-06-22T13:34:41.7610127Z</CreationTimeUtc>
    <LastWriteTime>2017-06-22T08:30:21.8135045-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-22T13:30:21.8135045Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-22T08:34:41.7610127-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-22T13:34:41.7610127Z</LastAccessTimeUtc>
    <Text># Git 2.12.2.2
# Package created by Sergey Gruzdev
# Package created 6/22/2017
# Package last edited 6/22/2017 by Sergey Gruzdev

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'git.2_12_2_2',
		package_revision =&gt; '20170622T0816',
	);
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

my $src = get_pkg_sourcefiles();

sub install
{
  print "Installing GIT 2.12.2.2...\n";
  # Run installer
  if(!run_command("\"$src\\Git-2.12.2.2-64-bit.exe\" /VERYSILENT /NORESTART /RESTARTEXITCODE=0"))
  {
    print "Error during installation: failed!\n";
	return 0;
  }
  print "Installation complete!\n";
  return 1;
}


do_install
(
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\git.2_15_0\prod\update.pl</FullName>
    <Length>1384</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-10T13:05:20.7758211-06:00</CreationTime>
    <CreationTimeUtc>2017-11-10T19:05:20.7758211Z</CreationTimeUtc>
    <LastWriteTime>2017-11-10T13:07:37.7133259-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-11-10T19:07:37.7133259Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-10T13:05:20.7758211-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-10T19:05:20.7758211Z</LastAccessTimeUtc>
    <Text># Git 2.15.0
# Package created by Sergey Gruzdev
# Package created 6/22/2017
# Package edited 6/22/2017 by Sergey Gruzdev
# Package last edited 11/10/2017 by Grayson Gratop

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'git.2_15_0',
		package_revision =&gt; '20171110T1306',
	);
}

use lib(
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

my $src = get_pkg_sourcefiles();

sub install {
  print "Installing GIT 2.15.0...\n";
  # Run installer
  if (!run_command("\"$src\\Git-2.15.0-64-bit.exe\" /VERYSILENT /NORESTART /RESTARTEXITCODE=0")) {
    print "Error during installation: failed!\n";
    return 0;
  }
  print "Installation complete!\n";
  return 1;
}


do_install(
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\git.2_17_0\prod\update.pl</FullName>
    <Length>1120</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-25T08:36:06.8751595-05:00</CreationTime>
    <CreationTimeUtc>2018-05-25T13:36:06.8751595Z</CreationTimeUtc>
    <LastWriteTime>2018-05-25T09:37:55.1007731-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-25T14:37:55.1007731Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-25T08:36:06.8751595-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-25T13:36:06.8751595Z</LastAccessTimeUtc>
    <Text># Git 2.17.0
# Package created by Cameron Loren
# Package created 5/25/2018
# Package last edited 5/25/2018 by Cameron Loren

use warnings;
use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'git.2_17_0',
		package_revision =&gt; '20180525T0852',
	);
}

use lib(
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

my $src = get_pkg_sourcefiles();

sub install {
  print "Installing GIT 2.17.0...\n";
  # Run installer
  if (!run_command("\"$src\\Git-2.17.0-64-bit.exe\" /VERYSILENT /NORESTART /RESTARTEXITCODE=0")) {
    print "Error during installation: failed!\n";
    return 0;
  }
  print "Installation complete!\n";
  return 1;
}

do_install(
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\git.2_9_0\prod\update.pl</FullName>
    <Length>2115</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-06-21T11:35:39.827112-05:00</CreationTime>
    <CreationTimeUtc>2016-06-21T16:35:39.827112Z</CreationTimeUtc>
    <LastWriteTime>2016-06-21T11:38:37.5613299-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-06-21T16:38:37.5613299Z</LastWriteTimeUtc>
    <LastAccessTime>2016-06-21T11:35:39.827112-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-06-21T16:35:39.827112Z</LastAccessTimeUtc>
    <Text># Package Created June 21, 2016
# Packaged by Austin Wall
# Last updated


=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS = 
    (
        package_id =&gt; 'git.2_9_0',
        package_revision =&gt; '20160621T1137',
    );
}

use lib
(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;
use Getopt::Long;

GetOptions(
    'uninstall' =&gt; sub { exit(!uninstall()); },
);

my $srcfiles = get_pkg_sourcefiles();

sub install
{
    my $log = "c:\\gitlog.txt";
    my $installer = "Git-2.9.0-64-bit.exe";
    
    output("Installing Git: ");
    my $success = run_command("\"$srcfiles\\$installer\" /SP- /SILENT /SUPPRESSMSGBOXES /LOG=\"$log\" /NORESTART /CLOSEAPPLICATIONS /LOADINF=\"$srcfiles\\GitSettings.txt\"");
    output($success ? "success!\n" : "FAILED: $!\n");
    
    run_command("move /y $log ". get_applogs_dir(), 'IgnoreReturnCode'=&gt;1);
    
    my $startmenu = get_allusers_start_menu();
    run_command("xcopy /q/y/e/i $srcfiles\\startmenu\\Git \"$startmenu\\Programs\\Git\"");
    
    return $success;
}

sub uninstall
{
    my $success = run_command("\"C:\\Program Files (x86)\\Git\\unins000.exe\" /silent");
    output($success ? "success!\n" : "FAILED: $!\n");

    if ($success)
    {
        delete_product_registry_key(get_package_name().".".get_version());
    }

    return $success;
}


do_install
( 
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN8_SP0 ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [ 'desktop', 'clc', 'traveling', 'virtual-desktop', 
                        'virtual-clc' ],

    exit_on_failure =&gt; 1,
    
    install_sub =&gt; \&amp;install,
    #postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\githubdesktop.1_1_1\dev\update.pl</FullName>
    <Length>2729</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-08-01T08:39:13.2361249-05:00</CreationTime>
    <CreationTimeUtc>2018-08-01T13:39:13.2361249Z</CreationTimeUtc>
    <LastWriteTime>2018-08-01T11:50:22.9561733-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-08-01T16:50:22.9561733Z</LastWriteTimeUtc>
    <LastAccessTime>2018-08-01T08:39:13.2361249-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-08-01T13:39:13.2361249Z</LastAccessTimeUtc>
    <Text># GitHubDesktop 1.1.1
# Package Created May 7th, 2018
# Packaged by Cameron Loren
# Last updated by Cameron Loren

#Because GitHub Destkop uses the Squirrel installer, the program installs to the current users'
# appdata/local directory. This means a login script is required and runs each time a new
# user logs on.

use strict;
use warnings;
use Win32::TieRegistry(Delimiter =&gt; '/');

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'githubdesktop.1_1_1',
        package_revision =&gt; '20180601T0951',
    );
}

# Add InstallMonkey Library to the path
use lib (
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);

use InstallMonkey::Shared;

my $login = getlogin || getpwuid($&lt;);
my $installer = build_path(get_pkg_sourcefiles(), 'GitHubDesktopSetup.exe');
my $login_script = build_path(get_pkg_sourcefiles(), 'login.pl');
my $startupKey = 'HKEY_LOCAL_MACHINE/Software/Microsoft/Windows/CurrentVersion/Run';


sub install
{
  #Runs the login script (data/login.pl)
  if(!run_command("\"$login_script\""))
  {
    output("Failed to install GitHubDesktop 1.1.1, check logs for more details. \n");
    return 0;
  }
  #Sets the 'Run' registry key to run the login script at each login
  else
  {
    my $loginKey = $Registry-&gt;{"$startupKey"};
    $loginKey-&gt;{'GitHubDesktop 1.1.1.'} = "\"C:\\SourceFiles\\githubdesktop.1_1_1\\login_start.cmd\"";

    #Give it time to install and create shortcuts
    print("Waiting 20 seconds to ensure installation completes...\n");
    sleep(20);

    print("GitHubDesktop 1.1.1 installation was successful!\n");
    #Try removing the shortcuts
    print("Attempting to remove desktop shortcut from C Drive: ");
    if(system("del \"%systemdrive%\\Users\\$login\\Desktop\\GitHub Desktop.lnk\" /Q") == 0)
    {
      print("Success!.\n");
    }
    print("Attempting to remove desktop shortcut from R Drive: ");
    if(system("del \\\\minerfiles.mst.edu\\dfs\\Users\\$login\\Desktop\\\"GitHub Desktop.lnk\" /Q") == 0)
    {
      print("Success!.\n");
    }

    return 1;
  }
}

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                     'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
	  need_reboot =&gt; 0,
    install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\githubdesktop.1_1_1\prod\update.pl</FullName>
    <Length>2729</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-07T11:02:33.185115-05:00</CreationTime>
    <CreationTimeUtc>2018-05-07T16:02:33.185115Z</CreationTimeUtc>
    <LastWriteTime>2018-08-01T11:50:22.9561733-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-08-01T16:50:22.9561733Z</LastWriteTimeUtc>
    <LastAccessTime>2018-08-01T11:50:40.9026494-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-08-01T16:50:40.9026494Z</LastAccessTimeUtc>
    <Text># GitHubDesktop 1.1.1
# Package Created May 7th, 2018
# Packaged by Cameron Loren
# Last updated by Cameron Loren

#Because GitHub Destkop uses the Squirrel installer, the program installs to the current users'
# appdata/local directory. This means a login script is required and runs each time a new
# user logs on.

use strict;
use warnings;
use Win32::TieRegistry(Delimiter =&gt; '/');

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'githubdesktop.1_1_1',
        package_revision =&gt; '20180601T0951',
    );
}

# Add InstallMonkey Library to the path
use lib (
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);

use InstallMonkey::Shared;

my $login = getlogin || getpwuid($&lt;);
my $installer = build_path(get_pkg_sourcefiles(), 'GitHubDesktopSetup.exe');
my $login_script = build_path(get_pkg_sourcefiles(), 'login.pl');
my $startupKey = 'HKEY_LOCAL_MACHINE/Software/Microsoft/Windows/CurrentVersion/Run';


sub install
{
  #Runs the login script (data/login.pl)
  if(!run_command("\"$login_script\""))
  {
    output("Failed to install GitHubDesktop 1.1.1, check logs for more details. \n");
    return 0;
  }
  #Sets the 'Run' registry key to run the login script at each login
  else
  {
    my $loginKey = $Registry-&gt;{"$startupKey"};
    $loginKey-&gt;{'GitHubDesktop 1.1.1.'} = "\"C:\\SourceFiles\\githubdesktop.1_1_1\\login_start.cmd\"";

    #Give it time to install and create shortcuts
    print("Waiting 20 seconds to ensure installation completes...\n");
    sleep(20);

    print("GitHubDesktop 1.1.1 installation was successful!\n");
    #Try removing the shortcuts
    print("Attempting to remove desktop shortcut from C Drive: ");
    if(system("del \"%systemdrive%\\Users\\$login\\Desktop\\GitHub Desktop.lnk\" /Q") == 0)
    {
      print("Success!.\n");
    }
    print("Attempting to remove desktop shortcut from R Drive: ");
    if(system("del \\\\minerfiles.mst.edu\\dfs\\Users\\$login\\Desktop\\\"GitHub Desktop.lnk\" /Q") == 0)
    {
      print("Success!.\n");
    }

    return 1;
  }
}

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                     'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
	  need_reboot =&gt; 0,
    install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\gitkraken.3_5_1\dev\update.pl</FullName>
    <Length>2105</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-07-10T10:53:17.1478987-05:00</CreationTime>
    <CreationTimeUtc>2018-07-10T15:53:17.1478987Z</CreationTimeUtc>
    <LastWriteTime>2018-08-01T12:12:07.1968341-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-08-01T17:12:07.1968341Z</LastWriteTimeUtc>
    <LastAccessTime>2018-08-01T11:59:52.7535465-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-08-01T16:59:52.7535465Z</LastAccessTimeUtc>
    <Text># GitKraken 3.5.1
# Package Created July 20th, 2018
# Packaged by Cameron Loren
# Last updated by Cameron Loren

#Because GitKraken uses the Squirrel installer, the program installs to the current users'
# appdata/local directory. This means an activesetup script is required and runs each time a new
# user logs on.

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'gitkraken.3_5_1',
        package_revision =&gt; '20180720T0819',
    );
}

# Add InstallMonkey Library to the path
use lib (
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);

use InstallMonkey::Shared;
use Win32::TieRegistry( Delimiter=&gt;"/");

my $login = getlogin || getpwuid($&lt;);
my $installer = build_path(get_pkg_sourcefiles(), 'GitKrakenSetup.exe');
my $login_script = build_path(get_pkg_sourcefiles(), 'login.pl');
my $startupKey = 'HKEY_LOCAL_MACHINE/Software/Microsoft/Windows/CurrentVersion/Run';

sub install
{
  #Runs the login script (data/login.pl)
  if(!run_command("\"$login_script\""))
  {
    output("Failed to install GitKraken 3.5.1, check logs for more details. \n");
    return 0;
  }
  #Sets the 'Run' registry key to run the login script at each login
  else
  {
    my $loginKey = $Registry-&gt;{"$startupKey"};
    $loginKey-&gt;{'GitKraken 3.5.1'} = "\"C:\\SourceFiles\\gitkraken.3_5_1\\login_start.cmd\"";

    print("GitKraken 3.5.1 installation was successful!\n");
    return 1;
  }
}


do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                     'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
	  need_reboot =&gt; 0,
    install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\gitkraken.3_5_1\prod\update.pl</FullName>
    <Length>2105</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-07-20T09:58:48.4688368-05:00</CreationTime>
    <CreationTimeUtc>2018-07-20T14:58:48.4688368Z</CreationTimeUtc>
    <LastWriteTime>2018-08-01T12:12:07.1968341-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-08-01T17:12:07.1968341Z</LastWriteTimeUtc>
    <LastAccessTime>2018-08-01T12:31:54.5760947-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-08-01T17:31:54.5760947Z</LastAccessTimeUtc>
    <Text># GitKraken 3.5.1
# Package Created July 20th, 2018
# Packaged by Cameron Loren
# Last updated by Cameron Loren

#Because GitKraken uses the Squirrel installer, the program installs to the current users'
# appdata/local directory. This means an activesetup script is required and runs each time a new
# user logs on.

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'gitkraken.3_5_1',
        package_revision =&gt; '20180720T0819',
    );
}

# Add InstallMonkey Library to the path
use lib (
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);

use InstallMonkey::Shared;
use Win32::TieRegistry( Delimiter=&gt;"/");

my $login = getlogin || getpwuid($&lt;);
my $installer = build_path(get_pkg_sourcefiles(), 'GitKrakenSetup.exe');
my $login_script = build_path(get_pkg_sourcefiles(), 'login.pl');
my $startupKey = 'HKEY_LOCAL_MACHINE/Software/Microsoft/Windows/CurrentVersion/Run';

sub install
{
  #Runs the login script (data/login.pl)
  if(!run_command("\"$login_script\""))
  {
    output("Failed to install GitKraken 3.5.1, check logs for more details. \n");
    return 0;
  }
  #Sets the 'Run' registry key to run the login script at each login
  else
  {
    my $loginKey = $Registry-&gt;{"$startupKey"};
    $loginKey-&gt;{'GitKraken 3.5.1'} = "\"C:\\SourceFiles\\gitkraken.3_5_1\\login_start.cmd\"";

    print("GitKraken 3.5.1 installation was successful!\n");
    return 1;
  }
}


do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                     'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
	  need_reboot =&gt; 0,
    install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\glade.3_8_5\prod\update.pl</FullName>
    <Length>850</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-07-20T15:44:52.685265-05:00</CreationTime>
    <CreationTimeUtc>2016-07-20T20:44:52.685265Z</CreationTimeUtc>
    <LastWriteTime>2016-07-20T15:41:50.0308159-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-07-20T20:41:50.0308159Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-20T15:44:52.685265-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-20T20:44:52.685265Z</LastAccessTimeUtc>
    <Text>#Glade 3 8 5
#Package Created July 2016
#Packaged by:Benjamin Krueger
#Last Updated 2016-07-12 by Benjamin Krueger
BEGIN{
    %INSTALLMONKEY_OPTIONS =(
        package_id =&gt; "glade.3_8_5",
        package_revision =&gt; "38507202016T937"
    )
}

use lib(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

sub install {
    if(!run_command(get_pkg_sourcefiles."\\install.exe"))
    {
        return 0;
    }
    return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1,OSVER_WIN8_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64,OSARCH_x86],
    allowed_regs =&gt; ['desktop','virtual-desktop','traveling','clc','virtual-clc'],
    install_sub =&gt; \&amp;install,
);
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\gnuplot.5_0_3\prod\update.pl</FullName>
    <Length>2350</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-06-20T13:09:30.2739209-05:00</CreationTime>
    <CreationTimeUtc>2016-06-20T18:09:30.2739209Z</CreationTimeUtc>
    <LastWriteTime>2016-06-20T14:07:39.5930219-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-06-20T19:07:39.5930219Z</LastWriteTimeUtc>
    <LastAccessTime>2016-06-20T13:09:30.3207218-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-06-20T18:09:30.3207218Z</LastAccessTimeUtc>
    <Text># GnuPlot 5.0.3
# Package Created June 2016
# Packaged by Ronith (Baseed on Eric Boyer's 2011 package)
# Last Updated ....

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'gnuplot.5_0_3',
        package_revision =&gt; '20160620T1300',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;
my $srcfiles= get_pkg_sourcefiles();
my $install_file = "";
my $if_x64arch = "x64";
my $os_arch = detect_os_architecture();

sub install {
	output("Installing Gnuplot\n");
	output("$os_arch\n");
	if(index($os_arch,$if_x64arch) != -1){
		$install_file = "gp503-win64-mingw.exe";
	}
	else{
		$install_file = "gp503-win32-mingw.exe";
	}
	if(!run_command("$srcfiles\\$install_file /silent")){
		output("Failed\n");
		return 0;
	}
	else{
		output("Success\n");
	}
	return 1;
}

sub postinstall {
	if(index($os_arch,$if_x64arch) != -1){
		# associate file types (*.gp or *.gpl)
		output("\nAssociating File types...\n");
		run_command("regedit /s $srcfiles\\gnuplot-x64.reg");
		# add env var SETX PATH /m "%PATH%;C:\Program Files\gnuplot\bin"
		output("\nSetting environment variables...\n");
		add_environment_variable("Path","C:\\Program Files\\gnuplot\\bin");
    }
	else{
	# associate file types (*.gp or *.gpl)
		output("\nAssociating File types...\n");
		run_command("regedit /s $srcfiles\\gnuplot-x86.reg");
		# add env var SETX PATH /m "%PATH%;C:\Program Files (x86)\gnuplot\bin"
		output("\nSetting environment variables...\n");
		add_environment_variable("Path","C:\\Program Files (x86)\\gnuplot\\bin");
	}
  return 1;
}

do_install( 
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; [qw(clc desktop traveling virtual-clc virtual-desktop)],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\gnuplot.5_0_6\prod\update.pl</FullName>
    <Length>2280</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-05-22T15:37:58.690813-05:00</CreationTime>
    <CreationTimeUtc>2017-05-22T20:37:58.690813Z</CreationTimeUtc>
    <LastWriteTime>2017-05-22T15:48:35.6198614-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-05-22T20:48:35.6198614Z</LastWriteTimeUtc>
    <LastAccessTime>2016-06-20T13:09:30-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-06-20T18:09:30Z</LastAccessTimeUtc>
    <Text># GnuPlot 5.0.6
# Package Created May 22, 2017
# Packaged by Austin Wall   
# Last Updated May 22, 2017 by Austin Wall



use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'gnuplot.5_0_6',
        package_revision =&gt; '20170522T1548',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;
my $srcfiles= get_pkg_sourcefiles();
my $install_file = "";
my $if_x64arch = "x64";
my $os_arch = detect_os_architecture();

sub install {
    output("Installing Gnuplot\n");
    output("$os_arch\n");
    if(index($os_arch,$if_x64arch) != -1){
        $install_file = "gp506-win64-mingw.exe";
    }
    else{
        $install_file = "gp506-win32-mingw.exe";
    }
    if(!run_command("$srcfiles\\$install_file /silent")){
        output("Failed\n");
        return 0;
    }
    else{
        output("Success\n");
    }
    return 1;
}

sub postinstall {
    if(index($os_arch,$if_x64arch) != -1){
        # associate file types (*.gp or *.gpl)
        output("\nAssociating File types...\n");
        run_command("regedit /s $srcfiles\\gnuplot-x64.reg");
        # add env var SETX PATH /m "%PATH%;C:\Program Files\gnuplot\bin"
        output("\nSetting environment variables...\n");
        add_environment_variable("Path","C:\\Program Files\\gnuplot\\bin");
    }
    else{
        # associate file types (*.gp or *.gpl)
        output("\nAssociating File types...\n");
        run_command("regedit /s $srcfiles\\gnuplot-x86.reg");
        # add env var SETX PATH /m "%PATH%;C:\Program Files (x86)\gnuplot\bin"
        output("\nSetting environment variables...\n");
        add_environment_variable("Path","C:\\Program Files (x86)\\gnuplot\\bin");
    }
    return 1;
}

do_install( 
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; [qw(clc desktop traveling virtual-clc virtual-desktop)],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\gnuplot.5_2_2\prod\update.pl</FullName>
    <Length>2311</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-23T11:34:15.2062883-05:00</CreationTime>
    <CreationTimeUtc>2018-05-23T16:34:15.2062883Z</CreationTimeUtc>
    <LastWriteTime>2018-05-23T11:36:54.6248773-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-23T16:36:54.6248773Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-23T11:34:15.2062883-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-23T16:34:15.2062883Z</LastAccessTimeUtc>
    <Text># GnuPlot 5.2.2
# Package Created May 23, 2018
# Packaged by Robert Smith, based on Austin's 5.0.6 package
# Last Updated May 23, 2018 by Robert Smith



use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'gnuplot.5_2_2',
        package_revision =&gt; '20180523T1135',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;
my $srcfiles= get_pkg_sourcefiles();
my $install_file = "";
my $if_x64arch = "x64";
my $os_arch = detect_os_architecture();

sub install {
    output("Installing Gnuplot\n");
    output("$os_arch\n");
    if(index($os_arch,$if_x64arch) != -1){
        $install_file = "gp522-win64-mingw.exe";
    }
    else{
        $install_file = "gp522-win32-mingw.exe";
    }
    if(!run_command("$srcfiles\\$install_file /silent")){
        output("Failed\n");
        return 0;
    }
    else{
        output("Success\n");
    }
    return 1;
}

sub postinstall {
    if(index($os_arch,$if_x64arch) != -1){
        # associate file types (*.gp or *.gpl)
        output("\nAssociating File types...\n");
        run_command("regedit /s $srcfiles\\gnuplot-x64.reg");
        # add env var SETX PATH /m "%PATH%;C:\Program Files\gnuplot\bin"
        output("\nSetting environment variables...\n");
        add_environment_variable("Path","C:\\Program Files\\gnuplot\\bin");
    }
    else{
        # associate file types (*.gp or *.gpl)
        output("\nAssociating File types...\n");
        run_command("regedit /s $srcfiles\\gnuplot-x86.reg");
        # add env var SETX PATH /m "%PATH%;C:\Program Files (x86)\gnuplot\bin"
        output("\nSetting environment variables...\n");
        add_environment_variable("Path","C:\\Program Files (x86)\\gnuplot\\bin");
    }
    return 1;
}

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; [qw(clc desktop traveling virtual-clc virtual-desktop)],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\go.1_8_1\dev\update.pl</FullName>
    <Length>908</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-22T12:39:40.2725317-05:00</CreationTime>
    <CreationTimeUtc>2017-06-22T17:39:40.2725317Z</CreationTimeUtc>
    <LastWriteTime>2017-06-22T12:39:40.2725317-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-22T17:39:40.2725317Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-22T12:39:40.2725317-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-22T17:39:40.2725317Z</LastAccessTimeUtc>
    <Text>
    # Go
    # Package Created June 22, 2017
    # Packaged by Krueger, Benjamin (S&amp;T IT Student Employee)
    # Last Updated --
    BEGIN {
        %::INSTALLMONKEY_OPTIONS = (
            package_id =&gt; 'go.1_8_1',
            package_revision =&gt; '20170622T1239',
        );
    }

    use lib (
        '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
        $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
        'C:\temp',
    );

    use InstallMonkey::Shared;
    use Getopt::Long;
    do_install(
        allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
        allowed_os_architectures =&gt; [OSARCH_x64],
        allowed_regs =&gt; ["clc", "desktop", "traveling", "virtual-desktop", "virtual-clc"],
        exit_on_failure =&gt; 1,
        msi_name_x86 =&gt; 'go.1_8_1.msi',
        msi_name_x64 =&gt; 'go.1_8_1.msi',
        
    );
    IM_Exit(EXIT_SUCCESS);
    </Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\golang.1_10_2\prod\update.pl</FullName>
    <Length>1164</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-10T11:46:34.471483-05:00</CreationTime>
    <CreationTimeUtc>2018-05-10T16:46:34.471483Z</CreationTimeUtc>
    <LastWriteTime>2018-05-11T12:53:01.0876108-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-11T17:53:01.0876108Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-10T11:46:34.471483-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-10T16:46:34.471483Z</LastAccessTimeUtc>
    <Text># Package created May 5th, 2018 by Cameron Loren
# Last updated by Cameron Loren on May 5th, 2018

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN {
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'golang.1_10_2',
		package_revision =&gt; '20180510T1148'
	);
}

use lib(
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);

use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
my $args = "/qn /norestart";
my $product_name = "Go Lang 1.10.2";
my $executable = "go1.10.2.windows-amd64.msi";

sub install {
	output("Installing $product_name...\n");
	if (!run_command("$sourcefilesdir\\$executable $args")) {
		output("$product_name installation failed!\n");
		return 0;
	}
	output("$product_name installation succeeded!\n");
	return 1;
}

do_install(
	allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
	allowed_os_architectures =&gt; [ OSARCH_x64 ],
	allowed_regs =&gt; [ 'clc', 'desktop' , 'traveling' , 'virtual-clc', 'virtual-desktop' ],
	exit_on_failure =&gt; 1,
	install_sub =&gt; \&amp;install,
);


IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\golang.1_6_2\prod\update.pl</FullName>
    <Length>1198</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-07-14T13:19:26.5372514-05:00</CreationTime>
    <CreationTimeUtc>2016-07-14T18:19:26.5372514Z</CreationTimeUtc>
    <LastWriteTime>2016-07-14T13:28:04.8884195-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-07-14T18:28:04.8884195Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-14T13:19:26.568452-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-14T18:19:26.568452Z</LastAccessTimeUtc>
    <Text># Package created July 8 2016
# Package created by Austin Wall
# Last updated -- by --

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
	%INSTALLMONKEY_OPTIONS = 
	(
		package_id =&gt; 'golang.1_6_2',
		package_revision =&gt; '20160714T1320'
	);
}	

use lib
(
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);

use InstallMonkey::Shared;

my $getapplogsdir = get_applogs_dir();
my $sourcefilesdir = get_pkg_sourcefiles();
my $args = "/qn /norestart";
my $product_name = "Go Lang 1.6.2";
my $executable = "go1.6.2.windows-amd64.msi";
sub install
{
	output("Installing $product_name...\n");
	if(!run_command("$sourcefilesdir\\$executable $args"))
	{
		output("$product_name installation failed!\n");
		return 0;
	}
	output("$product_name installation succeeded!\n");
	return 1;
}

do_install
(
	allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
	allowed_os_architectures =&gt; [ OSARCH_x64 ],
	allowed_regs =&gt; [ 'clc', 'desktop' , 'traveling' , 'virtual-clc', 'virtual-desktop' ],
	exit_on_failure =&gt; 1,
	install_sub =&gt; \&amp;install,
);


IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\golang.1_7_4\prod\update.pl</FullName>
    <Length>1209</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-12-14T12:28:26.5375787-06:00</CreationTime>
    <CreationTimeUtc>2016-12-14T18:28:26.5375787Z</CreationTimeUtc>
    <LastWriteTime>2016-12-14T12:30:45.3178475-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-12-14T18:30:45.3178475Z</LastWriteTimeUtc>
    <LastAccessTime>2016-12-14T12:30:35-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-12-14T18:30:35Z</LastAccessTimeUtc>
    <Text># Package created July 8 2016
# Package created by Austin Wall
# Last updated by Mark Raymond Jr.

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
	%INSTALLMONKEY_OPTIONS = 
	(
		package_id =&gt; 'golang.1_7_4',
		package_revision =&gt; '20161214T1230'
	);
}	

use lib
(
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);

use InstallMonkey::Shared;

my $getapplogsdir = get_applogs_dir();
my $sourcefilesdir = get_pkg_sourcefiles();
my $args = "/qn /norestart";
my $product_name = "Go Lang 1.7.4";
my $executable = "go1.7.4.windows-amd64.msi";
sub install
{
	output("Installing $product_name...\n");
	if(!run_command("$sourcefilesdir\\$executable $args"))
	{
		output("$product_name installation failed!\n");
		return 0;
	}
	output("$product_name installation succeeded!\n");
	return 1;
}

do_install
(
	allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
	allowed_os_architectures =&gt; [ OSARCH_x64 ],
	allowed_regs =&gt; [ 'clc', 'desktop' , 'traveling' , 'virtual-clc', 'virtual-desktop' ],
	exit_on_failure =&gt; 1,
	install_sub =&gt; \&amp;install,
);


IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\golang.1_9_2\prod\update.pl</FullName>
    <Length>1244</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-10T13:08:40.9237858-06:00</CreationTime>
    <CreationTimeUtc>2017-11-10T19:08:40.9237858Z</CreationTimeUtc>
    <LastWriteTime>2017-11-10T13:10:40.3238685-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-11-10T19:10:40.3238685Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-10T13:08:40.9237858-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-10T19:08:40.9237858Z</LastAccessTimeUtc>
    <Text># Package created July 8 2016
# Package created by Austin Wall
# Updated by Mark Raymond Jr.
# Last updated by Grayson Gratop on 2017-11-10

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN {
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'golang.1_9_2',
		package_revision =&gt; '20171110T1309'
	);
}	

use lib(
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);

use InstallMonkey::Shared;

my $getapplogsdir = get_applogs_dir();
my $sourcefilesdir = get_pkg_sourcefiles();
my $args = "/qn /norestart";
my $product_name = "Go Lang 1.9.2";
my $executable = "go1.9.2.windows-amd64.msi";

sub install {
	output("Installing $product_name...\n");
	if (!run_command("$sourcefilesdir\\$executable $args")) {
		output("$product_name installation failed!\n");
		return 0;
	}
	output("$product_name installation succeeded!\n");
	return 1;
}

do_install(
	allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
	allowed_os_architectures =&gt; [ OSARCH_x64 ],
	allowed_regs =&gt; [ 'clc', 'desktop' , 'traveling' , 'virtual-clc', 'virtual-desktop' ],
	exit_on_failure =&gt; 1,
	install_sub =&gt; \&amp;install,
);


IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\googleearth.7_3_1\prod\update.pl</FullName>
    <Length>2181</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-11T14:40:14.7585388-05:00</CreationTime>
    <CreationTimeUtc>2018-05-11T19:40:14.7585388Z</CreationTimeUtc>
    <LastWriteTime>2018-05-17T13:19:41.2942935-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-17T18:19:41.2942935Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-11T14:40:14.7750799-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-11T19:40:14.7750799Z</LastAccessTimeUtc>
    <Text>#Google Earth Pro 7.3.1
# Package Created May 11th, 2018
# Packaged by Kade Wessels
# Last updated by Kade Wessels

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'googleearth.7_3_1',
        package_revision =&gt; '20180511T1329',
    );
}

# Add InstallMonkey Library to the path
use lib (
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
my $applogs=get_applogs_dir();
my $programfiles = get_arch_programfiles(OSARCH_x64);

sub install{
		output("Installing Google Earth Pro 7.3.1 (x64)\n");
    if(!run_command("start /wait \"\" $sourcefilesdir\\googleearthinstall-7.3.1-x64.exe OMAHA=1"))
    {
        output("Google Earth Pro 7.3.1 (x64) installation did not complete!\n");
        return 0;
    }
    else{
        output("Google Earth Pro 7.3.1 (x64) installation was successful!\n");
    }
    return 1;
}

sub DeleteShort {
    output("Removing icons from public: ");
    my $Remove1 = run_command("del \"%systemdrive%\\Users\\Public\\Desktop\\Google\ Earth\ Pro.lnk\" /Q");
    output($Remove1 ? "Success!\n" : "FAILED: $!\n");

    output("Removing icons from user: ");
    my $current_user = getlogin || getpwuid($&lt;) || "Default";
    my $Remove2 = run_command("del \"%systemdrive%\\Users\\$current_user\\Desktop\\Google\ Earth\ Pro.lnk\" /Q");
    output($Remove2 ? "Success!\n" : "FAILED: $!\n");
    return ($Remove1 || $Remove2);
}


do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                     'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
	  need_reboot =&gt; 0,
	install_sub =&gt; \&amp;install,
	postinstall_sub =&gt; \&amp;DeleteShort,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\graphviz.2_38\prod\update.pl</FullName>
    <Length>1198</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-07-14T14:44:59.6599634-05:00</CreationTime>
    <CreationTimeUtc>2016-07-14T19:44:59.6599634Z</CreationTimeUtc>
    <LastWriteTime>2016-07-14T15:46:53.9041898-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-07-14T20:46:53.9041898Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-14T14:44:59.6599634-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-14T19:44:59.6599634Z</LastAccessTimeUtc>
    <Text># Package created July 14 2016
# Package created by Austin Wall
# Last updated -- by --

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
	%INSTALLMONKEY_OPTIONS = 
	(
		package_id =&gt; 'graphviz.2_38',
		package_revision =&gt; '20160714T1505'
	);
}	

use lib
(
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);

use InstallMonkey::Shared;

my $getapplogsdir = get_applogs_dir();
my $sourcefilesdir = get_pkg_sourcefiles();
my $args = "/qn /norestart ALLUSERS=1";
my $product_name = "Graphviz";
my $executable = "graphviz-2.38.msi";
sub install
{
	output("Installing $product_name...\n");
	if(!run_command("$sourcefilesdir\\$executable $args"))
	{
		output("$product_name installation failed!\n");
		return 0;
	}
	output("$product_name installation succeeded!\n");
	return 1;
}

do_install
(
	allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
	allowed_os_architectures =&gt; [ OSARCH_x64 ],
	allowed_regs =&gt; [ 'clc', 'desktop' , 'traveling' , 'virtual-clc', 'virtual-desktop' ],
	exit_on_failure =&gt; 1,
	install_sub =&gt; \&amp;install,
);


IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\gridgen.15_18\prod\update.pl</FullName>
    <Length>2433</Length>
    <Extension>.pl</Extension>
    <CreationTime>2015-12-18T15:49:59.0761389-06:00</CreationTime>
    <CreationTimeUtc>2015-12-18T21:49:59.0761389Z</CreationTimeUtc>
    <LastWriteTime>2015-12-21T14:14:26.87434-06:00</LastWriteTime>
    <LastWriteTimeUtc>2015-12-21T20:14:26.87434Z</LastWriteTimeUtc>
    <LastAccessTime>2015-12-18T15:49:59.0761389-06:00</LastAccessTime>
    <LastAccessTimeUtc>2015-12-18T21:49:59.0761389Z</LastAccessTimeUtc>
    <Text># Gridgen 15.18
# Package Created December 18, 2015
# Packaged by Dzu Pham
# Last Updated ...

=pod

Begin-Doc
Modified: $$
Name: Gridgen 15.18 Package Installer
Type: script
Description: Invokes the vendor-supplied installer.
Language: Perl
LastUpdatedBy: $Author:$
Version: $Revision$
Doc-Package-Info: https://wiki.mst.edu/deskinst/change/applications/packaging/gridgen
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

#use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'Gridgen.15_18',
        package_revision =&gt; '201512188T1111',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $sourceFiles = get_pkg_sourcefiles();

sub inst_sub
{
  my $logfile=$ENV{"SystemRoot"}."\\system32\\umrinst\\applogs\\gridgen.15_18.txt";

  output("Installation in progress...");

  push_dir($sourceFiles);
    if (!run_command("\"$sourceFiles\\setup.exe\" -s -f1\"$sourceFiles\\setup.iss\""))
	{
		output("Installation failed!\n");
		return 0;
	}
	output("Installation success!");

	return 1;
}

sub postinst_sub
{
  #Deletes the desktop shortcur
  run_command("del \"C:\\Users\\Public\\Desktop\\GridgenV15.lnk\" /q");

  #Generates the file Gridgen uses to identify the license server
  output("Acquiring License file...");

  #The filename and directory to store the license file
  my $installDir= "C:\\Program Files (x86)\\Pointwise\\GridgenV15";
  my $licfile = 'licenses\\license.lic';
if (open(my $LICFILE, '&gt;', $installDir.'\\'.$licfile)) {

  print $LICFILE q/
SERVER 	gridgen.lic.mst.edu ANY 1756
USE_SERVER
/;
  close($LICFILE);

} else {
   output("Error opening license file for writing '${licfile}': $!");
   return 0;
}
return 1;
}

do_install(
    allowed_versions =&gt; [ OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_XP_32 ],
    allowed_os_architectures =&gt; [ OSARCH_x86,  OSARCH_x64 ],
    allowed_regs =&gt; [ 'clc', 'desktop', 'traveling',
                      'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
	  install_sub =&gt; \&amp;inst_sub,
    postinstall_sub =&gt; \&amp;postinst_sub,
    additional_msi_properties =&gt; 'REBOOT="ReallySuppress"',
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\gridgen.18_3\dev\update.pl</FullName>
    <Length>2744</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-08-22T10:39:02.2252006-05:00</CreationTime>
    <CreationTimeUtc>2017-08-22T15:39:02.2252006Z</CreationTimeUtc>
    <LastWriteTime>2018-07-26T13:03:26.8365286-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-26T18:03:26.8365286Z</LastWriteTimeUtc>
    <LastAccessTime>2017-08-22T10:39:02.2252006-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-08-22T15:39:02.2252006Z</LastAccessTimeUtc>
    <Text># Gridgen 18.3
# Package Created Aug, 2017
# Packaged by kshbb
# Updated 2015

=pod

Begin-Doc
Modified: $Date: 2017-08-22 10:46:00$
Name: Gridgen 18.3 Package Installer
Type: script
Description: Invokes the vendor-supplied installer.
Language: Perl
LastUpdatedBy: $Author: kshbb $
Version: $Revision$
Doc-Package-Info: https://wiki.mst.edu/deskinst/change/applications/packaging/gridgen
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

#use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'Gridgen.18_3',
        package_revision =&gt; '20170822T1042',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $sourceFiles = get_pkg_sourcefiles();

sub inst_sub
{
  my $logfile=$ENV{"SystemRoot"}."\\system32\\umrinst\\applogs\\gridgen.18_3.txt";
  
  output("Installation in progress...");
  
  push_dir($sourceFiles);
    if (!run_command("\"$sourceFiles\\pointwise_install.cmd\""))
	{
		output("Installation failed!\n");
		return 0;
	}
	output("Installation success!");
	
	return 1;
}

sub postinst_sub
{
  #Deletes the desktop shortcur
  run_command("del \"C:\\Users\\Public\\Desktop\\GridgenV18.lnk\" /q");
  
  #Generates the file Gridgen uses to identify the license server
  output("Acquiring License file...");
  
  #The filename and directory to store the license file
  my $installDir= "C:\\Program Files (x86)\\Pointwise\\PointwiseV18.0R3";
  # my $licfile = 'licenses\\license.lic';
  my $install_lic_dir = "$installDir\\licenses";
  mkdir $install_lic_dir unless -d $install_lic_dir;
  
if (open(my $LICFILE, '&gt;', "$install_lic_dir\\license.lic" )) {

  print $LICFILE q/
SERVER 	gridgen.lic.mst.edu ANY 5053
USE_SERVER
/;
  close($LICFILE);

} else {
   output("Error opening license file for writing '$install_lic_dir\\license.lic': $!");
   return 0;
}
return 1;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
	install_sub =&gt; \&amp;inst_sub,
	postinstall_sub =&gt; \&amp;postinst_sub,
    additional_msi_properties =&gt; 'REBOOT="ReallySuppress"',
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

### subroutine documentation block ###
# Begin-Doc
################################
# Name: 
# Description: 
# Returns: 
# Requires: 
# LastUpdated: 
# LastUpdatedBy: 
################################
# End-Doc

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\groundwater_vista.6\prod\update.pl</FullName>
    <Length>4698</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-01-30T14:09:53.1516161-06:00</CreationTime>
    <CreationTimeUtc>2017-01-30T20:09:53.1516161Z</CreationTimeUtc>
    <LastWriteTime>2017-02-08T14:55:26.4681053-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-02-08T20:55:26.4681053Z</LastWriteTimeUtc>
    <LastAccessTime>2017-01-30T14:09:53.1828165-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-01-30T20:09:53.1828165Z</LastAccessTimeUtc>
    <Text># Package Created 2017-1-30
# Packages By Jason Mao

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;
use Win32::TieRegistry;
use Getopt::Long;
print "Started PERL script...\n";

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'groundwater_vista.6',
        package_revision =&gt; '20170130T1200',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;
print "Loaded InstallMonkey...\n";
my $srcfiles = get_pkg_sourcefiles();
#my $log_dir = get_applogs_dir();
my $as_script = '';
GetOptions(
    'uninstall' =&gt; sub { exit(! uninstall()); },
    'as-script' =&gt; \$as_script
);


sub install
{
    #Run installers for the 3 products
    output("Running installers:\n");
    output("  Aquifer:");
    run_command("msiexec \/i $srcfiles\\AquiferWin32-64bit\\setup.msi \/quiet \/qn \/passive");
    output(" Done\n");
        
    output("  GW3D:");
    run_command("msiexec \/i $srcfiles\\GW3D-64bit\\GW3DSetup.msi \/quiet \/qn \/passive");
    output("Done.\n");
    
    
    output("  Groundwater Vista 6:");
    run_command("msiexec \/i $srcfiles\\GroundwaterVistas6-64bit\\Setupx64.msi \/quiet \/qn \/passive");
    output("Done.\n\n");

    
    #Run driver installation from one of the product install directories
    output("Running driver installation:");
    run_command("msiexec \/i $srcfiles\\HASP_Setup.msi \/quiet \/qn \/passive");
    output("Done\n");
    
    #place/edit hasplm file
    my $hasplmdir = "C:\\Program Files (x86)\\Common Files\\Aladdin Shared\\HASP";
    print("Changing hasplm file:");
    unless(-e $hasplmdir."\\hasplm.ini")
    {
        print("\n  Previous file doesn't exists, copying new file:");
        run_command("copy \"$srcfiles\\hasplm.ini\" \"$hasplmdir\\\" /Y");
    }
    else
    {
        print("\n  Editting File:");
        rename $hasplmdir."\\hasplm.ini", $hasplmdir."\\hasplm.ini.bac";
        
        open(my $oldhasp, "$hasplmdir\\hasplm.ini.bac");
        open(my $newhasp, "&gt;$hasplmdir\\hasplm.ini" );

        while(my $filetxt = &lt;$oldhasp&gt;)
        {
            print $newhasp $filetxt;
            if ($filetxt =~ /serveraddr/)
            {
                print $newhasp "serveraddr = esi.lic.mst.edu\n";
            }
        }
    
    }
    print("Done.\n");
    return 1;
}

sub postinstall
{
    print("Setting Registry Key\n");
    #set registry keys with security codes
    $Registry-&gt;Delimiter("/");
    my $baseKey = $Registry-&gt;{"HKEY_LOCAL_MACHINE/SOFTWARE/Environmental Simulations/"};
    
    $baseKey-&gt;{"AquiferWin32 V5-x64/"}= {"Security/" =&gt; {"/Security Code" =&gt; "X9TL-6D1W-S04T-4FX2-LDRT-ZJFX-PBKS"}};
    $baseKey-&gt;{"GW Vistas 6-x64/"}= {"Security/" =&gt; {"/Security Code" =&gt; "XS1L-6D1W-S44T-4FL2-LDRT-ZJF7-PBK9"}};
    $baseKey-&gt;{"GW3D V3-x64/"}= {"Security/" =&gt; {"/Security Code" =&gt; "KS1L-6R4W-S04T-4FX2-LDRT-ZJ57-WBHS"}};
    
    if($as_script) 
    {
      print("Skipping start menu shortcuts\n");
      return 1;
    }
    print("Copying start manu shortcuts\n");
    #copy start menu shortcuts, if they dont exist
    my $startmenupath = "C:\\ProgramData\\Microsoft\\Windows\\\"Start Menu\"\\Programs\\";
    #if(-e $startmenupath."AquiferWin32 Version 5") { return 1; }
    run_command("move $srcfiles\\StartMenuShortcuts\\\"AquiferWin32 Version 5\" $startmenupath");
    run_command("move $srcfiles\\StartMenuShortcuts\\\"Groundwater Vistas Version 6\" $startmenupath");
    run_command("move $srcfiles\\StartMenuShortcuts\\\"GW3D Version 3\" $startmenupath");

    
    return 1;
}

do_install(
    no_os_version_check =&gt; 1,
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
#    prerequisite_sub =&gt; \&amp;prerequisite,
#    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    need_reboot =&gt; 1,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

sub uninstall
{
  my $outcome = 1;
  
    if($outcome)
    {
        delete_product_registry_key(get_package_name(). "." .get_version());
    }
    
    output(($outcome ? "OK\n" : "Failed\n"));
}
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\gvim.74\prod\update.pl</FullName>
    <Length>1447</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-07-13T12:36:31.8605343-05:00</CreationTime>
    <CreationTimeUtc>2016-07-13T17:36:31.8605343Z</CreationTimeUtc>
    <LastWriteTime>2016-07-13T09:50:46.4317291-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-07-13T14:50:46.4317291Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-13T12:36:31.8605343-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-13T17:36:31.8605343Z</LastAccessTimeUtc>
    <Text>BEGIN{
    %INSTALLMONKEY_OPTIONS =(
        package_id =&gt; "gVim.74",
        package_revision =&gt; "20160713T909"
    )
}

use lib(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;
GetOptions('uninstall' =&gt; sub {exit(!uninstall());});
sub install {
    output("Runninng gVim installation executable..\n");
    if(!run_command("".get_pkg_sourcefiles()."\\gvim74\\vim\\vim74\\install.exe -create-batfiles -create-vimrc -install-openwith -add-start-menu"))
    {
        output("gVim installation failed.\n");
        return 0;
    }
    return 1;
}
sub uninstall
{
    if(!run_command("echo \"y\n\"| ".get_pkg_sourcefiles()."\\gvim74\\vim\\vim74\\uninstal.exe"))
    {
        output("gVim Removal Failed.");
        return 0;
    }
    #run_command("REG DELETE  HKEY_LOCAL_MACHINE\\SOFTWARE\\UMR\\INSTALL\\Product_List\\VisualStudioCode1.2 /f");
    delete_product_registry_key(get_package_name().".".get_version());
    return 1;
}
sub postinstall
{

    return 1;   
}
do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1,OSVER_WIN8_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64,OSARCH_x86],
    allowed_regs =&gt; ['desktop','virtual-desktop','traveling','clc','virtual-clc'],
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);
IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\haskell.8_2_2\dev\update.pl</FullName>
    <Length>1381</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-07-05T09:06:40.0162594-05:00</CreationTime>
    <CreationTimeUtc>2018-07-05T14:06:40.0162594Z</CreationTimeUtc>
    <LastWriteTime>2018-07-13T10:32:54.036544-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-13T15:32:54.036544Z</LastWriteTimeUtc>
    <LastAccessTime>2018-07-05T09:06:40.0162594-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-07-05T14:06:40.0162594Z</LastAccessTimeUtc>
    <Text>
    # Haskell Platform 8.2.2
    # Package Created July 05, 2018
    # Packaged by Krueger, Benjamin (S&amp;T IT Student Employee)
    # Last Updated --

    BEGIN {
        %::INSTALLMONKEY_OPTIONS = (
            package_id =&gt; 'haskell.8_2_2',
            package_revision =&gt; '20180705T0905',
        );
    }

    use lib (
        '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
        $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
        'C:\temp',
    );
    use InstallMonkey::Shared;

    my $srcfiles = get_pkg_sourcefiles();
    my $log_dir = get_applogs_dir();

    sub install {
        if(!run_command($srcfiles."\\HaskellPlatform-8.2.2-core-x86_64-setup.exe /S /D\"C:\Program Files\""))
        {
            output("Installation failed!\n");
            return 0;
        }
        
        output("Installation successful!");
        return 1;
    }

    do_install( 
        exit_on_failure =&gt; 1,
        allowed_versions          =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
        allowed_os_architectures  =&gt; [ OSARCH_x64 ],
        allowed_regs              =&gt; [ "clc", "desktop", "traveling", "virtual-desktop", "virtual-clc" ],
        install_sub               =&gt; \&amp;install,

        
    );

    IM_Exit(EXIT_SUCCESS);

    ########################################################################
    </Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\hcs.7_2_1\prod\update.pl</FullName>
    <Length>2882</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-12T14:42:30.0701174-05:00</CreationTime>
    <CreationTimeUtc>2017-06-12T19:42:30.0701174Z</CreationTimeUtc>
    <LastWriteTime>2017-06-14T14:42:04.4414517-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-14T19:42:04.4414517Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-12T14:42:30.0701174-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-12T19:42:30.0701174Z</LastAccessTimeUtc>
    <Text># HCS 7.2.1
# Package created July 2011
# Package created by Edward Norris
# Last updated 6/12/2017 by Sergey Gruzdev

=pod

Begin-Doc
Modified: $Date$
Name: $Name$
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'hcs.7_2_1',
        package_revision =&gt; '20170612T1018',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;
use Getopt::Long;

my $src = get_pkg_sourcefiles();

GetOptions('uninstall' =&gt; sub{exit(uninstall())});

sub uninstall
{
  # Uninstall hcs
  print "Uninstalling HCS 7.2.1...\n";
  if(!run_command("\"$src\\InstallHCS7.exe\" /uninst /s /sms /f1\"$src\\uninstall.iss\""))
  {
    print "Error: could not uninstall HCS 7.2.1!\n";
	return 0;
  }
  print "Uninstalled HCS 7.2.1!\n";
  # Uninstall Corsim
  if(!run_command("\"$src\\Corsim\\Setup.exe\" /uninst /s /v\"/qn\" /hide_progress /sms /f1\"$src\\Corsim\\uninstall.iss\""))
  {
    #print "Error: could not uninstall CORSIM!\n";
	#return 0;
  }
  print "Uninstalled CORSIM!\n";
  # Delete reg key
  if(!delete_product_registry_key(get_package_name().".".get_version()))
  {
    print "Error: could not delete product reg key!\n";
	return 0;
  }
  print "Deleted product regkey!\n";
  print "Uninstallation complete!\n";
  return 1;
}

sub install
{
  # Install HCS
  print "Installing HCS 7.2.1...\n";
  if(!run_command("\"$src\\InstallHCS7.exe\" /s /sms /f1\"$src\\hcs.iss\""))
  {
    print "Installation failed!\n";
	return 0;
  }
  else
  {
    print "HCS 7.2.1 installed successfully!\n";
  }
  return 1;
}

sub postinstall
{
  # Install corsim
  print "Installing Corsim!\n";
  if(!run_command("\"$src\\Corsim\\Setup.exe\" /s /v\"/qn\" /sms /hide_progress /f1\"$src\\Corsim\\setup.iss\""))
  {
    print "Error: failed to install Corsim!\n";
	return 0;
  }
  print "Corsim installed!\n";
  # Delete icons
  print "Removing desktop icons...\n";
  my $icons = get_allusers_desktop().'\\HCS7.lnk';
  if(!run_command("del /q \"$icons\""))
  {
    print "No desktop icons to delete!\n";
  }
  else
  {
    print "Removed desktop icons!\n";
  }
  print "Postinstall complete! Installation complete!\n";
  return 1;
}

do_install
(
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'virtual-clc', 'desktop', 'virtual-desktop', 'traveling'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\hec.2016\prod\update.pl</FullName>
    <Length>2775</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-11-23T08:57:38.1361651-06:00</CreationTime>
    <CreationTimeUtc>2016-11-23T14:57:38.1361651Z</CreationTimeUtc>
    <LastWriteTime>2018-01-24T10:12:48.4898075-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-24T16:12:48.4898075Z</LastWriteTimeUtc>
    <LastAccessTime>2016-11-23T08:57:38.1361651-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-11-23T14:57:38.1361651Z</LastAccessTimeUtc>
    <Text># HEC 2016
# Package Created March 2011 for HEC 2011
# Packaged by idl8t3
# Updated 2016-11-23 by Chris Schaaf
# Last Updated 2018-01-23 by Grayson Gratop

=pod

Begin-Doc
Modified: $March 17, 2011$
Name: HEC software
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'hec.2016',
    package_revision =&gt; '20161123T1200',
  );
}

# Add InstallMonkey Library to the path
use lib(
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use InstallMonkey::Shared;

my $src = get_pkg_sourcefiles();
my $cwd = cwd();
my $applogs=get_applogs_dir();

#check if some ArcGIS is installed
sub prereq_sub {
	output("Checking for ArcGIS: ");
	my $foldername = 'C:\Program Files (x86)\ArcGIS';
	if (-d $foldername) { 
		output("Found!\n");
		return 1;
	}
	else {
		output("Not found, please install and try again.\n"); 
		return 0;
	}
}


sub inst_sub {
	output("Installing HEC-HMS 4.2...");
	if (!run_command("\"$src\\HEC-HMS_42_Setup.exe\" /S /v/qn")) {
		output("\nERROR installing HEC-HMS\n");
		return 0;
	}
	output("Success\nInstalling HEC-RAS 5.0.3...");
	if (!run_command("\"$src\\HEC-RAS_503_Setup.exe\" /S /v/qn")) {
		output("\nERROR installing HEC-RAS\n");
		return 0;
	}
	#ArcHydro Tools now includes the ApFramework as far as I can tell. Or it's just not needed anymore.
	#For future versions the files should be available here: http://downloads.esri.com/archydro/archydro/Setup/
	output("Success\nInstalling ArcHydro Tools 10.x...");
	if (!run_command("\"$src\\ArcHydroTools.msi\" /qn")) {
		output("\nFailed to install ArcHydroTools9\nThis is a prereq for HEC-GeoHMS\n");
		return 0;
	}
	output("Success\nInstalling HEC-GeoHMS 10.2...");
	if (!run_command("\"$src\\HEC-GeoHMS_10.2_Setup.msi\" /qn")) {
		output("\nERROR installing HEC-GeoHMS\n");
		return 0;
	}
	output("Success\nInstalling HEC-GeoRAS 10.2...");
	if (!run_command("\"$src\\HEC-GeoRAS_10.2_Setup.msi\" /qn")) {
		output("\nERROR installing HEC-GeoRAS\n");
		return 0;
	}
	output("...Success\n");

	return 1;  
}  

do_install( 
	allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
	allowed_os_architectures =&gt; [OSARCH_x64],
	allowed_regs =&gt; [ 'clc', 'desktop', 'traveling',
						 'virtual-clc', 'virtual-desktop' ],
	exit_on_failure =&gt; 1,
	prerequisite_sub =&gt; \&amp;prereq_sub,
	install_sub =&gt; \&amp;inst_sub,
);

IM_Exit(EXIT_SUCCESS);


</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\hec.2018\prod\update.pl</FullName>
    <Length>1940</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-23T10:17:10.5315455-05:00</CreationTime>
    <CreationTimeUtc>2018-05-23T15:17:10.5315455Z</CreationTimeUtc>
    <LastWriteTime>2018-05-23T10:17:10.5640304-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-23T15:17:10.5640304Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-23T10:17:10.5640304-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-23T15:17:10.5640304Z</LastAccessTimeUtc>
    <Text># 6966969696
# HEC-RAS 5.0.3 and HEC-HMS 4.2.1
# Package Created May 23rd 2018
# Packaged by Kade Wessels

=pod

Begin-Doc
Modified: $May 23, 2018$
Name: HEC software
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'hec.2018',
    package_revision =&gt; '20180523T1016',
  );
}

# Add InstallMonkey Library to the path
use lib(
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use InstallMonkey::Shared;

my $src = get_pkg_sourcefiles();
my $cwd = cwd();
my $applogs=get_applogs_dir();

#check if some ArcGIS is installed
sub prereq_sub {
	output("Checking for ArcGIS: ");
	my $foldername = 'C:\Program Files (x86)\ArcGIS';
	if (-d $foldername) { 
		output("Found!\n");
		return 1;
	}
	else {
		output("Not found, please install and try again.\n"); 
		return 0;
	}
}


sub inst_sub {
	output("Installing HEC-HMS 4.2.1...");
	if (!run_command("\"$src\\HEC-HMS_421_Setup.exe\" /S /v/qn")) {
		output("\nERROR installing HEC-HMS\n");
		return 0;
	}
	output("Success\nInstalling HEC-RAS 5.0.3...");
	if (!run_command("\"$src\\HEC-RAS_503_Setup.exe\" /S /v/qn")) {
		output("\nERROR installing HEC-RAS\n");
		return 0;
	}
	output("...Success\n");

	return 1;  
}  

do_install( 
	allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
	allowed_os_architectures =&gt; [OSARCH_x64],
	allowed_regs =&gt; [ 'clc', 'desktop', 'traveling',
						 'virtual-clc', 'virtual-desktop' ],
	exit_on_failure =&gt; 1,
	prerequisite_sub =&gt; \&amp;prereq_sub,
	install_sub =&gt; \&amp;inst_sub,
);

IM_Exit(EXIT_SUCCESS);


</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\hecNoGeo.2016\prod\update.pl</FullName>
    <Length>2171</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-03-21T10:24:19.0636859-05:00</CreationTime>
    <CreationTimeUtc>2018-03-21T15:24:19.0636859Z</CreationTimeUtc>
    <LastWriteTime>2018-06-07T15:03:16.5546888-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-07T20:03:16.5546888Z</LastWriteTimeUtc>
    <LastAccessTime>2018-03-21T10:24:19.0636859-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-03-21T15:24:19.0636859Z</LastAccessTimeUtc>
    <Text># HEC 2016
# Package Created March 2011 for HEC 2011
# Packaged by idl8t3
# Updated 2016-11-23 by Chris Schaaf
# Updated 2018-01-23 by Grayson Gratop
# Last Updated 2018-03-22 by Sergey Gruzdev

=pod

Begin-Doc
Modified: $March 17, 2011$
Name: HEC software
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'hecNoGeo.2016',
    package_revision =&gt; '20180322T1536',
  );
}

# Add InstallMonkey Library to the path
use lib(
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use InstallMonkey::Shared;

my $src = get_pkg_sourcefiles();
my $cwd = cwd();
my $applogs=get_applogs_dir();

#check if some ArcGIS is installed
sub prereq_sub {
	output("Checking for ArcGIS: ");
	my $foldername = 'C:\Program Files (x86)\ArcGIS';
	if (-d $foldername) { 
		output("Found!\n");
		return 1;
	}
	else {
		output("Not found, please install and try again.\n"); 
		return 0;
	}
}


sub inst_sub {
	output ("Unzipping data files...\n");
	if(!run_command("\"C:\\Program Files\\7-zip\\7z.exe\" x -o\"$src\" \"$src\\data.zip\""))
	{
	}
	output("Installing HEC-HMS 4.2...");
	if (!run_command("\"$src\\HEC-HMS_42_Setup.exe\" /S /v/qn")) {
		output("\nERROR installing HEC-HMS\n");
		return 0;
	}
	output("Success\nInstalling HEC-RAS 5.0.3...");
	if (!run_command("\"$src\\HEC-RAS_503_Setup.exe\" /S /v/qn")) {
		output("\nERROR installing HEC-RAS\n");
		return 0;
	}
	output("...Success\n");

	return 1;  
}  

do_install( 
	allowed_versions =&gt; [ 'OSVER_WIN10_SP0', 'OSVER_WIN10_SP1' ],
	allowed_os_architectures =&gt; [OSARCH_x64],
	allowed_regs =&gt; [ 'clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
	exit_on_failure =&gt; 1,
	prerequisite_sub =&gt; \&amp;prereq_sub,
	install_sub =&gt; \&amp;inst_sub,
);

IM_Exit(EXIT_SUCCESS);


</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\hyper-v_tools.7\prod\update.pl</FullName>
    <Length>2017</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-11-18T10:19:13.8518685-06:00</CreationTime>
    <CreationTimeUtc>2016-11-18T16:19:13.8518685Z</CreationTimeUtc>
    <LastWriteTime>2016-11-18T10:50:05.8978014-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-11-18T16:50:05.8978014Z</LastWriteTimeUtc>
    <LastAccessTime>2016-11-18T10:19:13.8518685-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-11-18T16:19:13.8518685Z</LastAccessTimeUtc>
    <Text># Enable Hyper-V Tools - Windows 7
# Package Created July 2016
# Packaged by Chris Schaaf
# Last Updated ...

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

#This is a very simple, one-line command. Probably doesn't even need an IM wrapper.
#Using IM to provide usual UMR registry keys and uninstall functionality.
#https://technet.microsoft.com/en-us/library/hh824822.aspx

use strict;
use warnings;
use Getopt::Long;
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'hyper-v_tools.7',
        package_revision =&gt; '20161118T1200',
    );
}

sub usage {
    print qq(
usage: $0 [--help] [--uninstall]

);
}
GetOptions(
    'help' =&gt; sub { usage(); exit(0); },
    'uninstall' =&gt; sub { exit(!uninstall()); },
);

 sub install {
	output("Enabling Hyper-V Tools: ");
	if(!run_command("DISM /Online /Enable-Feature /FeatureName:RemoteServerAdministrationTools-Roles-HyperV")){
		output("ERROR\n");
		return 0;
	}
	else{
		output("Enabled\n");
	}

   return 1;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling','virtual-clc', 'virtual-desktop'],
	no_source_files =&gt; 1,
    exit_on_failure =&gt; 1,
	install_sub =&gt; \&amp;install,
);


IM_Exit(EXIT_SUCCESS);

sub uninstall {
	output("Disabling Hyper-V Tools: ");
	if(!run_command("DISM /Online /Disable-Feature /FeatureName:RemoteServerAdministrationTools-Roles-HyperV")) {
		output("ERROR\n");
		return 0;
	}
	else {
		output("Disabled\n");
		delete_product_registry_key(get_package_name().".".get_version());
	}
	return 1;
}
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\hyperworks.14\prod\update.pl</FullName>
    <Length>1617</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-11-28T12:08:52.700581-06:00</CreationTime>
    <CreationTimeUtc>2016-11-28T18:08:52.700581Z</CreationTimeUtc>
    <LastWriteTime>2018-01-17T10:32:34.053945-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-17T16:32:34.053945Z</LastWriteTimeUtc>
    <LastAccessTime>2016-11-28T12:08:52.7317818-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-11-28T18:08:52.7317818Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Package Created June 2010
# Packaged by El Don
# Updated November 2016 by Jason Mao

=begin
Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc
=cut

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'hyperworks.14',
        package_revision =&gt; '20161128T1620',
    );
}


use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy";
my $src = get_pkg_sourcefiles();
my $cwd = cwd();
my $au = "C:\\Users\\Public";

sub install {
	#run installer silently
  output("  Installing: ");
	if(!run_command("$appdeploy\\hyperworks.14\\hwdesktop14.0.110_win64.exe -i silent")) {
		output("FAILED!\n");
		return 0;
	}
  output("OK\n");
  output("  Setting license path: ");
  if(!run_command("setx ALTAIR_LICENSE_PATH 6200\@hyperworks.lic.mst.edu \/m")) {
    output("FAILED!\n");
    return 0;
  }
  output("OK\n");

  return 1;
 }

do_install( 
    allowed_versions =&gt; [ OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_XP_32, OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-desktop', 'virtual-clc'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    no_source_files =&gt; 1,
);
IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\idea.2017_1_3\prod\update.pl</FullName>
    <Length>2169</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-07-20T10:58:36.5300542-05:00</CreationTime>
    <CreationTimeUtc>2017-07-20T15:58:36.5300542Z</CreationTimeUtc>
    <LastWriteTime>2017-07-20T10:48:51.7737685-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-07-20T15:48:51.7737685Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-20T10:58:36.5300542-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-20T15:58:36.5300542Z</LastAccessTimeUtc>
    <Text># Idea 2017.1.3
# Package Created July 20, 2017
# Packaged by Sergey Gruzdev
# Updated 2017-07-20 by Sergey Gruzdev

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'idea.2017_1_3',
        package_revision =&gt; '20170720T0944',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

my $src = get_pkg_sourcefiles();
my $dest = "C:\\Program Files (x86)\\JetBrains\\IntelliJ IDEA 2017.1.3\\bin";

GetOptions('uninstall' =&gt; sub{exit(uninstall())});

sub uninstall
{
  # Run uninstaller
  print "Uninstalling IdeaIU: ";
  if(!run_command("\"$dest\"\\uninstall.exe /S /NCRC"))
  {
    print "FAILED!\n";
	return 0;
  }
  # Delete reg key
  delete_product_registry_key(get_package_name().".".get_version());
  print "Done!\n";
  return 1;
}

sub install
{
  print "Installing IdeaIU: ";
  # Run installer
  if(!run_command("start \"IdealIU Install\" /wait \"$src\\IdeaIU-2017.1.3.exe\" /S /NCRC"))
  {
    print "FAILED!\n";
	return 0;
  }
  print "Success!\n";
  return 1;
}

sub postinstall
{
  print "Configuring IdeaIU...\n";
  # Do licensing and configuration
  if(!run_command("XCOPY /I /H /Y /E \"$src\\.IntelliJIdea2017.1\" \"C:".$ENV{"HOMEPATH"}."\\.IntelliJIdea2017.1\""))
  {
    print "Error: could not copy license and configuration files! Licensing and configuration steps must be completed manually!\n";
	return 0;
  }
  print "Installation complete!\n";
  return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\imagej.1_50\prod\update.pl</FullName>
    <Length>2079</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-05-20T12:01:14.603456-05:00</CreationTime>
    <CreationTimeUtc>2016-05-20T17:01:14.603456Z</CreationTimeUtc>
    <LastWriteTime>2016-05-20T11:45:46.6040102-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-05-20T16:45:46.6040102Z</LastWriteTimeUtc>
    <LastAccessTime>2016-05-20T12:01:14.603456-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-05-20T17:01:14.603456Z</LastAccessTimeUtc>
    <Text># Package created May 2016
# Package created by Austin Wall
# Last Updated 20 May 2016 by Austin Wall

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS = 
	(
        package_id =&gt; 'imagej.1_50',
        package_revision =&gt; '20160520T1134',
    );
}


use lib
(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);


use InstallMonkey::Shared;

my $getapplogsdir = get_applogs_dir();
my $sourcefilesdir = get_pkg_sourcefiles();
my $path = "C:\\Program Files (x86)\\ImageJ";
my $startmenu = get_allusers_start_menu();
sub install
{

	output("\nMoving files from $sourcefilesdir to $path\n");
	mkdir $path unless -d $path; # Makes path directory if it doesn't already exist
	if(!run_command("move /y $sourcefilesdir \"$path\\\""))
    {
        output("\n");
        output("ImageJ 1.50 did not install successfully - ");
        output("please check the logs.");
        output("\n");

        return 0;
    }

    return 1;
}


sub postinstall
{
	my $shortcutdir = $startmenu.'\ImageJ';
	output("Creating shortcut in $shortcutdir\n");
    mkdir $shortcutdir unless -d $shortcutdir;
	if(!create_shortcut(
		'target' 	  =&gt; $path . '\imagej.1_50\ImageJ.exe',
		'link' 		  =&gt; $shortcutdir.'\ImageJ.lnk',
		'description' =&gt; 'Launches ImageJ',
		)
	)
	{
		output("\nERROR: Could not create shortcut.\n");
	}
    return 1;
}


do_install
( 
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [ 'clc', 'desktop', 'traveling', 'virtual-clc', 
                        'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);


IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\imagej.1_52a\prod\update.pl</FullName>
    <Length>2097</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-22T14:57:35.0168447-05:00</CreationTime>
    <CreationTimeUtc>2018-05-22T19:57:35.0168447Z</CreationTimeUtc>
    <LastWriteTime>2018-05-23T08:23:17.9018731-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-23T13:23:17.9018731Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-22T14:57:35.0168447-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-22T19:57:35.0168447Z</LastAccessTimeUtc>
    <Text># Package created 5/22/2018
# Package created by Cameron Loren
# Last Updated 5/22/2018 by Cameron Loren

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS =
	(
        package_id =&gt; 'imagej.1_52a',
        package_revision =&gt; '20180522T1500',
    );
}


use lib
(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);


use InstallMonkey::Shared;

my $getapplogsdir = get_applogs_dir();
my $sourcefilesdir = get_pkg_sourcefiles();
my $path = "C:\\Program Files (x86)\\ImageJ";
my $startmenu = get_allusers_start_menu();
sub install
{

	output("\nMoving files from $sourcefilesdir to $path\n");
	mkdir $path unless -d $path; # Makes path directory if it doesn't already exist
	if(!run_command("move /y $sourcefilesdir \"$path\\\""))
    {
        output("\n");
        output("ImageJ 1.52a did not install successfully - ");
        output("please check the logs.");
        output("\n");

        return 0;
    }

    return 1;
}


sub postinstall
{
	my $shortcutdir = $startmenu.'\ImageJ';
	output("Creating shortcut in $shortcutdir\n");
    mkdir $shortcutdir unless -d $shortcutdir;
	if(!create_shortcut(
		'target' 	  =&gt; $path . '\imagej.1_52a\ImageJ.exe',
		'link' 		  =&gt; $shortcutdir.'\ImageJ.lnk',
		'description' =&gt; 'Launches ImageJ',
		)
	)
	{
		output("\nERROR: Could not create shortcut.\n");
	}
    return 1;
}


do_install
(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [ 'clc', 'desktop', 'traveling', 'virtual-clc',
                        'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);


IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\inkscape.0_92_1\prod\update.pl</FullName>
    <Length>1937</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-05-22T10:19:06.8416999-05:00</CreationTime>
    <CreationTimeUtc>2017-05-22T15:19:06.8416999Z</CreationTimeUtc>
    <LastWriteTime>2017-05-22T10:22:04.5603175-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-05-22T15:22:04.5603175Z</LastWriteTimeUtc>
    <LastAccessTime>2017-05-22T10:19:06.8416999-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-05-22T15:19:06.8416999Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Packaged by Austin Wall
# Last Updated May 22, 2017 by Austin Wall


use strict;
use warnings;
use Getopt::Long;
######
GetOptions(
    'uninstall' =&gt; sub { exit(!uninstall()); },
) || die "Usage: $!";
######

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'inkscape.0_92_1',
        package_revision =&gt; '20170522T1020',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
sub uninstall {
    my $sourcefilesdir = get_pkg_sourcefiles();
    output("Uninstalling InkScape: ");
    my $Success = install_msi(
        msi=&gt; "$sourcefilesdir\\inkscape-0.92.1-x64.msi",
        msi_action_flag =&gt; 'x',
    );
    output($Success ? "Success!\n" : "FAILED: $!\n");
    if ($Success) { delete_product_registry_key('inkscape.0_92_1'); }
    
    return $Success;
}



sub install {
    my $sourcefilesdir = get_pkg_sourcefiles();
    output( "Installing InkScape: " );
    my $Success = install_msi(
        msi =&gt; "$sourcefilesdir\\inkscape-0.92.1-x64.msi",
    );
    output($Success ? "Success!\n" : "FAILED: $!\n");
    
    return $Success;
}

sub post {
    output("Removing icons: ");
    my $Remove = run_command("del \"%systemdrive%\\Users\\Public\\Desktop\\Inkscape 0.92.1.lnk\" /Q");
    output($Remove ? "Success!\n" : "FAILED: $!\n");
    
    return $Remove;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;post,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\inkscape.0_92_3\prod\update.pl</FullName>
    <Length>1943</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-16T14:00:38.3376379-05:00</CreationTime>
    <CreationTimeUtc>2018-05-16T19:00:38.3376379Z</CreationTimeUtc>
    <LastWriteTime>2018-05-17T08:44:42.1312724-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-17T13:44:42.1312724Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-16T14:00:38.3376379-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-16T19:00:38.3376379Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Packaged by Gavin Altermatt
# Last Updated May 22, 2018 Based off Austin Wall package


use strict;
use warnings;
use Getopt::Long;
######
GetOptions(
    'uninstall' =&gt; sub { exit(!uninstall()); },
) || die "Usage: $!";
######

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'inkscape.0_92_3',
        package_revision =&gt; '20180517T0844',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
sub uninstall {
    my $sourcefilesdir = get_pkg_sourcefiles();
    output("Uninstalling InkScape: ");
    my $Success = install_msi(
        msi=&gt; "$sourcefilesdir\\inkscape-0.92.3-x64.msi",
        msi_action_flag =&gt; 'x',
    );
    output($Success ? "Success!\n" : "FAILED: $!\n");
    if ($Success) { delete_product_registry_key('inkscape.0_92_3'); }

    return $Success;
}



sub install {
    my $sourcefilesdir = get_pkg_sourcefiles();
    output( "Installing InkScape: " );
    my $Success = install_msi(
        msi =&gt; "$sourcefilesdir\\inkscape-0.92.3-x64.msi",
    );
    output($Success ? "Success!\n" : "FAILED: $!\n");

    return $Success;
}

sub post {
    output("Removing icons: ");
    my $Remove = run_command("del \"%systemdrive%\\Users\\Public\\Desktop\\Inkscape 0.92.3.lnk\" /Q");
    output($Remove ? "Success!\n" : "FAILED: $!\n");

    return $Remove;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;post,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\intellij.2017_1_3\dev\update.pl</FullName>
    <Length>1324</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-05T16:26:51.1642994-05:00</CreationTime>
    <CreationTimeUtc>2017-06-05T21:26:51.1642994Z</CreationTimeUtc>
    <LastWriteTime>2017-06-13T11:02:21.4678775-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-13T16:02:21.4678775Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-05T16:26:51.1642994-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-05T21:26:51.1642994Z</LastAccessTimeUtc>
    <Text>
    # intellij
    # Package Created June 05, 2017
    # Packaged by Krueger, Benjamin (S&amp;T IT Student Employee)
    # Last Updated --

    BEGIN {
        %::INSTALLMONKEY_OPTIONS = (
            package_id =&gt; 'intellij.2017_1_3',
            package_revision =&gt; '20170605T1626',
        );
    }

    use lib (
        '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
        $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
        'C:\temp',
    );
    use InstallMonkey::Shared;

    my $srcfiles = get_pkg_sourcefiles();
    my $log_dir = get_applogs_dir();

    sub install {
        if(!run_command($srcfiles."\\ideaIU-2017.1.3.exe /S"))
        {
            output("Installation failed!\n");
            return 0;
        }
        
        output("Installation successful!");
        return 1;
    }

    do_install( 
        exit_on_failure =&gt; 1,
        allowed_versions          =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
        allowed_os_architectures  =&gt; [ OSARCH_x64 ],
        allowed_regs              =&gt; [ "clc", "desktop", "traveling", "virtual-desktop", "virtual-clc" ],
        install_sub               =&gt; \&amp;install,

        
    );

    IM_Exit(EXIT_SUCCESS);

    ########################################################################
    </Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\intellij.2017_1_3\prod\update.pl</FullName>
    <Length>5480</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-07-26T10:29:19.0720435-05:00</CreationTime>
    <CreationTimeUtc>2017-07-26T15:29:19.0720435Z</CreationTimeUtc>
    <LastWriteTime>2018-07-05T12:28:18.8320144-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-05T17:28:18.8320144Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-26T10:29:19.0720435-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-26T15:29:19.0720435Z</LastAccessTimeUtc>
    <Text># Intellij 2017.1.3
# Package Created 2017-07-26
# Packaged by Alex Schrimpf
# Updated 2017-07-26 by Alex Schrimpf

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'intellij.2017_1_3',
        package_revision =&gt; '20170719T1433',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;
use Getopt::Long;
use File::Copy;
use File::Path qw(make_path remove_tree);
use File::Basename;

my $src = get_pkg_sourcefiles();

###################################################s#####
# CONFIG
########################################################

my $INSTALLER = "$src\\ideaIU-2017.1.3.exe";

my %SHORTCUTS = (
  "x64" =&gt; "$src\\Intellij IDEA 2017.1.3.lnk",
  #"x86" =&gt; "$src\\Intellij IDEA 2017.1.3.lnk"
);

#Where to store key
#Expected to be in %HOMEPATH% Dir
my $USER_CONFIG = '\\.IntelliJIdea2017.1\\config';
my $KEY_LOC = $USER_CONFIG.'\\idea.key';

#key file binary dump
#EX: $ xxd -b -i example.key
my @KEY = ( 0xff, 0xff, 0x55, 0x00, 0x52, 0x00, 0x4c, 0x00, 0x3a, 0x00, 0x68, 0x00,
  0x74, 0x00, 0x74, 0x00, 0x70, 0x00, 0x3a, 0x00, 0x2f, 0x00, 0x2f, 0x00,
  0x70, 0x00, 0x79, 0x00, 0x63, 0x00, 0x68, 0x00, 0x61, 0x00, 0x72, 0x00,
  0x6d, 0x00, 0x2e, 0x00, 0x6c, 0x00, 0x69, 0x00, 0x63, 0x00, 0x2e, 0x00,
  0x6d, 0x00, 0x73, 0x00, 0x74, 0x00, 0x2e, 0x00, 0x65, 0x00, 0x64, 0x00,
  0x75, 0x00, 0x3a, 0x00, 0x38, 0x00, 0x30, 0x00, 0x38, 0x00, 0x30, 0x00
);

########################################################

sub create_login_script
{
    my $script_dir = build_path(get_allusers_scripts(),'standard',get_package_id());
    
    my $script_file = build_path($script_dir,get_package_id().'_userlogin.pl');
   
    my $script_wrapper = build_path($script_dir,get_package_id().'_userlogin.cmd');

    if (-d $script_dir) {
      remove_tree($script_dir) or
      output(":: ERROR | REMOVING EXISTING LOGIN SCRIPT DIRECTORY '${script_dir}': $! |\n",
        LOG_ONLY);
    }
    
    make_path($script_dir);

    if (open(my $script,'&gt;',$script_file)) {
      print $script q|
  use strict;
  use File::Path qw (make_path remove_tree);
  
  my $home = $ENV{"HOMEPATH"};
  my $user_config = $home.'|.$USER_CONFIG.q|';
  my $key = $home.'|.$KEY_LOC.q|';

  print(": BUILDING DIRECTORY \| \"$user_config\" \|\n");
  if(!make_path($user_config)){
    print(":: FAILED\n\n");
  }
  print(": DONE\n\n");

  #key file binary dump
  #EX: $ xxd -b -i example.key

  my @key = (|.join(", ",@KEY).q|);

 print(": WRITING KEY FILE \| \"$key\" \|\n");
 if(open(KEY_FILE, "&gt;", $key)){
  foreach (@key){
   print KEY_FILE map { chr } $_;
  }
  close(KEY_FILE);
  print(": DONE\n\n");
  exit(0);
 }
 else{
  print(":: FAILED\n\n");
  exit(1);
 }
|;
      close($script);
      output(join("\n",get_package_id(),' Login Script:',('-' x 60),
        get_file_contents($script_file),('-' x 60),''), LOG_ONLY);
    } else {
      output(":: ERROR | COULD NOT OPEN LOGIN SCRIPT FILE '${script_file}': $! | \n");
      return 0;
    }

    if (open(my $script,'&gt;',$script_wrapper)) {
      my $log_dir = build_path('%APPDATA%','MST','Logs');
      print $script q|
C:
IF NOT EXIST |.$log_dir.q| mkdir "|.$log_dir.q|"
perl "%~dp0|.basename($script_file).q|" &gt; "|.
            build_path($log_dir,get_package_id().'-loginscript.txt').q|" 2&gt;&amp;1
|;

      close($script);
      output(join("\n",get_package_id(),' Login Script:',('-' x 60),
        get_file_contents($script_wrapper),('-' x 60),''), LOG_ONLY);
    } else {
      output(":: ERROR | COULD NOT OPEN LOGIN SCRIPT WRAPPER FILE '${script_wrapper}': $! |\n");
      return 0;
    }

    return $script_wrapper;
}

sub install
{
  output(": INSTALLING ".get_package_id()."\n");
  if(!run_command("\"$INSTALLER\" /S /NCRC"))
  {
    output ":: FAILED\n\n";
	  return 0;
  }
  output ": DONE\n\n";
  return 1;
}

sub postinstall
{
  foreach my $scut (keys %SHORTCUTS){
    output(": COPYING SHORTCUT \"$scut\" TO START MENU\n");
    if(!copy($SHORTCUTS{$scut},"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs")){
      output(":: FAILED\n\n");
      return 0;
    }
    output(": DONE\n\n");
  }
  output(": BUILDING LOGIN SCRIPT\n");
  my $script_wrapper = cmd_quote(create_login_script());
  output(": DONE\n\n");

  #this part can be disabled when not testing as system account won't ever run program
  if(!(`whoami` eq "nt authority\\system\n")){
    output(": RUNNING LOGIN SCRIPT FOR CURRENT USER\n");
    if(!run_command($script_wrapper)){
      output(":: FAILED\n\n");
      return 0;
    }
    output(": DONE\n\n");   
  }else{
    output(": DETECTED RUNNING AS SYSTEM\n")
  }

  create_activesetup_action(
	  'Identifier' =&gt; $INSTALLMONKEY_OPTIONS{'package_id'}.'_setup',
	  'ComponentID' =&gt; $INSTALLMONKEY_OPTIONS{'package_id'},
	  'Description' =&gt; 'add license server',
	  'Version' =&gt; '1.0',
	  'StubPath' =&gt; $script_wrapper);

  return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\intelliJ.2018_1_4\dev\update.pl</FullName>
    <Length>1351</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-07-05T12:21:42.0834423-05:00</CreationTime>
    <CreationTimeUtc>2018-07-05T17:21:42.0834423Z</CreationTimeUtc>
    <LastWriteTime>2018-07-05T12:26:34.112853-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-05T17:26:34.112853Z</LastWriteTimeUtc>
    <LastAccessTime>2018-07-05T12:21:42.0834423-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-07-05T17:21:42.0834423Z</LastAccessTimeUtc>
    <Text>
    # intellij
    # Package Created June 05, 2017
    # Packaged by Krueger, Benjamin (S&amp;T IT Student Employee)
    # Last Updated by Kade Wessels July 05, 2018

    BEGIN {
        %::INSTALLMONKEY_OPTIONS = (
            package_id =&gt; 'intellij.2018_1_4',
            package_revision =&gt; '20180705T1225',
        );
    }

    use lib (
        '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
        $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
        'C:\temp',
    );
    use InstallMonkey::Shared;

    my $srcfiles = get_pkg_sourcefiles();
    my $log_dir = get_applogs_dir();

    sub install {
        if(!run_command($srcfiles."\\ideaIU-2018.1.4.exe /S"))
        {
            output("Installation failed!\n");
            return 0;
        }
        
        output("Installation successful!");
        return 1;
    }

    do_install( 
        exit_on_failure =&gt; 1,
        allowed_versions          =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
        allowed_os_architectures  =&gt; [ OSARCH_x64 ],
        allowed_regs              =&gt; [ "clc", "desktop", "traveling", "virtual-desktop", "virtual-clc" ],
        install_sub               =&gt; \&amp;install,

        
    );

    IM_Exit(EXIT_SUCCESS);

    ########################################################################
    </Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\intelliJ.2018_1_4\prod\update.pl</FullName>
    <Length>5479</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-07-05T12:30:17.4782697-05:00</CreationTime>
    <CreationTimeUtc>2018-07-05T17:30:17.4782697Z</CreationTimeUtc>
    <LastWriteTime>2018-07-09T11:48:17.1236471-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-09T16:48:17.1236471Z</LastWriteTimeUtc>
    <LastAccessTime>2018-07-05T12:30:17.5376511-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-07-05T17:30:17.5376511Z</LastAccessTimeUtc>
    <Text># Intellij 2018.1.4
# Package Created 2017-07-26
# Packaged by Alex Schrimpf
# Updated 2018-07-05 by Kade Wessels

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'intellij.2018_1_4',
        package_revision =&gt; '20180705T1229',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;
use Getopt::Long;
use File::Copy;
use File::Path qw(make_path remove_tree);
use File::Basename;

my $src = get_pkg_sourcefiles();

###################################################s#####
# CONFIG
########################################################

my $INSTALLER = "$src\\ideaIU-2018.1.4.exe";

my %SHORTCUTS = (
  "x64" =&gt; "$src\\Intellij IDEA 2018.1.4.lnk",
  #"x86" =&gt; "$src\\Intellij IDEA 2017.1.3.lnk"
);

#Where to store key
#Expected to be in %HOMEPATH% Dir
my $USER_CONFIG = '\\.IntelliJIdea2018.1\\config';
my $KEY_LOC = $USER_CONFIG.'\\idea.key';

#key file binary dump
#EX: $ xxd -b -i example.key
my @KEY = ( 0xff, 0xff, 0x55, 0x00, 0x52, 0x00, 0x4c, 0x00, 0x3a, 0x00, 0x68, 0x00,
  0x74, 0x00, 0x74, 0x00, 0x70, 0x00, 0x3a, 0x00, 0x2f, 0x00, 0x2f, 0x00,
  0x70, 0x00, 0x79, 0x00, 0x63, 0x00, 0x68, 0x00, 0x61, 0x00, 0x72, 0x00,
  0x6d, 0x00, 0x2e, 0x00, 0x6c, 0x00, 0x69, 0x00, 0x63, 0x00, 0x2e, 0x00,
  0x6d, 0x00, 0x73, 0x00, 0x74, 0x00, 0x2e, 0x00, 0x65, 0x00, 0x64, 0x00,
  0x75, 0x00, 0x3a, 0x00, 0x38, 0x00, 0x30, 0x00, 0x38, 0x00, 0x30, 0x00
);

########################################################

sub create_login_script
{
    my $script_dir = build_path(get_allusers_scripts(),'standard',get_package_id());
    
    my $script_file = build_path($script_dir,get_package_id().'_userlogin.pl');
   
    my $script_wrapper = build_path($script_dir,get_package_id().'_userlogin.cmd');

    if (-d $script_dir) {
      remove_tree($script_dir) or
      output(":: ERROR | REMOVING EXISTING LOGIN SCRIPT DIRECTORY '${script_dir}': $! |\n",
        LOG_ONLY);
    }
    
    make_path($script_dir);

    if (open(my $script,'&gt;',$script_file)) {
      print $script q|
  use strict;
  use File::Path qw (make_path remove_tree);
  
  my $home = $ENV{"HOMEPATH"};
  my $user_config = $home.'|.$USER_CONFIG.q|';
  my $key = $home.'|.$KEY_LOC.q|';

  print(": BUILDING DIRECTORY \| \"$user_config\" \|\n");
  if(!make_path($user_config)){
    print(":: FAILED\n\n");
  }
  print(": DONE\n\n");

  #key file binary dump
  #EX: $ xxd -b -i example.key

  my @key = (|.join(", ",@KEY).q|);

 print(": WRITING KEY FILE \| \"$key\" \|\n");
 if(open(KEY_FILE, "&gt;", $key)){
  foreach (@key){
   print KEY_FILE map { chr } $_;
  }
  close(KEY_FILE);
  print(": DONE\n\n");
  exit(0);
 }
 else{
  print(":: FAILED\n\n");
  exit(1);
 }
|;
      close($script);
      output(join("\n",get_package_id(),' Login Script:',('-' x 60),
        get_file_contents($script_file),('-' x 60),''), LOG_ONLY);
    } else {
      output(":: ERROR | COULD NOT OPEN LOGIN SCRIPT FILE '${script_file}': $! | \n");
      return 0;
    }

    if (open(my $script,'&gt;',$script_wrapper)) {
      my $log_dir = build_path('%APPDATA%','MST','Logs');
      print $script q|
C:
IF NOT EXIST |.$log_dir.q| mkdir "|.$log_dir.q|"
perl "%~dp0|.basename($script_file).q|" &gt; "|.
            build_path($log_dir,get_package_id().'-loginscript.txt').q|" 2&gt;&amp;1
|;

      close($script);
      output(join("\n",get_package_id(),' Login Script:',('-' x 60),
        get_file_contents($script_wrapper),('-' x 60),''), LOG_ONLY);
    } else {
      output(":: ERROR | COULD NOT OPEN LOGIN SCRIPT WRAPPER FILE '${script_wrapper}': $! |\n");
      return 0;
    }

    return $script_wrapper;
}

sub install
{
  output(": INSTALLING ".get_package_id()."\n");
  if(!run_command("\"$INSTALLER\" /S /NCRC"))
  {
    output ":: FAILED\n\n";
	  return 0;
  }
  output ": DONE\n\n";
  return 1;
}

sub postinstall
{
  foreach my $scut (keys %SHORTCUTS){
    output(": COPYING SHORTCUT \"$scut\" TO START MENU\n");
    if(!copy($SHORTCUTS{$scut},"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs")){
      output(":: FAILED\n\n");
      return 0;
    }
    output(": DONE\n\n");
  }
  output(": BUILDING LOGIN SCRIPT\n");
  my $script_wrapper = cmd_quote(create_login_script());
  output(": DONE\n\n");

  #this part can be disabled when not testing as system account won't ever run program
  if(!(`whoami` eq "nt authority\\system\n")){
    output(": RUNNING LOGIN SCRIPT FOR CURRENT USER\n");
    if(!run_command($script_wrapper)){
      output(":: FAILED\n\n");
      return 0;
    }
    output(": DONE\n\n");   
  }else{
    output(": DETECTED RUNNING AS SYSTEM\n")
  }

  create_activesetup_action(
	  'Identifier' =&gt; $INSTALLMONKEY_OPTIONS{'package_id'}.'_setup',
	  'ComponentID' =&gt; $INSTALLMONKEY_OPTIONS{'package_id'},
	  'Description' =&gt; 'add license server',
	  'Version' =&gt; '1.0',
	  'StubPath' =&gt; $script_wrapper);

  return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\Inventor.2018x64\prod\update.pl</FullName>
    <Length>5350</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-14T11:15:53.1799559-05:00</CreationTime>
    <CreationTimeUtc>2017-06-14T16:15:53.1799559Z</CreationTimeUtc>
    <LastWriteTime>2017-06-14T15:21:20.9427874-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-14T20:21:20.9427874Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-14T11:15:53.1799559-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-14T16:15:53.1799559Z</LastAccessTimeUtc>
    <Text># Package Created June 14, 2017
# Packaged by Austin Wall
# Last Updated 

use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'Inventor.2018x64',
        package_revision =&gt; '20170614T1117',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Win32::TieRegistry;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();
use Getopt::Long;


my @uninstall_appids = (
    '{31ABA3F2-0000-1033-0102-111D43815377}', # ReCap
    '{31ABA3F2-0010-1033-0102-111D43815377}', # ReCap Language Pack
    '{5783F2D7-D028-0409-0100-0060B0CE6BBA}', # DWG Trueview
    '{7F4DD591-1864-0001-0000-7107D70F3DB4}', # Inventor
    '{7F4DD591-1864-0001-1033-7107D70F3DB4}', # Inventor Language Pack
    );

GetOptions(
    'uninstall' =&gt; sub { exit(!uninstall()); },
);

# Requires Win32::TieRegistry
# Declare @uninstall_appids BEFORE GetOptions sub
sub uninstall 
{
    my $success = 1;

    output( "Uninstalling " . get_package_id() . ":\n" );
    foreach my $appid (@uninstall_appids) {
        if (my @appids = IsAppInstalled('AppID' =&gt; $appid)) {
            my $display_name = $appid;
            $display_name = $Registry-&gt;{$appids[0]}-&gt;{DisplayName} if (exists($Registry-&gt;{$appids[0]}-&gt;{DisplayName}));
            
            my $uninstall_log = get_package_id() . '-'.$display_name.'_uninstall.txt';

            output("  Uninstalling $display_name: ");
            my $outcome =
                install_msi(
                    'app_id'              =&gt; $appid,
                    'msi_action_flag'     =&gt; 'x',
                    'logfile_name'        =&gt; $uninstall_log,
                    'logfile_indirection' =&gt; 1, # 32-bit app
                );

            $success &amp;= $outcome;
            output(($outcome?'OK':'FAILED')."\n");
        }
    }
    if ($success)
    {
        delete_product_registry_key(get_package_id());
    }
    return $success;
}

sub preinstall{
    output("Clearing reboot flag...\n");
    $Registry-&gt;Delimiter("/");
    # The setup will restart the machine first if this key exists
    delete $Registry-&gt;{"LMachine/Software/Microsoft/Windows/CurrentVersion/WindowsUpdate/Auto Update/RebootRequired/"};
}

sub install{
    # This is run from appdeploy to avoid copying over 13GB of files per install.
    # The setup is generated with "Create Deployment" in the original install file.
    # More info available on wiki.
    my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\Inventor_2018\\Img";
    my $command = "$appdeploy\\Setup.exe /qb /I $appdeploy\\inventor_2018x64.ini /language en-us";
    my $tasklist = `tasklist`;

    output("Installing Autodesk Inventor...\n");
    
    if($tasklist =~ /setup\.exe/gi){
        output("\tsetup.exe is already running...\n\tattemtping to kill it...\n");
        my $kill = run_command("taskkill /fi \"Imagename eq Setup.exe*\" /F");
        output($kill ? "\tKilled \n" : "\tFailed to kill: $!\n");
    }
    
    run_command($command, 'IgnoreReturnCode'=&gt;1);

    # The run_command spawns a separate process and returns immediately so this loop waits until setup.exe finishes running.
    my $index = 0;
    while($index &lt; 3600) # 3600*5sec = 5 hours
    {
        $tasklist = `tasklist`;
        if($tasklist =~ /setup\.exe/gi){
            $index++;
            sleep(5);
            if ($index % 60 == 0)
            {
                output((300 - $index/60) . " minutes remaining...\n");
            }
        }
        else{
            output("Setup finished!\n");
            return 1;
        }
    }

    output("Timed out...\n");

    return 0;
}

sub postinstall
{
    my $cwd = cwd();

    print("Copying License...\n");
    my $dest = get_arch_programfiles(OSARCH_x64).'\\Autodesk\\';
    run_command("copy \"$cwd\\LICPATH.LIC\" \"$dest\" /Y");
    run_command("setx ADSKFLEX_LICENSE_FILE \"C:\\Program Files\\Autodesk\\LICPATH.LIC\" \/m");


    output("Deleting desktop icons...\n");
    my $desk = get_allusers_desktop();
    run_command("DEL /Q \"$desk\\Autodesk 360.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk Design Review 2018.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk Inventor Professional 2018.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk ReCap.lnk\"");
    run_command("DEL /Q \"$desk\\DWG TrueView 2018 - English.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk Vault Basic 2018.lnk\"");
    run_command("DEL /Q \"$desk\\A360 Desktop.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk Desktop App.lnk\"");
    
    return 1;
}

do_install(
    no_source_files  =&gt; "1",
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
#    prerequisite_sub =&gt; \&amp;prerequisite,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\Inventor.2019x64\prod\update.pl</FullName>
    <Length>5496</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-07T08:07:03.3443623-05:00</CreationTime>
    <CreationTimeUtc>2018-06-07T13:07:03.3443623Z</CreationTimeUtc>
    <LastWriteTime>2018-06-13T09:58:01.7384959-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-13T14:58:01.7384959Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-07T08:07:03.3443623-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-07T13:07:03.3443623Z</LastAccessTimeUtc>
    <Text># Package Created June 7, 2018
# Packaged by Cameron Loren
# Last Updated

use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'Inventor.2019x64',
        package_revision =&gt; '20180612T0911',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Win32::TieRegistry;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();
use Getopt::Long;


my @uninstall_appids = (
    '{31ABA3F2-0000-1033-0102-111D43815377}', # ReCap
    '{31ABA3F2-0010-1033-0102-111D43815377}', # ReCap Language Pack
    '{5783F2D7-D028-0409-0100-0060B0CE6BBA}', # DWG Trueview
    '{7F4DD591-1864-0001-0000-7107D70F3DB4}', # Inventor
    '{7F4DD591-1864-0001-1033-7107D70F3DB4}', # Inventor Language Pack
    );

GetOptions(
    'uninstall' =&gt; sub { exit(!uninstall()); },
);

# Requires Win32::TieRegistry
# Declare @uninstall_appids BEFORE GetOptions sub
sub uninstall
{
    my $success = 1;

    output( "Uninstalling " . get_package_id() . ":\n" );
    foreach my $appid (@uninstall_appids) {
        if (my @appids = IsAppInstalled('AppID' =&gt; $appid)) {
            my $display_name = $appid;
            $display_name = $Registry-&gt;{$appids[0]}-&gt;{DisplayName} if (exists($Registry-&gt;{$appids[0]}-&gt;{DisplayName}));

            my $uninstall_log = get_package_id() . '-'.$display_name.'_uninstall.txt';

            output("  Uninstalling $display_name: ");
            my $outcome =
                install_msi(
                    'app_id'              =&gt; $appid,
                    'msi_action_flag'     =&gt; 'x',
                    'logfile_name'        =&gt; $uninstall_log,
                    'logfile_indirection' =&gt; 1, # 32-bit app
                );

            $success &amp;= $outcome;
            output(($outcome?'OK':'FAILED')."\n");
        }
    }
    if ($success)
    {
        delete_product_registry_key(get_package_id());
    }
    return $success;
}

sub preinstall{
    output("Clearing reboot flag...\n");
    $Registry-&gt;Delimiter("/");
    # The setup will restart the machine first if this key exists
    delete $Registry-&gt;{"LMachine/Software/Microsoft/Windows/CurrentVersion/WindowsUpdate/Auto Update/RebootRequired/"};
}

sub install{
    # This is run from appdeploy to avoid copying over 13GB of files per install.
    # The setup is generated with "Create Deployment" in the original install file.
    # More info available on wiki.
    my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\Inventor_2019\\Img";
    my $command = "$appdeploy\\Setup.exe /qb /I $appdeploy\\Inventor.2019x64.ini /language en-us";
    my $tasklist = `tasklist`;

    output("Installing Autodesk Inventor...\n");

    if($tasklist =~ /setup\.exe/gi){
        output("\tsetup.exe is already running...\n\tattemtping to kill it...\n");
        my $kill = run_command("taskkill /fi \"Imagename eq Setup.exe*\" /F");
        output($kill ? "\tKilled \n" : "\tFailed to kill: $!\n");
    }

    run_command($command, 'IgnoreReturnCode'=&gt;1);

    # The run_command spawns a separate process and returns immediately so this loop waits until setup.exe finishes running.
    my $index = 0;
    while($index &lt; 3600) # 3600*5sec = 5 hours
    {
        $tasklist = `tasklist`;
        if($tasklist =~ /setup\.exe/gi){
            $index++;
            sleep(5);
            if ($index % 60 == 0)
            {
                output((300 - $index/60) . " minutes remaining...\n");
            }
        }
        else{
            output("Setup finished!\n");
            return 1;
        }
    }

    output("Timed out...\n");

    return 0;
}

sub postinstall
{
    my $cwd = cwd();

    print("Copying License...\n");
    my $dest = get_arch_programfiles(OSARCH_x64).'\\Autodesk\\';
    run_command("copy \"$cwd\\LICPATH.LIC\" \"$dest\" /Y");
    run_command("setx ADSKFLEX_LICENSE_FILE \"C:\\Program Files\\Autodesk\\LICPATH.LIC\" \/m");


    output("Deleting desktop icons...\n");
    my $desk = get_allusers_desktop();
    run_command("DEL /Q \"$desk\\Autodesk 360.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk Design Review 2018.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk Inventor Professional 2019.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk ReCap.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk ReCap Photo.lnk\"");
    run_command("DEL /Q \"$desk\\DWG TrueView 2019 - English.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk Vault Basic 2018.lnk\"");
    run_command("DEL /Q \"$desk\\A360 Desktop.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk Desktop App.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk Desktop App.lnk\"");
    run_command("DEL /Q \"$desk\\Log\"");

    return 1;
}

do_install(
    no_source_files  =&gt; "1",
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
#    prerequisite_sub =&gt; \&amp;prerequisite,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\itasca.2016\dev\update.pl</FullName>
    <Length>2860</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-11-30T11:42:59.1214615-06:00</CreationTime>
    <CreationTimeUtc>2016-11-30T17:42:59.1214615Z</CreationTimeUtc>
    <LastWriteTime>2016-11-30T11:48:21.1761191-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-11-30T17:48:21.1761191Z</LastWriteTimeUtc>
    <LastAccessTime>2016-11-30T11:42:59.1214615-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-11-30T17:42:59.1214615Z</LastAccessTimeUtc>
    <Text># Itasca 2016 Program Suite
# Package Created November 2016
# Packaged by Austin Wall
# Last Updated 11/30/2016 by Austin Wall

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'itasca.2016',
        package_revision =&gt; '20161130T1144',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Win32;

my $sourcefilesdir = get_pkg_sourcefiles();
my $cwd = cwd();
my $applogs=get_applogs_dir();

sub install {
    
    @msis=("Flac800_64bit438","flac3d600_23","3dec520_238","pfc500_64_27","Udec600_64bit320");
    
    for ($i=0;$i&lt;@msis;$i++)
    {
        $msi="$msis[$i]";
        output"Installing $msi...";
        run_command("start /wait \"\" msiexec /qn /i \"$sourcefilesdir\\$msi.msi\" /l* \"$applogs\\itasca-$msi.txt\"");
        output("Done.\n");
    }
    
    return 1;
}

# sub postinstall
# { 
    # my $pgfiles = $ENV{"ProgramFiles(x86)"}."\\itasca";
    # output("Copying PFC3D Enchanced Visualization, customizations, and shortcuts...");
    # run_command("xcopy \"$sourcefilesdir\\pfc3d_32\" \"$pgfiles\\pfc3d400\" /E /I /Q /H /R /Y");
    # run_command("copy \"$sourcefilesdir\\fist_load.dat\" \"$pgfiles\\pfc3d400\" /Y");
    # run_command("copy \"$sourcefilesdir\\fist_load.dat\" \"$pgfiles\\pfc2d400\" /Y");
    # output("Done.\n");
    
    # output("Copying Active Setup files...");
    # run_command("XCOPY \"$sourcefilesdir\\ActiveSetup.pl\" \"%PROGRAMDATA%\\mst\\standard\\Itasca\\\" /I /Y /Q ");
    # run_command("XCOPY \"$sourcefilesdir\\FirstTime.reg\" \"%PROGRAMDATA%\\mst\\standard\\Itasca\\\" /I /Y /Q ");
    # output("Done.\n");

    # # Install the registry key for Active Setup
    # if(!run_command("REGEDIT /S \"$sourcefilesdir\\ActiveSetup.reg\""))
    # {
      # output("Active Setup has not been set! Please try installation again!\n");
      # return 0;
    # }
    # output("Active Setup has been set successfully!\n");
    
    # my $dir = "C:/Program Files (x86)/Itasca/FLAC700";
    # if(!run_command("icacls \"$dir\" /grant Users:(OI)(CI)F"))
    # {
        # output("Could not grant modify permissions for $dir.\n");
        # output("Please grant Users permission to write to this directory.\n");
    # }
    # output("Granted \'Users\' permissions to $dir\n");
    
    # return 1;
# }
 
do_install( 
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-desktop'],
    exit_on_failure =&gt; 1,

    install_sub =&gt; \&amp;install,
    #postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\itasca.2016\prod\update.pl</FullName>
    <Length>1331</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-11-30T13:16:52.8471123-06:00</CreationTime>
    <CreationTimeUtc>2016-11-30T19:16:52.8471123Z</CreationTimeUtc>
    <LastWriteTime>2016-11-30T13:42:35.5862687-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-11-30T19:42:35.5862687Z</LastWriteTimeUtc>
    <LastAccessTime>2016-11-30T13:16:52.8471123-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-11-30T19:16:52.8471123Z</LastAccessTimeUtc>
    <Text># Itasca 2016 Program Suite
# Package Created November 2016
# Packaged by Austin Wall
# Last Updated 11/30/2016 by Austin Wall

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'itasca.2016',
        package_revision =&gt; '20161130T1342',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Win32;

my $sourcefilesdir = get_pkg_sourcefiles();
my $cwd = cwd();
my $applogs=get_applogs_dir();

sub install {
    
    @msis=("Flac800_64bit438","flac3d600_23","3dec520_238","pfc500_64_27","Udec600_64bit320");
    
    for ($i=0;$i&lt;@msis;$i++)
    {
        $msi="$msis[$i]";
        output"Installing $msi...";
        run_command("start /wait \"\" msiexec /qn /i \"$sourcefilesdir\\$msi.msi\" /l* \"$applogs\\itasca-$msi.txt\"");
        output("Done.\n");
    }
    
    return 1;
}
 
do_install( 
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-desktop'],
    exit_on_failure =&gt; 1,

    install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\jdk.10_0_1\dev\update.pl</FullName>
    <Length>4803</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-07-31T13:50:58.5829635-05:00</CreationTime>
    <CreationTimeUtc>2018-07-31T18:50:58.5829635Z</CreationTimeUtc>
    <LastWriteTime>2018-08-02T16:20:01.1603924-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-08-02T21:20:01.1603924Z</LastWriteTimeUtc>
    <LastAccessTime>2018-07-31T13:50:58.5829635-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-07-31T18:50:58.5829635Z</LastAccessTimeUtc>
    <Text># JDK 10.0.1
# Package Created 2018-05-16
# Packaged by Gavin Altermatt (based on Joshua's 8u92 package)

=pod

Begin-Doc
Modified: $Date$
Name: $Name$
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'jdk.10_0_1',
        package_revision =&gt; '20180516T1137',
    );
}


# Add InstallMonkey Library to the path
use lib (
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);
use InstallMonkey::Shared;
use Win32::TieRegistry( Delimiter=&gt;"/");

my $sourcefilesdir = get_pkg_sourcefiles();
my $applogs=get_applogs_dir();
my $programfiles = get_arch_programfiles(OSARCH_x64);

sub install
{
	output("Installing JDK 10.0.1 (x64)\n");
    if(!run_command("start /wait $sourcefilesdir\\jdk-10.0.1_windows-x64_bin.exe /s /LV* \%TEMP%\\jdk10-0-1.log"))
    {
        output("JDK 10.0.1 (x64) installation did not complete!\n");
        return 0;
    }
    else{
        output("JDK 10.0.1 (x64) installation was successful!\n");
    }
    return 1;
}

=pod
sub isinstalled
{
  my $display_name = shift;
  local $/ = '';

  my %uninstall_commands;
  $uninstall_commands{x86} = `powershell \"Get-ItemProperty HKLM:\\Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* | Where-Object {\$_.DisplayName -and (\$_.DisplayName.trim() -match \\\"$display_name\\\")} | Select-Object InstallLocation | Format-List
\"`;
  $uninstall_commands{x64} = `powershell \"Get-ItemProperty HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* | Where-Object {\$_.DisplayName -and (\$_.DisplayName.trim() -match \\\"$display_name\\\")} | Select-Object InstallLocation | Format-List
\"`;
  $uninstall_commands{userx86} = `powershell \"Get-ItemProperty REGISTRY::HKEY_USERS\\*\\Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* | Where-Object {\$_.DisplayName -and (\$_.DisplayName.trim() -match \\\"$display_name\\\")} | Select-Object InstallLocation | Format-List
\"`;
  $uninstall_commands{userx64} = `powershell \"Get-ItemProperty REGISTRY::HKEY_USERS\\*\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* | Where-Object {\$_.DisplayName -and (\$_.DisplayName.trim() -match \\\"$display_name\\\")} | Select-Object InstallLocation | Format-List
\"`;

  my %results_uninstall_strings;
  $results_uninstall_strings{x86} = ();
  $results_uninstall_strings{x64} = ();
  $results_uninstall_strings{userx86} = ();
  $results_uninstall_strings{userx64} = ();

  while(my($key,$value) = each %uninstall_commands)
  {
    my @uninstall_strings = split/\n\n/, $value;
    @uninstall_strings = grep /\S/, @uninstall_strings;
    foreach my $i(@uninstall_strings)
    {
      $i =~ s/InstallLocation : //;
      $i =~ s/^                  //gm;
      $i =~ s/\R//g;
      $i =~ s/ +/ /;
      push(@{$results_uninstall_strings{$key}},$i);
    }
  }

  return defined $results_uninstall_strings{x86} || defined $results_uninstall_strings{x64} || defined $results_uninstall_strings{userx86} || defined $results_uninstall_strings{userx64};
}
=cut


sub postinstall
{
  output("Adding Environment Variable: ");
  output((add_environment_variable("Path","$ENV{'ProgramFiles'}\\Java\\jdk-10.0.1\\bin\\")?"OK":"FAILED")."\n");

  output("JDK installation successful!\nSleeping: ");

  #
  #
  #

  # The run_command spawns a separate process and returns immediately so this loop waits until setup.exe finishes running.
  #sleep(30);
  output("Done\n");

  #my $index = 0;
  #while($index &lt; 3600) # 3600*5sec = 5 hours
  #{
  #    $_ = `tasklist`;
      ##if(/setup\.exe/gi){
      ##    $index++;
      ##    sleep(5);
      ##}
      #output("Searched $index times\n");
      #if(isinstalled("Java 10.0.1 (64-bit)") != 1)
      #{
      #    $index++;
      #    sleep(5);
      #}
      #else
      #{
      #    output("JRE 10.0.1 Installed!\n");
          return 1;#
      #}
  #}

  #isinstalled("Java 10.0.1 (64-bit)");

  #output("Timed out...\n");
  #return 0;
}

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                     'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
	  need_reboot =&gt; 0,
    install_sub =&gt; \&amp;install,
    #isinstalled_sub =&gt; \&amp;isinstalled,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\jdk.10_0_1\prod\update.pl</FullName>
    <Length>3119</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-16T11:35:08.0134253-05:00</CreationTime>
    <CreationTimeUtc>2018-05-16T16:35:08.0134253Z</CreationTimeUtc>
    <LastWriteTime>2018-08-02T16:20:26.4234979-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-08-02T21:20:26.4234979Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-16T11:35:08.0134253-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-16T16:35:08.0134253Z</LastAccessTimeUtc>
    <Text># JDK 10.0.1
# Package Created 2018-05-16
# Packaged by Gavin Altermatt (based on Joshua's 8u92 package)
# Updated 2018-08-2 by Robert Smith

=pod

Begin-Doc
Modified: $Date$
Name: $Name$
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'jdk.10_0_1',
        package_revision =&gt; '20180802T1357',
    );
}


# Add InstallMonkey Library to the path
use lib (
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);
use InstallMonkey::Shared;
use Win32::TieRegistry( Delimiter=&gt;"/");

my $sourcefilesdir = get_pkg_sourcefiles();
my $applogs=get_applogs_dir();
my $programfiles = get_arch_programfiles(OSARCH_x64);

sub install
{
	output("Installing JDK 10.0.1 (x64)\n");

  if(!run_command("start /wait $sourcefilesdir\\jdk-10.0.1_windows-x64_bin.exe /s /LV* \%TEMP%\\jdk10-0-1.log"))
  {
    output("JDK 10.0.1 (x64) installation did not complete!\n");
    return 0;
  }
  else
  {
    output("JDK 10.0.1 (x64) installation was successful!\n");
  }

  return 1;
}

sub postinstall
{
  # environment variable is added so javac.exe can be ran from command prompt
  output("Adding Environment Variable: ");
  output((add_environment_variable("Path","$ENV{'ProgramFiles'}\\Java\\jdk-10.0.1\\bin\\")?"OK":"FAILED")."\n");

  output("JDK installation successful! Sleeping: ");

  # during JDK install, installer will look for and delete JRE installs, and then reinstall JRE after JDK installs, JDK installer then terminates
  # the below code will ensure that JRE reinstalls, preventing script from ending prematurely

  # The run_command spawns a separate process and returns immediately so this loop waits until setup.exe finishes running.
  sleep(30);
  output("Done\n");

  my $index = 0;
  while($index &lt; 3600) # 3600*5sec = 5 hours
  {
      $_ = `tasklist`;
      if(/jdk-10.0.1_windows-x64_bin\.exe/gi)
      #if(/jre\.exe/gi)
      {
        output("Process still running\n");
        $index++;
        sleep(5);
      }
      #output("Searched $index times\n");
      #if(isinstalled("Java 10.0.1 (64-bit)") != 1)
      #{
      #    $index++;
      #    sleep(5);
      #}
      else
      {
          output("Searched $index times\nJRE 10.0.1 Installed!\n");
          return 1;
      }
  }

  #isinstalled("Java 10.0.1 (64-bit)");

  output("Timed out...\n");
  return 0;
}

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                     'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
	  need_reboot =&gt; 0,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\jdk.8u112\prod\update.pl</FullName>
    <Length>1748</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-11-16T14:52:58.7556375-06:00</CreationTime>
    <CreationTimeUtc>2016-11-16T20:52:58.7556375Z</CreationTimeUtc>
    <LastWriteTime>2016-11-16T14:57:33.0089115-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-11-16T20:57:33.0089115Z</LastWriteTimeUtc>
    <LastAccessTime>2016-11-16T14:52:58.7868381-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-11-16T20:52:58.7868381Z</LastAccessTimeUtc>
    <Text># JDK 8u112
# Package Created 2016-11-16
# Packaged by Ronith (based on Joshua's 8u92 package)

=pod

Begin-Doc
Modified: $Date$
Name: $Name$
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'jdk.8u112',
        package_revision =&gt; '20161116T1500',
    );
}


use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);


use InstallMonkey::Shared;

my $installer_32 = build_path(get_pkg_sourcefiles(),"x86","jdk-8u112-windows-i586.exe");
my $installer_64 = build_path(get_pkg_sourcefiles(),"x86_64","jdk-8u112-windows-x64.exe");

sub install_x64
{
    my $outcome = install_x86();
    
    output("    JDK x64: ");
    $outcome  &amp;&amp;=
        run_command(
            $installer_64 . " /s"
        );
    output(($outcome?"JOLLY GOOD":"FAILURE")."\n");
    
    return $outcome;
};

sub install_x86
{
    output("    JDK x86: ");
    my $outcome =
        run_command(
            $installer_32 . " /s"
        );
    output(($outcome?"JOLLY GOOD":"FAILURE")."\n");
    
    return $outcome;
};

do_install( 
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
    allowed_os_architectures =&gt; [ OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 
                     'virtual-desktop'],
        
    exit_on_failure =&gt; 1,
    
    install_sub_x86 =&gt; \&amp;install_x86,
    install_sub_x64 =&gt; \&amp;install_x64,
);


IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\jmatpro.9\prod\update.pl</FullName>
    <Length>3746</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-01-25T14:41:04.8280535-06:00</CreationTime>
    <CreationTimeUtc>2016-01-25T20:41:04.8280535Z</CreationTimeUtc>
    <LastWriteTime>2016-02-26T14:31:36.5114392-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-02-26T20:31:36.5114392Z</LastWriteTimeUtc>
    <LastAccessTime>2016-01-25T14:41:04.8280535-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-01-25T20:41:04.8280535Z</LastAccessTimeUtc>
    <Text>#
# Package Created January 26, 2016
# Packaged by Ryan Andrews - based on the previous version's package
# Last Updated

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'jmatpro.9',
    package_revision =&gt; '20160126T1500',
  );
}


use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use InstallMonkey::Shared;
use ActiveState::Config::INI;

my $src = get_pkg_sourcefiles();
my $applogsdir = get_applogs_dir();
my $AppID = get_package_id();

sub install {

  output("Installing JMat Pro 9.0: ");
  if(run_command(build_path($src, "JMatPro-v9-install.exe") . " /batch /no-aftrun /no-postinstall"))
  {
      output("Success!\n");
  }
  else
  {
      output("FAILED: $!\n");
      return 0;
  }

  output("Installing HASP User Setup: ");
  if(run_command("\"" . build_path($ENV{"SYSTEMDRIVE"}, "JMatPro-v9", "Sentinel-HL-Keys", "Graphic Installer", "HASPUserSetup.exe") . "\" /qn"))
  {
      output("Success!\n");
  }
  else
  {
      output("FAILED: $!\n");
      return 0;
  }

  output("Installing Sentinel Device drivers: ");
  if(run_command("START \"\" /wait \"" . build_path($ENV{'SYSTEMDRIVE'}, "JMatPro-v9", "Sentinel-HL-Keys", "Command Line Installer", "haspdinst.exe") . "\" -i -nomsg"))
  {
      output ("Success!\n"); #Port 1947
  }
  else
  {
      output("FAILED: $!\n");
      return 0;
  }

  return 1;
}

sub post {
    output("Adding firewall rule for JMat Pro: ");
    if (!run_command("netsh advfirewall firewall add rule name=\"JMatPro\" dir=in program=\"" . $ENV{"SYSTEMDRIVE"} . "\\JMatPro-v9\\JMatPro.exe\" action=allow"))
    {
        output("FAILED: $!\n");
        return 0;
    }
    else
    {
        output("Success!\n");
    }

    output("Adding HASP lmid file: ");
    if (!run_command("xcopy \"$src\\MgTfxGZSetwQINm6C_dchSM-t-NFMii82N3WPfUA.id\" \"\%PROGRAMFILES(x86)\%\\Common Files\\Aladdin Shared\\HASP\\lmid\" /I /Q /Y"))
    {
        output("FAILED: $!\n");
        return 0;
    }
    else
    {
        output("Success!\n");
    }

    output("Adding Hasplm.ini file: ");
    if (!run_command("xcopy \"$src\\hasplm.ini\" \"\%PROGRAMFILES(x86)\%\\Common Files\\Aladdin Shared\\HASP\" /I /Q /Y"))
    {
        output("FAILED: $!\n");
        return 0;
    }
    else
    {
        output("Success!\n");
    }

#    output("Copying JMatPro init files: ");
#    if (!run_command("del \"" . $ENV{"SYSTEMDRIVE"} . "\\JMatPro-v9\\inits\\\" /Q") &amp;&amp;
#        !run_command("xcopy \"$src\\inits\" \"" . $ENV{"SYSTEMDRIVE"} . "\\JMatPro-v9\\inits\\\" /I /Q /Y"))
#    {
#        output("FAILED: $!\n");
#        return 0;
#    }
#    else
#    {
#        output("Success!\n");
#    }

    output("Removing desktop icon: ");
    if (!run_command("del " . build_path("%SYSTEMDRIVE%", "Users", "Public", "Desktop", "JMatPro-v9.lnk") . "/Q"))
    {
        output("FAILED: $!\n");
        return 0;
    }
    else
    {
        output("Success!\n");
    }
  return 1;
}

do_install(
  allowed_versions =&gt; [ OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1],
  allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
  allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;post,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>9_1_2.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\jmatpro.9_1\prod\9_1_2.pl</FullName>
    <Length>1403</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-04-03T15:23:33.4511995-05:00</CreationTime>
    <CreationTimeUtc>2017-04-03T20:23:33.4511995Z</CreationTimeUtc>
    <LastWriteTime>2016-11-21T09:10:01.8636892-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-11-21T15:10:01.8636892Z</LastWriteTimeUtc>
    <LastAccessTime>2017-04-03T15:23:33.4511995-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-04-03T20:23:33.4511995Z</LastAccessTimeUtc>
    <Text># Package Created May 2016
# Packaged by Chris Schaaf
# Last Updated ...

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'jmatpro.9_1_2',
    package_revision =&gt; '20161118T1430',
  );
}

use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);

use InstallMonkey::Shared;
use ActiveState::Config::INI;


sub install {
	#installs from appdist without grabbing source files
	output("Updating to 9.1.2: ");
	if(!run_command("\"\\\\minerfiles.mst.edu\\dfs\\software\\itwindist\\appdeploy\\jmatpro.9_1_2\\JMatPro-v9-update.exe\" /batch /dest C:\\JMatPro-v9.1")) {
		output("FAILED: $!\n");
		return 0;
	}
	else {
		output("Success!\n");
	}
    return 1;
}

do_install(
  allowed_versions =&gt; [ OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1],
  allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
  allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
  exit_on_failure =&gt; 1,
  no_source_files =&gt; 1,
  install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\jmatpro.9_1\prod\update.pl</FullName>
    <Length>8002</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-04-03T15:23:33.5136007-05:00</CreationTime>
    <CreationTimeUtc>2017-04-03T20:23:33.5136007Z</CreationTimeUtc>
    <LastWriteTime>2017-04-25T11:25:19.5228402-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-04-25T16:25:19.5228402Z</LastWriteTimeUtc>
    <LastAccessTime>2017-04-03T15:23:33.5136007-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-04-03T20:23:33.5136007Z</LastAccessTimeUtc>
    <Text># 
# Package Created May 2016
# Packaged by Austin Wall
# Last Updated ...

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'jmatpro.9_1',
    package_revision =&gt; '20160526T1430',
  );
}


use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);

use InstallMonkey::Shared;
use ActiveState::Config::INI;

my $src = get_pkg_sourcefiles();
my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\software\\itwindist\\appdeploy";
my $applogsdir = get_applogs_dir();
my $AppID = get_package_id();
my $svaddr_val = "jmatpro.lic.mst.edu";
my $lic_file_path = "C:\\Program Files (x86)\\Common Files\\Aladdin Shared\\HASP\\hasplm.ini";
my $backup_path = "C:\\Program Files (x86)\\Common Files\\Aladdin Shared\\HASP\\hasplm.ini.bak";

sub install {

    output("Installing JMat Pro 9.1: ");
    if(run_command(build_path($src, "JMatPro-v9.1-install.exe") . " /batch /no-aftrun /no-postinstall"))
    {
        output("Success!\n");
    }
    else
    {
        output("FAILED: $!\n");
        return 0;
    }
    output("Installing HASP User Setup: ");
    if(run_command("\"" . build_path($ENV{"SYSTEMDRIVE"}, "JMatPro-v9.1", "Sentinel-HL-Keys", "Graphic Installer", "HASPUserSetup.exe") . "\" /qn"))
    {
        output("Success!\n");
    }
    else
    {
        output("FAILED: $!\n");
        return 0;
    }

    output("Installing Sentinel Device drivers: ");
    if(run_command("START \"\" /wait \"" . build_path($ENV{'SYSTEMDRIVE'}, "JMatPro-v9.1", "Sentinel-HL-Keys", "Command Line Installer", "haspdinst.exe") . "\" -i -nomsg"))
    {
        output ("Success!\n"); #Port 1947
    }
    else
    {
        output("FAILED: $!\n");
        return 0;
    }

    my $api_install_dir = build_path($ENV{'SYSTEMDRIVE'});
    my $api_src_dir = build_path($src, "JMatProAPI.2_0_1");
    output("Moving API to " . $ENV{'SYSTEMDRIVE'} . "\\JMatProAPI.2_0_1 from $api_src_dir: ");
    if(run_command("move /y " . $api_src_dir . " " . $api_install_dir))
    {
        output ("Success!\n");
    }
    else
    {
        output("FAILED: $!\n");
        return 0;
    }
    return 1;
}

sub post {
    output("Adding firewall rule for JMat Pro: ");
    if (!run_command("netsh advfirewall firewall add rule name=\"JMatPro\" dir=in program=\"" . $ENV{"SYSTEMDRIVE"} . "\\JMatPro-v9.1\\JMatPro.exe\" action=allow"))
    {
        output("FAILED: $!\n");
        return 0;
    }
    else
    {
        output("Success!\n");
    }

    output("Adding HASP lmid file: ");
    if (!run_command("xcopy \"$src\\MgTfxGZSetwQINm6C_dchSM-t-NFMii82N3WPfUA.id\" \"\%PROGRAMFILES(x86)\%\\Common Files\\Aladdin Shared\\HASP\\lmid\" /I /Q /Y"))
    {
        output("FAILED: $!\n");
        return 0;
    }
    else
    {
        output("Success!\n");
    }

    output("Adding Hasplm.ini file: ");
	configure_licensing();
    # if (!run_command("xcopy \"$src\\hasplm.ini\" \"\%PROGRAMFILES(x86)\%\\Common Files\\Aladdin Shared\\HASP\" /I /Q /Y"))
    # {
        # output("FAILED: $!\n");
        # return 0;
    # }
    # else
    # {
        # output("Success!\n");
    # }

    output("Fixing permissions... ");
    my $jmatpro_dir = build_path($ENV{"SYSTEMDRIVE"}, "JMatPro-v9.1");
    # Set object-inheritance and container-inheritance (OI)(CI), enable inheritance,
    # and give users modify permission. Do it recursively (/T)
    # this is pretty overreaching but this program has serious disagreement with its users
    # not being administrators on the machine
    my $outcome = run_command("icacls \"$jmatpro_dir\" /grant Users:(OI)(CI)M /T /inheritance:e");
    if($outcome) {
        output("OK\n");
    } else {
        output("FAILED: $!\n");
    }
    
    output("Removing desktop icon: ");
    if (!run_command("del " . build_path("%SYSTEMDRIVE%", "Users", "Public", "Desktop", "JMatPro-v9.1.lnk") . "/Q"))
    {
        output("FAILED: $!\n");
        return 0;
    }
    else
    {
        output("Success!\n");
    }
	output("Updating JMat Pro to 9.1.2: ");
	if(run_command("\"$src\\JMatPro-v9-update.exe\" /batch /dest \"C:\\JMatPro-v9.1\""))
	{
		output("Success!\n");
	}
	else
	{
		output("FAILED: $!\n");
		return 0;
	}
  return 1;
}

do_install(
  allowed_versions =&gt; [ OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1],
  allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
  allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;post,
);



sub configure_licensing {
  # Make sure the dir exists
  my $license_file_dir = "C:\\Program Files (x86)\\Common Files\\Aladdin Shared\\HASP";
  unless (-d $license_file_dir) {
    my $cmd2 = "md \"$license_file_dir\"";
    my $outcome2 = run_command($cmd2);
    if ($outcome2)  {
      print "Installation successful! \n";
    } else {
      print "Installation failed. \n";
      return $outcome2;
    }
  }  
  #If the file exists, back it up and then make updates to it
  if (-f $lic_file_path) {
	output("HASP Config File exists, making changes.\n");
    my $cmd = "copy \"$lic_file_path\" \"$backup_path\"";
	output("Backup starting... ");
    my $outcome3 = run_command($cmd);
    if ($outcome3) {
    	print "Backup successful! \n";
    } else {
      print "Backup failed. $! \n";
      return $outcome3;
    }
    # Update file with changes marked in file by &lt;------ (overwrite if the value in the section is present, otherwise append under the section header)
    my $contents = "";
    #slurp file
    {
      local $/=undef;
      open FILE, $lic_file_path or die "Couldn't open file: $!";
      $contents = &lt;FILE&gt;;
      close FILE;
    }
    # do the replacements/additions
	$contents = address_str($contents, "serveraddr", $svaddr_val);
    #overwrite file
    open (OUTFILE, "&gt;$lic_file_path") or die("$!");
    print OUTFILE $contents or die("$!");
    close (OUTFILE);  
    
  } else { 
  	# The file doesn't exist, copy the one from sourcefiles
    my $cmd = "xcopy \"$src\\hasplm.ini\" \"$license_file_dir\" /E /I /Y";
    my $outcome = run_command ($cmd);
    if ($outcome)  {
      print "Installation successful! \n";
    } else {
      print "Installation failed. \n";
      return $outcome;
    }
  }  
}

sub update_numeric {
  my $contents = shift;
  my $key = shift;
  my $val = shift;
  
  if(! ($contents =~ /$key\s*=\s*[0-9]+/)) {
    #print "no $key, adding\n";
    $contents =~ s/(?&lt;=\[SERVER\])\r\n/\r\n$key = $val\r\n/g;
  } else {
      #print "$key was there, updating.\n";
      $contents =~ s/(?&lt;=$key)\s+=\s+[0-9]+/ = $val/g;
  }
  
  return $contents;
}

sub update_str {
  my $contents = shift;
  my $key = shift;
  my $val = shift;
  
  if(! ($contents =~ /$key\s*=\s+.*\r\n/)) {
    print "no $key, adding\n";
    $contents =~ s/(?&lt;=\[SERVER\])\r\n/\r\n$key = $val\r\n/g;
  } else {
      print "$key was there, updating.\n";
      $contents =~ s/(?&lt;=$key)\s+=\s+.*\r\n/ = $val\r\n/g;
  }
  
  return $contents;
}

sub address_str {
	my $contents = shift;
	my $key = shift;
	my $val = shift;
	my $insert = "$key = $val\r\n";

	if($contents =~ /$val/){
		print "$key exists with correct value\n";
	}
	#This should leave the possibilities of a key existing but being the wrong server (very likely)
	#	or no server existing (should not happen)
	else{
		print "no $key, adding\n";
		$contents =~ s/\[REMOTE\]\n/\[REMOTE\]\n$insert/g;
	}
	
	return $contents;
}

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>9_1_2.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\jmatpro.9_1\prod.old\9_1_2.pl</FullName>
    <Length>1403</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-11-18T14:46:26.512443-06:00</CreationTime>
    <CreationTimeUtc>2016-11-18T20:46:26.512443Z</CreationTimeUtc>
    <LastWriteTime>2016-11-21T09:10:01.8636892-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-11-21T15:10:01.8636892Z</LastWriteTimeUtc>
    <LastAccessTime>2016-11-18T14:46:26.512443-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-11-18T20:46:26.512443Z</LastAccessTimeUtc>
    <Text># Package Created May 2016
# Packaged by Chris Schaaf
# Last Updated ...

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'jmatpro.9_1_2',
    package_revision =&gt; '20161118T1430',
  );
}

use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);

use InstallMonkey::Shared;
use ActiveState::Config::INI;


sub install {
	#installs from appdist without grabbing source files
	output("Updating to 9.1.2: ");
	if(!run_command("\"\\\\minerfiles.mst.edu\\dfs\\software\\itwindist\\appdeploy\\jmatpro.9_1_2\\JMatPro-v9-update.exe\" /batch /dest C:\\JMatPro-v9.1")) {
		output("FAILED: $!\n");
		return 0;
	}
	else {
		output("Success!\n");
	}
    return 1;
}

do_install(
  allowed_versions =&gt; [ OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1],
  allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
  allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
  exit_on_failure =&gt; 1,
  no_source_files =&gt; 1,
  install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\jmatpro.9_1\prod.old\update.pl</FullName>
    <Length>4702</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-11-18T14:42:53.9881938-06:00</CreationTime>
    <CreationTimeUtc>2016-11-18T20:42:53.9881938Z</CreationTimeUtc>
    <LastWriteTime>2016-11-21T11:05:46.2413456-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-11-21T17:05:46.2413456Z</LastWriteTimeUtc>
    <LastAccessTime>2016-11-18T14:42:53.9881938-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-11-18T20:42:53.9881938Z</LastAccessTimeUtc>
    <Text># 
# Package Created May 2016
# Packaged by Austin Wall
# Last Updated ...

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'jmatpro.9_1',
    package_revision =&gt; '20160526T1430',
  );
}


use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);

use InstallMonkey::Shared;
use ActiveState::Config::INI;

my $src = get_pkg_sourcefiles();
my $applogsdir = get_applogs_dir();
my $AppID = get_package_id();

sub install {

    output("Installing JMat Pro 9.1: ");
    if(run_command(build_path($src, "JMatPro-v9.1-install.exe") . " /batch /no-aftrun /no-postinstall"))
    {
        output("Success!\n");
    }
    else
    {
        output("FAILED: $!\n");
        return 0;
    }
    output("Installing HASP User Setup: ");
    if(run_command("\"" . build_path($ENV{"SYSTEMDRIVE"}, "JMatPro-v9.1", "Sentinel-HL-Keys", "Graphic Installer", "HASPUserSetup.exe") . "\" /qn"))
    {
        output("Success!\n");
    }
    else
    {
        output("FAILED: $!\n");
        return 0;
    }

    output("Installing Sentinel Device drivers: ");
    if(run_command("START \"\" /wait \"" . build_path($ENV{'SYSTEMDRIVE'}, "JMatPro-v9.1", "Sentinel-HL-Keys", "Command Line Installer", "haspdinst.exe") . "\" -i -nomsg"))
    {
        output ("Success!\n"); #Port 1947
    }
    else
    {
        output("FAILED: $!\n");
        return 0;
    }

    my $api_install_dir = build_path($ENV{'SYSTEMDRIVE'});
    my $api_src_dir = build_path($src, "JMatProAPI.2_0_1");
    output("Moving API to " . $ENV{'SYSTEMDRIVE'} . "\\JMatProAPI.2_0_1 from $api_src_dir: ");
    if(run_command("move /y " . $api_src_dir . " " . $api_install_dir))
    {
        output ("Success!\n");
    }
    else
    {
        output("FAILED: $!\n");
        return 0;
    }
    return 1;
}

sub post {
    output("Adding firewall rule for JMat Pro: ");
    if (!run_command("netsh advfirewall firewall add rule name=\"JMatPro\" dir=in program=\"" . $ENV{"SYSTEMDRIVE"} . "\\JMatPro-v9.1\\JMatPro.exe\" action=allow"))
    {
        output("FAILED: $!\n");
        return 0;
    }
    else
    {
        output("Success!\n");
    }

    output("Adding HASP lmid file: ");
    if (!run_command("xcopy \"$src\\MgTfxGZSetwQINm6C_dchSM-t-NFMii82N3WPfUA.id\" \"\%PROGRAMFILES(x86)\%\\Common Files\\Aladdin Shared\\HASP\\lmid\" /I /Q /Y"))
    {
        output("FAILED: $!\n");
        return 0;
    }
    else
    {
        output("Success!\n");
    }

    output("Adding Hasplm.ini file: ");
    if (!run_command("xcopy \"$src\\hasplm.ini\" \"\%PROGRAMFILES(x86)\%\\Common Files\\Aladdin Shared\\HASP\" /I /Q /Y"))
    {
        output("FAILED: $!\n");
        return 0;
    }
    else
    {
        output("Success!\n");
    }

    output("Fixing permissions... ");
    my $jmatpro_dir = build_path($ENV{"SYSTEMDRIVE"}, "JMatPro-v9.1");
    # Set object-inheritance and container-inheritance (OI)(CI), enable inheritance,
    # and give users modify permission. Do it recursively (/T)
    # this is pretty overreaching but this program has serious disagreement with its users
    # not being administrators on the machine
    my $outcome = run_command("icacls \"$jmatpro_dir\" /grant Users:(OI)(CI)M /T /inheritance:e");
    if($outcome) {
        output("OK\n");
    } else {
        output("FAILED: $!\n");
    }
    
    output("Removing desktop icon: ");
    if (!run_command("del " . build_path("%SYSTEMDRIVE%", "Users", "Public", "Desktop", "JMatPro-v9.1.lnk") . "/Q"))
    {
        output("FAILED: $!\n");
        return 0;
    }
    else
    {
        output("Success!\n");
    }
	output("Updating JMat Pro to 9.1.2: ");
	if(run_command("\"\\\\minerfiles.mst.edu\\dfs\\software\\itwindist\\appdeploy\\jmatpro.9_1_2\\JMatPro-v9-update.exe\" /batch /dest C:\\JMatPro-v9.1"))
	{
		output("Success!\n");
	}
	else
	{
		output("FAILED: $!\n");
		return 0;
	}
  return 1;
}

do_install(
  allowed_versions =&gt; [ OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1],
  allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
  allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;post,
);

IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>9_1_2.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\jmatpro.9_1_2\prod\9_1_2.pl</FullName>
    <Length>1403</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-04-26T12:14:21.6022718-05:00</CreationTime>
    <CreationTimeUtc>2017-04-26T17:14:21.6022718Z</CreationTimeUtc>
    <LastWriteTime>2016-11-21T09:10:01.8636892-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-11-21T15:10:01.8636892Z</LastWriteTimeUtc>
    <LastAccessTime>2017-04-26T12:14:21.6022718-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-04-26T17:14:21.6022718Z</LastAccessTimeUtc>
    <Text># Package Created May 2016
# Packaged by Chris Schaaf
# Last Updated ...

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'jmatpro.9_1_2',
    package_revision =&gt; '20161118T1430',
  );
}

use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);

use InstallMonkey::Shared;
use ActiveState::Config::INI;


sub install {
	#installs from appdist without grabbing source files
	output("Updating to 9.1.2: ");
	if(!run_command("\"\\\\minerfiles.mst.edu\\dfs\\software\\itwindist\\appdeploy\\jmatpro.9_1_2\\JMatPro-v9-update.exe\" /batch /dest C:\\JMatPro-v9.1")) {
		output("FAILED: $!\n");
		return 0;
	}
	else {
		output("Success!\n");
	}
    return 1;
}

do_install(
  allowed_versions =&gt; [ OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1],
  allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
  allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
  exit_on_failure =&gt; 1,
  no_source_files =&gt; 1,
  install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\jmatpro.9_1_2\prod\update.pl</FullName>
    <Length>8064</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-04-26T12:14:21.664673-05:00</CreationTime>
    <CreationTimeUtc>2017-04-26T17:14:21.664673Z</CreationTimeUtc>
    <LastWriteTime>2017-05-04T16:11:52.0250666-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-05-04T21:11:52.0250666Z</LastWriteTimeUtc>
    <LastAccessTime>2017-04-26T12:14:21.664673-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-04-26T17:14:21.664673Z</LastAccessTimeUtc>
    <Text># 
# Package Created May 2016
# Packaged by Austin Wall
# Last Updated ...

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'jmatpro.9_1_2',
    package_revision =&gt; '20170426T1350',
  );
}


use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);

use InstallMonkey::Shared;
use ActiveState::Config::INI;

my $src = get_pkg_sourcefiles();
my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\software\\itwindist\\appdeploy";
my $applogsdir = get_applogs_dir();
my $AppID = get_package_id();
my $svaddr_val = "jmatpro.lic.mst.edu";
my $lic_file_path = "C:\\Program Files (x86)\\Common Files\\Aladdin Shared\\HASP\\hasplm.ini";
my $backup_path = "C:\\Program Files (x86)\\Common Files\\Aladdin Shared\\HASP\\hasplm.ini.bak";

sub install {

    output("Installing JMat Pro 9.1: ");
    if(run_command(build_path($src, "JMatPro-v9.1-install.exe") . " /batch /no-aftrun /no-postinstall"))
    {
        output("Success!\n");
    }
    else
    {
        output("FAILED: $!\n");
        return 0;
    }
    output("Installing HASP User Setup: ");
    if(run_command("\"" . build_path($ENV{"SYSTEMDRIVE"}, "JMatPro-v9.1", "Sentinel-HL-Keys", "Graphic Installer", "HASPUserSetup.exe") . "\" /qn"))
    {
        output("Success!\n");
    }
    else
    {
        output("FAILED: $!\n");
        return 0;
    }

    output("Installing Sentinel Device drivers: ");
    if(run_command("START \"\" /wait \"" . build_path($ENV{'SYSTEMDRIVE'}, "JMatPro-v9.1", "Sentinel-HL-Keys", "Command Line Installer", "haspdinst.exe") . "\" -i -nomsg"))
    {
        output ("Success!\n"); #Port 1947
    }
    else
    {
        output("FAILED: $!\n");
        return 0;
    }

    my $api_install_dir = build_path($ENV{'SYSTEMDRIVE'},"JMatProAPI.2_0_1");
    my $api_src_dir = build_path($src, "JMatProAPI.2_0_1");
    output("Moving API to " . $ENV{'SYSTEMDRIVE'} . "\\JMatProAPI.2_0_1 from $api_src_dir: ");
	run_command("mkdir $api_install_dir");
    if(run_command("move /y " . $api_src_dir . " " . $api_install_dir))
    {
        output ("Success!\n");
    }
    else
    {
        output("FAILED: $!\n");
        return 0;
    }
    return 1;
}

sub post {
    output("Adding firewall rule for JMat Pro: ");
    if (!run_command("netsh advfirewall firewall add rule name=\"JMatPro\" dir=in program=\"" . $ENV{"SYSTEMDRIVE"} . "\\JMatPro-v9.1\\JMatPro.exe\" action=allow"))
    {
        output("FAILED: $!\n");
        return 0;
    }
    else
    {
        output("Success!\n");
    }

    output("Adding HASP lmid file: ");
    if (!run_command("xcopy \"$src\\MgTfxGZSetwQINm6C_dchSM-t-NFMii82N3WPfUA.id\" \"\%PROGRAMFILES(x86)\%\\Common Files\\Aladdin Shared\\HASP\\lmid\" /I /Q /Y"))
    {
        output("FAILED: $!\n");
        return 0;
    }
    else
    {
        output("Success!\n");
    }

    output("Adding Hasplm.ini file: ");
	configure_licensing();
    # if (!run_command("xcopy \"$src\\hasplm.ini\" \"\%PROGRAMFILES(x86)\%\\Common Files\\Aladdin Shared\\HASP\" /I /Q /Y"))
    # {
        # output("FAILED: $!\n");
        # return 0;
    # }
    # else
    # {
        # output("Success!\n");
    # }

    output("Fixing permissions... ");
    my $jmatpro_dir = build_path($ENV{"SYSTEMDRIVE"}, "JMatPro-v9.1");
    # Set object-inheritance and container-inheritance (OI)(CI), enable inheritance,
    # and give users modify permission. Do it recursively (/T)
    # this is pretty overreaching but this program has serious disagreement with its users
    # not being administrators on the machine
    my $outcome = run_command("icacls \"$jmatpro_dir\" /grant Users:(OI)(CI)M /T /inheritance:e");
    if($outcome) {
        output("OK\n");
    } else {
        output("FAILED: $!\n");
    }
    
    output("Removing desktop icon: ");
    if (!run_command("del " . build_path("%SYSTEMDRIVE%", "Users", "Public", "Desktop", "JMatPro-v9.1.lnk") . "/Q"))
    {
        output("FAILED: $!\n");
        return 0;
    }
    else
    {
        output("Success!\n");
    }
	output("Updating JMat Pro to 9.1.2: ");
	if(run_command("\"$src\\JMatPro-v9-update.exe\" /batch /dest \"C:\\JMatPro-v9.1\""))
	{
		output("Success!\n");
	}
	else
	{
		output("FAILED: $!\n");
		return 0;
	}
  return 1;
}

do_install(
  allowed_versions =&gt; [ OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1],
  allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
  allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;post,
);



sub configure_licensing {
  # Make sure the dir exists
  my $license_file_dir = "C:\\Program Files (x86)\\Common Files\\Aladdin Shared\\HASP";
  unless (-d $license_file_dir) {
    my $cmd2 = "md \"$license_file_dir\"";
    my $outcome2 = run_command($cmd2);
    if ($outcome2)  {
      print "Installation successful! \n";
    } else {
      print "Installation failed. \n";
      return $outcome2;
    }
  }  
  #If the file exists, back it up and then make updates to it
  if (-f $lic_file_path) {
	output("HASP Config File exists, making changes.\n");
    my $cmd = "copy \"$lic_file_path\" \"$backup_path\"";
	output("Backup starting... ");
    my $outcome3 = run_command($cmd);
    if ($outcome3) {
    	print "Backup successful! \n";
    } else {
      print "Backup failed. $! \n";
      return $outcome3;
    }
    # Update file with changes marked in file by &lt;------ (overwrite if the value in the section is present, otherwise append under the section header)
    my $contents = "";
    #slurp file
    {
      local $/=undef;
      open FILE, $lic_file_path or die "Couldn't open file: $!";
      $contents = &lt;FILE&gt;;
      close FILE;
    }
    # do the replacements/additions
	$contents = address_str($contents, "serveraddr", $svaddr_val);
    #overwrite file
    open (OUTFILE, "&gt;$lic_file_path") or die("$!");
    print OUTFILE $contents or die("$!");
    close (OUTFILE);  
    
  } else { 
  	# The file doesn't exist, copy the one from sourcefiles
    my $cmd = "xcopy \"$src\\hasplm.ini\" \"$license_file_dir\" /E /I /Y";
    my $outcome = run_command ($cmd);
    if ($outcome)  {
      print "Installation successful! \n";
    } else {
      print "Installation failed. \n";
      return $outcome;
    }
  }  
}

sub update_numeric {
  my $contents = shift;
  my $key = shift;
  my $val = shift;
  
  if(! ($contents =~ /$key\s*=\s*[0-9]+/)) {
    #print "no $key, adding\n";
    $contents =~ s/(?&lt;=\[SERVER\])\r\n/\r\n$key = $val\r\n/g;
  } else {
      #print "$key was there, updating.\n";
      $contents =~ s/(?&lt;=$key)\s+=\s+[0-9]+/ = $val/g;
  }
  
  return $contents;
}

sub update_str {
  my $contents = shift;
  my $key = shift;
  my $val = shift;
  
  if(! ($contents =~ /$key\s*=\s+.*\r\n/)) {
    print "no $key, adding\n";
    $contents =~ s/(?&lt;=\[SERVER\])\r\n/\r\n$key = $val\r\n/g;
  } else {
      print "$key was there, updating.\n";
      $contents =~ s/(?&lt;=$key)\s+=\s+.*\r\n/ = $val\r\n/g;
  }
  
  return $contents;
}

sub address_str {
	my $contents = shift;
	my $key = shift;
	my $val = shift;
	my $insert = "$key = $val\r\n";

	if($contents =~ /$val/){
		print "$key exists with correct value\n";
	}
	#This should leave the possibilities of a key existing but being the wrong server (very likely)
	#	or no server existing (should not happen)
	else{
		print "no $key, adding\n";
		$contents =~ s/\[REMOTE\]\n/\[REMOTE\]\n$insert/g;
	}
	
	return $contents;
}

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\jmpPro.12_2\prod\update.pl</FullName>
    <Length>1663</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-07-28T08:19:10.363648-05:00</CreationTime>
    <CreationTimeUtc>2016-07-28T13:19:10.363648Z</CreationTimeUtc>
    <LastWriteTime>2016-05-27T13:29:13.1606506-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-05-27T18:29:13.1606506Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-28T08:19:10.363648-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-28T13:19:10.363648Z</LastAccessTimeUtc>
    <Text># SAS JMP Pro 12.2
# Package Created May 2016
# Packaged by Austin Wall
# Last Updated --

=begin
Modified:
Name:
Type: script
Description: SAS JMP Pro version 12.2 install script
Language: Perl
LastUpdatedBy: $Author: Austin Wall $
Version:
End-Doc
=cut

BEGIN {
    %::INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'jmp.12_2',
        package_revision =&gt; '20160527T1327',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

sub prereq
{
  if( run_command("reg query \"HKLM\\SOFTWARE\\UMR\\INSTALL\\Product_List\\jmp.12\"") )
  {
    output( "JMP Pro v12 is installed.\n" );
    return 1;
  }
  else
  {
    output("\n**ERROR**: JMP Pro v12 is not installed! Please install it before proceeding.\n\n");
    return 0;
  }
}

sub install {
    if(!run_command("\"$srcfiles\\setup.exe\" -s -f1\"$srcfiles\\MST_silent.iss\""))
    {
        output("Installation failed!\n");
        return 0;
    }
    
    output("Installation successful!");
    return 1;
}

do_install( 
    exit_on_failure =&gt; 1,
    allowed_versions          =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
    allowed_os_architectures  =&gt; [OSARCH_x64],
    allowed_regs              =&gt; ["clc", "desktop", "traveling", "virtual-desktop", "virtual-clc"],
    prerequisite_sub          =&gt; \&amp;prereq,
    install_sub               =&gt; \&amp;install,

    
);

IM_Exit(EXIT_SUCCESS);

########################################################################</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\jmpPro.13_1\dev\update.pl</FullName>
    <Length>1178</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-07-19T11:19:03.6560605-05:00</CreationTime>
    <CreationTimeUtc>2017-07-19T16:19:03.6560605Z</CreationTimeUtc>
    <LastWriteTime>2017-07-19T11:19:03.6560605-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-07-19T16:19:03.6560605Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-19T11:19:03.6560605-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-19T16:19:03.6560605Z</LastAccessTimeUtc>
    <Text># SAS JMP Pro 13.1
# Package Created May 15, 2017
# Packaged by Austin Wall
# Last Updated --

BEGIN {
    %::INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'jmp.13.1',
        package_revision =&gt; '20170515T1143',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

sub install {
    if(!run_command("\"$srcfiles\\JMP\\JMP_Pro\\13_1\\Windows\\setup.exe\" -s -f1\"$srcfiles\\Setup.iss\""))
    {
        output("Installation failed!\n");
        return 0;
    }
    
    output("Installation successful!");
    return 1;
}

do_install( 
    exit_on_failure =&gt; 1,
    allowed_versions          =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures  =&gt; [OSARCH_x64],
    allowed_regs              =&gt; ["clc", "desktop", "traveling", "virtual-desktop", "virtual-clc"],
    install_sub               =&gt; \&amp;install,

    
);

IM_Exit(EXIT_SUCCESS);

########################################################################
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\jmpPro.13_1\prod\update.pl</FullName>
    <Length>1662</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-07-19T11:34:35.8030537-05:00</CreationTime>
    <CreationTimeUtc>2017-07-19T16:34:35.8030537Z</CreationTimeUtc>
    <LastWriteTime>2017-07-26T13:33:11.4133583-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-07-26T18:33:11.4133583Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-20T14:30:43.8726063-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-20T19:30:43.8726063Z</LastAccessTimeUtc>
    <Text># SAS JMP Pro 13.1
# Package Created May 15, 2017
# Packaged by Austin Wall
# Last Updated July 19, 2017 by Alex Schrimpf

BEGIN {
    %::INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'jmpPro.13_1',
        package_revision =&gt; '20170719T1613',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Win32::TieRegistry qw(REG_DWORD);

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();


my $CMD = "\"$srcfiles\\JMP\\JMP_Pro\\13_1\\Windows\\setup.exe\" -s -f1\"$srcfiles\\Setup.iss\"";

my %EXIT_CODE;
$EXIT_CODE{'SUCCESS'} = 0;
$EXIT_CODE{'REBOOT_NOW'} = 26880;
$EXIT_CODE{'REBOOT_REQUESTED'} = 49664;

sub install {
	output(": RUNNING | $CMD |\n");
	my $e_code = system($CMD);
	output(": DONE\n");
	foreach my $key(keys %EXIT_CODE){
		if($e_code == $EXIT_CODE{$key}){
			if($e_code!=$EXIT_CODE{'SUCCESS'}){
				output(":: ERROR WAS RETURNED BUT WAS IGNORED | $key/$EXIT_CODE{$key} |\n");
			}
			output(": INSTALL SUCCESSFULL\n");
			return 1;
		}
	}

	output(":: INSTALL FAILED \n\t::\"$CMD\" RETURNED ERROR | $e_code |\n ");
	return 0;
}


do_install( 
    exit_on_failure =&gt; 1,
    allowed_versions          =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures  =&gt; [OSARCH_x64],
    allowed_regs              =&gt; ["clc", "desktop", "traveling", "virtual-desktop", "virtual-clc"],
    install_sub               =&gt; \&amp;install,
    
);

IM_Exit(EXIT_SUCCESS);

########################################################################
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\jmppro.14\dev\update.pl</FullName>
    <Length>1178</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-26T11:45:46.7569492-05:00</CreationTime>
    <CreationTimeUtc>2018-06-26T16:45:46.7569492Z</CreationTimeUtc>
    <LastWriteTime>2017-07-19T11:19:03-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-07-19T16:19:03Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-19T11:19:03-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-19T16:19:03Z</LastAccessTimeUtc>
    <Text># SAS JMP Pro 13.1
# Package Created May 15, 2017
# Packaged by Austin Wall
# Last Updated --

BEGIN {
    %::INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'jmp.13.1',
        package_revision =&gt; '20170515T1143',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

sub install {
    if(!run_command("\"$srcfiles\\JMP\\JMP_Pro\\13_1\\Windows\\setup.exe\" -s -f1\"$srcfiles\\Setup.iss\""))
    {
        output("Installation failed!\n");
        return 0;
    }
    
    output("Installation successful!");
    return 1;
}

do_install( 
    exit_on_failure =&gt; 1,
    allowed_versions          =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures  =&gt; [OSARCH_x64],
    allowed_regs              =&gt; ["clc", "desktop", "traveling", "virtual-desktop", "virtual-clc"],
    install_sub               =&gt; \&amp;install,

    
);

IM_Exit(EXIT_SUCCESS);

########################################################################
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\jmppro.14\prod\update.pl</FullName>
    <Length>1683</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-26T11:46:46.937387-05:00</CreationTime>
    <CreationTimeUtc>2018-06-26T16:46:46.937387Z</CreationTimeUtc>
    <LastWriteTime>2018-07-25T11:24:22.5832739-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-25T16:24:22.5832739Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-20T14:30:43-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-20T19:30:43Z</LastAccessTimeUtc>
    <Text># SAS JMP Pro 14
# Package Created June 26, 2018
# Packaged by Benjamin Krueger
# Last Updated July 19, 2017 by Benjamin Krueger

BEGIN {
    %::INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'jmpPro.14',
        package_revision =&gt; '20170719T1613',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Win32::TieRegistry qw(REG_DWORD);

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();


my $CMD = "\"$srcfiles\\JMP\\JMP_Pro\\14_0\\Windows\\setup.exe\" -s -f1\"$srcfiles\\setup.iss\"";

my %EXIT_CODE;
$EXIT_CODE{'SUCCESS'} = 0;
$EXIT_CODE{'REBOOT_NOW'} = 26880;
$EXIT_CODE{'REBOOT_REQUESTED'} = 49664;


sub install {
	output(": RUNNING | $CMD |\n");
	my $e_code = system($CMD);
	output(": DONE\n");
	foreach my $key(keys %EXIT_CODE){
		if($e_code == $EXIT_CODE{$key}){
			
			if($e_code!=$EXIT_CODE{'SUCCESS'}){

				output(":: ERROR WAS RETURNED BUT WAS IGNORED | $key/$EXIT_CODE{$key} |\n");
			}
			
			output(": INSTALL SUCCESSFULL\n");
			return 1;
		}
	}

	output(":: INSTALL FAILED \n\t::\"$CMD\" RETURNED ERROR | $e_code |\n ");

	return 0;
}


do_install( 
    exit_on_failure =&gt; 1,
    allowed_versions          =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures  =&gt; [OSARCH_x64],
    allowed_regs              =&gt; ["clc", "desktop", "traveling", "virtual-desktop", "virtual-clc"],
    install_sub               =&gt; \&amp;install,
    
);

IM_Exit(EXIT_SUCCESS);

########################################################################
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\julia.0_5_0\dev\update.pl</FullName>
    <Length>1778</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-11-18T11:48:31.292081-06:00</CreationTime>
    <CreationTimeUtc>2016-11-18T17:48:31.292081Z</CreationTimeUtc>
    <LastWriteTime>2016-11-28T11:10:20.3502651-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-11-28T17:10:20.3502651Z</LastWriteTimeUtc>
    <LastAccessTime>2016-11-18T11:48:31.292081-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-11-18T17:48:31.292081Z</LastAccessTimeUtc>
    <Text># Julia 0.5.0
# Package Created November 18, 2016
# Packaged by Austin Wall
# Last Updated November 18, 2016 by Austin Wall

BEGIN {
    %::INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'julia.0_5_0',
        package_revision =&gt; '20161118T1501',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use File::Copy;
use File::Path;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();
my @exit_codes = (0, 1, 2, 3, 5, 6, 7);

sub install {
    if(!run_command("robocopy \"$srcfiles\\Julia\" \"C:\\Program Files\\Julia\" -E", IgnoreExitCodes=&gt;\@exit_codes))
    {
        output("ERROR: Installation failed!\n");
        return 0;
    }
    
    output("Installation successful!");
    return 1;
}

sub postinstall {
    my $start_menu_folder = build_path(get_allusers_start_menu(), "/Julia 0.5.0/");
    if(-d $start_menu_folder)
    {
        rmtree($start_menu_folder);
    }
    mkdir($start_menu_folder);
    
    if(!run_command("robocopy \"$srcfiles\\Julia 0.5.0\" \"$start_menu_folder\" -E", IgnoreExitCodes=&gt;\@exit_codes))
    {
        output("WARNING: Unable to create start menu shortcuts!");
    }
    
    return 1;
}

do_install( 
    exit_on_failure =&gt; 1,
    allowed_versions          =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
    allowed_os_architectures  =&gt; [OSARCH_x64],
    allowed_regs              =&gt; ["clc", "desktop", "traveling", "virtual-desktop", "virtual-clc"],
    install_sub               =&gt; \&amp;install,
    postinstall_sub           =&gt; \&amp;postinstall,
    
);

IM_Exit(EXIT_SUCCESS);

########################################################################</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\julia.0_5_0\prod\update.pl</FullName>
    <Length>1778</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-11-28T11:15:54.3548291-06:00</CreationTime>
    <CreationTimeUtc>2016-11-28T17:15:54.3548291Z</CreationTimeUtc>
    <LastWriteTime>2016-11-28T11:10:20.3502651-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-11-28T17:10:20.3502651Z</LastWriteTimeUtc>
    <LastAccessTime>2016-11-28T11:15:54.3548291-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-11-28T17:15:54.3548291Z</LastAccessTimeUtc>
    <Text># Julia 0.5.0
# Package Created November 18, 2016
# Packaged by Austin Wall
# Last Updated November 18, 2016 by Austin Wall

BEGIN {
    %::INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'julia.0_5_0',
        package_revision =&gt; '20161118T1501',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use File::Copy;
use File::Path;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();
my @exit_codes = (0, 1, 2, 3, 5, 6, 7);

sub install {
    if(!run_command("robocopy \"$srcfiles\\Julia\" \"C:\\Program Files\\Julia\" -E", IgnoreExitCodes=&gt;\@exit_codes))
    {
        output("ERROR: Installation failed!\n");
        return 0;
    }
    
    output("Installation successful!");
    return 1;
}

sub postinstall {
    my $start_menu_folder = build_path(get_allusers_start_menu(), "/Julia 0.5.0/");
    if(-d $start_menu_folder)
    {
        rmtree($start_menu_folder);
    }
    mkdir($start_menu_folder);
    
    if(!run_command("robocopy \"$srcfiles\\Julia 0.5.0\" \"$start_menu_folder\" -E", IgnoreExitCodes=&gt;\@exit_codes))
    {
        output("WARNING: Unable to create start menu shortcuts!");
    }
    
    return 1;
}

do_install( 
    exit_on_failure =&gt; 1,
    allowed_versions          =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
    allowed_os_architectures  =&gt; [OSARCH_x64],
    allowed_regs              =&gt; ["clc", "desktop", "traveling", "virtual-desktop", "virtual-clc"],
    install_sub               =&gt; \&amp;install,
    postinstall_sub           =&gt; \&amp;postinstall,
    
);

IM_Exit(EXIT_SUCCESS);

########################################################################</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\julia.0_6_0\dev\update.pl</FullName>
    <Length>3840</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-27T10:20:58.3104047-05:00</CreationTime>
    <CreationTimeUtc>2017-06-27T15:20:58.3104047Z</CreationTimeUtc>
    <LastWriteTime>2017-06-30T16:44:09.3023957-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-30T21:44:09.3023957Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-30T16:41:31.750107-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-30T21:41:31.750107Z</LastAccessTimeUtc>
    <Text># Package Name: Julia Install
# Package Created: June 27th, 2017
# Packaged By: Jason S. Holm
# Last Update: June 30th, 2017

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;
use Getopt::Long;

# Global InstallMonkey options that must be specified before you load the
# module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
       %INSTALLMONKEY_OPTIONS = (
       package_id =&gt; 'julia.0_6_0',
       package_revision =&gt; '20170630T1644',
       );
}

# Add InstallMonkey Library to the path - 201706261017 added extra backslashes.
my $umrinst = $ENV{'WINDIR'}.'\\SYSTEM32\\UMRINST';
use lib (
    '\\\\minerfiles.mst.edu\\dfs\\software\\loginscripts\\im',
    '$umrinst',
    'C:\\temp',
);


use InstallMonkey::Shared;
my $srcfiles = get_pkg_sourcefiles();

sub preinstall
{
 # Create Directory
 # Need to check if directory exists and then create / set / verify permissions (if needed).
 
 print "If needed, creating directory to copy the extracted program files...";
 run_command("if not exist \"C:\\Program Files\\Julia-0.6.0\\.\" mkdir \"C:\\Program Files\\Julia-0.6.0\""); 
 print "done!\n";
 return 1;
}

sub install
{
 print "Creating a local copy of the program on the target machine...";
 run_command("xcopy C:\\SourceFiles\\Julia.0_6_0\\* \"C:\\Program Files\\Julia-0.6.0\\\" /h /e /y");
 output("done!\n");
 
 # Create Desktop Shortcut - julia.lnk
 # Disabled on 201706301627
 # print "Creating shortcut to Julia.0.6.0 on desktop...";
 # run_command("xcopy C:\\SourceFiles\\Julia.0_6_0\\julia.lnk \"C:\\Users\\Public\\Desktop\\\" /y");
 # print "done!\n";

 # Create Start Menu Folder - Julia 0.6.0
 print "Creating start menu folder for Julia.0.6.0...";
 run_command("if not exist \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Julia 0.6.0\\.\" mkdir \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Julia 0.6.0\"");
 print "done!\n";
 
 # Create Start Menu Program Shortcut - julia.lnk
 print "Creating program link in Julia 0.6.0 start menu folder...";
 run_command("xcopy C:\\SourceFiles\\Julia.0_6_0\\julia.lnk \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Julia 0.6.0\\\" /y");
 print "done!\n";
 
 # Create Start Menu Program HTML RTFM - julia documentation.lnk
 # "C:\SourceFiles\julia.0_6_0\julia documentation.lnk"
 print "Creating link to HTML based documentation for Julia 0.6.0 in the respective start menu folder...";
 run_command("xcopy \"C:\\SourceFiles\\Julia.0_6_0\\Julia Documentation.lnk\" \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Julia 0.6.0\\\" /y");
 print "done!\n";
  
 return 1;
}

sub postinstall
{
  my $PATH = $ENV{'PATH'};
  #  a SYSTEM PATH for the program
  print "Checking current PATH information...";
  if ($PATH !~ /C:\\Program Files\\Julia\-0\.6\.0\\bin/)
  {
   print "PATH information required.\n";
   print "Setting PATH information...";
   run_command("setx /m PATH \"$PATH;C:\\Program Files\\Julia-0.6.0\\bin");
   print "done!\n";
  }
  else
  {
   print "PATH information already exists for Julia-0.6.0.\n";
  }
    
  return 1;
}

do_install( 
    allowed_versions =&gt; ['OSVER_WIN7_SP0', 'OSVER_WIN7_SP1', 'OSVER_WIN10_SP0'],
    allowed_os_architectures =&gt; ['x64', 'OSARCH_x64', 'AMD64'],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    # prerequisite_sub =&gt; \&amp;prerequisite,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit('EXIT_SUCCESS');

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\julia.0_6_0\prod\update.pl</FullName>
    <Length>3840</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-30T16:45:55.259118-05:00</CreationTime>
    <CreationTimeUtc>2017-06-30T21:45:55.259118Z</CreationTimeUtc>
    <LastWriteTime>2017-06-30T16:44:09.3023957-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-30T21:44:09.3023957Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-30T16:45:55.259118-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-30T21:45:55.259118Z</LastAccessTimeUtc>
    <Text># Package Name: Julia Install
# Package Created: June 27th, 2017
# Packaged By: Jason S. Holm
# Last Update: June 30th, 2017

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;
use Getopt::Long;

# Global InstallMonkey options that must be specified before you load the
# module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
       %INSTALLMONKEY_OPTIONS = (
       package_id =&gt; 'julia.0_6_0',
       package_revision =&gt; '20170630T1644',
       );
}

# Add InstallMonkey Library to the path - 201706261017 added extra backslashes.
my $umrinst = $ENV{'WINDIR'}.'\\SYSTEM32\\UMRINST';
use lib (
    '\\\\minerfiles.mst.edu\\dfs\\software\\loginscripts\\im',
    '$umrinst',
    'C:\\temp',
);


use InstallMonkey::Shared;
my $srcfiles = get_pkg_sourcefiles();

sub preinstall
{
 # Create Directory
 # Need to check if directory exists and then create / set / verify permissions (if needed).
 
 print "If needed, creating directory to copy the extracted program files...";
 run_command("if not exist \"C:\\Program Files\\Julia-0.6.0\\.\" mkdir \"C:\\Program Files\\Julia-0.6.0\""); 
 print "done!\n";
 return 1;
}

sub install
{
 print "Creating a local copy of the program on the target machine...";
 run_command("xcopy C:\\SourceFiles\\Julia.0_6_0\\* \"C:\\Program Files\\Julia-0.6.0\\\" /h /e /y");
 output("done!\n");
 
 # Create Desktop Shortcut - julia.lnk
 # Disabled on 201706301627
 # print "Creating shortcut to Julia.0.6.0 on desktop...";
 # run_command("xcopy C:\\SourceFiles\\Julia.0_6_0\\julia.lnk \"C:\\Users\\Public\\Desktop\\\" /y");
 # print "done!\n";

 # Create Start Menu Folder - Julia 0.6.0
 print "Creating start menu folder for Julia.0.6.0...";
 run_command("if not exist \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Julia 0.6.0\\.\" mkdir \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Julia 0.6.0\"");
 print "done!\n";
 
 # Create Start Menu Program Shortcut - julia.lnk
 print "Creating program link in Julia 0.6.0 start menu folder...";
 run_command("xcopy C:\\SourceFiles\\Julia.0_6_0\\julia.lnk \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Julia 0.6.0\\\" /y");
 print "done!\n";
 
 # Create Start Menu Program HTML RTFM - julia documentation.lnk
 # "C:\SourceFiles\julia.0_6_0\julia documentation.lnk"
 print "Creating link to HTML based documentation for Julia 0.6.0 in the respective start menu folder...";
 run_command("xcopy \"C:\\SourceFiles\\Julia.0_6_0\\Julia Documentation.lnk\" \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Julia 0.6.0\\\" /y");
 print "done!\n";
  
 return 1;
}

sub postinstall
{
  my $PATH = $ENV{'PATH'};
  #  a SYSTEM PATH for the program
  print "Checking current PATH information...";
  if ($PATH !~ /C:\\Program Files\\Julia\-0\.6\.0\\bin/)
  {
   print "PATH information required.\n";
   print "Setting PATH information...";
   run_command("setx /m PATH \"$PATH;C:\\Program Files\\Julia-0.6.0\\bin");
   print "done!\n";
  }
  else
  {
   print "PATH information already exists for Julia-0.6.0.\n";
  }
    
  return 1;
}

do_install( 
    allowed_versions =&gt; ['OSVER_WIN7_SP0', 'OSVER_WIN7_SP1', 'OSVER_WIN10_SP0'],
    allowed_os_architectures =&gt; ['x64', 'OSARCH_x64', 'AMD64'],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    # prerequisite_sub =&gt; \&amp;prerequisite,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit('EXIT_SUCCESS');

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\julia.0_6_2\dev\update.pl</FullName>
    <Length>3853</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-22T11:56:21.6842768-05:00</CreationTime>
    <CreationTimeUtc>2018-05-22T16:56:21.6842768Z</CreationTimeUtc>
    <LastWriteTime>2018-05-22T12:19:20.8084268-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-22T17:19:20.8084268Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-22T12:07:02.9509665-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-22T17:07:02.9509665Z</LastAccessTimeUtc>
    <Text># Package Name: Julia Install
# Package Created: May 22nd, 2018
# Packaged By: Robert Smith, based on Jason's 0.6.0 package
# Last Update: May 22nd, 2018

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;
use Getopt::Long;

# Global InstallMonkey options that must be specified before you load the
# module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
       %INSTALLMONKEY_OPTIONS = (
       package_id =&gt; 'julia.0_6_2',
       package_revision =&gt; '20180522T1210',
       );
}

# Add InstallMonkey Library to the path - 20180522T1210 added extra backslashes.
my $umrinst = $ENV{'WINDIR'}.'\\SYSTEM32\\UMRINST';
use lib (
    '\\\\minerfiles.mst.edu\\dfs\\software\\loginscripts\\im',
    '$umrinst',
    'C:\\temp',
);


use InstallMonkey::Shared;
my $srcfiles = get_pkg_sourcefiles();

sub preinstall
{
 # Create Directory
 # Need to check if directory exists and then create / set / verify permissions (if needed).

 print "If needed, creating directory to copy the extracted program files...";
 run_command("if not exist \"C:\\Program Files\\Julia-0.6.2\\.\" mkdir \"C:\\Program Files\\Julia-0.6.2\"");
 print "done!\n";
 return 1;
}

sub install
{
 print "Creating a local copy of the program on the target machine...";
 run_command("xcopy C:\\SourceFiles\\Julia.0_6_2\\* \"C:\\Program Files\\Julia-0.6.2\\\" /h /e /y");
 output("done!\n");

 # Create Desktop Shortcut - julia.lnk
 # Disabled on 201706301627
 # print "Creating shortcut to Julia.0.6.2 on desktop...";
 # run_command("xcopy C:\\SourceFiles\\Julia.0_6_2\\julia.lnk \"C:\\Users\\Public\\Desktop\\\" /y");
 # print "done!\n";

 # Create Start Menu Folder - Julia 0.6.2
 print "Creating start menu folder for Julia.0.6.2...";
 run_command("if not exist \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Julia 0.6.2\\.\" mkdir \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Julia 0.6.2\"");
 print "done!\n";

 # Create Start Menu Program Shortcut - julia.lnk
 print "Creating program link in Julia 0.6.2 start menu folder...";
 run_command("xcopy C:\\SourceFiles\\Julia.0_6_2\\julia.lnk \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Julia 0.6.2\\\" /y");
 print "done!\n";

 # Create Start Menu Program HTML RTFM - julia documentation.lnk
 # "C:\SourceFiles\julia.0_6_2\julia documentation.lnk"
 print "Creating link to HTML based documentation for Julia 0.6.2 in the respective start menu folder...";
 run_command("xcopy \"C:\\SourceFiles\\Julia.0_6_2\\Julia Documentation.lnk\" \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Julia 0.6.2\\\" /y");
 print "done!\n";

 return 1;
}

sub postinstall
{
  my $PATH = $ENV{'PATH'};
  #  a SYSTEM PATH for the program
  print "Checking current PATH information...";
  if ($PATH !~ /C:\\Program Files\\Julia\-0\.6\.2\\bin/)
  {
   print "PATH information required.\n";
   print "Setting PATH information...";
   run_command("setx /m PATH \"$PATH;C:\\Program Files\\Julia-0.6.2\\bin");
   print "done!\n";
  }
  else
  {
   print "PATH information already exists for Julia-0.6.2.\n";
  }

  return 1;
}

do_install(
    allowed_versions =&gt; ['OSVER_WIN7_SP0', 'OSVER_WIN7_SP1', 'OSVER_WIN10_SP0'],
    allowed_os_architectures =&gt; ['x64', 'OSARCH_x64', 'AMD64'],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    # prerequisite_sub =&gt; \&amp;prerequisite,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit('EXIT_SUCCESS');
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\julia.0_6_2\prod\update.pl</FullName>
    <Length>3853</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-22T11:56:43.9352093-05:00</CreationTime>
    <CreationTimeUtc>2018-05-22T16:56:43.9352093Z</CreationTimeUtc>
    <LastWriteTime>2018-05-22T12:19:20.8084268-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-22T17:19:20.8084268Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-22T12:19:33.7060047-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-22T17:19:33.7060047Z</LastAccessTimeUtc>
    <Text># Package Name: Julia Install
# Package Created: May 22nd, 2018
# Packaged By: Robert Smith, based on Jason's 0.6.0 package
# Last Update: May 22nd, 2018

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;
use Getopt::Long;

# Global InstallMonkey options that must be specified before you load the
# module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
       %INSTALLMONKEY_OPTIONS = (
       package_id =&gt; 'julia.0_6_2',
       package_revision =&gt; '20180522T1210',
       );
}

# Add InstallMonkey Library to the path - 20180522T1210 added extra backslashes.
my $umrinst = $ENV{'WINDIR'}.'\\SYSTEM32\\UMRINST';
use lib (
    '\\\\minerfiles.mst.edu\\dfs\\software\\loginscripts\\im',
    '$umrinst',
    'C:\\temp',
);


use InstallMonkey::Shared;
my $srcfiles = get_pkg_sourcefiles();

sub preinstall
{
 # Create Directory
 # Need to check if directory exists and then create / set / verify permissions (if needed).

 print "If needed, creating directory to copy the extracted program files...";
 run_command("if not exist \"C:\\Program Files\\Julia-0.6.2\\.\" mkdir \"C:\\Program Files\\Julia-0.6.2\"");
 print "done!\n";
 return 1;
}

sub install
{
 print "Creating a local copy of the program on the target machine...";
 run_command("xcopy C:\\SourceFiles\\Julia.0_6_2\\* \"C:\\Program Files\\Julia-0.6.2\\\" /h /e /y");
 output("done!\n");

 # Create Desktop Shortcut - julia.lnk
 # Disabled on 201706301627
 # print "Creating shortcut to Julia.0.6.2 on desktop...";
 # run_command("xcopy C:\\SourceFiles\\Julia.0_6_2\\julia.lnk \"C:\\Users\\Public\\Desktop\\\" /y");
 # print "done!\n";

 # Create Start Menu Folder - Julia 0.6.2
 print "Creating start menu folder for Julia.0.6.2...";
 run_command("if not exist \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Julia 0.6.2\\.\" mkdir \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Julia 0.6.2\"");
 print "done!\n";

 # Create Start Menu Program Shortcut - julia.lnk
 print "Creating program link in Julia 0.6.2 start menu folder...";
 run_command("xcopy C:\\SourceFiles\\Julia.0_6_2\\julia.lnk \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Julia 0.6.2\\\" /y");
 print "done!\n";

 # Create Start Menu Program HTML RTFM - julia documentation.lnk
 # "C:\SourceFiles\julia.0_6_2\julia documentation.lnk"
 print "Creating link to HTML based documentation for Julia 0.6.2 in the respective start menu folder...";
 run_command("xcopy \"C:\\SourceFiles\\Julia.0_6_2\\Julia Documentation.lnk\" \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Julia 0.6.2\\\" /y");
 print "done!\n";

 return 1;
}

sub postinstall
{
  my $PATH = $ENV{'PATH'};
  #  a SYSTEM PATH for the program
  print "Checking current PATH information...";
  if ($PATH !~ /C:\\Program Files\\Julia\-0\.6\.2\\bin/)
  {
   print "PATH information required.\n";
   print "Setting PATH information...";
   run_command("setx /m PATH \"$PATH;C:\\Program Files\\Julia-0.6.2\\bin");
   print "done!\n";
  }
  else
  {
   print "PATH information already exists for Julia-0.6.2.\n";
  }

  return 1;
}

do_install(
    allowed_versions =&gt; ['OSVER_WIN7_SP0', 'OSVER_WIN7_SP1', 'OSVER_WIN10_SP0'],
    allowed_os_architectures =&gt; ['x64', 'OSARCH_x64', 'AMD64'],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    # prerequisite_sub =&gt; \&amp;prerequisite,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit('EXIT_SUCCESS');
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\keiluvision.5_17\prod\update.pl</FullName>
    <Length>2474</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-02-04T15:10:28.6913102-06:00</CreationTime>
    <CreationTimeUtc>2016-02-04T21:10:28.6913102Z</CreationTimeUtc>
    <LastWriteTime>2016-02-05T16:36:14.9672355-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-02-05T22:36:14.9672355Z</LastWriteTimeUtc>
    <LastAccessTime>2016-02-04T15:10:28.6913102-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-02-04T21:10:28.6913102Z</LastAccessTimeUtc>
    <Text># Keil uVision 5.17 - an ARM microcontroller development kit
# Package generated with GenGen on 2016-Feb-04 15:10
# Packaged by Grayson Gratop

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
      package_id =&gt; 'keiluvision.5_17',
      package_revision =&gt; '20160204T1510',
  );
}

# Add InstallMonkey Library to the path
use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);

use InstallMonkey::Shared;

my $srcfilesdir = get_pkg_sourcefiles();
my $allUsersDesktop = get_allusers_desktop();
my $allUsersStartmenu = get_allusers_start_menu();


sub install {
  #thanks, creator of python 2.7 package. second argument is whether or not it's okay if the command fails
  my @commands = (
    ["certutil -addstore \"TrustedPublisher\" \"$srcfilesdir\\armltd.cer\"", 0],
    ["\"C:\\Program Files\\7-Zip\\7z\" x \"$srcfilesdir\\data.7z\" -oC:\\", 0],
    ["C:\\Keil_v5\\ARM\\ULINK\\InstallULINK.exe", 0],
    ["mkdir \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Keil\"", 0],
    ["copy \"$srcfilesdir\\Keil uVision5.lnk\" \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Keil\"", 0]
  );

  my $success = 0;
  my $allDone = 1;
  
  output("Installing Keil uVision 5.17... \n");
  
  for (my $i = 0; $i &lt; scalar @commands; $i++) {
    output("\t" . $commands[$i][0] . ": ");
    $success = run_command($commands[$i][0]);
    output($success ? "Done!\n" : "FAILED: $!\n");
    $allDone &amp;&amp;= $commands[$i][1] || $success;
  }

  if ($allDone) {
    output("Looks like it was a success!\n");
  }
  else {
    output("Something went wrong!\n");
  }

  return $allDone;
}


sub postInstall {
  return 1;
}

do_install( 
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
  allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postInstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\kingdom.2016_1\dev\update.pl</FullName>
    <Length>7696</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-13T14:01:17.4995387-05:00</CreationTime>
    <CreationTimeUtc>2017-06-13T19:01:17.4995387Z</CreationTimeUtc>
    <LastWriteTime>2016-09-07T11:16:08-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-09-07T16:16:08Z</LastWriteTimeUtc>
    <LastAccessTime>2016-09-07T11:03:26-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-09-07T16:03:26Z</LastAccessTimeUtc>
    <Text># Kingdom Suite 2016
# Package Created June 2016
# Daniel T. Holtzclaw
#
# Updated September 7, 2016
# Austin Wall
#
# Note:
# This package is a good example of why "The documentation is always wrong" is
# currently written on the DI whiteboard. Each of the Microsoft-based prereqs
# required manual download from MSDN and renaming, despite the fact the manual
# says these are unloaded when the msi is extracted.

# Only trust the install order of the prereqs in the manual.
# The proper installers have been renamed to match the manual in case someone
# decides to compare the install process to the manual.

# Three of the installers that DID come from the extraction are not listed
# in the manual.

# GUIDs, as grouped by the extractor:
# AppSight Installer: {6AFDAFE0-309E-424B-B15E-B78BF06C5C86}
# Kingdom Software Installer: {6D3F056B-7FA0-4602-94DB-BCED791DA961}
# Sam131,Sentinel,SSDCleanup,SSDCleanupx64:{E0C5CB65-E21A-4EE2-A1CE-10C724CA152C}


use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'kingdom.2016',
        package_revision =&gt; '20160907T1115',
    );
}

use lib
(
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);

use InstallMonkey::Shared;
my $files = get_pkg_sourcefiles();
my $log_dir = '%SYSTEMDRIVE%\Windows\system32\UMRInst\AppLogs';
# Appsight will simply not write it's log there at all.
# my $appsight_log = '"C:\Windows\system32\UMRInst\AppLogs\kingdom_2016-Appsight.log"';

# "Key" (Can be sorted easily)
# =&gt; "Install command"
my %prereqs_installs = (
	"0 - .NET Framework 3.5 SP1"
		=&gt; "\"$files".'\dotnetfx35SP1.exe" "/q:a /C:"install /q /norestart" /norestart"',
	"1 - .NET Framework 4.0"
		=&gt; "\"$files".'\dotnetfx40\Setup.exe" /q /norestart /log ' . "\"$log_dir\\kingdom_2016-DotNETFX40.log\"",
	#"2 - SQL Server 2008 R2 Native Installer"
	#	=&gt; "msiexec.exe /i \"$files\\sqlncli_x64i.msi\" /quiet /log \"$log_dir\\kingdom_2016-SQL08_R2.log\" /norestart IACCEPTSQLNCLILICENSETERMS=Yes",
	"3 - SQL Server System CLR Types"
		=&gt; "msiexec.exe /i \"$files\\SQLSysClrTypes_amd64.msi\" /qn /log \"$log_dir\\kingdom_2016-SQL_Server_CLR_Types.log\" /norestart",
	"4 - SQL Server Management Objects"
		=&gt; "msiexec.exe /i \"$files\\SharedManagementObjects_amd64.msi\" /qn /log \"$log_dir\\kingdom_2016-SQL_Server_Management.log\" /norestart",
	#"5 - Sentinel Driver"
	#    =&gt; "start /wait \"$files\\Sentinel.exe\" /v/qn",
);

my %installs = (
	"0 - The Kingdom Software AppSight Installer"
		=&gt; "\"$files\\KingdomAppSightInstaller.exe\" /S /f1\"$files\\install.iss\"", # /f2$appsight_log",
	"1 - The Kingdom Software 2016 64-Bit"
		=&gt; "msiexec.exe /i \"$files\\tks_2016_64.msi\" /quiet /log \"$log_dir\\kingdom_2016-TKS.log\" /norestart",
);
################################################################################
################################################################################
sub preinstall {
	output("\nPreinstall phase: Installing The Kingdom Software Prerequisites\n\n");

	foreach my $key (sort keys %prereqs_installs) {
		output("$key:\n  " . $prereqs_installs{$key} . "\n  Result: ");
		my $success = run_command($prereqs_installs{$key});

		if ($success != 1) {
			output("Failed: $success $!\n");
			return 0;
		}
		output("Succeeded\n\n");
	}
	
	output("Preinstall succeeded.\n");
	return 1;
}

sub install {
	output("\nMain installs: \n\n");

	foreach my $key (sort keys %installs) {
		output("$key:\n  " . $installs{$key} . "\n  Result: ");
		my $success = run_command($installs{$key});

		if ($success != 1) {
			output("Failed: $success $!\n");
			return 0;
		}

		output("Succeeded\n\n");
	}
	output("Installs succeeded.\n");
	return 1;
}

sub postinstall
{
	my $username = "SMTKINGDOM";
	my $password = "\$ei\$micMicro";
	output("Configuring license server info: ");
	my $LSHOST = $ENV{'LSHOST'};
	if( !defined($LSHOST)) {
		run_command("setx /m LSHOST kingdomsuite.lic.mst.edu");
	}
	elsif( $LSHOST !~ /kingdomsuite.lic.mst.edu/) {
		run_command("setx /m LSHOST $LSHOST:kingdomsuite.lic.mst.edu:");
	}
	
	output("Installing SQL Server....................");
	start_global_MSI_logging();

	my @chars = ("A".."Z", "a".."z");
	my $randompass = "Ex4";
  my $hostname = $ENV{'COMPUTERNAME'};
	$randompass .= $chars[rand @chars] for 1..12;
  $randompass .= '!';
	if( !run_command( "\"$files\\SQL\\SQLEXPRWT_x64_ENU.exe\" /IACCEPTSQLSERVERLICENSETERMS /ACTION=install " .
			"/FEATURES=SQL,Tools " .
			"/INSTANCENAME=SMTKINGDOM /INSTANCEDIR=\"C:\\Program Files\\IHS\\KingdomSuite\" /QUIET /TCPENABLED=1 /NPENABLED=1 " .
			"/SQLSVCACCOUNT=\"NT AUTHORITY\\SYSTEM\" " .
			"/SECURITYMODE=SQL " .
			"/SAPWD=\"$randompass\" " .
			"/SQLSYSADMINACCOUNTS=\"$hostname\\Administrators\" ", 'IgnoreExitCodes' =&gt; [2226388992])) #, 'IgnoreExitCodes' =&gt; [1, 2226388992, 2227044356, 2226914596] ) )
	{
		output("FAILED\n");

		finish_global_MSI_logging();
		return 0;
	}
	else {
		output("DONE\n");
		output("\tSA Password: $randompass\n");
	}
	#######################################################################
	# Adding SQL User                                                     #
	#######################################################################
	output("Adding SQL User:\n");

	start_global_MSI_logging();

	my @queries = ( "CREATE LOGIN $username WITH PASSWORD = '$password'",
		"CREATE USER $username FOR LOGIN $username",
		"EXEC master..sp_addsrvrolemember \@loginame='smtkingdom', \@rolename='sysadmin'" );
	my @titles = ( "Creating SQL Login", "Creating SQL User", "Assigning User Role" );
	# Path isn't updated until the script restarts so we have to reference this
	my $sqlcmd = "C:\\Program Files\\Microsoft SQL Server\\100\\Tools\\Binn\\SQLCMD.EXE";

	foreach my $i (@queries) {
		output( "\t" . ( shift @titles ) . ":\t" );
		if( !run_command( "\"$sqlcmd\" -S .\\SMTKINGDOM -e -t 3 -l 5 -Q \"$i\"", 'IgnoreExitCodes' =&gt; [1] ) ) {
			output("\nQuery Execution FAILED\n");
		}
		else {
			output("DONE\n");
		}
	}
	
	#######################################################################
    # Installing Demos                                                    #
    #######################################################################

    output("Installing Demos.........................");
	my $demo_dir = "C:\\Kingdom Demo Projects";

    if(!run_command("robocopy \"$files\\Kingdom Demo Projects\" \"$demo_dir\" /E", 'IgnoreExitCodes' =&gt; [1, 2, 3])) {
		output("FAILED\n");
		finish_global_MSI_logging();
        return 0;
    }
    else {
		output("DONE\n");
    }
	# Add full control permissions for demo projects directory
    run_command("icacls \"$demo_dir\" /T /grant Users\:F");

    finish_global_MSI_logging();
	
=pod
	if(!run_command("DEL /F \"$get_allusers_desktop\\BMC Appsight for Windows Black Box.lnk\"")) {
		output("Could not delete BMC shortcut.\n");
		return 0;
	}
	
	if(!run_command("DEL /F \"$get_allusers_desktop\\The Kingdom Software 2016.lnk\"")) {
		output("Could not delete Kingdom shortcut.\n");
		return 0;
	}
=cut
	
	output("Done!");
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    need_reboot =&gt; 1,
);


IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\kingdom.2016_1\patchprod\update.pl</FullName>
    <Length>4753</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-13T14:01:40.5105712-05:00</CreationTime>
    <CreationTimeUtc>2017-06-13T19:01:40.5105712Z</CreationTimeUtc>
    <LastWriteTime>2016-09-06T11:01:55-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-09-06T16:01:55Z</LastWriteTimeUtc>
    <LastAccessTime>2016-09-06T10:54:23-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-09-06T15:54:23Z</LastAccessTimeUtc>
    <Text>#Patch script for Kingdom 2016 SQL Server
#Patch created September 2016
#Last updated 09/06/2016
#Last updated by Austin Wall


use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS =
	(
        package_id =&gt; 'kingdom.2016.sql',
        package_revision =&gt; '20160906T1100',
    );
}


use lib
(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;

# DEV: install/configure SQL server express and exit
# exit(!install_KingdomSQL());

my $sourcefilesdir = get_pkg_sourcefiles();

my $username = "SMTKINGDOM";
my $password = "\$ei\$micMicro";

sub install
{
    output("Removing SQL Native Client.....");
    if(!run_command("MsiExec.exe /x {2180B33F-3225-423E-BBC1-7798CFD3CD1F} /qn /norestart"))
    {
        output("FAILED\n");
        return 0;
    }
    else
    {
        output("Success!\n");
    }
    #######################################################################
    # Installing SQL Server                                               #
    # http://www.seismicmicro.com/ProductReleaseDocumentation/KINGDOM/InstallationGuide.pdf
    # See: Creating and Configuring an SMTKINGDOM Instance                #
    # Mixed auth mode as Kingdom doesn't support windows auth             #
    #######################################################################

    output("Installing SQL Server....................");
    start_global_MSI_logging();

   my @chars = ("A".."Z", "a".."z");
   my $randompass = "Ex4";
   my $hostname = $ENV{'COMPUTERNAME'};
   $randompass .= $chars[rand @chars] for 1..12;
   $randompass .= '!';
   if( !run_command( "\"$sourcefilesdir\\SQL\\SQLEXPRWT_x64_ENU.exe\" /IACCEPTSQLSERVERLICENSETERMS /ACTION=install " .
                      "/FEATURES=SQL,Tools " .
                      "/INSTANCENAME=SMTKINGDOM /INSTANCEDIR=\"C:\\Program Files\\IHS\\KingdomSuite\" /QUIET /TCPENABLED=1 /NPENABLED=1 " .
                      "/SQLSVCACCOUNT=\"NT AUTHORITY\\SYSTEM\" " .
                      "/SECURITYMODE=SQL " .
                      "/SAPWD=\"$randompass\" " .
                      "/SQLSYSADMINACCOUNTS=\"$hostname\\Administrators\" ", 'IgnoreExitCodes' =&gt; [2226388992]) )
    {
        output("FAILED\n");

        finish_global_MSI_logging();
        return 0;
    }
    else
    {
        output("DONE\n");
        output("\tSA Password: $randompass\n");
    }

	  #######################################################################
    # Adding SQL User                                                     #
    #######################################################################
	  output("Adding SQL User:\n");

    start_global_MSI_logging();

   my @queries = ( "CREATE LOGIN $username WITH PASSWORD = '$password'",
                 "CREATE USER $username FOR LOGIN $username",
                 "EXEC master..sp_addsrvrolemember \@loginame='smtkingdom', \@rolename='sysadmin'" );
   my @titles = ( "Creating SQL Login", "Creating SQL User", "Assigning User Role" );
   # Path isn't updated until the script restarts so we have to reference this
   my $sqlcmd = "C:\\Program Files\\Microsoft SQL Server\\100\\Tools\\Binn\\SQLCMD.EXE";

   foreach my $i (@queries)
   {
     output( "\t" . ( shift @titles ) . ":\t" );
     if( !run_command( "\"$sqlcmd\" -S .\\SMTKINGDOM -e -t 3 -l 5 -Q \"$i\"", 'IgnoreExitCodes' =&gt; [1]  ) )
     {
       output("\nQuery Execution FAILED\n");
     }
     else
     {
       output("DONE\n");
     }
    }
    return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
);


IM_Exit(EXIT_SUCCESS);







# Begin-Doc
################################
# Name: install_KingdomSQL()
# Description: Do whatever is necessary to install and configure
#   SQL server needed by The Kingdom Suite 2015.
# Returns:
# Requires:
# LastUpdated:
# LastUpdatedBy:
################################
# End-Doc
sub install_KingdomSQL {

    # Invoke the IHS installer (wrapper for SQL Server Express)
    #   'setup.iss' was created the regular way (setup.exe /r)
    my $setup_dir = build_path(get_pkg_sourcefiles(),
                               'Web_SQLExpress',
                               'SupportFiles',
                               'SQLExpress');
    push_dir($setup_dir);
    my $outcome = installshield_install();

    pop_dir();
    return $outcome;
}
</Text>
  </Script>
  <Script>
    <Name>old_update_do_not_use.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\kingdom.2016_1\prod\old_update_do_not_use.pl</FullName>
    <Length>9398</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-13T14:07:43.601263-05:00</CreationTime>
    <CreationTimeUtc>2017-06-13T19:07:43.601263Z</CreationTimeUtc>
    <LastWriteTime>2016-06-20T13:32:02-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-06-20T18:32:02Z</LastWriteTimeUtc>
    <LastAccessTime>2016-06-14T12:49:30-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-06-14T17:49:30Z</LastAccessTimeUtc>
    <Text># Kingdom Suite 2015
# Package Created June 2016
# Daniel T. Holtzclaw

=pod

Begin-Doc
Modified: 11/30/2012
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: Kyle Knudsen
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS =
	(
        package_id =&gt; 'kingdom.2016',
        package_revision =&gt; '11062014T1146',
    );
}


use lib
(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;

# DEV: install/configure SQL server express and exit
# exit(!install_KingdomSQL());

my $sourcefilesdir = get_pkg_sourcefiles();
my $msiDir = "$sourcefilesdir\\SMTUpdateManagerSetupExtract\\SmtUpdateManagerSetup.msi";

my $username = "SMTKINGDOM";
my $password = "\$ei\$micMicro";

sub install
{
    start_global_MSI_logging();
    output("\n");

    #####################################################################
    # Installing SMT Update Manager                                     #
    #####################################################################

    output("Installing SUM...........................");

    if(!install_msi(msi =&gt; $msiDir))
    {
      output("FAILED\n");
      finish_global_MSI_logging();
      return 0;
    }
    else
    {
        output("DONE\n");
    }



    #######################################################################
    # Installing Sentinel Driver                                          #
    #######################################################################

    #If this driver is not installed then kingdom installer will fail in
	#the SCCM environment and it may or may not say that it failed.

    output("Installing Sentinel Driver...............");

    if(!installshield_install('setup'=&gt; 'sentinel_driver\\Sentinel System Driver Installer 7.5.8.exe',
	                          'ignore-MSI-logging' =&gt; 1,
							  'ignore-is-log' =&gt; 1,
							  'additional-parameters' =&gt; ['S']))
    {
      output("FAILED\n");
	  finish_global_MSI_logging();
      return 0;
    }
    else
    {
      output("DONE\n");
    }

    #######################################################################
    # Installing KINGDOM Suite                                            #
    #######################################################################

    output("Installing Kingdom Suite.................");

    if(!run_command("start /D \"$sourcefilesdir\\KingdomSoftware\" /WAIT The_Kingdom_Software_2015_(64-bit).msi /qn"))
    {
        output("\n");
        output("KINGDOM Suite did not install successfully.  ");
        output("Please check the logs.\n");

        finish_global_MSI_logging();
        return 0;
    }
    else
    {
        output("DONE\n");
    }

    #######################################################################
    # Installing SQL Server                                               #
    # http://www.seismicmicro.com/ProductReleaseDocumentation/KINGDOM/InstallationGuide.pdf
    # See: Creating and Configuring an SMTKINGDOM Instance                #
    # Mixed auth mode as Kingdom doesn't support windows auth             #
    #######################################################################

    output("Installing SQL Server....................");
    start_global_MSI_logging();

   my @chars = ("A".."Z", "a".."z");
   my $randompass = "Ex4";
   $randompass .= $chars[rand @chars] for 1..12;

    if( !run_command( "\"$sourcefilesdir\\SQL\\SQLEXPRWT_x64_ENU.exe\" /IACCEPTSQLSERVERLICENSETERMS /ACTION=install " .
                      "/FEATURES=SQL,Tools " .
                      "/INSTANCENAME=SMTKINGDOM /INSTANCEDIR=\"C:\\Program Files\\IHS\\KingdomSuite\" /QUIET /TCPENABLED=1 /NPENABLED=1 " .
                      "/SQLSVCACCOUNT=\"NT AUTHORITY\\SYSTEM\" " .
                      "/SECURITYMODE=SQL " .
                      "/SAPWD=\"$randompass\" " .
                      "/SQLSYSADMINACCOUNTS=\"BUILTIN\\Administrators\" " ) )
    {
        output("FAILED\n");

        finish_global_MSI_logging();
        return 0;
    }
    else
    {
        output("DONE\n");
        output("\tSA Password: $randompass\n");
    }

	  #######################################################################
    # Adding SQL User                                                     #
    #######################################################################
	  output("Adding SQL User:\n");

    start_global_MSI_logging();

   my @queries = ( "CREATE LOGIN $username WITH PASSWORD = '$password'",
                 "CREATE USER $username FOR LOGIN $username",
                 "EXEC master..sp_addsrvrolemember \@loginame='smtkingdom', \@rolename='sysadmin'" );
   my @titles = ( "Creating SQL Login", "Creating SQL User", "Assigning User Role" );
   # Path isn't updated until the script restarts so we have to reference this
   my $sqlcmd = "C:\\Program Files\\Microsoft SQL Server\\100\\Tools\\Binn\\SQLCMD.EXE";

   foreach my $i (@queries)
   {
     output( "\t" . ( shift @titles ) . ":\t" );
     if( !run_command( "\"$sqlcmd\" -S .\\SMTKINGDOM -e -t 3 -l 5 -Q \"$i\"" ) )
     {
       output("\nQuery Execution FAILED\n");
     }
     else
     {
       output("DONE\n");
     }
    }

    #######################################################################
    # Installing Demos                                                    #
    #######################################################################

    output("Installing Demos.........................");

    # if(!installshield_install('setup' =&gt; 'DemoProjects\\setup.exe', 'iss' =&gt; 'DemoProjects\\setup.iss'))
    # {
      # output("FAILED\n");
      # finish_global_MSI_logging($sourcefilesdir);
      # return 0;
    # }

    if(!run_command("start /wait $sourcefilesdir\\DemoProjects\\setup.exe /s"))
    {
        output("FAILED\n");
        finish_global_MSI_logging();

        return 0;
    }

    else
    {
        output("DONE\n");
    }

    finish_global_MSI_logging();

    return 1;
}


sub postinstall
{
    my $currentuser = $ENV{'public'}."\\desktop";

    ########################################################################
    # ActiveSetup action to copy .set file containing license info to user #
    # profile root.                                                        #
    ########################################################################

    if(!create_activesetup_action
    (
        'Identifier' =&gt; get_package_id(),
        'ComponentID' =&gt; get_package_id(),
        'Description' =&gt; 'Copy license info to user profile',
        'Version' =&gt; '1,0',
        'StubPath' =&gt; "c:\\sourcefiles\\kingdom.2015\\license.cmd",))
    {
        output("\n");
        output("ActiveSetup action unsuccessful.");
        output("\n");

        return 0;
    }

    my $LSHOST = $ENV{'LSHOST'};
    if( !defined($LSHOST) )
    {
        run_command("setx /m LSHOST kingdomsuite.lic.mst.edu");
    }
    elsif( $LSHOST !~ /kingdomsuite.lic.mst.edu/ )
    {
        run_command("setx /m LSHOST $LSHOST:kingdomsuite.lic.mst.edu:");
    }

    #######################################################################
    # Remove desktop shortcuts                                            #
    #######################################################################

    if(!run_command("del \"$currentuser\\Kingdom 8.8 (64-bit).lnk\" /Q"))
    {
        output("\n");
        output("Desktop icon removal unsuccessful");
        output("\n");
    }

    if(!run_command("del \"$currentuser\\BMC AppSight for Windows Black Box.lnk\" /Q"))
    {
        output("\n");
        output("Desktop icon removal unsuccessful");
        output("\n");
    }


    # Add full control permissions for demo projects directory
    my $demo_dir = "C:\\Kingdom Demo Projects";
    run_command("icacls \"$demo_dir\" /T /grant Users\:F");
    return 1;

}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);


IM_Exit(EXIT_SUCCESS);







# Begin-Doc
################################
# Name: install_KingdomSQL()
# Description: Do whatever is necessary to install and configure
#   SQL server needed by The Kingdom Suite 2015.
# Returns:
# Requires:
# LastUpdated:
# LastUpdatedBy:
################################
# End-Doc
sub install_KingdomSQL {

    # Invoke the IHS installer (wrapper for SQL Server Express)
    #   'setup.iss' was created the regular way (setup.exe /r)
    my $setup_dir = build_path(get_pkg_sourcefiles(),
                               'Web_SQLExpress',
                               'SupportFiles',
                               'SQLExpress');
    push_dir($setup_dir);
    my $outcome = installshield_install();

    pop_dir();
    return $outcome;
}
</Text>
  </Script>
  <Script>
    <Name>update-new-preconfig.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\kingdom.2016_1\prod\update-new-preconfig.pl</FullName>
    <Length>7809</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-13T14:07:43.7416693-05:00</CreationTime>
    <CreationTimeUtc>2017-06-13T19:07:43.7416693Z</CreationTimeUtc>
    <LastWriteTime>2016-09-01T14:22:16-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-09-01T19:22:16Z</LastWriteTimeUtc>
    <LastAccessTime>2016-09-01T13:56:12-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-09-01T18:56:12Z</LastAccessTimeUtc>
    <Text># Kingdom Suite 2016
# Package Created June 2016
# Daniel T. Holtzclaw

# Note:
# This package is a good example of why "The documentation is always wrong" is
# currently written on the DI whiteboard. Each of the Microsoft-based prereqs
# required manual download from MSDN and renaming, despite the fact the manual
# says these are unloaded when the msi is extracted.

# Only trust the install order of the prereqs in the manual.
# The proper installers have been renamed to match the manual in case someone
# decides to compare the install process to the manual.

# Three of the installers that DID come from the extraction are not listed
# in the manual.

# GUIDs, as grouped by the extractor:
# AppSight Installer: {6AFDAFE0-309E-424B-B15E-B78BF06C5C86}
# Kingdom Software Installer: {6D3F056B-7FA0-4602-94DB-BCED791DA961}
# Sam131,Sentinel,SSDCleanup,SSDCleanupx64:{E0C5CB65-E21A-4EE2-A1CE-10C724CA152C}

=pod

Begin-Doc
Modified: 11/30/2012
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: Kyle Knudsen
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'kingdom.2016',
        package_revision =&gt; '11062014T1146',
    );
}

use lib
(
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);

use InstallMonkey::Shared;
my $files = get_pkg_sourcefiles();
my $log_dir = '%SYSTEMDRIVE%\Windows\system32\UMRInst\AppLogs';
# Appsight will simply not write it's log there at all.
# my $appsight_log = '"C:\Windows\system32\UMRInst\AppLogs\kingdom_2016-Appsight.log"';

# "Key" (Can be sorted easily)
# =&gt; "Install command"
my %prereqs_installs = (
	"0 - .NET Framework 3.5 SP1"
		=&gt; "\"$files".'\dotnetfx35SP1.exe" "/q:a /C:"install /q /norestart" /norestart"',
	"1 - .NET Framework 4.0"
		=&gt; "\"$files".'\dotnetfx40\Setup.exe" /q /norestart /log ' . "\"$log_dir\\kingdom_2016-DotNETFX40.log\"",
	#"2 - SQL Server 2008 R2 Native Installer"
	#	=&gt; "msiexec.exe /i \"$files\\sqlncli_x64i.msi\" /quiet /log \"$log_dir\\kingdom_2016-SQL08_R2.log\" /norestart IACCEPTSQLNCLILICENSETERMS=Yes",
	"3 - SQL Server System CLR Types"
		=&gt; "msiexec.exe /i \"$files\\SQLSysClrTypes_amd64.msi\" /qn /log \"$log_dir\\kingdom_2016-SQL_Server_CLR_Types.log\" /norestart",
	"4 - SQL Server Management Objects"
		=&gt; "msiexec.exe /i \"$files\\SharedManagementObjects_amd64.msi\" /qn /log \"$log_dir\\kingdom_2016-SQL_Server_Management.log\" /norestart",
	#"5 - Sentinel Driver"
	#    =&gt; "start /wait \"$files\\Sentinel.exe\" /v/qn",
);

my %installs = (
	"0 - The Kingdom Software AppSight Installer"
		=&gt; "\"$files\\KingdomAppSightInstaller.exe\" /S /f1\"$files\\install.iss\"", # /f2$appsight_log",
	"1 - The Kingdom Software 2016 64-Bit"
		=&gt; "msiexec.exe /i \"$files\\tks_2016_64.msi\" /quiet /log \"$log_dir\\kingdom_2016-TKS.log\" /norestart",
);
################################################################################
################################################################################
sub preinstall {
	output("\nPreinstall phase: Installing The Kingdom Software Prerequisites\n\n");

	foreach my $key (sort keys %prereqs_installs) {
		output("$key:\n  " . $prereqs_installs{$key} . "\n  Result: ");
		my $success = run_command($prereqs_installs{$key});

		if ($success != 1) {
			output("Failed: $success $!\n");
			return 0;
		}
		output("Succeeded\n\n");
	}
	
	output("Preinstall succeeded.\n");
	return 1;
}

sub install {
	output("\nMain installs: \n\n");

	foreach my $key (sort keys %installs) {
		output("$key:\n  " . $installs{$key} . "\n  Result: ");
		my $success = run_command($installs{$key});

		if ($success != 1) {
			output("Failed: $success $!\n");
			return 0;
		}

		output("Succeeded\n\n");
	}
	output("Installs succeeded.\n");
	return 1;
}

sub postinstall
{
	my $username = "SMTKINGDOM";
	my $password = "\$ei\$micMicro";
	output("Configuring license server info: ");
	my $LSHOST = $ENV{'LSHOST'};
	if( !defined($LSHOST)) {
		run_command("setx /m LSHOST kingdomsuite.lic.mst.edu");
	}
	elsif( $LSHOST !~ /kingdomsuite.lic.mst.edu/) {
		run_command("setx /m LSHOST $LSHOST:kingdomsuite.lic.mst.edu:");
	}
=pod
	output("Installing SQL Server....................");
	start_global_MSI_logging();

	my @chars = ("A".."Z", "a".."z");
	my $randompass = "Ex4";
	$randompass .= $chars[rand @chars] for 1..12;

	if( !run_command( "\"$files\\SQL\\SQLEXPRWT_x64_ENU.exe\" /IACCEPTSQLSERVERLICENSETERMS /ACTION=install " .
			"/FEATURES=SQL,Tools " .
			"/INSTANCENAME=SMTKINGDOM /INSTANCEDIR=\"C:\\Program Files\\IHS\\KingdomSuite\" /QUIET /TCPENABLED=1 /NPENABLED=1 " .
			"/SQLSVCACCOUNT=\"NT AUTHORITY\\SYSTEM\" " .
			"/SECURITYMODE=SQL " .
			"/SAPWD=\"$randompass\" " .
			"/SQLSYSADMINACCOUNTS=\"BUILTIN\\Administrators\" ", 'IgnoreExitCodes' =&gt; [2226388992])) #, 'IgnoreExitCodes' =&gt; [1, 2226388992, 2227044356, 2226914596] ) )
	{
		output("FAILED\n");

		finish_global_MSI_logging();
		return 0;
	}
	else {
		output("DONE\n");
		output("\tSA Password: $randompass\n");
	}
	#######################################################################
	# Adding SQL User                                                     #
	#######################################################################
	output("Adding SQL User:\n");

	start_global_MSI_logging();

	my @queries = ( "CREATE LOGIN $username WITH PASSWORD = '$password'",
		"CREATE USER $username FOR LOGIN $username",
		"EXEC master..sp_addsrvrolemember \@loginame='smtkingdom', \@rolename='sysadmin'" );
	my @titles = ( "Creating SQL Login", "Creating SQL User", "Assigning User Role" );
	# Path isn't updated until the script restarts so we have to reference this
	my $sqlcmd = "C:\\Program Files\\Microsoft SQL Server\\100\\Tools\\Binn\\SQLCMD.EXE";

	foreach my $i (@queries) {
		output( "\t" . ( shift @titles ) . ":\t" );
		if( !run_command( "\"$sqlcmd\" -S .\\SMTKINGDOM -e -t 3 -l 5 -Q \"$i\"", 'IgnoreExitCodes' =&gt; [1] ) ) {
			output("\nQuery Execution FAILED\n");
		}
		else {
			output("DONE\n");
		}
	}
=cut
	#######################################################################
    # Installing Demos                                                    #
    #######################################################################

    output("Installing Demos.........................");
	my $demo_dir = "C:\\Kingdom Demo Projects";

    if(!run_command("robocopy \"$files\\Kingdom Demo Projects\" \"$demo_dir\" /E", 'IgnoreExitCodes' =&gt; [1, 2, 3])) {
		output("FAILED\n");
		finish_global_MSI_logging();
        return 0;
    }
    else {
		output("DONE\n");
    }
	# Add full control permissions for demo projects directory
    run_command("icacls \"$demo_dir\" /T /grant Users\:F");

    finish_global_MSI_logging();
	
=pod
	if(!run_command("DEL /F \"$get_allusers_desktop\\BMC Appsight for Windows Black Box.lnk\"")) {
		output("Could not delete BMC shortcut.\n");
		return 0;
	}
	
	if(!run_command("DEL /F \"$get_allusers_desktop\\The Kingdom Software 2016.lnk\"")) {
		output("Could not delete Kingdom shortcut.\n");
		return 0;
	}
=cut
	
	output("Done!");
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    need_reboot =&gt; 1,
);


IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update-old.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\kingdom.2016_1\prod\update-old.pl</FullName>
    <Length>4854</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-13T14:07:43.7884714-05:00</CreationTime>
    <CreationTimeUtc>2017-06-13T19:07:43.7884714Z</CreationTimeUtc>
    <LastWriteTime>2016-08-15T10:34:53-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-08-15T15:34:53Z</LastWriteTimeUtc>
    <LastAccessTime>2016-06-20T13:30:42-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-06-20T18:30:42Z</LastAccessTimeUtc>
    <Text># Kingdom Suite 2016
# Package Created June 2016
# Daniel T. Holtzclaw

# Note:
# This package is a good example of why "The documentation is always wrong" is
# currently written on the DI whiteboard. Each of the Microsoft-based prereqs
# required manual download from MSDN and renaming, despite the fact the manual
# says these are unloaded when the msi is extracted.

# Only trust the install order of the prereqs in the manual.
# The proper installers have been renamed to match the manual in case someone
# decides to compare the install process to the manual.

# Three of the installers that DID come from the extraction are not listed
# in the manual.

# GUIDs, as grouped by the extractor:
# AppSight Installer: {6AFDAFE0-309E-424B-B15E-B78BF06C5C86}
# Kingdom Software Installer: {6D3F056B-7FA0-4602-94DB-BCED791DA961}
# Sam131,Sentinel,SSDCleanup,SSDCleanupx64:{E0C5CB65-E21A-4EE2-A1CE-10C724CA152C}

=pod

Begin-Doc
Modified: 11/30/2012
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: Kyle Knudsen
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'kingdom.2016',
        package_revision =&gt; '11062014T1146',
    );
}

use lib
(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;
my $files = get_pkg_sourcefiles();
my $log_dir = '%SYSTEMDRIVE%\Windows\system32\UMRInst\AppLogs';
# Appsight will simply not write it's log there at all.
# my $appsight_log = '"C:\Windows\system32\UMRInst\AppLogs\kingdom_2016-Appsight.log"';

# "Key" (Can be sorted easily)
# =&gt; "Install command"
my %prereqs_installs = (
  "0 - .NET Framework 3.5 SP1"
    =&gt; "\"$files".'\dotnetfx35SP1.exe" "/q:a /C:"install /q /norestart" /norestart"',
  "1 - .NET Framework 4.0"
    =&gt; "\"$files".'\dotnetfx40\Setup.exe" /q /norestart /log ' . "\"$log_dir\\kingdom_2016-DotNETFX40.log\"",
  "2 - SQL Server 2008 R2 Native Installer"
    =&gt; "msiexec.exe /i \"$files\\sqlncli_x64i.msi\" /quiet /log \"$log_dir\\kingdom_2016-SQL08_R2.log\" /norestart IACCEPTSQLNCLILICENSETERMS=Yes",
  "3 - SQL Server System CLR Types"
    =&gt; "msiexec.exe /i \"$files\\SQLSysClrTypes_amd64.msi\" /qn /log \"$log_dir\\kingdom_2016-SQL_Server_CLR_Types.log\" /norestart",
  "4 - SQL Server Management Objects"
    =&gt; "msiexec.exe /i \"$files\\SharedManagementObjects_amd64.msi\" /qn /log \"$log_dir\\kingdom_2016-SQL_Server_Management.log\" /norestart",
#  "5 - Sentinel Driver"
#   =&gt; "start /wait \"$files\\Sentinel.exe\" /v/qn",
);

my %installs = (
 "0 - The Kingdom Software AppSight Installer"
   =&gt; "\"$files\\KingdomAppSightInstaller.exe\" /S /f1\"$files\\install.iss\"", # /f2$appsight_log",
 "1 - The Kingdom Software 2016 64-Bit"
  =&gt; "msiexec.exe /i \"$files\\tks_2016_64.msi\" /quiet /log \"$log_dir\\kingdom_2016-TKS.log\" /norestart",
);
################################################################################
################################################################################
sub preinstall {
  output("\nPreinstall phase: Installing The Kingdom Software Prerequisites\n\n");

  foreach my $key (sort keys %prereqs_installs)
  {
    output("$key:\n  " . $prereqs_installs{$key} . "\n  Result: ");
    my $success = run_command($prereqs_installs{$key});

    if ($success != 1)
    {
      output("Failed: $success $!\n");
      return 0;
    }
    output("Succeeded\n\n");
  }
 output("Preinstall succeeded.\n");
 return 1;
}

sub install
{
  output("\nMain installs: \n\n");

  foreach my $key (sort keys %installs)
  {
    output("$key:\n  " . $installs{$key} . "\n  Result: ");
    my $success = run_command($installs{$key});

    if ($success != 1)
    {
      output("Failed: $success $!\n");
      return 0;
    }

    output("Succeeded\n\n");
  }
  output("Installs succeeded.\n");
  return 1;
}

sub postinstall
{
  output("Configuring license server info: ");
  my $LSHOST = $ENV{'LSHOST'};
  if( !defined($LSHOST) )
  {
      run_command("setx /m LSHOST kingdomsuite.lic.mst.edu");
  }
  elsif( $LSHOST !~ /kingdomsuite.lic.mst.edu/ )
  {
      run_command("setx /m LSHOST $LSHOST:kingdomsuite.lic.mst.edu:");
  }
  output("Done!");
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    need_reboot =&gt; 1,
);


IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update-sql-only-super-test.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\kingdom.2016_1\prod\update-sql-only-super-test.pl</FullName>
    <Length>5017</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-13T14:07:43.8196728-05:00</CreationTime>
    <CreationTimeUtc>2017-06-13T19:07:43.8196728Z</CreationTimeUtc>
    <LastWriteTime>2016-09-02T14:57:49-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-09-02T19:57:49Z</LastWriteTimeUtc>
    <LastAccessTime>2016-09-01T16:08:53-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-09-01T21:08:53Z</LastAccessTimeUtc>
    <Text># Package Created May 2012
# Package created by Kyle Knudsen (some code borrowed from Sam Pilla)
# Package fixed by Billy Rhoades (01/2015)
# Last Updated November 20 2014

=pod

Begin-Doc
Modified: 11/30/2012
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: Kyle Knudsen
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS =
	(
        package_id =&gt; 'kingdom.2016.sql',
        package_revision =&gt; '09012016T1051',
    );
}


use lib
(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;

# DEV: install/configure SQL server express and exit
# exit(!install_KingdomSQL());

my $sourcefilesdir = get_pkg_sourcefiles();

my $username = "SMTKINGDOM";
my $password = "\$ei\$micMicro";

sub install
{
    output("Removing SQL Native Client.....");
    if(!run_command("MsiExec.exe /x {2180B33F-3225-423E-BBC1-7798CFD3CD1F} /qn /norestart"))
    {
        output("FAILED\n");
        return 0;
    }
    else
    {
        output("Success!\n");
    }
    #######################################################################
    # Installing SQL Server                                               #
    # http://www.seismicmicro.com/ProductReleaseDocumentation/KINGDOM/InstallationGuide.pdf
    # See: Creating and Configuring an SMTKINGDOM Instance                #
    # Mixed auth mode as Kingdom doesn't support windows auth             #
    #######################################################################

    output("Installing SQL Server....................");
    start_global_MSI_logging();

   my @chars = ("A".."Z", "a".."z");
   my $randompass = "Ex4";
   my $hostname = $ENV{'COMPUTERNAME'};
   $randompass .= $chars[rand @chars] for 1..12;
   $randompass .= '!';
   if( !run_command( "\"$sourcefilesdir\\SQL\\SQLEXPRWT_x64_ENU.exe\" /IACCEPTSQLSERVERLICENSETERMS /ACTION=install " .
                      "/FEATURES=SQL,Tools " .
                      "/INSTANCENAME=SMTKINGDOM /INSTANCEDIR=\"C:\\Program Files\\IHS\\KingdomSuite\" /QUIET /TCPENABLED=1 /NPENABLED=1 " .
                      "/SQLSVCACCOUNT=\"NT AUTHORITY\\SYSTEM\" " .
                      "/SECURITYMODE=SQL " .
                      "/SAPWD=\"$randompass\" " .
                      "/SQLSYSADMINACCOUNTS=\"$hostname\\Administrators\" ", 'IgnoreExitCodes' =&gt; [2226388992]) )
    {
        output("FAILED\n");

        finish_global_MSI_logging();
        return 0;
    }
    else
    {
        output("DONE\n");
        output("\tSA Password: $randompass\n");
    }

	  #######################################################################
    # Adding SQL User                                                     #
    #######################################################################
	  output("Adding SQL User:\n");

    start_global_MSI_logging();

   my @queries = ( "CREATE LOGIN $username WITH PASSWORD = '$password'",
                 "CREATE USER $username FOR LOGIN $username",
                 "EXEC master..sp_addsrvrolemember \@loginame='smtkingdom', \@rolename='sysadmin'" );
   my @titles = ( "Creating SQL Login", "Creating SQL User", "Assigning User Role" );
   # Path isn't updated until the script restarts so we have to reference this
   my $sqlcmd = "C:\\Program Files\\Microsoft SQL Server\\100\\Tools\\Binn\\SQLCMD.EXE";

   foreach my $i (@queries)
   {
     output( "\t" . ( shift @titles ) . ":\t" );
     if( !run_command( "\"$sqlcmd\" -S .\\SMTKINGDOM -e -t 3 -l 5 -Q \"$i\"", 'IgnoreExitCodes' =&gt; [1]  ) )
     {
       output("\nQuery Execution FAILED\n");
     }
     else
     {
       output("DONE\n");
     }
    }
    return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
);


IM_Exit(EXIT_SUCCESS);







# Begin-Doc
################################
# Name: install_KingdomSQL()
# Description: Do whatever is necessary to install and configure
#   SQL server needed by The Kingdom Suite 2015.
# Returns:
# Requires:
# LastUpdated:
# LastUpdatedBy:
################################
# End-Doc
sub install_KingdomSQL {

    # Invoke the IHS installer (wrapper for SQL Server Express)
    #   'setup.iss' was created the regular way (setup.exe /r)
    my $setup_dir = build_path(get_pkg_sourcefiles(),
                               'Web_SQLExpress',
                               'SupportFiles',
                               'SQLExpress');
    push_dir($setup_dir);
    my $outcome = installshield_install();

    pop_dir();
    return $outcome;
}
</Text>
  </Script>
  <Script>
    <Name>update-sql-only.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\kingdom.2016_1\prod\update-sql-only.pl</FullName>
    <Length>5784</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-13T14:07:43.8352735-05:00</CreationTime>
    <CreationTimeUtc>2017-06-13T19:07:43.8352735Z</CreationTimeUtc>
    <LastWriteTime>2016-09-01T10:51:59-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-09-01T15:51:59Z</LastWriteTimeUtc>
    <LastAccessTime>2016-09-01T10:47:28-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-09-01T15:47:28Z</LastAccessTimeUtc>
    <Text># Package Created May 2012
# Package created by Kyle Knudsen (some code borrowed from Sam Pilla)
# Package fixed by Billy Rhoades (01/2015)
# Last Updated November 20 2014

=pod

Begin-Doc
Modified: 11/30/2012
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: Kyle Knudsen
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS =
	(
        package_id =&gt; 'kingdom.2016.sql',
        package_revision =&gt; '09012016T1051',
    );
}


use lib
(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;

# DEV: install/configure SQL server express and exit
# exit(!install_KingdomSQL());

my $sourcefilesdir = get_pkg_sourcefiles();

my $username = "SMTKINGDOM";
my $password = "\$ei\$micMicro";

sub install
{
    
    #######################################################################
    # Installing SQL Server                                               #
    # http://www.seismicmicro.com/ProductReleaseDocumentation/KINGDOM/InstallationGuide.pdf
    # See: Creating and Configuring an SMTKINGDOM Instance                #
    # Mixed auth mode as Kingdom doesn't support windows auth             #
    #######################################################################

    output("Installing SQL Server....................");
    start_global_MSI_logging();

   my @chars = ("A".."Z", "a".."z");
   my $randompass = "Ex4";
   $randompass .= $chars[rand @chars] for 1..12;

    if( !run_command( "\"$sourcefilesdir\\SQL\\SQLEXPRWT_x64_ENU.exe\" /IACCEPTSQLSERVERLICENSETERMS /ACTION=install " .
                      "/FEATURES=SQL,Tools " .
                      "/INSTANCENAME=SMTKINGDOM /INSTANCEDIR=\"C:\\Program Files\\IHS\\KingdomSuite\" /QUIET /TCPENABLED=1 /NPENABLED=1 " .
                      "/SQLSVCACCOUNT=\"NT AUTHORITY\\SYSTEM\" " .
                      "/SECURITYMODE=SQL " .
                      "/SAPWD=\"$randompass\" " .
                      "/SQLSYSADMINACCOUNTS=\"BUILTIN\\Administrators\" " ) )
    {
        output("FAILED\n");

        finish_global_MSI_logging();
        return 0;
    }
    else
    {
        output("DONE\n");
        output("\tSA Password: $randompass\n");
    }

	  #######################################################################
    # Adding SQL User                                                     #
    #######################################################################
	  output("Adding SQL User:\n");

    start_global_MSI_logging();

   my @queries = ( "CREATE LOGIN $username WITH PASSWORD = '$password'",
                 "CREATE USER $username FOR LOGIN $username",
                 "EXEC master..sp_addsrvrolemember \@loginame='smtkingdom', \@rolename='sysadmin'" );
   my @titles = ( "Creating SQL Login", "Creating SQL User", "Assigning User Role" );
   # Path isn't updated until the script restarts so we have to reference this
   my $sqlcmd = "C:\\Program Files\\Microsoft SQL Server\\100\\Tools\\Binn\\SQLCMD.EXE";

   foreach my $i (@queries)
   {
     output( "\t" . ( shift @titles ) . ":\t" );
     if( !run_command( "\"$sqlcmd\" -S .\\SMTKINGDOM -e -t 3 -l 5 -Q \"$i\"" ) )
     {
       output("\nQuery Execution FAILED\n");
     }
     else
     {
       output("DONE\n");
     }
    }
}


sub postinstall
{
    my $currentuser = $ENV{'public'}."\\desktop";

    ########################################################################
    # ActiveSetup action to copy .set file containing license info to user #
    # profile root.                                                        #
    ########################################################################

    if(!create_activesetup_action
    (
        'Identifier' =&gt; get_package_id(),
        'ComponentID' =&gt; get_package_id(),
        'Description' =&gt; 'Copy license info to user profile',
        'Version' =&gt; '1,0',
        'StubPath' =&gt; "c:\\sourcefiles\\kingdom.2015\\license.cmd",))
    {
        output("\n");
        output("ActiveSetup action unsuccessful.");
        output("\n");

        return 0;
    }

    my $LSHOST = $ENV{'LSHOST'};
    if( !defined($LSHOST) )
    {
        run_command("setx /m LSHOST kingdomsuite.lic.mst.edu");
    }
    elsif( $LSHOST !~ /kingdomsuite.lic.mst.edu/ )
    {
        run_command("setx /m LSHOST $LSHOST:kingdomsuite.lic.mst.edu:");
    }
    return 1;

}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);


IM_Exit(EXIT_SUCCESS);







# Begin-Doc
################################
# Name: install_KingdomSQL()
# Description: Do whatever is necessary to install and configure
#   SQL server needed by The Kingdom Suite 2015.
# Returns:
# Requires:
# LastUpdated:
# LastUpdatedBy:
################################
# End-Doc
sub install_KingdomSQL {

    # Invoke the IHS installer (wrapper for SQL Server Express)
    #   'setup.iss' was created the regular way (setup.exe /r)
    my $setup_dir = build_path(get_pkg_sourcefiles(),
                               'Web_SQLExpress',
                               'SupportFiles',
                               'SQLExpress');
    push_dir($setup_dir);
    my $outcome = installshield_install();

    pop_dir();
    return $outcome;
}
</Text>
  </Script>
  <Script>
    <Name>update-super-test.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\kingdom.2016_1\prod\update-super-test.pl</FullName>
    <Length>7866</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-13T14:07:43.8664749-05:00</CreationTime>
    <CreationTimeUtc>2017-06-13T19:07:43.8664749Z</CreationTimeUtc>
    <LastWriteTime>2016-09-01T14:09:40-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-09-01T19:09:40Z</LastWriteTimeUtc>
    <LastAccessTime>2016-09-01T14:04:28-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-09-01T19:04:28Z</LastAccessTimeUtc>
    <Text># Kingdom Suite 2016
# Package Created June 2016
# Daniel T. Holtzclaw

# Note:
# This package is a good example of why "The documentation is always wrong" is
# currently written on the DI whiteboard. Each of the Microsoft-based prereqs
# required manual download from MSDN and renaming, despite the fact the manual
# says these are unloaded when the msi is extracted.

# Only trust the install order of the prereqs in the manual.
# The proper installers have been renamed to match the manual in case someone
# decides to compare the install process to the manual.

# Three of the installers that DID come from the extraction are not listed
# in the manual.

# GUIDs, as grouped by the extractor:
# AppSight Installer: {6AFDAFE0-309E-424B-B15E-B78BF06C5C86}
# Kingdom Software Installer: {6D3F056B-7FA0-4602-94DB-BCED791DA961}
# Sam131,Sentinel,SSDCleanup,SSDCleanupx64:{E0C5CB65-E21A-4EE2-A1CE-10C724CA152C}

=pod

Begin-Doc
Modified: 11/30/2012
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: Kyle Knudsen
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'kingdom.2016',
        package_revision =&gt; '11062014T1146',
    );
}

use lib
(
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);

use InstallMonkey::Shared;
my $files = get_pkg_sourcefiles();
my $log_dir = '%SYSTEMDRIVE%\Windows\system32\UMRInst\AppLogs';
# Appsight will simply not write it's log there at all.
# my $appsight_log = '"C:\Windows\system32\UMRInst\AppLogs\kingdom_2016-Appsight.log"';

# "Key" (Can be sorted easily)
# =&gt; "Install command"
my %prereqs_installs = (
	"0 - .NET Framework 3.5 SP1"
		=&gt; "\"$files".'\dotnetfx35SP1.exe" "/q:a /C:"install /q /norestart" /norestart"',
	"1 - .NET Framework 4.0"
		=&gt; "\"$files".'\dotnetfx40\Setup.exe" /q /norestart /log ' . "\"$log_dir\\kingdom_2016-DotNETFX40.log\"",
	#"2 - SQL Server 2008 R2 Native Installer"
	#	=&gt; "msiexec.exe /i \"$files\\sqlncli_x64i.msi\" /quiet /log \"$log_dir\\kingdom_2016-SQL08_R2.log\" /norestart IACCEPTSQLNCLILICENSETERMS=Yes",
	"3 - SQL Server System CLR Types"
		=&gt; "msiexec.exe /i \"$files\\SQLSysClrTypes_amd64.msi\" /qn /log \"$log_dir\\kingdom_2016-SQL_Server_CLR_Types.log\" /norestart",
	"4 - SQL Server Management Objects"
		=&gt; "msiexec.exe /i \"$files\\SharedManagementObjects_amd64.msi\" /qn /log \"$log_dir\\kingdom_2016-SQL_Server_Management.log\" /norestart",
	#"5 - Sentinel Driver"
	#    =&gt; "start /wait \"$files\\Sentinel.exe\" /v/qn",
);

my %installs = (
	"0 - The Kingdom Software AppSight Installer"
		=&gt; "\"$files\\KingdomAppSightInstaller.exe\" /S /f1\"$files\\install.iss\"", # /f2$appsight_log",
	"1 - The Kingdom Software 2016 64-Bit"
		=&gt; "msiexec.exe /i \"$files\\tks_2016_64.msi\" /quiet /log \"$log_dir\\kingdom_2016-TKS.log\" /norestart",
);
################################################################################
################################################################################
sub preinstall {
	output("\nPreinstall phase: Installing The Kingdom Software Prerequisites\n\n");

	foreach my $key (sort keys %prereqs_installs) {
		output("$key:\n  " . $prereqs_installs{$key} . "\n  Result: ");
		my $success = run_command($prereqs_installs{$key});

		if ($success != 1) {
			output("Failed: $success $!\n");
			return 0;
		}
		output("Succeeded\n\n");
	}
	
	output("Preinstall succeeded.\n");
	return 1;
}

sub install {
	output("\nMain installs: \n\n");

	foreach my $key (sort keys %installs) {
		output("$key:\n  " . $installs{$key} . "\n  Result: ");
		my $success = run_command($installs{$key});

		if ($success != 1) {
			output("Failed: $success $!\n");
			return 0;
		}

		output("Succeeded\n\n");
	}
	output("Installs succeeded.\n");
	return 1;
}

sub postinstall
{
	my $username = "SMTKINGDOM";
	my $password = "\$ei\$micMicro";
	output("Configuring license server info: ");
	my $LSHOST = $ENV{'LSHOST'};
	if( !defined($LSHOST)) {
		run_command("setx /m LSHOST kingdomsuite.lic.mst.edu");
	}
	elsif( $LSHOST !~ /kingdomsuite.lic.mst.edu/) {
		run_command("setx /m LSHOST $LSHOST:kingdomsuite.lic.mst.edu:");
	}
	
	output("Installing SQL Server....................");
	start_global_MSI_logging();

	my @chars = ("A".."Z", "a".."z");
	my $randompass = "Ex4";
  my $hostname = $ENV{'COMPUTERNAME'};
	$randompass .= $chars[rand @chars] for 1..12;
  $randompass .= '!';
	if( !run_command( "\"$files\\SQL\\SQLEXPRWT_x64_ENU.exe\" /IACCEPTSQLSERVERLICENSETERMS /ACTION=install " .
			"/FEATURES=SQL,Tools " .
			"/INSTANCENAME=SMTKINGDOM /INSTANCEDIR=\"C:\\Program Files\\IHS\\KingdomSuite\" /QUIET /TCPENABLED=1 /NPENABLED=1 " .
			"/SQLSVCACCOUNT=\"NT AUTHORITY\\SYSTEM\" " .
			"/SECURITYMODE=SQL " .
			"/SAPWD=\"$randompass\" " .
			"/SQLSYSADMINACCOUNTS=\"$hostname\\Administrators\" ", 'IgnoreExitCodes' =&gt; [2226388992])) #, 'IgnoreExitCodes' =&gt; [1, 2226388992, 2227044356, 2226914596] ) )
	{
		output("FAILED\n");

		finish_global_MSI_logging();
		return 0;
	}
	else {
		output("DONE\n");
		output("\tSA Password: $randompass\n");
	}
	#######################################################################
	# Adding SQL User                                                     #
	#######################################################################
	output("Adding SQL User:\n");

	start_global_MSI_logging();

	my @queries = ( "CREATE LOGIN $username WITH PASSWORD = '$password'",
		"CREATE USER $username FOR LOGIN $username",
		"EXEC master..sp_addsrvrolemember \@loginame='smtkingdom', \@rolename='sysadmin'" );
	my @titles = ( "Creating SQL Login", "Creating SQL User", "Assigning User Role" );
	# Path isn't updated until the script restarts so we have to reference this
	my $sqlcmd = "C:\\Program Files\\Microsoft SQL Server\\100\\Tools\\Binn\\SQLCMD.EXE";

	foreach my $i (@queries) {
		output( "\t" . ( shift @titles ) . ":\t" );
		if( !run_command( "\"$sqlcmd\" -S .\\SMTKINGDOM -e -t 3 -l 5 -Q \"$i\"", 'IgnoreExitCodes' =&gt; [1] ) ) {
			output("\nQuery Execution FAILED\n");
		}
		else {
			output("DONE\n");
		}
	}
	
	#######################################################################
    # Installing Demos                                                    #
    #######################################################################

    output("Installing Demos.........................");
	my $demo_dir = "C:\\Kingdom Demo Projects";

    if(!run_command("robocopy \"$files\\Kingdom Demo Projects\" \"$demo_dir\" /E", 'IgnoreExitCodes' =&gt; [1, 2, 3])) {
		output("FAILED\n");
		finish_global_MSI_logging();
        return 0;
    }
    else {
		output("DONE\n");
    }
	# Add full control permissions for demo projects directory
    run_command("icacls \"$demo_dir\" /T /grant Users\:F");

    finish_global_MSI_logging();
	
=pod
	if(!run_command("DEL /F \"$get_allusers_desktop\\BMC Appsight for Windows Black Box.lnk\"")) {
		output("Could not delete BMC shortcut.\n");
		return 0;
	}
	
	if(!run_command("DEL /F \"$get_allusers_desktop\\The Kingdom Software 2016.lnk\"")) {
		output("Could not delete Kingdom shortcut.\n");
		return 0;
	}
=cut
	
	output("Done!");
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    need_reboot =&gt; 1,
);


IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\kingdom.2016_1\prod\update.pl</FullName>
    <Length>8907</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-13T14:07:43.913277-05:00</CreationTime>
    <CreationTimeUtc>2017-06-13T19:07:43.913277Z</CreationTimeUtc>
    <LastWriteTime>2017-06-13T16:50:11.5894531-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-13T21:50:11.5894531Z</LastWriteTimeUtc>
    <LastAccessTime>2016-08-31T09:44:33-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-08-31T14:44:33Z</LastAccessTimeUtc>
    <Text># Kingdom Suite 2016.1
# Package Created June 2017
# By Benjamin Krueger
# Note:
# This package is a good example of why "The documentation is always wrong" is
# currently written on the DI whiteboard. Each of the Microsoft-based prereqs
# required manual download from MSDN and renaming, despite the fact the manual
# says these are unloaded when the msi is extracted.

# Only trust the install order of the prereqs in the manual.
# The proper installers have been renamed to match the manual in case someone
# decides to compare the install process to the manual.

# Three of the installers that DID come from the extraction are not listed
# in the manual.

# GUIDs, as grouped by the extractor:
# AppSight Installer: {6AFDAFE0-309E-424B-B15E-B78BF06C5C86}
# Kingdom Software Installer: {6D3F056B-7FA0-4602-94DB-BCED791DA961}
# Sam131,Sentinel,SSDCleanup,SSDCleanupx64:{E0C5CB65-E21A-4EE2-A1CE-10C724CA152C}

=pod

Begin-Doc
Modified: 11/30/2012
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: Kyle Knudsen
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'kingdom.2016_1',
        package_revision =&gt; '06132017T0536',
    );
}

use lib
(
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);

use InstallMonkey::Shared;
my $files = get_pkg_sourcefiles();
my $log_dir = '%SYSTEMDRIVE%\Windows\system32\UMRInst\AppLogs';
# Appsight will simply not write it's log there at all.
my $appsight_log = '%SYSTEMDRIVE%\Windows\system32\UMRInst\AppLogs\kingdom_2016-Appsight.log"';

# "Key" (Can be sorted easily)
# =&gt; "Install command"
my %prereqs_installs = (
	"0 - .NET Framework 3.5 SP1"
		=&gt; "\"$files".'\dotnetfx35SP1.exe" "/q:a /C:"install /q /norestart" /norestart"',
	"1 - .NET Framework 4.0"
		=&gt; "\"$files".'\dotnetfx40\Setup.exe" /q /norestart /log ' . "\"$log_dir\\kingdom_2016-DotNETFX40.log\"",
	#"2 - SQL Server 2008 R2 Native Installer"
	#	=&gt; "msiexec.exe /i \"$files\\sqlncli_x64i.msi\" /quiet /log \"$log_dir\\kingdom_2016-SQL08_R2.log\" /norestart IACCEPTSQLNCLILICENSETERMS=Yes",
	"3 - SQL Server System CLR Types"
		=&gt; "msiexec.exe /i \"$files\\SQLSysClrTypes_amd64.msi\" /qn /log \"$log_dir\\kingdom_2016-SQL_Server_CLR_Types.log\" /norestart",
	"4 - SQL Server Management Objects"
		=&gt; "msiexec.exe /i \"$files\\SharedManagementObjects_amd64.msi\" /qn /log \"$log_dir\\kingdom_2016-SQL_Server_Management.log\" /norestart",
	#"5 - Sentinel Driver"
	#    =&gt; "start /wait \"$files\\Sentinel.exe\" /v/qn",
);

my %installs = (
	"0 - The Kingdom Software AppSight Installer"
		=&gt; "\"$files\\KingdomAppSightInstaller.exe\" /S /f1\"$files\\iss\\install.iss\" /V\"/L*vC:\\Windows\\system32\\umrinst\\applogs\\kingdom_2016-appsight.log\"",
	"1 - The Kingdom Software 2016 64-Bit"
		=&gt; "msiexec.exe /i \"$files\\tks_2016_64.msi\" /quiet /log \"$log_dir\\kingdom_2016-TKS.log\" /norestart",
);
################################################################################
################################################################################
sub preinstall {
	output("\nPreinstall phase: Installing The Kingdom Software Prerequisites\n\n");

	foreach my $key (sort keys %prereqs_installs) {
		output("$key:\n  " . $prereqs_installs{$key} . "\n  Result: ");
		my $success = run_command($prereqs_installs{$key});

		if ($success != 1) {
			output("Failed: $success $!\n");
			return 0;
		}
		output("Succeeded\n\n");
	}
	
	output("Preinstall succeeded.\n");
	return 1;
}

sub install {
	output("\nMain installs: \n\n");

	foreach my $key (sort keys %installs) {
		output("$key:\n  " . $installs{$key} . "\n  Result: ");
		my $success = run_command($installs{$key});

		if ($success != 1) {
			output("Failed: $success $!\n");
			return 0;
		}

		output("Succeeded\n\n");
	}
	output("Installs succeeded.\n");
	return 1;
}

sub postinstall
{
	my $username = "SMTKINGDOM";
	my $password = "\$ei\$micMicro";
	output("Configuring license server info: ");
	my $LSHOST = $ENV{'LSHOST'};
	if( !defined($LSHOST)) {
		run_command("setx /m LSHOST kingdomsuite.lic.mst.edu");
	}
	elsif( $LSHOST !~ /kingdomsuite.lic.mst.edu/) {
		run_command("setx /m LSHOST $LSHOST:kingdomsuite.lic.mst.edu:");
	}
	
output("Removing SQL Native Client.....");
    if(!run_command("MsiExec.exe /x {2180B33F-3225-423E-BBC1-7798CFD3CD1F} /qn /norestart", 'IgnoreExitCodes' =&gt; [1605]))
    {
        output("FAILED\n");
        return 0;
    }
    else
    {
        output("Success!\n");
    }
    #######################################################################
    # Installing SQL Server                                               #
    # http://www.seismicmicro.com/ProductReleaseDocumentation/KINGDOM/InstallationGuide.pdf
    # See: Creating and Configuring an SMTKINGDOM Instance                #
    # Mixed auth mode as Kingdom doesn't support windows auth             #
    #######################################################################

    output("Installing SQL Server....................");
    start_global_MSI_logging();

   my @chars = ("A".."Z", "a".."z");
   my $randompass = "Ex4";
   my $hostname = $ENV{'COMPUTERNAME'};
   $randompass .= $chars[rand @chars] for 1..12;
   $randompass .= '!';
   if( !run_command( "\"$files\\SQL\\SQLEXPRWT_X64_ENU.EXE\" /IACCEPTSQLSERVERLICENSETERMS /ACTION=INSTALL " .
                      "/FEATURES=SQL,TOOLS " .
                      "/INSTANCENAME=SMTKINGDOM /INSTANCEDIR=\"C:\\PROGRAM FILES\\IHS\\KINGDOMSUITE\" /QUIET /TCPENABLED=1 /NPENABLED=1 " .
                      "/SQLSVCACCOUNT=\"NT AUTHORITY\\SYSTEM\" " .
                      "/SECURITYMODE=SQL " .
                      "/SAPWD=\"$randompass\" " .
                      "/SQLSYSADMINACCOUNTS=\"$hostname\\ADMINISTRATORS\" ", 'IgnoreExitCodes' =&gt; [2226388992]) )
    {
        output("FAILED\n");

        finish_global_MSI_logging();
        return 0;
    }
    else
    {
        output("DONE\n");
        output("\tSA Password: $randompass\n");
    }

	#######################################################################
    # Adding SQL User                                                     #
    #######################################################################
	  output("Adding SQL User:\n");

    start_global_MSI_logging();

   my @queries = ( "CREATE LOGIN $username WITH PASSWORD = '$password'",
                 "CREATE USER $username FOR LOGIN $username",
                 "EXEC master..sp_addsrvrolemember \@loginame='smtkingdom', \@rolename='sysadmin'" );
   my @titles = ( "Creating SQL Login", "Creating SQL User", "Assigning User Role" );
   # Path isn't updated until the script restarts so we have to reference this
   my $sqlcmd = "C:\\Program Files\\Microsoft SQL Server\\100\\Tools\\Binn\\SQLCMD.EXE";

   foreach my $i (@queries)
   {
     output( "\t" . ( shift @titles ) . ":\t" );
     if( !run_command( "\"$sqlcmd\" -S .\\SMTKINGDOM -e -t 3 -l 5 -Q \"$i\"", 'IgnoreExitCodes' =&gt; [1]  ) )
     {
       output("\nQuery Execution FAILED\n");
     }
     else
     {
       output("DONE\n");
     }
    }
	
	#######################################################################
    # Installing Demos                                                    #
    #######################################################################

    output("Installing Demos.........................");
	my $demo_dir = "C:\\Kingdom Demo Projects";

    if(!run_command("robocopy \"$files\\Kingdom Demo Projects\" \"$demo_dir\" /E", 'IgnoreExitCodes' =&gt; [1, 2, 3])) {
		output("FAILED\n");
		finish_global_MSI_logging();
        return 0;
    }
    else {
		output("DONE\n");
    }
	# Add full control permissions for demo projects directory
    run_command("icacls \"$demo_dir\" /T /grant Users\:F");

    finish_global_MSI_logging();
	
=pod
	if(!run_command("DEL /F \"$get_allusers_desktop\\BMC Appsight for Windows Black Box.lnk\"")) {
		output("Could not delete BMC shortcut.\n");
		return 0;
	}
	
	if(!run_command("DEL /F \"$get_allusers_desktop\\The Kingdom Software 2016.lnk\"")) {
		output("Could not delete Kingdom shortcut.\n");
		return 0;
	}
=cut
	
	output("Done!");
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    need_reboot =&gt; 1,
);


IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\kingdom.2016_1_new\prod\update.pl</FullName>
    <Length>9135</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-20T08:21:58.2529933-05:00</CreationTime>
    <CreationTimeUtc>2017-06-20T13:21:58.2529933Z</CreationTimeUtc>
    <LastWriteTime>2017-09-12T13:00:27.0182586-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-09-12T18:00:27.0182586Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-20T08:21:58.2529933-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-20T13:21:58.2529933Z</LastAccessTimeUtc>
    <Text># Kingdom Suite 2016.1
# Package Created June 2017
# By Benjamin Krueger
# Last updated 6/20/2017 by Sergey Gruzdev
# Note:
# This package is a good example of why "The documentation is always wrong" is
# currently written on the DI whiteboard. Each of the Microsoft-based prereqs
# required manual download from MSDN and renaming, despite the fact the manual
# says these are unloaded when the msi is extracted.

# Only trust the install order of the prereqs in the manual.
# The proper installers have been renamed to match the manual in case someone
# decides to compare the install process to the manual.

# Three of the installers that DID come from the extraction are not listed
# in the manual.

# GUIDs, as grouped by the extractor:
# AppSight Installer: {6AFDAFE0-309E-424B-B15E-B78BF06C5C86}
# Kingdom Software Installer: {6D3F056B-7FA0-4602-94DB-BCED791DA961}
# Sam131,Sentinel,SSDCleanup,SSDCleanupx64:{E0C5CB65-E21A-4EE2-A1CE-10C724CA152C}

=pod

Begin-Doc
Modified: 11/30/2012
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: Kyle Knudsen
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'kingdom.2016_1',
        package_revision =&gt; '06202017T0818',
    );
}

use lib
(
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);

use InstallMonkey::Shared;
my $files = get_pkg_sourcefiles();
my $log_dir = '%SYSTEMDRIVE%\Windows\system32\UMRInst\AppLogs';
# Appsight will simply not write it's log there at all.
my $appsight_log = '%SYSTEMDRIVE%\Windows\system32\UMRInst\AppLogs\kingdom_2016-Appsight.log"';

# "Key" (Can be sorted easily)
# =&gt; "Install command"
my %prereqs_installs = (
	"0 - .NET Framework 3.5 SP1"
		=&gt; "\"$files".'\dotnetfx35SP1.exe" "/q:a /C:"install /q /norestart" /norestart"',
	"1 - .NET Framework 4.0"
		=&gt; "\"$files".'\dotnetfx40\Setup.exe" /q /norestart /log ' . "\"$log_dir\\kingdom_2016-DotNETFX40.log\"",
	#"2 - SQL Server 2008 R2 Native Installer"
	#	=&gt; "msiexec.exe /i \"$files\\sqlncli_x64i.msi\" /quiet /log \"$log_dir\\kingdom_2016-SQL08_R2.log\" /norestart IACCEPTSQLNCLILICENSETERMS=Yes",
	"3 - SQL Server System CLR Types"
		=&gt; "msiexec.exe /i \"$files\\SQLSysClrTypes_amd64.msi\" /qn /log \"$log_dir\\kingdom_2016-SQL_Server_CLR_Types.log\" /norestart",
	"4 - SQL Server Management Objects"
		=&gt; "msiexec.exe /i \"$files\\SharedManagementObjects_amd64.msi\" /qn /log \"$log_dir\\kingdom_2016-SQL_Server_Management.log\" /norestart",
	#"5 - Sentinel Driver"
	#    =&gt; "start /wait \"$files\\Sentinel.exe\" /v/qn",
);

my %installs = (
	"0 - The Kingdom Software AppSight Installer"
		=&gt; "\"$files\\KingdomAppSightInstaller.exe\" /S /f1\"$files\\iss\\install.iss\" /V\"/L*vC:\\Windows\\system32\\umrinst\\applogs\\kingdom_2016-appsight.log\"",
	"1 - The Kingdom Software 2016 64-Bit"
		=&gt; "msiexec.exe /i \"$files\\tks_2016_64.msi\" /quiet /log \"$log_dir\\kingdom_2016-TKS.log\" /norestart",
);
################################################################################
################################################################################
sub preinstall {
	output("\nPreinstall phase: Installing The Kingdom Software Prerequisites\n\n");
	open(FILE, "&gt;\"$files\"\\file.txt");
	print FILE "foobar :D\n";
	close(FILE);

	foreach my $key (sort keys %prereqs_installs) {
		output("$key:\n  " . $prereqs_installs{$key} . "\n  Result: ");
		my $success = run_command($prereqs_installs{$key});

		if ($success != 1) {
			output("Failed: $success $!\n");
			return 0;
		}
		output("Succeeded\n\n");
	}
	
	output("Preinstall succeeded.\n");
	return 1;
}

sub install {
	output("\nMain installs: \n\n");

	foreach my $key (sort keys %installs) {
		output("$key:\n  " . $installs{$key} . "\n  Result: ");
		my $success = run_command($installs{$key});

		if ($success != 1) {
			output("Failed: $success $!\n");
			return 0;
		}

		output("Succeeded\n\n");
	}
	output("Installs succeeded.\n");
	return 1;
}

sub postinstall
{
	my $username = "SMTKINGDOM";
	my $password = "\$ei\$micMicro";
	output("Configuring license server info: ");
	my $LSHOST = $ENV{'LSHOST'};
	if( !defined($LSHOST)) {
		run_command("setx /m LSHOST kingdomsuite.lic.mst.edu");
	}
	elsif( $LSHOST !~ /kingdomsuite.lic.mst.edu/) {
		run_command("setx /m LSHOST $LSHOST:kingdomsuite.lic.mst.edu:");
	}
	
output("Removing SQL Native Client.....");
    if(!run_command("MsiExec.exe /x {2180B33F-3225-423E-BBC1-7798CFD3CD1F} /qn /norestart", 'IgnoreExitCodes' =&gt; [1605]))
    {
        output("FAILED\n");
        return 0;
    }
    else
    {
        output("Success!\n");
    }
    #######################################################################
    # Installing SQL Server                                               #
    # http://www.seismicmicro.com/ProductReleaseDocumentation/KINGDOM/InstallationGuide.pdf
    # See: Creating and Configuring an SMTKINGDOM Instance                #
    # Mixed auth mode as Kingdom doesn't support windows auth             #
    #######################################################################

    output("Installing SQL Server....................");
    start_global_MSI_logging();

   my @chars = ("A".."Z", "a".."z");
   my $randompass = "Ex4";
   my $hostname = $ENV{'COMPUTERNAME'};
   $randompass .= $chars[rand @chars] for 1..12;
   $randompass .= '!';
   if( !run_command( "\"$files\\SQL\\SQLEXPRWT_X64_ENU.EXE\" /IACCEPTSQLSERVERLICENSETERMS /ACTION=INSTALL " .
                      "/FEATURES=SQL,TOOLS " .
                      "/INSTANCENAME=SMTKINGDOM /INSTANCEDIR=\"C:\\PROGRAM FILES\\IHS\\KINGDOMSUITE\" /QUIET /TCPENABLED=1 /NPENABLED=1 " .
                      "/SQLSVCACCOUNT=\"NT AUTHORITY\\SYSTEM\" " .
                      "/SECURITYMODE=SQL " .
                      "/SAPWD=\"$randompass\" " .
                      "/SQLSYSADMINACCOUNTS=\"$hostname\\ADMINISTRATORS\" ", 'IgnoreExitCodes' =&gt; [2226388992]) )
    {
        output("FAILED\n");

        finish_global_MSI_logging();
        return 0;
    }
    else
    {
        output("DONE\n");
        output("\tSA Password: $randompass\n");
    }

	#######################################################################
    # Adding SQL User                                                     #
    #######################################################################
	  output("Adding SQL User:\n");

    start_global_MSI_logging();

   my @queries = ( "CREATE LOGIN $username WITH PASSWORD = '$password'",
                 "CREATE USER $username FOR LOGIN $username",
                 "EXEC master..sp_addsrvrolemember \@loginame='smtkingdom', \@rolename='sysadmin'" );
   my @titles = ( "Creating SQL Login", "Creating SQL User", "Assigning User Role" );
   # Path isn't updated until the script restarts so we have to reference this
   my $sqlcmd = "C:\\Program Files\\Microsoft SQL Server\\100\\Tools\\Binn\\SQLCMD.EXE";

   foreach my $i (@queries)
   {
     output( "\t" . ( shift @titles ) . ":\t" );
     if( !run_command( "\"$sqlcmd\" -S .\\SMTKINGDOM -e -t 3 -l 5 -Q \"$i\"", 'IgnoreExitCodes' =&gt; [1]  ) )
     {
       output("\nQuery Execution FAILED\n");
     }
     else
     {
       output("DONE\n");
     }
    }
	
	#######################################################################
    # Installing Demos                                                    #
    #######################################################################

    output("Installing Demos.........................");
	my $demo_dir = "C:\\Kingdom Demo Projects";

    if(!run_command("robocopy \"$files\\Kingdom Demo Projects\" \"$demo_dir\" /E", 'IgnoreExitCodes' =&gt; [1, 2, 3])) {
		output("FAILED\n");
		finish_global_MSI_logging();
        return 0;
    }
    else {
		output("DONE\n");
    }
	# Add full control permissions for demo projects directory
    if(!run_command("icacls \"$demo_dir\" /T /grant Users:(OI)(CI)W"))
	{
	  print "Error: failed to grant permissions!\n";
	}

    finish_global_MSI_logging();
	
	print "Deleting desktop shortcuts...\n";
	
	if(!run_command("DEL /F \"".get_allusers_desktop()."\\BMC Appsight for Windows Black Box.lnk\"")) {
		output("Could not delete BMC shortcut.\n");
	}	
	if(!run_command("DEL /F \"".get_allusers_desktop()."\\The Kingdom Software 2016.lnk\"")) {
		output("Could not delete Kingdom shortcut.\n");
	}
	
	output("Done!");
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    need_reboot =&gt; 1,
);


IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\kingdom.2017\prod\update.pl</FullName>
    <Length>4988</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-12-04T16:58:27.1073771-06:00</CreationTime>
    <CreationTimeUtc>2017-12-04T22:58:27.1073771Z</CreationTimeUtc>
    <LastWriteTime>2017-12-14T09:31:26.9915608-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-12-14T15:31:26.9915608Z</LastWriteTimeUtc>
    <LastAccessTime>2017-12-04T16:58:27.1073771-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-12-04T22:58:27.1073771Z</LastAccessTimeUtc>
    <Text># Kingdom Suite 2017
# Package Created November 11, 2017
# Last updated 11/28/2017 by Sergey Gruzdev
# Note (from Kingdom 2016.1):
# This package is a good example of why "The documentation is always wrong" is
# currently written on the DI whiteboard. Each of the Microsoft-based prereqs
# required manual download from MSDN and renaming, despite the fact the manual
# says these are unloaded when the msi is extracted.

# Only trust the install order of the prereqs in the manual.
# The proper installers have been renamed to match the manual in case someone
# decides to compare the install process to the manual.

# Five of the installers that DID come from the extraction are not listed
# in the manual (Sam131, SSDCleanup, SSDCleanupx64, vcredist2010SP1_x64, vcredist2012Update4_x64)

=pod

Begin-Doc
Modified: 11/30/2012
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: Kyle Knudsen
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'kingdom.2017',
        package_revision =&gt; '11282017T1250',
    );
}

use lib
(
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);

use InstallMonkey::Shared;
my $src = get_pkg_sourcefiles();
my $installdir = 'C:\\Program Files\\IHS Markit\\KingdomSuite';
my $log_dir = '%SYSTEMDRIVE%\\Windows\\system32\\UMRInst\\AppLogs';

sub preinstall
{
  print "Installing prerequisites..\n";
  my $return = 0;
  print "=VC Redist 2010 SP1 x64: ";
  # vcredist 2010 SP1
  if(!run_command("$src\\vcredist2012Update4_x64 /q /norestart"))
  {
    
    print "FAILED\n";
	return 0;
  }
  print "Success\n";
  # vcredist 2012 Updated 4
  print "=VC Redist 2012 U4 x64: ";
  if(!run_command("$src\\vcredist2012Update4_x64.exe /q /norestart"))
  {
    print "FAILED\n";
	return 0;
  }
  print "Success\n";
  # .NET 3.5 SP1
  print "=.NET 3.5 SP1: ";
  if(!run_command("$src\\dotnetfx35setup.exe /q /norestart"))
  {
    print "FAILED\n";
	return 0;
  }
  print "Success\n";
  # .NET 4.5.2
  print "=.NET 4.5.2: ";
  if(!run_command("$src\\NDP452-KB2901907-x86-x64-AllOS-ENU.exe /q /norestart"))
  {
    print "FAILED\n";
	return 0;
  }
  print "Success\n";
  # SQL Server 2008 R2 Native Client 10.50.1600.1 x64
  print "=SQL Server 2008 R2 Native Client x64: ";
  if(!run_command("msiexec /i $src\\sqlncli.msi /qn", IgnoreExitCodes =&gt; [1603]))
  {
    print "FAILED\n";
	return 0;
  }
  print "Success\n";
  # SQL Server Management Objects 10.00.2531 x64
  print "=SQL Server 2008 R2 Management Objects x64: ";
  if(!run_command("msiexec /i $src\\SharedManagementObjects.msi /qn", IgnoreExitCodes =&gt; [1603]))
  {
    print "FAILED\n";
	return 0;
  }
  print "Success\n";
  # SQL Server System CLR Types 10.00.2531 x64
  print "=SQL Server 2008 R2 System CLR Types x64: ";
  if(!run_command("msiexec /i $src\\SQLSysClrTypes.msi /qn", IgnoreExitCodes =&gt; [1603]))
  {
    print "FAILED\n";
	return 0;
  }
  print "Success\n";
  # SSDCleanup x64
  print "=SSD Cleanup x64: ";
  if(!run_command("$src\\SSDCleanupx64.exe -q"))
  {
    print "FAILED\n";
	return 0;
  }
  print "Success\n";
  print "Ready for installation!\n";
  return 1;
}

sub postinstall
{
  # Install geosyn
  if(!run_command("msiexec /i $src\\IHSMarkitGeoSyn2017.msi /qn"))
  {
    print "Error installing GeoSYN!\n";
	return 0;
  }
  # Sam131
  print "=Sam131: ";
  run_command("mkdir \"$installdir\\Sam131\"");
  if(!run_command("xcopy $src\\Sam131 \"$installdir\\Sam131\" /I /E /Q /Y"))
  {
    print "FAILED\n";
	return 0;
  }
  print "Success\n";
  # Configure license server info
  print "Configuring license info...\n";
  my $username = "SMTKINGDOM";
  my $password = "\$ei\$micMicro";
  output("Configuring license server info: ");
  my $LSHOST = $ENV{'LSHOST'};
  if( !defined($LSHOST))
  {
  	run_command("setx /m LSHOST kingdomsuite.lic.mst.edu");
  }
  elsif( $LSHOST !~ /kingdomsuite.lic.mst.edu/)
  {
    run_command("setx /m LSHOST $LSHOST:kingdomsuite.lic.mst.edu:");
  }
  
  # Delete shortcuts
  print "Deleting shortcuts...\n";
  run_command("del \"C:\\Users\\Public\\Desktop\\GeoSyn 2017.lnk\"");
  run_command("del \"C:\\Users\\Public\\Desktop\\GeoSyn2D 2017.lnk\"");
  run_command("del \"C:\\Users\\Public\\Desktop\\The Kingdom Software 2017.lnk\"");
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    preinstall_sub =&gt; \&amp;preinstall,
	msi_name =&gt; "TheKingdomSoftware2017.msi",
	postinstall_sub =&gt; \&amp;postinstall,
    need_reboot =&gt; 1,
);


IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\kingdom.2018\prod\update.pl</FullName>
    <Length>4203</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-18T09:32:07.6033429-05:00</CreationTime>
    <CreationTimeUtc>2018-06-18T14:32:07.6033429Z</CreationTimeUtc>
    <LastWriteTime>2018-06-20T10:38:22.7880611-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-20T15:38:22.7880611Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-18T09:32:07.6814584-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-18T14:32:07.6814584Z</LastAccessTimeUtc>
    <Text># Kingdom 2017
# Package Created June 2018
# Packaged by Alex Schrimpf

=pod

Begin-Doc
Modified: 
Name: 
Type:
Description: 
Language: Perl
LastUpdatedBy:
Version:
Doc-Package-Info
Doc-SVN-Repository:
RCSId:
End-Doc

=cut

use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'Kingdom.2018',
        package_revision =&gt; '',
    );
}

use lib ( '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 'C:\temp' );

use InstallMonkey::Shared;

my $KINGDOM_HOSTNAME = "kingdomsuite.lic.mst.edu";

use Data::Dumper;

use IM_helper(
    \%INSTALLMONKEY_OPTIONS,
    v5.01,
    (
        "INSTALL" =&gt; [
            sub {
                return 0 unless IM_helper::run_command(
                    command=&gt; "start \"Kingdom Installer\" \"$IM_helper::source_files\\The Kingdom Software 2018 (64-bit).exe\"",
                    description=&gt; "Kingdom installer"
                );

                my @page_keys = (
                    "Next",
                    "Next",
                    "Install"
                );

                while(!IM_helper::get_windows(
                    title=&gt;'The Kingdom Software 2018 (64-bit)',
                    succ_cb=&gt;sub{
                        my @window_ids = @{{@_}-&gt;{results}};
                        foreach my $pk (@page_keys){
                            return 0 unless IM_helper::send_keys_to_window(
                                window=&gt;$window_ids[0],
                                keys=&gt; $pk
                            );    
                            sleep(1);                  
                        }
                        return 1;
                    }
                )){
                    sleep(5);
                }

                IM_helper::flush_msg(msg=&gt;"Waiting for installer to finish...");
                while(!IM_helper::get_install_locations(
                    display_name=&gt; "The Kingdom Software 2018 (64-bit)",
                    quiet=&gt;1
                )){
                    sleep(5);
                }
                IM_helper::flush_msg(msg=&gt;"Done");

                while(!IM_helper::get_windows(
                        title=&gt;'The Kingdom Software 2018 (64-bit)',
                        succ_cb=&gt;sub{
                            my @window_ids = @{{@_}-&gt;{results}};
                            return IM_helper::send_keys_to_window(
                                window=&gt;$window_ids[0],
                                keys=&gt;"{TAB}{SPACE}"
                            );
                        }
                    )){
                    sleep(5);
                };

                return 1;
            }
        ],
        "LICENSE" =&gt; [
            sub {
                IM_helper::push_to_system_var(
                    name=&gt;"LSHOST",
                    value=&gt;$KINGDOM_HOSTNAME
                )
            }
        ],
        "UNINSTALL" =&gt; [
          sub {
            IM_helper::get_uninstall_strings(
                    display_name=&gt;"The Kingdom Software 2018 (64-bit)",
                    succ_cb=&gt;sub{
                        if(!exists({@_}-&gt;{x86})){
                            return 0;
                        }
                        return IM_helper::run_command(
                            command=&gt;"@{{@_}-&gt;{x86}} /qn",
                            description=&gt;"Kingdom Uninstaller"
                        );
                    }
            );
          }
        ]
    )
);

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt;
      [ 'clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    no_install_check =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    no_product_key =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    install_sub =&gt; $IM_helper::exec_call_stack_override || sub{IM_helper::exec_call_stacks(ids=&gt;["INSTALL","LICENSE"])}
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\labstats.5_2_30303_134\dev\update.pl</FullName>
    <Length>2195</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-04-28T15:23:02.6348358-05:00</CreationTime>
    <CreationTimeUtc>2017-04-28T20:23:02.6348358Z</CreationTimeUtc>
    <LastWriteTime>2017-08-03T10:54:55.5243099-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-08-03T15:54:55.5243099Z</LastWriteTimeUtc>
    <LastAccessTime>2017-04-28T15:55:19.8332889-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-04-28T20:55:19.8332889Z</LastAccessTimeUtc>
    <Text># LabStats 5.2.30303.134
# Package Created 2013-11-13
# Packaged by Joshua Hertlein
# Last Updated 2013-11-13
# Updated by Alex Schrimpf

=pod

Begin-Doc
Modified: $Date$
Name: $Name$
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'labstats.5_2_30303_134',
        package_revision =&gt; '20131113T1540',
    );
}


use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);


use InstallMonkey::Shared;
use Getopt::Long;

my $sourcefilesdir = get_pkg_sourcefiles();
my $applog = get_default_app_log();

######
GetOptions(
    'uninstall' =&gt; sub { exit(!uninstall()); },
) || die "Usage: $!";
######

sub uninstall
{
	my @command = (
		   'msiexec.exe', '/uninstall', cmd_quote(build_path($sourcefilesdir, 'LabStatsMSIWrapper.msi')),
		   '/quiet', #'/LOG="$applog\$log"',
		);
	my $success = run_command(join(' ',@command));

	if ($success)
	{
		output("Removing leftover folder in Program Files (x86)\n");
		run_command("rmdir /q /s \"\%programfiles(x86)\%\\Mathcad\\\"");
		output("Removing registry key.\n");
		delete_product_registry_key('labstats.5_2_30303_134');
		output("LabStats 5.2 removed successfully!");
		return 1;
	}
	else
	{
		output("Issue removing LabStats 5.2: $!");
		return 0;
	}
}

sub install
{
    my $installer = build_path(get_pkg_sourcefiles(),"LabStatsMSIWrapper.msi");

    output("   Labstats: ");
    my $outcome =
        install_msi(
            msi =&gt; $installer
        );
    output(($outcome?"SUCCESS":"FAILURE")."\n");
    
    return $outcome;
};

do_install( 
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
    allowed_os_architectures =&gt; [ OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 
                     'virtual-desktop'],
    exit_on_failure =&gt; 1,
	install_sub =&gt; \&amp;install
);


IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\labstats.7_17_706_0\prod\update.pl</FullName>
    <Length>1988</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-09-05T10:09:47.694962-05:00</CreationTime>
    <CreationTimeUtc>2017-09-05T15:09:47.694962Z</CreationTimeUtc>
    <LastWriteTime>2018-07-24T08:29:37.4372648-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-24T13:29:37.4372648Z</LastWriteTimeUtc>
    <LastAccessTime>2017-09-05T10:09:47.694962-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-09-05T15:09:47.694962Z</LastAccessTimeUtc>
    <Text># LabStats 5.2.30303.134
# Package Created 2017-08-05
# Packaged by Ryan Andrews

=pod

Begin-Doc
Modified: $Date$
Name: $Name$
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'labstats.7_17_706_0',
        package_revision =&gt; '20170805T1012',
    );
}


use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);


use InstallMonkey::Shared;
use Getopt::Long;

use Win32::TieRegistry(Delimiter=&gt;'/');

my $sourcefilesdir = get_pkg_sourcefiles();
my $applog = get_default_app_log();
#new stuff
my $src = get_pkg_sourcefiles();

sub install
{
    my $installer = build_path(get_pkg_sourcefiles(),"LabStatsGO-7.17.706.0.msi");

    output("   Labstats: ");
    my $outcome = install_msi(
                    msi =&gt; $installer,
                    additional_msi_properties =&gt; 'STARTSERVICE=1'
                  );
    $outcome = $outcome &amp;&amp; $Registry-&gt;{'HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Services/LabStatsGo/'}-&gt;SetValue("DelayedAutoStart"=&gt;["0x0001",'REG_DWORD']);
    output(($outcome ? "SUCCESS" : "FAILURE") . "\n");

#old spot

#new fix for registry key supplied after the deadline
{ output("Running registry fix: "); }
if(!run_command("\"$src\\LabStatsRegistryUpdate.bat")) {
  output("FAILED: $!\n");
  return 0;
}
{ output("OK\n"); }

#new spot for thing
return $outcome;


};

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [ 'clc', 'desktop', 'traveling', 'virtual-clc',
                     'virtual-desktop' ],
    exit_on_failure =&gt; 1,
	install_sub =&gt; \&amp;install
);


IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\labview.2015\dev\update.pl</FullName>
    <Length>20891</Length>
    <Extension>.pl</Extension>
    <CreationTime>2015-11-30T14:59:23.1870479-06:00</CreationTime>
    <CreationTimeUtc>2015-11-30T20:59:23.1870479Z</CreationTimeUtc>
    <LastWriteTime>2015-12-10T13:55:27.5271538-06:00</LastWriteTime>
    <LastWriteTimeUtc>2015-12-10T19:55:27.5271538Z</LastWriteTimeUtc>
    <LastAccessTime>2015-11-30T14:59:23.1870479-06:00</LastAccessTime>
    <LastAccessTimeUtc>2015-11-30T20:59:23.1870479Z</LastAccessTimeUtc>
    <Text># LabVIEW 2015
# Package Created November 2015
# Package created by Dzu Pham


# This package was request to be installed with minimal amount of addons
# Labview 2015
# NI-system configuration 15
# NI-daqmx 15.0
# NI-ELVISmx 15.0

# Create a specfile to do the install of Labview
# This means you need to do a /generatespcefile and updaet it on appdeploy

=pod

Begin-Doc
Modified: $Date$
Name: LabVIEW 2015 Installer
Type: script
Description: Refer to top explanation.
    For specialized installations, new specfiles will need to be generated.
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

$|=1;
use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'labview.2015',
        package_revision =&gt; '20151130T0800',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

use File::Temp qw(tempfile tempdir);
use File::Copy;
use File::Basename;
use File::Path qw(remove_tree);
use Win32;
use XML::Simple;
use Encode;
use Archive::Extract;
use Time::HiRes qw(gettimeofday tv_interval);
use JSON;
use Data::Dumper;

my $srcfiledir = get_pkg_sourcefiles();
my $sourceshare = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\labview_2015";

##############################################################################
# BEGIN Configuration

# The /generatespecfile flag doesn't do any dependency checking! It will
#   let you select items that will cause the install to fail.
# Run setup.exe interactively (no flag) to verify that a set of components
#   to install is valid.
#   Example:
#      The FPGA components require the Xilinx compiler (which I don't think
#        we have.
#
#      The "Visual Studio Integration" components require something to be
#        (pre)installed before they are installable. (DeviceDrivers)

# component_count is used in the validation phase to determine if the
#   expected number of components is installed.
my %specs = (
    'default' =&gt; {
        'labview' =&gt; 'MST.labview.specs',
        #'drivers' =&gt; 'MST.devicedrivers.specs',

        'updates' =&gt; 'MST.updates.json',
        'component_count'   =&gt; 5, # manually calculated after an install
    },
);
my $install_profile = 'default'; # configurable via command-line

my $flexlm_license_path = 'labview.lic.mst.edu:27001';

my $licutil = build_path(get_arch_programfiles(OSARCH_x86),
                         'National Instruments', 'Shared',
                         'License Manager', 'Bin',
                         'nilmUtil.exe');

my %shortcuts_to_move = (
    # We usually don't want Desktop icons, ever.
    # In this case, there's no StartMenu icon. move it to the NI folder.
    build_path(get_allusers_desktop(),'NI MAX.lnk') =&gt;
        build_path(get_allusers_start_menu(),'Programs',
                   'National Instruments','NI MAX.lnk'),

);

my @shortcuts_to_delete = (
);

my $install_results = get_default_app_log();
$install_results =~ s/\.txt$/_results.txt/i;


my $updates_dir = 'updates';

# Serial: M63X12479

# A number of components need a reboot in order to be fully complete.
# The WTG/TS data should include a reboot or a reboot+delay+reboot.

# The update service wants a firewall exception.

# END Configuration
##############################################################################

my $skip_updates = 0; # allow for the possibility of skipping the updates.

my $cwd = cwd();
my $isSccmInstall = 0;

##############################################################################
# Check to see if it's being installed by SCCM (package files are
#   currently in cache folder).
# If so, change isSccmInstall to true to use for no_source_files value
#   &amp; preinstall.
##############################################################################
my @splitPath = split(/\\/,$cwd);

# This could be smarter. Have it check to see if the cwd and srcfiles are
#   on the same drive.
if(lc $splitPath[0] eq "c:"){
    $isSccmInstall = 1;
}

use Getopt::Long;
sub usage {
    print qq(
usage: $0 [--help] [--validate] [--preinstall] [--install] [--updates] [--postinstall]

);
}
GetOptions(
    'help' =&gt; sub { usage(); exit(0); },

    'prerequisites' =&gt; sub { exit(! prereq_sub()); },
    'preinstall' =&gt; sub { exit(! preinstall()); },
    'install' =&gt; sub { exit(! install()); },
    'updates' =&gt; sub { exit(! install_updates()); },
    'postinstall' =&gt; sub { exit(! postinstall()); },
    'validate' =&gt; sub { exit(! validate_install()); },

    'skip-updates' =&gt; \$skip_updates,
);
if ($skip_updates) {
    output("Skipping update installation.\n");
}


do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; [qw(clc desktop traveling virtual-clc virtual-desktop)],
    exit_on_failure =&gt; 1,
    no_source_files =&gt; $isSccmInstall,
    #prerequisite_sub =&gt; \&amp;prereq_sub, # Refer to labview 2014 if you need to check disk space
    #preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    validate_sub =&gt; \&amp;validate_install,
);

# Warn for reboot if we have gotten to completion - maybe a little overboard
#if ($need_reboot) {
#    output("**THIS PACKAGE REQUIRES A REBOOT BEFORE USE**\n");
#}

IM_Exit(EXIT_SUCCESS);

########################################################################
########################################################################
########################################################################

sub install {
    my ($fh,$temp_logfile,$temp_results,@command,@output,$logfile,$outcome);

    ######################################################################
    # Install the actual LabVIEW 2015 software using a specfile (default
    #   settings) also disabling the update notifications.
    ######################################################################

    ($fh,$temp_logfile) = tempfile('LabviewInstall_install_XXXXXXXX',
                                   DIR =&gt; $ENV{TEMP},
                                   SUFFIX =&gt; '.log');
    close($fh);

    ($fh,$temp_results) = tempfile('LabviewInstall_results_XXXXXXXX',
                                   DIR =&gt; $ENV{TEMP},
                                   SUFFIX =&gt; '.txt');
    close($fh);


    my $command = join(' ',
        build_path($sourceshare,'setup.exe'),
        '/q',
        '/AcceptLicenses', 'yes',
        '/r:n',
        '/log', sprintf('"%s"',$temp_logfile),
        '/results', sprintf('"%s"',$temp_results),
        '/applyspecfile', build_path($sourceshare),
        '/disableNotificationCheck',
        );

    output("   Installing LabVIEW 2015: ");
    $outcome = run_command($command, IgnoreExitCodes =&gt; [3010] );

    output(($outcome?'OK':'FAILED')."\n");

    # Copy the log files.
    $logfile = get_default_app_log();
    output("   Copying (Install) '${temp_logfile}' =&gt; '${logfile}'\n",
           LOG_ONLY);
    copy($temp_logfile,$logfile);
    output("   Copying (Results) '${temp_results}' =&gt; '${install_results}'\n",
           LOG_ONLY);
    copy($temp_results,$install_results);

    # Additional log file dir.
    # The subcomponents that get installed create logs here.
    #   They appear to be named '&lt;component&gt;.txt'.
    my $addl_logs_dir = $temp_logfile.'_additionalLogs';
    if (-d $addl_logs_dir) {
        if (opendir(my $ADDLLOGS,$addl_logs_dir)) {
            while (my $logfile = readdir($ADDLLOGS)) {
                next if ($logfile =~ /^\.?\.$/);

                my $source = build_path($addl_logs_dir,$logfile);

                my $target = get_default_app_log();
                $logfile =~ s/\.txt$//i; # strip the extension
                $target =~ s/\.txt$/__${logfile}.txt/i;

                output("   Copying (Addl) '${source}' =&gt; '${target}'\n", LOG_ONLY);
                if (!copy($source,$target)) {
                    output("  ERROR: $!\n",LOG_ONLY);
                }
            }
            closedir($ADDLLOGS);
        } else {
            output("Error opening additional logs dir '${addl_logs_dir}': $!\n",
                   LOG_ONLY);
        }
    }

    # Attempt to install any updates in the 'updates' directory.
    # Failure to update should not be a condition of "successful" installation.
    #   (Depending on the instal profile, some updates may not even apply).
    #install_updates();

    return $outcome;
}

#
# I used the NI Update Service to download these updates, all of which are
#   .ZIP archives.
# The service downloads them to:
#    %ProgramData%\National Instruments\Update Service\Installers
#   They are ZIP archives (though the filename extension doesn't say so).
# Anecdotal experience suggests that these updates can be re-applied more
#   than once.
# Updates for locally-licensed features are not detected until the local
#   licenses are activated (maybe?).
sub install_updates {
    # Each update is compressed.
    # Unpack and install each one.

    if ($skip_updates) {
        output("   Installing Updates SKIPPED.\n");
        return 1;
    }

    output("   Installing Updates:\n");
    my $_updates_dir = build_path($srcfiledir,$updates_dir);
    if (! -d $_updates_dir) {
        output("     No updates to install.\n");
        return 1;
    }

    # Get the metadata file.
    my $updates;
    eval {
        my $json_file = build_path($_updates_dir,
                                   $specs{$install_profile}-&gt;{updates});
        output("   Updates Metadata: ${json_file}\n", LOG_ONLY);
        my $json_data = get_file_contents($json_file);
        $json_data =~ s/\/\/.*$//gm; # strip out comments
        my $updates_metadata = decode_json($json_data);

        # The metadata could be more complex, if necessary. For now
        #   it's just a list of updates to install.
        $updates = [ @$updates_metadata ];
        output("Updates:\n  ".join("\n  ",@$updates)."\n", LOG_ONLY);
    };

    my $success = 1;
    foreach my $update_file (@$updates) {
        # Only allow archive file types.
        # We can add more later if they're needed. At the moment, NI
        #   distributed all of them as .ZIP.
        next if ($update_file !~ /\.(?:zip)$/);

        my $update_name = $update_file;
        $update_name =~ s/(?:^\d+ |\.[^.]+$)//g;
        output("     ${update_name}: ");

        my $archive = Archive::Extract-&gt;new(
            archive =&gt; build_path($_updates_dir,$update_file)
        );
        if (! $archive) {
            output("FAILED\n     Error creating archive object from file: $!\n");
            $success = 0;
            next;
        }

        my $fssafe_update_name = $update_name;
        $fssafe_update_name =~ s/ /_/g;

        my $update_tmp = tempdir('labview-2014_update__'.
                                     $fssafe_update_name.'__XXXXXXXX',
                                 DIR =&gt; $ENV{TEMP});

        output('X', CONSOLE_ONLY);
        my $extract_start = [gettimeofday()];
        if (! $archive-&gt;extract( to =&gt; $update_tmp )) {
            output("FAILED\n     Error extracting update '${update_file}': $!\n");
            $success = 0;
            next;
        }
        my $elapsed = tv_interval($extract_start);
        output("\n       Extracted: ${elapsed} seconds.\n", LOG_ONLY);

        my $logfile = get_default_app_log();
        $logfile =~ s/(?=\.txt)$/__update__${fssafe_update_name}/i;
        my ($fh,$temp_logfile) = tempfile('labview-2014_update-install__'.
                                          $fssafe_update_name.'__XXXXXXXX',
                                          DIR =&gt; $ENV{TEMP});
        close($fh);

        # Invoke the installer.
        my @command = (
            'cmd','/c','start','/wait','""',
            build_path($update_tmp,'setup.exe'),
            '/log','"'.$temp_logfile.'"',
            '/qn', # no interaction
            '/AcceptLicenses','yes',
            '/r:n', # suppress reboot
        );
        if (! copy($temp_logfile,$logfile)) {
            # not a fatal error
            output("        Error copying log file '${temp_logfile}' to '${logfile}': $!\n", LOG_ONLY);
        }
        # Check for additional logs

        output('I', CONSOLE_ONLY);
        my $outcome =
            run_command(join(' ',@command),
                        Description =&gt; 'installing update: '.$update_name,
						IgnoreExitCodes =&gt; [3010]
            );

        output(($outcome?' OK':' FAILED')."\n");
        $success &amp;&amp;= $outcome;

        my $errors;
        remove_tree($update_tmp, { error =&gt; \$errors } );

        if( defined $errors )
        {
          output( join( @$errors, '\n' ), LOG_ONLY );
        }
    }

    # It's possible that some updates do not apply. Perhaps failure here
    #   should only be advisory.
    return $success;
}

sub postinstall {
    #####################################################
    # Application Licensing
    #####################################################
    return 0 if (! configure_licensing());


    #####################################################
    # Need to fix shortcuts
    #####################################################
    foreach my $sc (keys(%shortcuts_to_move)) {
        if (-e $sc) {
            my $target = $shortcuts_to_move{$sc};
            output("Moving '${sc}' to '${target}: ");
            output((run_command('MOVE /Y "'.$sc.'" "'.$target.'"')?'OK':'FAILED')."\n");
        }
    }

    #####################################################
    # Need to delete any desktop shortcuts
    #####################################################
    foreach my $sc (@shortcuts_to_delete) {
        if (-e $sc) {
            output("Deleting '${sc}': ");
            output((run_command('DEL /Q "'.$sc.'"')?'OK':'FAILED')."\n");
        }
    }

    #####################################################
    # Delete the files in sourceFiles because it's BIG
    #   This has the side effect of making it impossible to do a
    #   repair install.
    #####################################################
    #if(!run_command("RMDIR /S /Q \"$srcfiledir\"")){
    #    output("LabVIEW install files were not completely deleted!\n".
    #           "You might want to clean these up manually\n");
    #    # Don't stop, because it's likely just a few files left over
    #} else {
    #    output("LabVIEW install files deleted successfully!\n");
    #}

    ####################################################
    # Try to stop some of those firewall warnings
    ####################################################
    if(!run_command(join(' ',
                         'netsh', 'advfirewall', 'firewall',
                         'add', 'rule', 'DataFinder',
                         'enable=yes',
                         'action=allow',
                         'profile=domain',
                         'dir=in',
                         'program="'.
                             build_path(get_arch_programfiles(OSARCH_x86),
                                        'National Instruments','Shared',
                                        'DataFinderDesktop','bin',
                                        'datafinder.exe').'"',
                    )))
    {
        output("Firewall rule (Data Finder) installation has failed!\n");
        # Dont stop. Not too large of a deal
    } else {
        output("Installing firewall rules was successful!\n");
    }

    # The update service doesn't need a firewall exception. Block it.
    if(!run_command(join(' ',
                         'netsh', 'advfirewall', 'firewall',
                         'add', 'rule', 'DataFinder',
                         'enable=yes',
                         'action=block',
                         'profile=domain',
                         'dir=in',
                         'program="'.
                             build_path(get_arch_programfiles(OSARCH_x86),
                                        'National Instruments','Shared',
                                        'Update Service',
                                        'niupdateservice.exe').'"',
                    )))
    {
        output("Firewall rule (NI Update Service) installation has failed!\n");
        # Dont stop. Not too large of a deal
    } else {
        output("Installing firewall rules was successful!\n");
    }

    return 1;
}


sub validate_install {
    # Read the results file and verify that all components were installed
    #   sucessfully.

    if (! -f $install_results) {
        output("Cannot find LabVIEW 2015 Install Results!\n");
        return 0;
    }

    ## XML::SAX::PurePerl croaks on the BOM. Do the decoding manually.
    my $content = '';
    if (open(my $IR_CONTENT,'&lt;:raw',$install_results)) {
        $content = decode('UTF-16',join('',&lt;$IR_CONTENT&gt;));
        $content =~ s/\s+encoding="[^"]+"//i;
    } else {
        output("Error opening install results file '${install_results}': $!\n");
        return 0;
    }
    my $results = XMLin($content);

    my $composite_success = 1;
    my $count = 0;
    foreach my $subproduct (keys(%{$results-&gt;{distribution}})) {
        my $outcome = $results-&gt;{distribution}-&gt;{$subproduct}-&gt;{result};
        output("  ${subproduct}: ${outcome}\n");
        if (lc($outcome) ne 'success') {
            $composite_success = 0;
        } else {
            $count++;
        }
    }

    if ($count != $specs{$install_profile}-&gt;{component_count}) {
        output("ERROR: Incorrect count of installed components!\n".
               "Expected(".$specs{$install_profile}-&gt;{component_count}.") Got(".
               $count.")\n");
        $composite_success = 0;
    }

    return $composite_success;
}

sub configure_licensing {
    ####################################################################
    # Run a command using a Labview utility to add a volume license
    #   located at 27001@labview.lic.mst.edu
    ####################################################################
    if(! run_command(join(' ',
                          '"'.$licutil.'"',
                          '-addservers',$flexlm_license_path
                     ))) {
        output("LabVIEW network license was not added correctly!\n");
        return 0;
    } else {
        output("LabVIEW network license was installed\n");
    }

    # This is not crucial to the install being "successful."
    activate_local_licenses();

    return 1;
}

sub activate_local_licenses {
    # Activate local licenses.
    # Local license files are located in:
    #     C:\ProgramData\National Instruments\License Manager\Licenses
    #   The files there contain the FLEXlm feature names and version numbers.
    # Perhaps it would be wiser to parse those files and attempt to activate
    #   all features than to compile a static list here.
    output("    Activating local features for ${install_profile} profile...\n");
    my $local_licenses = build_path($ENV{ProgramData},'National Instruments',
                             'License Manager','Licenses');

    my @all_local_features;
    if (opendir(my $LICDIR,$local_licenses)) {
        foreach my $entry (readdir($LICDIR)) {
            my $lic = build_path($local_licenses,$entry);
            next if (! -f $lic);

            if (open(my $LIC,'&lt;',$lic)) {
                foreach my $line (&lt;$LIC&gt;) {
                    if ($line =~ /^(?:FEATURE|INCREMENT)\s+(\S+)\s+\S+\s+(\S+)\s+/) {
                        output("   [DETECT_LOCAL_LICENSE] (${lic}) '$1','$2'\n",
                               LOG_ONLY);
                        push(@all_local_features,[$1,$2]);
                    }
                }

                close($LIC);
            } else {
                output("Error opening file '${lic}' to look for licenses: $!\n");
            }
        }
    }

    foreach my $feature (@all_local_features) {
        output("      ".join(' ',@$feature)."\n");
        if(! run_command(join(' ',
                              'start','/wait','""',
                              '"'.$licutil.'"',
                              '-s',
                              '-activate', '"'.join(' ',@$feature).'"',
                              '-serialnumber', '"M63X12479"',
                              '-firstname', '"Missouri S&amp;T"',
                              '-lastname', '"Missouri S&amp;T"',
                              '-organizationname', '"Missouri S&amp;T"',
                         ))) {
            # In my experience, even when this fails, it doesn't report it.
            output("LabVIEW local license activation did not succeed!\n");
            # Not fatal
        } else {
            output("LabVIEW local license activation reported success.\n",
                   LOG_ONLY);
        }
    }

    return 1; # meaningless
}
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\labview.2015\prod\update.pl</FullName>
    <Length>20909</Length>
    <Extension>.pl</Extension>
    <CreationTime>2015-12-10T14:22:24.8830234-06:00</CreationTime>
    <CreationTimeUtc>2015-12-10T20:22:24.8830234Z</CreationTimeUtc>
    <LastWriteTime>2016-11-15T15:45:32.7479594-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-11-15T21:45:32.7479594Z</LastWriteTimeUtc>
    <LastAccessTime>2015-12-10T14:22:24.8830234-06:00</LastAccessTime>
    <LastAccessTimeUtc>2015-12-10T20:22:24.8830234Z</LastAccessTimeUtc>
    <Text># LabVIEW 2015
# Package Created November 2015
# Package created by Dzu Pham


# This package was request to be installed with minimal amount of addons
# Labview 2015
# NI-system configuration 15
# NI-daqmx 15.0
# NI-ELVISmx 15.0

# Create a specfile to do the install of Labview
# This means you need to do a /generatespcefile and updaet it on appdeploy

=pod

Begin-Doc
Modified: $Date$
Name: LabVIEW 2015 Installer
Type: script
Description: Refer to top explanation.
    For specialized installations, new specfiles will need to be generated.
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

$|=1;
use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'labview.2015',
        package_revision =&gt; '20151130T0800',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

use File::Temp qw(tempfile tempdir);
use File::Copy;
use File::Basename;
use File::Path qw(remove_tree);
use Win32;
use XML::Simple;
use Encode;
use Archive::Extract;
use Time::HiRes qw(gettimeofday tv_interval);
use JSON;
use Data::Dumper;

my $srcfiledir = get_pkg_sourcefiles();
my $sourceshare = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\labview_2015";

##############################################################################
# BEGIN Configuration

# The /generatespecfile flag doesn't do any dependency checking! It will
#   let you select items that will cause the install to fail.
# Run setup.exe interactively (no flag) to verify that a set of components
#   to install is valid.
#   Example:
#      The FPGA components require the Xilinx compiler (which I don't think
#        we have.
#
#      The "Visual Studio Integration" components require something to be
#        (pre)installed before they are installable. (DeviceDrivers)

# component_count is used in the validation phase to determine if the
#   expected number of components is installed.
my %specs = (
    'default' =&gt; {
        'labview' =&gt; 'MST.labview.specs',
        #'drivers' =&gt; 'MST.devicedrivers.specs',

        'updates' =&gt; 'MST.updates.json',
        'component_count'   =&gt; 7, # manually calculated after an install
    },
);
my $install_profile = 'default'; # configurable via command-line

my $flexlm_license_path = 'labview.lic.mst.edu:27001';

my $licutil = build_path(get_arch_programfiles(OSARCH_x86),
                         'National Instruments', 'Shared',
                         'License Manager', 'Bin',
                         'nilmUtil.exe');

my %shortcuts_to_move = (
    # We usually don't want Desktop icons, ever.
    # In this case, there's no StartMenu icon. move it to the NI folder.
    build_path(get_allusers_desktop(),'NI MAX.lnk') =&gt;
        build_path(get_allusers_start_menu(),'Programs',
                   'National Instruments','NI MAX.lnk'),

);

my @shortcuts_to_delete = (
);

my $install_results = get_default_app_log();
$install_results =~ s/\.txt$/_results.txt/i;


my $updates_dir = 'updates';

# Serial: M63X12479

# A number of components need a reboot in order to be fully complete.
# The WTG/TS data should include a reboot or a reboot+delay+reboot.

# The update service wants a firewall exception.

# END Configuration
##############################################################################

my $skip_updates = 0; # allow for the possibility of skipping the updates.

my $cwd = cwd();
my $isSccmInstall = 0;

##############################################################################
# Check to see if it's being installed by SCCM (package files are
#   currently in cache folder).
# If so, change isSccmInstall to true to use for no_source_files value
#   &amp; preinstall.
##############################################################################
my @splitPath = split(/\\/,$cwd);

# This could be smarter. Have it check to see if the cwd and srcfiles are
#   on the same drive.
if(lc $splitPath[0] eq "c:"){
    $isSccmInstall = 1;
}

use Getopt::Long;
sub usage {
    print qq(
usage: $0 [--help] [--validate] [--preinstall] [--install] [--updates] [--postinstall]

);
}
GetOptions(
    'help' =&gt; sub { usage(); exit(0); },

    'prerequisites' =&gt; sub { exit(! prereq_sub()); },
    'preinstall' =&gt; sub { exit(! preinstall()); },
    'install' =&gt; sub { exit(! install()); },
    'updates' =&gt; sub { exit(! install_updates()); },
    'postinstall' =&gt; sub { exit(! postinstall()); },
    'validate' =&gt; sub { exit(! validate_install()); },

    'skip-updates' =&gt; \$skip_updates,
);
if ($skip_updates) {
    output("Skipping update installation.\n");
}


do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; [qw(clc desktop traveling virtual-clc virtual-desktop)],
    exit_on_failure =&gt; 1,
    no_source_files =&gt; $isSccmInstall,
    #prerequisite_sub =&gt; \&amp;prereq_sub, # Refer to labview 2014 if you need to check disk space
    #preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    #validate_sub =&gt; \&amp;validate_install,
);

# Warn for reboot if we have gotten to completion - maybe a little overboard
#if ($need_reboot) {
#    output("**THIS PACKAGE REQUIRES A REBOOT BEFORE USE**\n");
#}

IM_Exit(EXIT_SUCCESS);

########################################################################
########################################################################
########################################################################

sub install {
    my ($fh,$temp_logfile,$temp_results,@command,@output,$logfile,$outcome);

    ######################################################################
    # Install the actual LabVIEW 2015 software using a specfile (default
    #   settings) also disabling the update notifications.
    ######################################################################

    ($fh,$temp_logfile) = tempfile('LabviewInstall_install_XXXXXXXX',
                                   DIR =&gt; $ENV{TEMP},
                                   SUFFIX =&gt; '.log');
    close($fh);

    ($fh,$temp_results) = tempfile('LabviewInstall_results_XXXXXXXX',
                                   DIR =&gt; $ENV{TEMP},
                                   SUFFIX =&gt; '.txt');
    close($fh);


    my $command = join(' ',
        build_path($sourceshare,'setup.exe'),
        '/q',
        '/AcceptLicenses', 'yes',
        '/r:n',
        '/log', sprintf('"%s"',$temp_logfile),
        '/results', sprintf('"%s"',$temp_results),
        '/applyspecfile', build_path($sourceshare),
        '/disableNotificationCheck',
        );

    output("   Installing LabVIEW 2015: ");
    $outcome = run_command($command, IgnoreExitCodes =&gt; [3010] );

    output(($outcome?'OK':'FAILED')."\n");

    # Copy the log files.
    $logfile = get_default_app_log();
    output("   Copying (Install) '${temp_logfile}' =&gt; '${logfile}'\n",
           LOG_ONLY);
    copy($temp_logfile,$logfile);
    output("   Copying (Results) '${temp_results}' =&gt; '${install_results}'\n",
           LOG_ONLY);
    copy($temp_results,$install_results);

    # Additional log file dir.
    # The subcomponents that get installed create logs here.
    #   They appear to be named '&lt;component&gt;.txt'.
    my $addl_logs_dir = $temp_logfile.'_additionalLogs';
    if (-d $addl_logs_dir) {
        if (opendir(my $ADDLLOGS,$addl_logs_dir)) {
            while (my $logfile = readdir($ADDLLOGS)) {
                next if ($logfile =~ /^\.?\.$/);

                my $source = build_path($addl_logs_dir,$logfile);

                my $target = get_default_app_log();
                $logfile =~ s/\.txt$//i; # strip the extension
                $target =~ s/\.txt$/__${logfile}.txt/i;

                output("   Copying (Addl) '${source}' =&gt; '${target}'\n", LOG_ONLY);
                if (!copy($source,$target)) {
                    output("  ERROR: $!\n",LOG_ONLY);
                }
            }
            closedir($ADDLLOGS);
        } else {
            output("Error opening additional logs dir '${addl_logs_dir}': $!\n",
                   LOG_ONLY);
        }
    }

    # Attempt to install any updates in the 'updates' directory.
    # Failure to update should not be a condition of "successful" installation.
    #   (Depending on the instal profile, some updates may not even apply).
    install_updates();

    return $outcome;
}

#
# I used the NI Update Service to download these updates, all of which are
#   .ZIP archives.
# The service downloads them to:
#    %ProgramData%\National Instruments\Update Service\Installers
#   They are ZIP archives (though the filename extension doesn't say so).
# Anecdotal experience suggests that these updates can be re-applied more
#   than once.
# Updates for locally-licensed features are not detected until the local
#   licenses are activated (maybe?).
sub install_updates {
    # Each update is compressed.
    # Unpack and install each one.

    if ($skip_updates) {
        output("   Installing Updates SKIPPED.\n");
        return 1;
    }

    output("   Installing Updates:\n");
    my $_updates_dir = build_path($srcfiledir,$updates_dir);
    if (! -d $_updates_dir) {
        output("     No updates to install.\n");
        return 1;
    }

    # Get the metadata file.
    my $updates;
    eval {
        my $json_file = build_path($_updates_dir,
                                   $specs{$install_profile}-&gt;{updates});
        output("   Updates Metadata: ${json_file}\n", LOG_ONLY);
        my $json_data = get_file_contents($json_file);
        $json_data =~ s/\/\/.*$//gm; # strip out comments
        my $updates_metadata = decode_json($json_data);

        # The metadata could be more complex, if necessary. For now
        #   it's just a list of updates to install.
        $updates = [ @$updates_metadata ];
        output("Updates:\n  ".join("\n  ",@$updates)."\n", LOG_ONLY);
    };

    my $success = 1;
    foreach my $update_file (@$updates) {
        # Only allow archive file types.
        # We can add more later if they're needed. At the moment, NI
        #   distributed all of them as .ZIP.
        next if ($update_file !~ /\.(?:zip)$/);

        my $update_name = $update_file;
        $update_name =~ s/(?:^\d+ |\.[^.]+$)//g;
        output("     ${update_name}: ");

        my $archive = Archive::Extract-&gt;new(
            archive =&gt; build_path($_updates_dir,$update_file)
        );
        if (! $archive) {
            output("FAILED\n     Error creating archive object from file: $!\n");
            $success = 0;
            next;
        }

        my $fssafe_update_name = $update_name;
        $fssafe_update_name =~ s/ /_/g;

        my $update_tmp = tempdir('labview-2015_update__'.
                                     $fssafe_update_name.'__XXXXXXXX',
                                 DIR =&gt; $ENV{TEMP});

        output('X', CONSOLE_ONLY);
        my $extract_start = [gettimeofday()];
        if (! $archive-&gt;extract( to =&gt; $update_tmp )) {
            output("FAILED\n     Error extracting update '${update_file}': $!\n");
            $success = 0;
            next;
        }
        my $elapsed = tv_interval($extract_start);
        output("\n       Extracted: ${elapsed} seconds.\n", LOG_ONLY);

        my $logfile = get_default_app_log();
        $logfile =~ s/(?=\.txt)$/__update__${fssafe_update_name}/i;
        my ($fh,$temp_logfile) = tempfile('labview-2015_update-install__'.
                                          $fssafe_update_name.'__XXXXXXXX',
                                          DIR =&gt; $ENV{TEMP});
        close($fh);

        # Invoke the installer.
        my @command = (
            'cmd','/c','start','/wait','""',
            build_path($update_tmp,'setup.exe'),
            '/log','"'.$temp_logfile.'"',
            '/qn', # no interaction
            '/AcceptLicenses','yes',
            '/r:n', # suppress reboot
        );
        if (! copy($temp_logfile,$logfile)) {
            # not a fatal error
            output("        Error copying log file '${temp_logfile}' to '${logfile}': $!\n", LOG_ONLY);
        }
        # Check for additional logs

        output('I', CONSOLE_ONLY);
        my $outcome =
            run_command(join(' ',@command),
                        Description =&gt; 'installing update: '.$update_name,
                        IgnoreExitCodes =&gt; [3010]
            );

        output(($outcome?' OK':' FAILED')."\n");
        $success &amp;&amp;= $outcome;

        my $errors;
        remove_tree($update_tmp, { error =&gt; \$errors } );

        if( defined $errors )
        {
          output( join( @$errors, '\n' ), LOG_ONLY );
        }
    }

    # It's possible that some updates do not apply. Perhaps failure here
    #   should only be advisory.
    return $success;
}

sub postinstall {
    #####################################################
    # Application Licensing
    #####################################################
    return 0 if (! configure_licensing());


    #####################################################
    # Need to fix shortcuts
    #####################################################
    foreach my $sc (keys(%shortcuts_to_move)) {
        if (-e $sc) {
            my $target = $shortcuts_to_move{$sc};
            output("Moving '${sc}' to '${target}: ");
            output((run_command('MOVE /Y "'.$sc.'" "'.$target.'"')?'OK':'FAILED')."\n");
        }
    }

    #####################################################
    # Need to delete any desktop shortcuts
    #####################################################
    foreach my $sc (@shortcuts_to_delete) {
        if (-e $sc) {
            output("Deleting '${sc}': ");
            output((run_command('DEL /Q "'.$sc.'"')?'OK':'FAILED')."\n");
        }
    }

    #####################################################
    # Delete the files in sourceFiles because it's BIG
    #   This has the side effect of making it impossible to do a
    #   repair install.
    #####################################################
    #if(!run_command("RMDIR /S /Q \"$srcfiledir\"")){
    #    output("LabVIEW install files were not completely deleted!\n".
    #           "You might want to clean these up manually\n");
    #    # Don't stop, because it's likely just a few files left over
    #} else {
    #    output("LabVIEW install files deleted successfully!\n");
    #}

    ####################################################
    # Try to stop some of those firewall warnings
    ####################################################
    if(!run_command(join(' ',
                         'netsh', 'advfirewall', 'firewall',
                         'add', 'rule', 'DataFinder',
                         'enable=yes',
                         'action=allow',
                         'profile=domain',
                         'dir=in',
                         'program="'.
                             build_path(get_arch_programfiles(OSARCH_x86),
                                        'National Instruments','Shared',
                                        'DataFinderDesktop','bin',
                                        'datafinder.exe').'"',
                    )))
    {
        output("Firewall rule (Data Finder) installation has failed!\n");
        # Dont stop. Not too large of a deal
    } else {
        output("Installing firewall rules was successful!\n");
    }

    # The update service doesn't need a firewall exception. Block it.
    if(!run_command(join(' ',
                         'netsh', 'advfirewall', 'firewall',
                         'add', 'rule', 'DataFinder',
                         'enable=yes',
                         'action=block',
                         'profile=domain',
                         'dir=in',
                         'program="'.
                             build_path(get_arch_programfiles(OSARCH_x86),
                                        'National Instruments','Shared',
                                        'Update Service',
                                        'niupdateservice.exe').'"',
                    )))
    {
        output("Firewall rule (NI Update Service) installation has failed!\n");
        # Dont stop. Not too large of a deal
    } else {
        output("Installing firewall rules was successful!\n");
    }

    return 1;
}


sub validate_install {
    # Read the results file and verify that all components were installed
    #   sucessfully.

    if (! -f $install_results) {
        output("Cannot find LabVIEW 2015 Install Results!\n");
        return 0;
    }

    ## XML::SAX::PurePerl croaks on the BOM. Do the decoding manually.
    my $content = '';
    if (open(my $IR_CONTENT,'&lt;:raw',$install_results)) {
        $content = decode('UTF-16',join('',&lt;$IR_CONTENT&gt;));
        $content =~ s/\s+encoding="[^"]+"//i;
    } else {
        output("Error opening install results file '${install_results}': $!\n");
        return 0;
    }
    my $results = XMLin($content);

    my $composite_success = 1;
    my $count = 0;
    foreach my $subproduct (keys(%{$results-&gt;{distribution}})) {
        my $outcome = $results-&gt;{distribution}-&gt;{$subproduct}-&gt;{result};
        output("  ${subproduct}: ${outcome}\n");
        if (lc($outcome) ne 'success') {
            $composite_success = 0;
        } else {
            $count++;
        }
    }

    if ($count != $specs{$install_profile}-&gt;{component_count}) {
        output("ERROR: Incorrect count of installed components!\n".
               "Expected(".$specs{$install_profile}-&gt;{component_count}.") Got(".
               $count.")\n");
        $composite_success = 0;
    }

    return $composite_success;
}

sub configure_licensing {
    ####################################################################
    # Run a command using a Labview utility to add a volume license
    #   located at 27001@labview.lic.mst.edu
    ####################################################################
    if(! run_command(join(' ',
                          '"'.$licutil.'"',
                          '-addservers',$flexlm_license_path
                     ))) {
        output("LabVIEW network license was not added correctly!\n");
        return 0;
    } else {
        output("LabVIEW network license was installed\n");
    }

    # This is not crucial to the install being "successful."
    activate_local_licenses();

    return 1;
}

sub activate_local_licenses {
    # Activate local licenses.
    # Local license files are located in:
    #     C:\ProgramData\National Instruments\License Manager\Licenses
    #   The files there contain the FLEXlm feature names and version numbers.
    # Perhaps it would be wiser to parse those files and attempt to activate
    #   all features than to compile a static list here.
    output("    Activating local features for ${install_profile} profile...\n");
    my $local_licenses = build_path($ENV{ProgramData},'National Instruments',
                             'License Manager','Licenses');

    my @all_local_features;
    if (opendir(my $LICDIR,$local_licenses)) {
        foreach my $entry (readdir($LICDIR)) {
            my $lic = build_path($local_licenses,$entry);
            next if (! -f $lic);

            if (open(my $LIC,'&lt;',$lic)) {
                foreach my $line (&lt;$LIC&gt;) {
                    if ($line =~ /^(?:FEATURE|INCREMENT)\s+(\S+)\s+\S+\s+(\S+)\s+/) {
                        output("   [DETECT_LOCAL_LICENSE] (${lic}) '$1','$2'\n",
                               LOG_ONLY);
                        push(@all_local_features,[$1,$2]);
                    }
                }

                close($LIC);
            } else {
                output("Error opening file '${lic}' to look for licenses: $!\n");
            }
        }
    }

    foreach my $feature (@all_local_features) {
        output("      ".join(' ',@$feature)."\n");
        if(! run_command(join(' ',
                              'start','/wait','""',
                              '"'.$licutil.'"',
                              '-s',
                              '-activate', '"'.join(' ',@$feature).'"',
                              '-serialnumber', '"M63X12479"',
                              '-firstname', '"Missouri S&amp;T"',
                              '-lastname', '"Missouri S&amp;T"',
                              '-organizationname', '"Missouri S&amp;T"',
                         ))) {
            # In my experience, even when this fails, it doesn't report it.
            output("LabVIEW local license activation did not succeed!\n");
            # Not fatal
        } else {
            output("LabVIEW local license activation reported success.\n",
                   LOG_ONLY);
        }
    }

    return 1; # meaningless
}
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\labview.2016\prod\update.pl</FullName>
    <Length>23779</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-11-28T10:18:47.6333667-06:00</CreationTime>
    <CreationTimeUtc>2016-11-28T16:18:47.6333667Z</CreationTimeUtc>
    <LastWriteTime>2016-11-30T15:12:55.6176403-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-11-30T21:12:55.6176403Z</LastWriteTimeUtc>
    <LastAccessTime>2016-11-28T10:18:47.6333667-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-11-28T16:18:47.6333667Z</LastAccessTimeUtc>
    <Text>=pod
Package Created November 2016
Package Created by Benjamin Krueger

LabVIEW 2016
Packaged with the following addons per Jpetriko request.
Based on the LabVIEW 2016 script.
"LabVIEW" section
     - LabVIEW 2016 (32-bit) English

"LabVIEW Add-Ons: Design" section
     - LabVIEW 2016 Control Design and Simulation Module
     - LabVIEW 2016 MathScript RT Module
"Device Drivers" section
    - NI System Configuration 16.0
    - NI-DAQmx 16.0.0
    - NI ELVISmx 16.0
=cut
$|=1;
use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'labview.2016',
        package_revision =&gt; '20161109T1546',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

use File::Temp qw(tempfile tempdir);
use File::Copy;
use File::Basename;
use File::Path qw(remove_tree);
use Win32;
use XML::Simple;
use Encode;
use Archive::Extract;
use Time::HiRes qw(gettimeofday tv_interval);
use JSON;
use Data::Dumper;

my $srcfiledir = get_pkg_sourcefiles();
my $sourceshare = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\labview_2016";

##############################################################################
# BEGIN Configuration

# The /generatespecfile flag doesn't do any dependency checking! It will
#   let you select items that will cause the install to fail.
# Run setup.exe interactively (no flag) to verify that a set of components
#   to install is valid.
#   Example:
#      The FPGA components require the Xilinx compiler (which I don't think
#        we have.
#
#      The "Visual Studio Integration" components require something to be
#        (pre)installed before they are installable. (DeviceDrivers)

# component_count is used in the validation phase to determine if the
#   expected number of components is installed.
my %specs = (
    'default' =&gt; {
        'labview' =&gt; 'MST.labview.specs',
        'drivers' =&gt; 'MST.devicedrivers.specs',

        'updates' =&gt; 'MST.updates.json',
        'component_count'   =&gt; 7, # manually calculated after an install
    },
);
my $install_profile = 'default'; # configurable via command-line

my $flexlm_license_path = 'labview.lic.mst.edu:27001';

my $licutil = build_path(get_arch_programfiles(OSARCH_x86),
                         'National Instruments', 'Shared',
                         'License Manager', 'Bin',
                         'nilmUtil.exe');

my %shortcuts_to_move = (
    # We usually don't want Desktop icons, ever.
    # In this case, there's no StartMenu icon. move it to the NI folder.
    build_path(get_allusers_desktop(),'NI MAX.lnk') =&gt;
        build_path(get_allusers_start_menu(),'Programs',
                   'National Instruments','NI MAX.lnk'),

);

my @shortcuts_to_delete = (
);

my $install_results = get_default_app_log();
$install_results =~ s/\.txt$/_results.txt/i;


my $updates_dir = 'updates';

# Serial: M63X12479

# A number of components need a reboot in order to be fully complete.
# The WTG/TS data should include a reboot or a reboot+delay+reboot.

# The update service wants a firewall exception.

# END Configuration
##############################################################################

my $skip_updates = 0; # allow for the possibility of skipping the updates.

my $cwd = cwd();
my $isSccmInstall = 0;

##############################################################################
# Check to see if it's being installed by SCCM (package files are
#   currently in cache folder).
# If so, change isSccmInstall to true to use for no_source_files value
#   &amp; preinstall.
##############################################################################
my @splitPath = split(/\\/,$cwd);

# This could be smarter. Have it check to see if the cwd and srcfiles are
#   on the same drive.
if(lc $splitPath[0] eq "c:"){
    $isSccmInstall = 1;
}

use Getopt::Long;
sub usage {
    print qq(
usage: $0 [--help] [--validate] [--preinstall] [--install] [--updates] [--postinstall]

);
}
GetOptions(
    'help' =&gt; sub { usage(); exit(0); },

    'prerequisites' =&gt; sub { exit(! prereq_sub()); },
    'preinstall' =&gt; sub { exit(! preinstall()); },
    'install' =&gt; sub { exit(! install()); },
    'updates' =&gt; sub { exit(! install_updates()); },
    'postinstall' =&gt; sub { exit(! postinstall()); },
    'validate' =&gt; sub { exit(! validate_install()); },

    'skip-updates' =&gt; \$skip_updates,
);
if ($skip_updates) {
    output("Skipping update installation.\n");
}


do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; [qw(clc desktop traveling virtual-clc virtual-desktop)],
    exit_on_failure =&gt; 1,
    no_source_files =&gt; $isSccmInstall,
    #prerequisite_sub =&gt; \&amp;prereq_sub, # Refer to labview 2014 if you need to check disk space
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    #validate_sub =&gt; \&amp;validate_install,
);

# Warn for reboot if we have gotten to completion - maybe a little overboard
#if ($need_reboot) {
#    output("**THIS PACKAGE REQUIRES A REBOOT BEFORE USE**\n");
#}

IM_Exit(EXIT_SUCCESS);

########################################################################
########################################################################
########################################################################

sub install {
    my ($fh,$temp_logfile,$temp_results,@command,@output,$logfile,$outcome);

    ######################################################################
    # Install the actual LabVIEW 2016 software using a specfile (default
    #   settings) also disabling the update notifications.
    ######################################################################

    ($fh,$temp_logfile) = tempfile('LabviewInstall_install_XXXXXXXX',
                                   DIR =&gt; $ENV{TEMP},
                                   SUFFIX =&gt; '.log');
    close($fh);

    ($fh,$temp_results) = tempfile('LabviewInstall_results_XXXXXXXX',
                                   DIR =&gt; $ENV{TEMP},
                                   SUFFIX =&gt; '.txt');
    close($fh);


    my $command = join(' ',
        build_path($sourceshare,'setup.exe'),
        '/q',
        '/AcceptLicenses', 'yes',
        '/r:n', 
        '/log', sprintf('"%s"',$temp_logfile),
        '/results', sprintf('"%s"',$temp_results),
        '/applyspecfile', build_path($sourceshare),
        '/disableNotificationCheck',
        '/confirmCriticalWarnings'
        );
    
    output("   Installing LabVIEW 2016: ");
    $outcome = run_command($command, IgnoreExitCodes =&gt; [3010] );

    output(($outcome?'OK':'FAILED')."\n");
    #Install poorly named to modules and drivers.
    #Some of them come as executables, some are msi's, none are easy to find and for some reason we have millions of
    #useless files in the same directory as well...
    #Executable Supplemental Programs First..
    #NIDAQnx
    $command = join(' ',
        build_path($sourceshare,"Distributions","NI-DAQmx","setup.exe"),
        '/q',
        '/r:n',
        '/AcceptLicenses', 'yes',
        '/log', sprintf('"%s"',$temp_logfile),
        #'/results', sprintf('"%s"',$temp_results),
        #'/applyspecfile', build_path($sourceshare),
        '/disableNotificationCheck',
        '/confirmCriticalWarnings'
    );
    output("    Installing NI-DAQmx Software");
    $outcome = run_command($command, IgnoreExitCodes =&gt; [3010]);
    output(($outcome?'OK':'FAILED')."\n");

    #ELVISmx
    $command = join(' ',
        build_path($sourceshare,"Distributions","ELVISmx","setup.exe"),
        '/q',
        '/r:n',
        '/AcceptLicenses', 'yes',
        '/log', sprintf('"%s"',$temp_logfile),
        #'/results', sprintf('"%s"',$temp_results),
        #'/applyspecfile', build_path($sourceshare),
        '/disableNotificationCheck',
        '/confirmCriticalWarnings'
    );
    output("    Installing ELVISmx Software");
    $outcome = run_command($command, IgnoreExitCodes =&gt; [3010]);
    output(($outcome?'OK':'FAILED')."\n");
    
    #Now For the MSI installers.
    #Start with Control Design Simulation Module
    my $msi_path = build_path($sourceshare,"Distributions","LV_CDS64","Products","Control_Design_Sim_Module_64_2016","LV_Co00","LV_CD_Sim64.msi");
    output("    Installing Design Simulation MSI.");
    $outcome = install_msi(msi=&gt;$msi_path);
    output(($outcome?'OK':'FAILED')."\n");

    #Next we need MathScript
    $msi_path = build_path($sourceshare,"Distributions","LV_MSRT","Products","LabVIEW_MathScript_RT_2016","lvmsrt01","LVMathScriptRT.msi");
    output("    Installing MathScript RT");
    $outcome = install_msi(msi=&gt;$msi_path);
    output(($outcome?'OK':'FAILED')."\n");
    
    # Copy the log files.
    $logfile = get_default_app_log();
    output("   Copying (Install) '${temp_logfile}' =&gt; '${logfile}'\n",
           LOG_ONLY);
    copy($temp_logfile,$logfile);
    output("   Copying (Results) '${temp_results}' =&gt; '${install_results}'\n",
           LOG_ONLY);
    copy($temp_results,$install_results);

    # Additional log file dir.
    # The subcomponents that get installed create logs here.
    #   They appear to be named '&lt;component&gt;.txt'.
    my $addl_logs_dir = $temp_logfile.'_additionalLogs';
    if (-d $addl_logs_dir) {
        if (opendir(my $ADDLLOGS,$addl_logs_dir)) {
            while (my $logfile = readdir($ADDLLOGS)) {
                next if ($logfile =~ /^\.?\.$/);

                my $source = build_path($addl_logs_dir,$logfile);

                my $target = get_default_app_log();
                $logfile =~ s/\.txt$//i; # strip the extension
                $target =~ s/\.txt$/__${logfile}.txt/i;

                output("   Copying (Addl) '${source}' =&gt; '${target}'\n", LOG_ONLY);
                if (!copy($source,$target)) {
                    output("  ERROR: $!\n",LOG_ONLY);
                }
            }
            closedir($ADDLLOGS);
        } else {
            output("Error opening additional logs dir '${addl_logs_dir}': $!\n",
                   LOG_ONLY);
        }
    }

    # Attempt to install any updates in the 'updates' directory.
    # Failure to update should not be a condition of "successful" installation.
    #   (Depending on the instal profile, some updates may not even apply).
    #install_updates();

    return $outcome;
}
sub preinstall
{
    #Install .net 4.6.2
    my $outcome = 0;
    my $command = join(' ', build_path($sourceshare,'dotnetsetup.exe'),'/q','/norestart');
    output("    Installing .NET 4.6.1");
    $outcome = run_command($command,IgnoreExitCodes =&gt; [5100,3010]);
    output(($outcome?'OK':'FAILED')."\n");
    return 1;
}
#
# I used the NI Update Service to download these updates, all of which are
#   .ZIP archives.
# The service downloads them to:
#    %ProgramData%\National Instruments\Update Service\Installers
#   They are ZIP archives (though the filename extension doesn't say so).
# Anecdotal experience suggests that these updates can be re-applied more
#   than once.
# Updates for locally-licensed features are not detected until the local
#   licenses are activated (maybe?).
sub install_updates {
    # Each update is compressed.
    # Unpack and install each one.

    if ($skip_updates) {
        output("   Installing Updates SKIPPED.\n");
        return 1;
    }

    output("   Installing Updates:\n");
    my $_updates_dir = build_path($srcfiledir,$updates_dir);
    if (! -d $_updates_dir) {
        output("     No updates to install.\n");
        return 1;
    }

    # Get the metadata file.
    my $updates;
    eval {
        my $json_file = build_path($_updates_dir,
                                   $specs{$install_profile}-&gt;{updates});
        output("   Updates Metadata: ${json_file}\n", LOG_ONLY);
        my $json_data = get_file_contents($json_file);
        $json_data =~ s/\/\/.*$//gm; # strip out comments
        my $updates_metadata = decode_json($json_data);

        # The metadata could be more complex, if necessary. For now
        #   it's just a list of updates to install.
        $updates = [ @$updates_metadata ];
        output("Updates:\n  ".join("\n  ",@$updates)."\n", LOG_ONLY);
    };

    my $success = 1;
    foreach my $update_file (@$updates) {
        # Only allow archive file types.
        # We can add more later if they're needed. At the moment, NI
        #   distributed all of them as .ZIP.
        next if ($update_file !~ /\.(?:zip)$/);

        my $update_name = $update_file;
        $update_name =~ s/(?:^\d+ |\.[^.]+$)//g;
        output("     ${update_name}: ");

        my $archive = Archive::Extract-&gt;new(
            archive =&gt; build_path($_updates_dir,$update_file)
        );
        if (! $archive) {
            output("FAILED\n     Error creating archive object from file: $!\n");
            $success = 0;
            next;
        }

        my $fssafe_update_name = $update_name;
        $fssafe_update_name =~ s/ /_/g;

        my $update_tmp = tempdir('labview-2016_update__'.
                                     $fssafe_update_name.'__XXXXXXXX',
                                 DIR =&gt; $ENV{TEMP});

        output('X', CONSOLE_ONLY);
        my $extract_start = [gettimeofday()];
        if (! $archive-&gt;extract( to =&gt; $update_tmp )) {
            output("FAILED\n     Error extracting update '${update_file}': $!\n");
            $success = 0;
            next;
        }
        my $elapsed = tv_interval($extract_start);
        output("\n       Extracted: ${elapsed} seconds.\n", LOG_ONLY);

        my $logfile = get_default_app_log();
        $logfile =~ s/(?=\.txt)$/__update__${fssafe_update_name}/i;
        my ($fh,$temp_logfile) = tempfile('labview-2016_update-install__'.
                                          $fssafe_update_name.'__XXXXXXXX',
                                          DIR =&gt; $ENV{TEMP});
        close($fh);

        # Invoke the installer.
        my @command = (
            'cmd','/c','start','/wait','""',
            build_path($update_tmp,'setup.exe'),
            '/log','"'.$temp_logfile.'"',
            '/qn', # no interaction
            '/AcceptLicenses','yes',
            '/r:n', # suppress reboot
        );
        if (! copy($temp_logfile,$logfile)) {
            # not a fatal error
            output("        Error copying log file '${temp_logfile}' to '${logfile}': $!\n", LOG_ONLY);
        }
        # Check for additional logs

        output('I', CONSOLE_ONLY);
        my $outcome =
            run_command(join(' ',@command),
                        Description =&gt; 'installing update: '.$update_name,
                        IgnoreExitCodes =&gt; [3010,1]
            );

        output(($outcome?' OK':' FAILED')."\n");
        $success &amp;&amp;= $outcome;

        my $errors;
        remove_tree($update_tmp, { error =&gt; \$errors } );

        if( defined $errors )
        {
          output( join( @$errors, '\n' ), LOG_ONLY );
        }
    }

    # It's possible that some updates do not apply. Perhaps failure here
    #   should only be advisory.
    return $success;
}

sub postinstall {
    #####################################################
    # Application Licensing
    #####################################################
    return 0 if (! configure_licensing());


    #####################################################
    # Need to fix shortcuts
    #####################################################
    foreach my $sc (keys(%shortcuts_to_move)) {
        if (-e $sc) {
            my $target = $shortcuts_to_move{$sc};
            output("Moving '${sc}' to '${target}: ");
            output((run_command('MOVE /Y "'.$sc.'" "'.$target.'"')?'OK':'FAILED')."\n");
        }
    }

    #####################################################
    # Need to delete any desktop shortcuts
    #####################################################
    foreach my $sc (@shortcuts_to_delete) {
        if (-e $sc) {
            output("Deleting '${sc}': ");
            output((run_command('DEL /Q "'.$sc.'"')?'OK':'FAILED')."\n");
        }
    }

    #####################################################
    # Delete the files in sourceFiles because it's BIG
    #   This has the side effect of making it impossible to do a
    #   repair install.
    #####################################################
    if(!run_command("RMDIR /S /Q \"$srcfiledir\"")){
        output("LabVIEW install files were not completely deleted!\n".
               "You might want to clean these up manually\n");
        # Don't stop, because it's likely just a few files left over
    } else {
        output("LabVIEW install files deleted successfully!\n");
    }

    ####################################################
    # Try to stop some of those firewall warnings
    ####################################################
    if(!run_command(join(' ',
                         'netsh', 'advfirewall', 'firewall',
                         'add', 'rule', 'DataFinder',
                         'enable=yes',
                         'action=allow',
                         'profile=domain',
                         'dir=in',
                         'program="'.
                             build_path(get_arch_programfiles(OSARCH_x86),
                                        'National Instruments','Shared',
                                        'DataFinderDesktop','bin',
                                        'datafinder.exe').'"',
                    )))
    {
        output("Firewall rule (Data Finder) installation has failed!\n");
        # Dont stop. Not too large of a deal
    } else {
        output("Installing firewall rules was successful!\n");
    }

    # The update service doesn't need a firewall exception. Block it.
    if(!run_command(join(' ',
                         'netsh', 'advfirewall', 'firewall',
                         'add', 'rule', 'DataFinder',
                         'enable=yes',
                         'action=block',
                         'profile=domain',
                         'dir=in',
                         'program="'.
                             build_path(get_arch_programfiles(OSARCH_x86),
                                        'National Instruments','Shared',
                                        'Update Service',
                                        'niupdateservice.exe').'"',
                    )))
    {
        output("Firewall rule (NI Update Service) installation has failed!\n");
        # Dont stop. Not too large of a deal
    } else {
        output("Installing firewall rules was successful!\n");
    }

    return 1;
}


sub validate_install {
    # Read the results file and verify that all components were installed
    #   sucessfully.

    if (! -f $install_results) {
        output("Cannot find LabVIEW 2016 Install Results!\n");
        return 0;
    }

    ## XML::SAX::PurePerl croaks on the BOM. Do the decoding manually.
    my $content = '';
    if (open(my $IR_CONTENT,'&lt;:raw',$install_results)) {
        $content = decode('UTF-16',join('',&lt;$IR_CONTENT&gt;));
        $content =~ s/\s+encoding="[^"]+"//i;
    } else {
        output("Error opening install results file '${install_results}': $!\n");
        return 0;
    }
    my $results = XMLin($content);

    my $composite_success = 1;
    my $count = 0;
    foreach my $subproduct (keys(%{$results-&gt;{distribution}})) {
        my $outcome = $results-&gt;{distribution}-&gt;{$subproduct}-&gt;{result};
        output("  ${subproduct}: ${outcome}\n");
        if (lc($outcome) ne 'success') {
            $composite_success = 0;
        } else {
            $count++;
        }
    }

    if ($count != $specs{$install_profile}-&gt;{component_count}) {
        output("ERROR: Incorrect count of installed components!\n".
               "Expected(".$specs{$install_profile}-&gt;{component_count}.") Got(".
               $count.")\n");
        $composite_success = 0;
    }

    return $composite_success;
}

sub configure_licensing {
    ####################################################################
    # Run a command using a Labview utility to add a volume license
    #   located at 27001@labview.lic.mst.edu
    ####################################################################
    if(! run_command(join(' ',
                          '"'.$licutil.'"',
                          '-addservers',$flexlm_license_path
                     ))) {
        output("LabVIEW network license was not added correctly!\n");
        return 0;
    } else {
        output("LabVIEW network license was installed\n");
    }

    # This is not crucial to the install being "successful."
    activate_local_licenses();

    return 1;
}

sub activate_local_licenses {
    # Activate local licenses.
    # Local license files are located in:
    #     C:\ProgramData\National Instruments\License Manager\Licenses
    #   The files there contain the FLEXlm feature names and version numbers.
    # Perhaps it would be wiser to parse those files and attempt to activate
    #   all features than to compile a static list here.
    output("    Activating local features for ${install_profile} profile...\n");
    my $local_licenses = build_path($ENV{ProgramData},'National Instruments',
                             'License Manager','Licenses');

    my @all_local_features;
    if (opendir(my $LICDIR,$local_licenses)) {
        foreach my $entry (readdir($LICDIR)) {
            my $lic = build_path($local_licenses,$entry);
            next if (! -f $lic);

            if (open(my $LIC,'&lt;',$lic)) {
                foreach my $line (&lt;$LIC&gt;) {
                    if ($line =~ /^(?:FEATURE|INCREMENT)\s+(\S+)\s+\S+\s+(\S+)\s+/) {
                        output("   [DETECT_LOCAL_LICENSE] (${lic}) '$1','$2'\n",
                               LOG_ONLY);
                        push(@all_local_features,[$1,$2]);
                    }
                }

                close($LIC);
            } else {
                output("Error opening file '${lic}' to look for licenses: $!\n");
            }
        }
    }

    foreach my $feature (@all_local_features) {
        output("      ".join(' ',@$feature)."\n");
        if(! run_command(join(' ',
                              'start','/wait','""',
                              '"'.$licutil.'"',
                              '-s',
                              '-activate', '"'.join(' ',@$feature).'"',
                              '-serialnumber', '"M63X12479"',
                              '-firstname', '"Missouri S&amp;T"',
                              '-lastname', '"Missouri S&amp;T"',
                              '-organizationname', '"Missouri S&amp;T"',
                         ))) {
            # In my experience, even when this fails, it doesn't report it.
            output("LabVIEW local license activation did not succeed!\n");
            # Not fatal
        } else {
            output("LabVIEW local license activation reported success.\n",
                   LOG_ONLY);
        }
    }

    return 1; # meaningless
}
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\labview.2017\prod\update.pl</FullName>
    <Length>25037</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-01-05T12:07:04.1996939-06:00</CreationTime>
    <CreationTimeUtc>2018-01-05T18:07:04.1996939Z</CreationTimeUtc>
    <LastWriteTime>2018-05-21T17:30:19.889474-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-21T22:30:19.889474Z</LastWriteTimeUtc>
    <LastAccessTime>2018-01-05T12:07:04.1996939-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-01-05T18:07:04.1996939Z</LastAccessTimeUtc>
    <Text>=pod
Package Created November 2017
Package Created by Benjamin Krueger

LabVIEW 2017
Packaged with the following addons per Jpetriko request.
Based on the LabVIEW 2017 script.
"LabVIEW" section
     - LabVIEW 2017 (32-bit) English

"LabVIEW Add-Ons: Design" section
     - LabVIEW 2017 Control Design and Simulation Module
     - LabVIEW 2017 MathScript RT Module
"Device Drivers" section
    - NI System Configuration 17.0
    - NI-DAQmx 17.0.0
    - NI ELVISmx 17.0
=cut
$|=1;
use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'labview.2017',
        package_revision =&gt; '20171109T1546',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

use File::Temp qw(tempfile tempdir);
use File::Copy;
use File::Basename;
use File::Path qw(remove_tree);
use Win32;
use XML::Simple;
use Encode;
use Archive::Extract;
use Time::HiRes qw(gettimeofday tv_interval);
use JSON;
use Data::Dumper;

my $srcfiledir = get_pkg_sourcefiles();
my $sourceshare = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\labview_2017";

##############################################################################
# BEGIN Configuration

# The /generatespecfile flag doesn't do any dependency checking! It will
#   let you select items that will cause the install to fail.
# Run setup.exe interactively (no flag) to verify that a set of components
#   to install is valid.
#   Example:
#      The FPGA components require the Xilinx compiler (which I don't think
#        we have.
#
#      The "Visual Studio Integration" components require something to be
#        (pre)installed before they are installable. (DeviceDrivers)

# component_count is used in the validation phase to determine if the
#   expected number of components is installed.
my %specs = (
    'default' =&gt; {
        'labview' =&gt; 'MST.labview.specs',
        'drivers' =&gt; 'MST.devicedrivers.specs',

        'updates' =&gt; 'MST.updates.json',
        'component_count'   =&gt; 7, # manually calculated after an install
    },
);
my $install_profile = 'default'; # configurable via command-line

my $flexlm_license_path = 'labview.lic.mst.edu:27001';

my $licutil = build_path(get_arch_programfiles(OSARCH_x86),
                         'National Instruments', 'Shared',
                         'License Manager', 'Bin',
                         'nilmUtil.exe');

my %shortcuts_to_move = (
    # We usually don't want Desktop icons, ever.
    # In this case, there's no StartMenu icon. move it to the NI folder.
    build_path(get_allusers_desktop(),'NI MAX.lnk') =&gt;
        build_path(get_allusers_start_menu(),'Programs',
                   'National Instruments','NI MAX.lnk'),

);

my @shortcuts_to_delete = (
);

my $install_results = get_default_app_log();
$install_results =~ s/\.txt$/_results.txt/i;


my $updates_dir = 'updates';

# Serial: M63X12479

# A number of components need a reboot in order to be fully complete.
# The WTG/TS data should include a reboot or a reboot+delay+reboot.

# The update service wants a firewall exception.

# END Configuration
##############################################################################

my $skip_updates = 0; # allow for the possibility of skipping the updates.

my $cwd = cwd();
my $isSccmInstall = 0;

##############################################################################
# Check to see if it's being installed by SCCM (package files are
#   currently in cache folder).
# If so, change isSccmInstall to true to use for no_source_files value
#   &amp; preinstall.
##############################################################################
my @splitPath = split(/\\/,$cwd);

# This could be smarter. Have it check to see if the cwd and srcfiles are
#   on the same drive.
if(lc $splitPath[0] eq "c:"){
    $isSccmInstall = 1;
}

use Getopt::Long;
sub usage {
    print qq(
usage: $0 [--help] [--validate] [--preinstall] [--install] [--updates] [--postinstall]

);
}
GetOptions(
    'help' =&gt; sub { usage(); exit(0); },

    'prerequisites' =&gt; sub { exit(! prereq_sub()); },
    'preinstall' =&gt; sub { exit(! preinstall()); },
    'install' =&gt; sub { exit(! install()); },
    'updates' =&gt; sub { exit(! install_updates()); },
    'postinstall' =&gt; sub { exit(! postinstall()); },
    'validate' =&gt; sub { exit(! validate_install()); },

    'skip-updates' =&gt; \$skip_updates,
);
if ($skip_updates) {
    output("Skipping update installation.\n");
}


do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; [qw(clc desktop traveling virtual-clc virtual-desktop)],
    exit_on_failure =&gt; 1,
    no_source_files =&gt; 1, #$isSccmInstall,
    #prerequisite_sub =&gt; \&amp;prereq_sub, # Refer to labview 2014 if you need to check disk space
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    #validate_sub =&gt; \&amp;validate_install,
);

# Warn for reboot if we have gotten to completion - maybe a little overboard
#if ($need_reboot) {
#    output("**THIS PACKAGE REQUIRES A REBOOT BEFORE USE**\n");
#}

IM_Exit(EXIT_SUCCESS);

########################################################################
########################################################################
########################################################################

sub install {
    my ($fh,$temp_logfile,$temp_results,@command,@output,$logfile,$outcome);

    ######################################################################
    # Install the actual LabVIEW 2017 software using a specfile (default
    #   settings) also disabling the update notifications.
    ######################################################################

    ($fh,$temp_logfile) = tempfile('LabviewInstall_install_XXXXXXXX',
                                   DIR =&gt; $ENV{TEMP},
                                   SUFFIX =&gt; '.log');
    close($fh);

    ($fh,$temp_results) = tempfile('LabviewInstall_results_XXXXXXXX',
                                   DIR =&gt; $ENV{TEMP},
                                   SUFFIX =&gt; '.txt');
    close($fh);

	#base installer command, doubles as template for rarely used commands
    my $command = join(' ',
        build_path($sourceshare,'setup.exe'),
        #'/log', sprintf('"%s"',$temp_logfile),
        #'/results', sprintf('"%s"',$temp_results),
        build_path($sourceshare,'2017-spec-noaddons.txt'),
        ' /q',
        ' /AcceptLicenses ', 'yes',
        '/r:n',
        #'/disableNotificationCheck',
        #'/confirmCriticalWarnings'
        #'/generatespecfile spf1'
        );
	my $commandCDSim = join(' ',
		build_path($sourceshare,"LV17_CDSim",'setup.exe'),
		build_path($sourceshare,"LV17_CDSim",'cdsim17.txt'),
        ' /q',
        ' /AcceptLicenses ', 'yes',
		'/r:n',
	);
	my $commandDAQmx = join(' ',
        build_path($sourceshare,"LV17_DAQmx",'setup.exe'),
		build_path($sourceshare,"LV17_DAQmx",'daq17.txt'),
        ' /q',
        ' /AcceptLicenses ', 'yes',
		'/r:n',
	);
	my $commandMSRT = join(' ',
        build_path($sourceshare,"LV17_MSRT",'setup.exe'),
		build_path($sourceshare,"LV17_MSRT",'msrt17.txt'),
        ' /q',
        ' /AcceptLicenses ', 'yes',
		'/r:n',
	);
	my $commandELVISmx = join(' ',
        build_path($sourceshare,"LV17_ELVISmx",'setup.exe'),
		' /applyspecfile ',
		build_path($sourceshare,"LV17_ELVISmx"), #just want the directory of the misuite.xml, not the file itself
        ' /q',
        ' /AcceptLicenses ', 'yes',
		'/r:n',
	);

    output("   Installing LabVIEW 2017: ");
    $outcome = run_command($command, IgnoreExitCodes =&gt; [1618, 3010] );
	output(($outcome?'OK':'FAILED')."\n");
	# $outcome = run_command($commandCDSim, IgnoreExitCodes =&gt; [3010] );
	output("   Installing DAQmx drivers: ");
	$outcome = run_command($commandDAQmx, IgnoreExitCodes =&gt; [3010] );
	output(($outcome?'OK':'FAILED')."\n");
	# $outcome = run_command($commandMSRT, IgnoreExitCodes =&gt; [3010] );
	output("   Installing minimal plugin set: ");
	$outcome = run_command($commandELVISmx, IgnoreExitCodes =&gt; [3010] ); #this installs CDSim &amp; MSRT as well
	output(($outcome?'OK':'FAILED')."\n");


    output(($outcome?'OK':'FAILED')."\n");

=cut      #DOC STR ENDS HERE
    #Install poorly named to modules and drivers.
    #Some of them come as executables, some are msi's, none are easy to find and for some reason we have millions of
    #useless files in the same directory as well...
    #Executable Supplemental Programs First..
    #NIDAQnx
    $command = join(' ',
        build_path($sourceshare,"Distributions","NI-DAQmx","setup.exe"),
        build_path($sourceshare,"Distributions","spf2"),
        '/q',
        '/r:n',
        '/AcceptLicenses', 'yes',

        #'/results', sprintf('"%s"',$temp_results),
        '/disableNotificationCheck',
        '/confirmCriticalWarnings'
    );
    output("    Installing NI-DAQmx Software");
    $outcome = run_command($command, IgnoreExitCodes =&gt; [3010]);
    output(($outcome?'OK':'FAILED')."\n");

    #ELVISmx
    $command = join(' ',
        build_path($sourceshare,"Distributions","ELVISmx","setup.exe"),
        '/q',
        '/r:n',
        '/AcceptLicenses', 'yes',
        '/log', sprintf('"%s"',$temp_logfile),
        #'/results', sprintf('"%s"',$temp_results),
        #'/applyspecfile', build_path($sourceshare),
        '/disableNotificationCheck',
        '/confirmCriticalWarnings'
    );
    output("    Installing ELVISmx Software");
    $outcome = run_command($command, IgnoreExitCodes =&gt; [3010]);
    output(($outcome?'OK':'FAILED')."\n");

    #Now For the MSI installers.
    #Start with Control Design Simulation Module
    my $msi_path = build_path($sourceshare,"Distributions","LV_CDS64","Products","Control_Design_Sim_Module_64_2017","LV_Co00","LV_CD_Sim64.msi");
    output("    Installing Design Simulation MSI.");
    $outcome = install_msi(msi=&gt;$msi_path);
    output(($outcome?'OK':'FAILED')."\n");

    #Next we need MathScript
    $msi_path = build_path($sourceshare,"Distributions","LV_MSRT","Products","LabVIEW_MathScript_RT_2017","lvmsrt01","LVMathScriptRT.msi");
    output("    Installing MathScript RT");
    $outcome = install_msi(msi=&gt;$msi_path);
    output(($outcome?'OK':'FAILED')."\n");

    # Copy the log files.
    $logfile = get_default_app_log();
    output("   Copying (Install) '${temp_logfile}' =&gt; '${logfile}'\n",
           LOG_ONLY);
    copy($temp_logfile,$logfile);
    output("   Copying (Results) '${temp_results}' =&gt; '${install_results}'\n",
           LOG_ONLY);
    copy($temp_results,$install_results);

    # Additional log file dir.
    # The subcomponents that get installed create logs here.
    #   They appear to be named '&lt;component&gt;.txt'.
    my $addl_logs_dir = $temp_logfile.'_additionalLogs';
    if (-d $addl_logs_dir) {
        if (opendir(my $ADDLLOGS,$addl_logs_dir)) {
            while (my $logfile = readdir($ADDLLOGS)) {
                next if ($logfile =~ /^\.?\.$/);

                my $source = build_path($addl_logs_dir,$logfile);

                my $target = get_default_app_log();
                $logfile =~ s/\.txt$//i; # strip the extension
                $target =~ s/\.txt$/__${logfile}.txt/i;

                output("   Copying (Addl) '${source}' =&gt; '${target}'\n", LOG_ONLY);
                if (!copy($source,$target)) {
                    output("  ERROR: $!\n",LOG_ONLY);
                }
            }
            closedir($ADDLLOGS);
        } else {
            output("Error opening additional logs dir '${addl_logs_dir}': $!\n",
                   LOG_ONLY);
        }
    }

    # Attempt to install any updates in the 'updates' directory.
    # Failure to update should not be a condition of "successful" installation.
    #   (Depending on the instal profile, some updates may not even apply).
    #install_updates();
=cut
    return $outcome;
} #man this is a long ass install

#
# I used the NI Update Service to download these updates, all of which are
#   .ZIP archives.
# The service downloads them to:
#    %ProgramData%\National Instruments\Update Service\Installers
#   They are ZIP archives (though the filename extension doesn't say so).
# Anecdotal experience suggests that these updates can be re-applied more
#   than once.
# Updates for locally-licensed features are not detected until the local
#   licenses are activated (maybe?).

sub install_updates {
    # Each update is compressed.
    # Unpack and install each one.

    if ($skip_updates) {
        output("   Installing Updates SKIPPED.\n");
        return 1;
    }

    output("   Installing Updates:\n");
    my $_updates_dir = build_path($srcfiledir,$updates_dir);
    if (! -d $_updates_dir) {
        output("     No updates to install.\n");
        return 1;
    }

    # Get the metadata file.
    my $updates;
    eval {
        my $json_file = build_path($_updates_dir,
                                   $specs{$install_profile}-&gt;{updates});
        output("   Updates Metadata: ${json_file}\n", LOG_ONLY);
        my $json_data = get_file_contents($json_file);
        $json_data =~ s/\/\/.*$//gm; # strip out comments
        my $updates_metadata = decode_json($json_data);

        # The metadata could be more complex, if necessary. For now
        #   it's just a list of updates to install.
        $updates = [ @$updates_metadata ];
        output("Updates:\n  ".join("\n  ",@$updates)."\n", LOG_ONLY);
    };

    my $success = 1;
    foreach my $update_file (@$updates) {
        # Only allow archive file types.
        # We can add more later if they're needed. At the moment, NI
        #   distributed all of them as .ZIP.
        next if ($update_file !~ /\.(?:zip)$/);

        my $update_name = $update_file;
        $update_name =~ s/(?:^\d+ |\.[^.]+$)//g;
        output("     ${update_name}: ");

        my $archive = Archive::Extract-&gt;new(
            archive =&gt; build_path($_updates_dir,$update_file)
        );
        if (! $archive) {
            output("FAILED\n     Error creating archive object from file: $!\n");
            $success = 0;
            next;
        }

        my $fssafe_update_name = $update_name;
        $fssafe_update_name =~ s/ /_/g;

        my $update_tmp = tempdir('labview-2017_update__'.
                                     $fssafe_update_name.'__XXXXXXXX',
                                 DIR =&gt; $ENV{TEMP});

        output('X', CONSOLE_ONLY);
        my $extract_start = [gettimeofday()];
        if (! $archive-&gt;extract( to =&gt; $update_tmp )) {
            output("FAILED\n     Error extracting update '${update_file}': $!\n");
            $success = 0;
            next;
        }
        my $elapsed = tv_interval($extract_start);
        output("\n       Extracted: ${elapsed} seconds.\n", LOG_ONLY);

        my $logfile = get_default_app_log();
        $logfile =~ s/(?=\.txt)$/__update__${fssafe_update_name}/i;

        my ($fh,$temp_logfile) = tempfile('labview-2017_update-install__'.
                                          $fssafe_update_name.'__XXXXXXXX',
                                          DIR =&gt; $ENV{TEMP});
        close($fh);

        # Invoke the installer.
        my @command = (
            'cmd','/c','start','/wait','""',
            build_path($update_tmp,'setup.exe'),
            '/log','"'.$temp_logfile.'"',
            '/qn', # no interaction
            '/AcceptLicenses','yes',
            '/r:n', # suppress reboot
        );
        if (! copy($temp_logfile,$logfile)) {
            # not a fatal error
            output("        Error copying log file '${temp_logfile}' to '${logfile}': $!\n", LOG_ONLY);
        }
        # Check for additional logs

        output('I', CONSOLE_ONLY);
        my $outcome =
            run_command(join(' ',@command),
                        Description =&gt; 'installing update: '.$update_name,
                        IgnoreExitCodes =&gt; [3010,1]
            );

        output(($outcome?' OK':' FAILED')."\n");
        $success &amp;&amp;= $outcome;

        my $errors;
        remove_tree($update_tmp, { error =&gt; \$errors } );

        if( defined $errors )
        {
          output( join( @$errors, '\n' ), LOG_ONLY );
        }
    }

    # It's possible that some updates do not apply. Perhaps failure here
    #   should only be advisory.
    return $success;
}

sub postinstall {
    #####################################################
    # Application Licensing
    #####################################################
    return 0 if (! configure_licensing());


    #####################################################
    # Need to fix shortcuts
    #####################################################
    foreach my $sc (keys(%shortcuts_to_move)) {
        if (-e $sc) {
            my $target = $shortcuts_to_move{$sc};
            output("Moving '${sc}' to '${target}: ");
            output((run_command('MOVE /Y "'.$sc.'" "'.$target.'"')?'OK':'FAILED')."\n");
        }
    }

    #####################################################
    # Need to delete any desktop shortcuts
    #####################################################
    foreach my $sc (@shortcuts_to_delete) {
        if (-e $sc) {
            output("Deleting '${sc}': ");
            output((run_command('DEL /Q "'.$sc.'"')?'OK':'FAILED')."\n");
        }
    }

    #####################################################
    # Delete the files in sourceFiles because it's BIG
    #   This has the side effect of making it impossible to do a
    #   repair install.
    #####################################################
    if(!run_command("RMDIR /S /Q \"$srcfiledir\"")){
        output("LabVIEW install files were not completely deleted!\n".
               "You might want to clean these up manually\n");
        # Don't stop, because it's likely just a few files left over
    } else {
        output("LabVIEW install files deleted successfully!\n");
    }

    ####################################################
    # Try to stop some of those firewall warnings
    ####################################################
    if(!run_command(join(' ',
                         'netsh', 'advfirewall', 'firewall',
                         'add', 'rule', 'DataFinder',
                         'enable=yes',
                         'action=allow',
                         'profile=domain',
                         'dir=in',
                         'program="'.
                             build_path(get_arch_programfiles(OSARCH_x86),
                                        'National Instruments','Shared',
                                        'DataFinderDesktop','bin',
                                        'datafinder.exe').'"',
                    )))
    {
        output("Firewall rule (Data Finder) installation has failed!\n");
        # Dont stop. Not too large of a deal
    } else {
        output("Installing firewall rules was successful!\n");
    }

    # The update service doesn't need a firewall exception. Block it.
    if(!run_command(join(' ',
                         'netsh', 'advfirewall', 'firewall',
                         'add', 'rule', 'DataFinder',
                         'enable=yes',
                         'action=block',
                         'profile=domain',
                         'dir=in',
                         'program="'.
                             build_path(get_arch_programfiles(OSARCH_x86),
                                        'National Instruments','Shared',
                                        'Update Service',
                                        'niupdateservice.exe').'"',
                    )))
    {
        output("Firewall rule (NI Update Service) installation has failed!\n");
        # Dont stop. Not too large of a deal
    } else {
        output("Installing firewall rules was successful!\n");
    }
    return 1;
}


sub validate_install {
    # Read the results file and verify that all components were installed
    #   sucessfully.

    if (! -f $install_results) {
        output("Cannot find LabVIEW 2017 Install Results!\n");
        return 0;
    }

    ## XML::SAX::PurePerl croaks on the BOM. Do the decoding manually.
    my $content = '';
    if (open(my $IR_CONTENT,'&lt;:raw',$install_results)) {
        $content = decode('UTF-16',join('',&lt;$IR_CONTENT&gt;));
        $content =~ s/\s+encoding="[^"]+"//i;
    } else {
        output("Error opening install results file '${install_results}': $!\n");
        return 0;
    }
    my $results = XMLin($content);

    my $composite_success = 1;
    my $count = 0;
    foreach my $subproduct (keys(%{$results-&gt;{distribution}})) {
        my $outcome = $results-&gt;{distribution}-&gt;{$subproduct}-&gt;{result};
        output("  ${subproduct}: ${outcome}\n");
        if (lc($outcome) ne 'success') {
            $composite_success = 0;
        } else {
            $count++;
        }
    }

    if ($count != $specs{$install_profile}-&gt;{component_count}) {
        output("ERROR: Incorrect count of installed components!\n".
               "Expected(".$specs{$install_profile}-&gt;{component_count}.") Got(".
               $count.")\n");
        $composite_success = 0;
    }

    return $composite_success;
}

sub configure_licensing {
    ####################################################################
    # Run a command using a Labview utility to add a volume license
    #   located at 27001@labview.lic.mst.edu
    ####################################################################
    if(! run_command(join(' ',
                          '"'.$licutil.'"',
                          '-addservers',$flexlm_license_path
                     ))) {
        output("LabVIEW network license was not added correctly!\n");
        return 0;
    } else {
        output("LabVIEW network license was installed\n");
    }

    # This is not crucial to the install being "successful."
    activate_local_licenses();

    return 1;
}

sub activate_local_licenses {
    # Activate local licenses.
    # Local license files are located in:
    #     C:\ProgramData\National Instruments\License Manager\Licenses
    #   The files there contain the FLEXlm feature names and version numbers.
    # Perhaps it would be wiser to parse those files and attempt to activate
    #   all features than to compile a static list here.
    output("    Activating local features for ${install_profile} profile...\n");
    my $local_licenses = build_path($ENV{ProgramData},'National Instruments',
                             'License Manager','Licenses');

    my @all_local_features;
    if (opendir(my $LICDIR,$local_licenses)) {
        foreach my $entry (readdir($LICDIR)) {
            my $lic = build_path($local_licenses,$entry);
            next if (! -f $lic);

            if (open(my $LIC,'&lt;',$lic)) {
                foreach my $line (&lt;$LIC&gt;) {
                    if ($line =~ /^(?:FEATURE|INCREMENT)\s+(\S+)\s+\S+\s+(\S+)\s+/) {
                        output("   [DETECT_LOCAL_LICENSE] (${lic}) '$1','$2'\n",
                               LOG_ONLY);
                        push(@all_local_features,[$1,$2]);
                    }
                }

                close($LIC);
            } else {
                output("Error opening file '${lic}' to look for licenses: $!\n");
            }
        }
    }

    foreach my $feature (@all_local_features) {
        output("      ".join(' ',@$feature)."\n");
        if(! run_command(join(' ',
                              'start','/wait','""',
                              '"'.$licutil.'"',
                              '-s',
                              '-activate', '"'.join(' ',@$feature).'"',
                              '-serialnumber', '"M63X12479"',
                              '-firstname', '"Missouri S&amp;T"',
                              '-lastname', '"Missouri S&amp;T"',
                              '-organizationname', '"Missouri S&amp;T"',
                         ))) {
            # In my experience, even when this fails, it doesn't report it.
            output("LabVIEW local license activation did not succeed!\n");
            # Not fatal
        } else {
            output("LabVIEW local license activation reported success.\n",
                   LOG_ONLY);
        }
    }

    return 1; # meaningless
}
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\labview.2017\prod_old\update.pl</FullName>
    <Length>23937</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-29T14:26:03.5044629-06:00</CreationTime>
    <CreationTimeUtc>2017-11-29T20:26:03.5044629Z</CreationTimeUtc>
    <LastWriteTime>2018-01-04T13:55:34.8682327-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-04T19:55:34.8682327Z</LastWriteTimeUtc>
    <LastAccessTime>2016-11-28T10:18:47-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-11-28T16:18:47Z</LastAccessTimeUtc>
    <Text>=pod
Package Created November 2017
Package Created by Benjamin Krueger

LabVIEW 2017
Packaged with the following addons per Jpetriko request.
Based on the LabVIEW 2017 script.
"LabVIEW" section
     - LabVIEW 2017 (32-bit) English

"LabVIEW Add-Ons: Design" section
     - LabVIEW 2017 Control Design and Simulation Module
     - LabVIEW 2017 MathScript RT Module
"Device Drivers" section
    - NI System Configuration 17.0
    - NI-DAQmx 17.0.0
    - NI ELVISmx 17.0
=cut
$|=1;
use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'labview.2017',
        package_revision =&gt; '20171109T1546',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

use File::Temp qw(tempfile tempdir);
use File::Copy;
use File::Basename;
use File::Path qw(remove_tree);
use Win32;
use XML::Simple;
use Encode;
use Archive::Extract;
use Time::HiRes qw(gettimeofday tv_interval);
use JSON;
use Data::Dumper;

my $srcfiledir = get_pkg_sourcefiles();
my $sourceshare = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\labview_2017";

##############################################################################
# BEGIN Configuration

# The /generatespecfile flag doesn't do any dependency checking! It will
#   let you select items that will cause the install to fail.
# Run setup.exe interactively (no flag) to verify that a set of components
#   to install is valid.
#   Example:
#      The FPGA components require the Xilinx compiler (which I don't think
#        we have.
#
#      The "Visual Studio Integration" components require something to be
#        (pre)installed before they are installable. (DeviceDrivers)

# component_count is used in the validation phase to determine if the
#   expected number of components is installed.
my %specs = (
    'default' =&gt; {
        'labview' =&gt; 'MST.labview.specs',
        'drivers' =&gt; 'MST.devicedrivers.specs',

        'updates' =&gt; 'MST.updates.json',
        'component_count'   =&gt; 7, # manually calculated after an install
    },
);
my $install_profile = 'default'; # configurable via command-line

my $flexlm_license_path = 'labview.lic.mst.edu:27001';

my $licutil = build_path(get_arch_programfiles(OSARCH_x86),
                         'National Instruments', 'Shared',
                         'License Manager', 'Bin',
                         'nilmUtil.exe');

my %shortcuts_to_move = (
    # We usually don't want Desktop icons, ever.
    # In this case, there's no StartMenu icon. move it to the NI folder.
    build_path(get_allusers_desktop(),'NI MAX.lnk') =&gt;
        build_path(get_allusers_start_menu(),'Programs',
                   'National Instruments','NI MAX.lnk'),

);

my @shortcuts_to_delete = (
);

my $install_results = get_default_app_log();
$install_results =~ s/\.txt$/_results.txt/i;


my $updates_dir = 'updates';

# Serial: M63X12479

# A number of components need a reboot in order to be fully complete.
# The WTG/TS data should include a reboot or a reboot+delay+reboot.

# The update service wants a firewall exception.

# END Configuration
##############################################################################

my $skip_updates = 0; # allow for the possibility of skipping the updates.

my $cwd = cwd();
my $isSccmInstall = 0;

##############################################################################
# Check to see if it's being installed by SCCM (package files are
#   currently in cache folder).
# If so, change isSccmInstall to true to use for no_source_files value
#   &amp; preinstall.
##############################################################################
my @splitPath = split(/\\/,$cwd);

# This could be smarter. Have it check to see if the cwd and srcfiles are
#   on the same drive.
if(lc $splitPath[0] eq "c:"){
    $isSccmInstall = 1;
}

use Getopt::Long;
sub usage {
    print qq(
usage: $0 [--help] [--validate] [--preinstall] [--install] [--updates] [--postinstall]

);
}
GetOptions(
    'help' =&gt; sub { usage(); exit(0); },

    'prerequisites' =&gt; sub { exit(! prereq_sub()); },
    'preinstall' =&gt; sub { exit(! preinstall()); },
    'install' =&gt; sub { exit(! install()); },
    'updates' =&gt; sub { exit(! install_updates()); },
    'postinstall' =&gt; sub { exit(! postinstall()); },
    'validate' =&gt; sub { exit(! validate_install()); },

    'skip-updates' =&gt; \$skip_updates,
);
if ($skip_updates) {
    output("Skipping update installation.\n");
}


do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; [qw(clc desktop traveling virtual-clc virtual-desktop)],
    exit_on_failure =&gt; 1,
    no_source_files =&gt; $isSccmInstall,
    #prerequisite_sub =&gt; \&amp;prereq_sub, # Refer to labview 2014 if you need to check disk space
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    #postinstall_sub =&gt; \&amp;postinstall,
    #validate_sub =&gt; \&amp;validate_install,
);

# Warn for reboot if we have gotten to completion - maybe a little overboard
#if ($need_reboot) {
#    output("**THIS PACKAGE REQUIRES A REBOOT BEFORE USE**\n");
#}

IM_Exit(EXIT_SUCCESS);

########################################################################
########################################################################
########################################################################

sub install {
    my ($fh,$temp_logfile,$temp_results,@command,@output,$logfile,$outcome);

    ######################################################################
    # Install the actual LabVIEW 2017 software using a specfile (default
    #   settings) also disabling the update notifications.
    ######################################################################

    ($fh,$temp_logfile) = tempfile('LabviewInstall_install_XXXXXXXX',
                                   DIR =&gt; $ENV{TEMP},
                                   SUFFIX =&gt; '.log');
    close($fh);

    ($fh,$temp_results) = tempfile('LabviewInstall_results_XXXXXXXX',
                                   DIR =&gt; $ENV{TEMP},
                                   SUFFIX =&gt; '.txt');
    close($fh);


    my $command = join(' ',
        build_path($sourceshare,'setup.exe'),
        
        
         
        #'/log', sprintf('"%s"',$temp_logfile),
        #'/results', sprintf('"%s"',$temp_results),
        build_path($sourceshare,'spf1'),
        ' /qb',
        ' /AcceptLicenses ', 'yes',
        #'/r:n',
        #'/disableNotificationCheck',
        #'/confirmCriticalWarnings'
        #'/generatespecfile spf1'
        );
    
    output("   Installing LabVIEW 2017: ");
    $outcome = run_command($command, IgnoreExitCodes =&gt; [3010] );


    output(($outcome?'OK':'FAILED')."\n");

=cut      #DOC STR ENDS HERE
    #Install poorly named to modules and drivers.
    #Some of them come as executables, some are msi's, none are easy to find and for some reason we have millions of
    #useless files in the same directory as well...
    #Executable Supplemental Programs First..
    #NIDAQnx
    $command = join(' ',
        build_path($sourceshare,"Distributions","NI-DAQmx","setup.exe"),
        build_path($sourceshare,"Distributions","spf2"),
        '/q',
        '/r:n',
        '/AcceptLicenses', 'yes',
        '/log', sprintf('"%s"',$temp_logfile),
        #'/results', sprintf('"%s"',$temp_results),
        '/disableNotificationCheck',
        '/confirmCriticalWarnings'
    );
    output("    Installing NI-DAQmx Software");
    $outcome = run_command($command, IgnoreExitCodes =&gt; [3010]);
    output(($outcome?'OK':'FAILED')."\n");

    #ELVISmx
    $command = join(' ',
        build_path($sourceshare,"Distributions","ELVISmx","setup.exe"),
        '/q',
        '/r:n',
        '/AcceptLicenses', 'yes',
        '/log', sprintf('"%s"',$temp_logfile),
        #'/results', sprintf('"%s"',$temp_results),
        #'/applyspecfile', build_path($sourceshare),
        '/disableNotificationCheck',
        '/confirmCriticalWarnings'
    );
    output("    Installing ELVISmx Software");
    $outcome = run_command($command, IgnoreExitCodes =&gt; [3010]);
    output(($outcome?'OK':'FAILED')."\n");
    
    #Now For the MSI installers.
    #Start with Control Design Simulation Module
    my $msi_path = build_path($sourceshare,"Distributions","LV_CDS64","Products","Control_Design_Sim_Module_64_2017","LV_Co00","LV_CD_Sim64.msi");
    output("    Installing Design Simulation MSI.");
    $outcome = install_msi(msi=&gt;$msi_path);
    output(($outcome?'OK':'FAILED')."\n");

    #Next we need MathScript
    $msi_path = build_path($sourceshare,"Distributions","LV_MSRT","Products","LabVIEW_MathScript_RT_2017","lvmsrt01","LVMathScriptRT.msi");
    output("    Installing MathScript RT");
    $outcome = install_msi(msi=&gt;$msi_path);
    output(($outcome?'OK':'FAILED')."\n");
    
    # Copy the log files.
    $logfile = get_default_app_log();
    output("   Copying (Install) '${temp_logfile}' =&gt; '${logfile}'\n",
           LOG_ONLY);
    copy($temp_logfile,$logfile);
    output("   Copying (Results) '${temp_results}' =&gt; '${install_results}'\n",
           LOG_ONLY);
    copy($temp_results,$install_results);

    # Additional log file dir.
    # The subcomponents that get installed create logs here.
    #   They appear to be named '&lt;component&gt;.txt'.
    my $addl_logs_dir = $temp_logfile.'_additionalLogs';
    if (-d $addl_logs_dir) {
        if (opendir(my $ADDLLOGS,$addl_logs_dir)) {
            while (my $logfile = readdir($ADDLLOGS)) {
                next if ($logfile =~ /^\.?\.$/);

                my $source = build_path($addl_logs_dir,$logfile);

                my $target = get_default_app_log();
                $logfile =~ s/\.txt$//i; # strip the extension
                $target =~ s/\.txt$/__${logfile}.txt/i;

                output("   Copying (Addl) '${source}' =&gt; '${target}'\n", LOG_ONLY);
                if (!copy($source,$target)) {
                    output("  ERROR: $!\n",LOG_ONLY);
                }
            }
            closedir($ADDLLOGS);
        } else {
            output("Error opening additional logs dir '${addl_logs_dir}': $!\n",
                   LOG_ONLY);
        }
    }

    # Attempt to install any updates in the 'updates' directory.
    # Failure to update should not be a condition of "successful" installation.
    #   (Depending on the instal profile, some updates may not even apply).
    #install_updates();
=cut
    return $outcome;
} #man this is a long ass install
sub preinstall
{
    #Install .net 4.6.2
    my $outcome = 0;
    my $command = join(' ', build_path($sourceshare,'dotnetsetup.exe'),'/q','/norestart');
    output("    Installing .NET 4.6.1");
    $outcome = run_command($command,IgnoreExitCodes =&gt; [5100,3010]);
    output(($outcome?'OK':'FAILED')."\n");
    return 1;
}
#
# I used the NI Update Service to download these updates, all of which are
#   .ZIP archives.
# The service downloads them to:
#    %ProgramData%\National Instruments\Update Service\Installers
#   They are ZIP archives (though the filename extension doesn't say so).
# Anecdotal experience suggests that these updates can be re-applied more
#   than once.
# Updates for locally-licensed features are not detected until the local
#   licenses are activated (maybe?).

sub install_updates {
    # Each update is compressed.
    # Unpack and install each one.

    if ($skip_updates) {
        output("   Installing Updates SKIPPED.\n");
        return 1;
    }

    output("   Installing Updates:\n");
    my $_updates_dir = build_path($srcfiledir,$updates_dir);
    if (! -d $_updates_dir) {
        output("     No updates to install.\n");
        return 1;
    }

    # Get the metadata file.
    my $updates;
    eval {
        my $json_file = build_path($_updates_dir,
                                   $specs{$install_profile}-&gt;{updates});
        output("   Updates Metadata: ${json_file}\n", LOG_ONLY);
        my $json_data = get_file_contents($json_file);
        $json_data =~ s/\/\/.*$//gm; # strip out comments
        my $updates_metadata = decode_json($json_data);

        # The metadata could be more complex, if necessary. For now
        #   it's just a list of updates to install.
        $updates = [ @$updates_metadata ];
        output("Updates:\n  ".join("\n  ",@$updates)."\n", LOG_ONLY);
    };

    my $success = 1;
    foreach my $update_file (@$updates) {
        # Only allow archive file types.
        # We can add more later if they're needed. At the moment, NI
        #   distributed all of them as .ZIP.
        next if ($update_file !~ /\.(?:zip)$/);

        my $update_name = $update_file;
        $update_name =~ s/(?:^\d+ |\.[^.]+$)//g;
        output("     ${update_name}: ");

        my $archive = Archive::Extract-&gt;new(
            archive =&gt; build_path($_updates_dir,$update_file)
        );
        if (! $archive) {
            output("FAILED\n     Error creating archive object from file: $!\n");
            $success = 0;
            next;
        }

        my $fssafe_update_name = $update_name;
        $fssafe_update_name =~ s/ /_/g;

        my $update_tmp = tempdir('labview-2017_update__'.
                                     $fssafe_update_name.'__XXXXXXXX',
                                 DIR =&gt; $ENV{TEMP});

        output('X', CONSOLE_ONLY);
        my $extract_start = [gettimeofday()];
        if (! $archive-&gt;extract( to =&gt; $update_tmp )) {
            output("FAILED\n     Error extracting update '${update_file}': $!\n");
            $success = 0;
            next;
        }
        my $elapsed = tv_interval($extract_start);
        output("\n       Extracted: ${elapsed} seconds.\n", LOG_ONLY);

        my $logfile = get_default_app_log();
        $logfile =~ s/(?=\.txt)$/__update__${fssafe_update_name}/i;

        my ($fh,$temp_logfile) = tempfile('labview-2017_update-install__'.
                                          $fssafe_update_name.'__XXXXXXXX',
                                          DIR =&gt; $ENV{TEMP});
        close($fh);

        # Invoke the installer.
        my @command = (
            'cmd','/c','start','/wait','""',
            build_path($update_tmp,'setup.exe'),
            '/log','"'.$temp_logfile.'"',
            '/qn', # no interaction
            '/AcceptLicenses','yes',
            '/r:n', # suppress reboot
        );
        if (! copy($temp_logfile,$logfile)) {
            # not a fatal error
            output("        Error copying log file '${temp_logfile}' to '${logfile}': $!\n", LOG_ONLY);
        }
        # Check for additional logs

        output('I', CONSOLE_ONLY);
        my $outcome =
            run_command(join(' ',@command),
                        Description =&gt; 'installing update: '.$update_name,
                        IgnoreExitCodes =&gt; [3010,1]
            );

        output(($outcome?' OK':' FAILED')."\n");
        $success &amp;&amp;= $outcome;

        my $errors;
        remove_tree($update_tmp, { error =&gt; \$errors } );

        if( defined $errors )
        {
          output( join( @$errors, '\n' ), LOG_ONLY );
        }
    }

    # It's possible that some updates do not apply. Perhaps failure here
    #   should only be advisory.
    return $success;
}

sub postinstall {
    #####################################################
    # Application Licensing
    #####################################################
    return 0 if (! configure_licensing());


    #####################################################
    # Need to fix shortcuts
    #####################################################
    foreach my $sc (keys(%shortcuts_to_move)) {
        if (-e $sc) {
            my $target = $shortcuts_to_move{$sc};
            output("Moving '${sc}' to '${target}: ");
            output((run_command('MOVE /Y "'.$sc.'" "'.$target.'"')?'OK':'FAILED')."\n");
        }
    }

    #####################################################
    # Need to delete any desktop shortcuts
    #####################################################
    foreach my $sc (@shortcuts_to_delete) {
        if (-e $sc) {
            output("Deleting '${sc}': ");
            output((run_command('DEL /Q "'.$sc.'"')?'OK':'FAILED')."\n");
        }
    }

    #####################################################
    # Delete the files in sourceFiles because it's BIG
    #   This has the side effect of making it impossible to do a
    #   repair install.
    #####################################################
    if(!run_command("RMDIR /S /Q \"$srcfiledir\"")){
        output("LabVIEW install files were not completely deleted!\n".
               "You might want to clean these up manually\n");
        # Don't stop, because it's likely just a few files left over
    } else {
        output("LabVIEW install files deleted successfully!\n");
    }

    ####################################################
    # Try to stop some of those firewall warnings
    ####################################################
    if(!run_command(join(' ',
                         'netsh', 'advfirewall', 'firewall',
                         'add', 'rule', 'DataFinder',
                         'enable=yes',
                         'action=allow',
                         'profile=domain',
                         'dir=in',
                         'program="'.
                             build_path(get_arch_programfiles(OSARCH_x86),
                                        'National Instruments','Shared',
                                        'DataFinderDesktop','bin',
                                        'datafinder.exe').'"',
                    )))
    {
        output("Firewall rule (Data Finder) installation has failed!\n");
        # Dont stop. Not too large of a deal
    } else {
        output("Installing firewall rules was successful!\n");
    }

    # The update service doesn't need a firewall exception. Block it.
    if(!run_command(join(' ',
                         'netsh', 'advfirewall', 'firewall',
                         'add', 'rule', 'DataFinder',
                         'enable=yes',
                         'action=block',
                         'profile=domain',
                         'dir=in',
                         'program="'.
                             build_path(get_arch_programfiles(OSARCH_x86),
                                        'National Instruments','Shared',
                                        'Update Service',
                                        'niupdateservice.exe').'"',
                    )))
    {
        output("Firewall rule (NI Update Service) installation has failed!\n");
        # Dont stop. Not too large of a deal
    } else {
        output("Installing firewall rules was successful!\n");
    }

    return 1;
}


sub validate_install {
    # Read the results file and verify that all components were installed
    #   sucessfully.

    if (! -f $install_results) {
        output("Cannot find LabVIEW 2017 Install Results!\n");
        return 0;
    }

    ## XML::SAX::PurePerl croaks on the BOM. Do the decoding manually.
    my $content = '';
    if (open(my $IR_CONTENT,'&lt;:raw',$install_results)) {
        $content = decode('UTF-16',join('',&lt;$IR_CONTENT&gt;));
        $content =~ s/\s+encoding="[^"]+"//i;
    } else {
        output("Error opening install results file '${install_results}': $!\n");
        return 0;
    }
    my $results = XMLin($content);

    my $composite_success = 1;
    my $count = 0;
    foreach my $subproduct (keys(%{$results-&gt;{distribution}})) {
        my $outcome = $results-&gt;{distribution}-&gt;{$subproduct}-&gt;{result};
        output("  ${subproduct}: ${outcome}\n");
        if (lc($outcome) ne 'success') {
            $composite_success = 0;
        } else {
            $count++;
        }
    }

    if ($count != $specs{$install_profile}-&gt;{component_count}) {
        output("ERROR: Incorrect count of installed components!\n".
               "Expected(".$specs{$install_profile}-&gt;{component_count}.") Got(".
               $count.")\n");
        $composite_success = 0;
    }

    return $composite_success;
}

sub configure_licensing {
    ####################################################################
    # Run a command using a Labview utility to add a volume license
    #   located at 27001@labview.lic.mst.edu
    ####################################################################
    if(! run_command(join(' ',
                          '"'.$licutil.'"',
                          '-addservers',$flexlm_license_path
                     ))) {
        output("LabVIEW network license was not added correctly!\n");
        return 0;
    } else {
        output("LabVIEW network license was installed\n");
    }

    # This is not crucial to the install being "successful."
    activate_local_licenses();

    return 1;
}

sub activate_local_licenses {
    # Activate local licenses.
    # Local license files are located in:
    #     C:\ProgramData\National Instruments\License Manager\Licenses
    #   The files there contain the FLEXlm feature names and version numbers.
    # Perhaps it would be wiser to parse those files and attempt to activate
    #   all features than to compile a static list here.
    output("    Activating local features for ${install_profile} profile...\n");
    my $local_licenses = build_path($ENV{ProgramData},'National Instruments',
                             'License Manager','Licenses');

    my @all_local_features;
    if (opendir(my $LICDIR,$local_licenses)) {
        foreach my $entry (readdir($LICDIR)) {
            my $lic = build_path($local_licenses,$entry);
            next if (! -f $lic);

            if (open(my $LIC,'&lt;',$lic)) {
                foreach my $line (&lt;$LIC&gt;) {
                    if ($line =~ /^(?:FEATURE|INCREMENT)\s+(\S+)\s+\S+\s+(\S+)\s+/) {
                        output("   [DETECT_LOCAL_LICENSE] (${lic}) '$1','$2'\n",
                               LOG_ONLY);
                        push(@all_local_features,[$1,$2]);
                    }
                }

                close($LIC);
            } else {
                output("Error opening file '${lic}' to look for licenses: $!\n");
            }
        }
    }

    foreach my $feature (@all_local_features) {
        output("      ".join(' ',@$feature)."\n");
        if(! run_command(join(' ',
                              'start','/wait','""',
                              '"'.$licutil.'"',
                              '-s',
                              '-activate', '"'.join(' ',@$feature).'"',
                              '-serialnumber', '"M63X12479"',
                              '-firstname', '"Missouri S&amp;T"',
                              '-lastname', '"Missouri S&amp;T"',
                              '-organizationname', '"Missouri S&amp;T"',
                         ))) {
            # In my experience, even when this fails, it doesn't report it.
            output("LabVIEW local license activation did not succeed!\n");
            # Not fatal
        } else {
            output("LabVIEW local license activation reported success.\n",
                   LOG_ONLY);
        }
    }

    return 1; # meaningless
}
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\LAPS_admin.x64\update.pl</FullName>
    <Length>1626</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-02-08T16:58:14.3960618-06:00</CreationTime>
    <CreationTimeUtc>2016-02-08T22:58:14.3960618Z</CreationTimeUtc>
    <LastWriteTime>2016-02-08T16:59:05.8458512-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-02-08T22:59:05.8458512Z</LastWriteTimeUtc>
    <LastAccessTime>2016-02-08T16:58:14.3960618-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-02-08T22:58:14.3960618Z</LastAccessTimeUtc>
    <Text># Local Admin Password Solution
# Package Created Feb 8, 2016
# Packaged by Dillon Lustick

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
      package_id =&gt; 'LAPS-admin.x64',
      package_revision =&gt; '20160208T1446',
  );
}

# Add InstallMonkey Library to the path
use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use Getopt::Long;
use InstallMonkey::Shared;

my $admin = 1;

GetOptions(
    'admin' =&gt; \$admin,
);

my $srcfiles = get_pkg_sourcefiles();

sub install {
    ##################################
    # Install the program!
    ##################################
    my $install_string = "msiexec /i $srcfiles\\LAPS.x64.msi /quiet";
    if($admin){
        $install_string .= " TRANSFORMS=$srcfiles\\admin.mst";
    }
    
    output("Installing LAPS: ");
    if(!run_command($install_string)){
        return 0;
    }
    output("DONE\n");
    
    return 1;
}


do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\LAPS_client.x64\prod\update.pl</FullName>
    <Length>1620</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-02-08T15:58:38.5564532-06:00</CreationTime>
    <CreationTimeUtc>2016-02-08T21:58:38.5564532Z</CreationTimeUtc>
    <LastWriteTime>2016-02-08T16:38:11.4887299-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-02-08T22:38:11.4887299Z</LastWriteTimeUtc>
    <LastAccessTime>2016-02-08T16:40:33.7368243-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-02-08T22:40:33.7368243Z</LastAccessTimeUtc>
    <Text># Local Admin Password Solution
# Package Created Feb 8, 2016
# Packaged by Dillon Lustick

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
      package_id =&gt; 'LAPS.x64',
      package_revision =&gt; '20160208T1446',
  );
}

# Add InstallMonkey Library to the path
use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use Getopt::Long;
use InstallMonkey::Shared;

my $admin = 0;

GetOptions(
    'admin' =&gt; \$admin,
);

my $srcfiles = get_pkg_sourcefiles();

sub install {
    ##################################
    # Install the program!
    ##################################
    my $install_string = "msiexec /i $srcfiles\\LAPS.x64.msi /quiet";
    if($admin){
        $install_string .= " TRANSFORMS=$srcfiles\\admin.mst";
    }
    
    output("Installing LAPS: ");
    if(!run_command($install_string)){
        return 0;
    }
    output("DONE\n");
    
    return 1;
}


do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\Lua.5_3_5\prod\update.pl</FullName>
    <Length>1350</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-07-27T11:20:07.4089496-05:00</CreationTime>
    <CreationTimeUtc>2018-07-27T16:20:07.4089496Z</CreationTimeUtc>
    <LastWriteTime>2018-07-30T09:06:54.2547271-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-30T14:06:54.2547271Z</LastWriteTimeUtc>
    <LastAccessTime>2018-07-27T11:20:07.4089496-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-07-27T16:20:07.4089496Z</LastAccessTimeUtc>
    <Text># Lua
# Package Created July 27, 2018
# Packaged by Matthes, Alexander (S&amp;T-IT Employee)
# Last Updated --

BEGIN {
    %::INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'Lua.5_3_5',
        package_revision =&gt; '20180727T1119',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

sub install {
    #There is no instalation.  You have to recompile new files using winGW and
	#put those files into /data/
	
	output("Adding Enviorment Var: ");
	#I am unsure what the $ENV{'SsourceFiles'} does.  but this works so im not going to try and break it.
    output((add_environment_variable("Path","$ENV{'SourceFiles'}C:\\SourceFiles\\Lua.5_3_5\\bin\\")?"OK":"FAILED")."\n");

    output("Installation successful!");
    return 1;
}

do_install( 
    exit_on_failure =&gt; 1,
    allowed_versions          =&gt; [ OSVER_WIN10_SP0 ],
    allowed_os_architectures  =&gt; [ OSARCH_x64 ],
    allowed_regs              =&gt; [ "clc", "desktop", "traveling", "virtual-desktop", "virtual-clc" ],
    install_sub               =&gt; \&amp;install,

    
);

IM_Exit(EXIT_SUCCESS);

########################################################################</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\lyx.2_2_0\prod\update.pl</FullName>
    <Length>1494</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-07-19T11:34:29.5574666-05:00</CreationTime>
    <CreationTimeUtc>2016-07-19T16:34:29.5574666Z</CreationTimeUtc>
    <LastWriteTime>2016-08-04T15:55:59.8405225-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-08-04T20:55:59.8405225Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-19T11:34:29.5886672-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-19T16:34:29.5886672Z</LastAccessTimeUtc>
    <Text># LyX 2.2.0
# Package Created July 2016
# Packaged by Ronith
# Last Updated ...

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'lyx.2_2_0',
        package_revision =&gt; '20160804T1310',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
my $audesktop=$ENV{"public"}."\\desktop";

 sub install {
	output("installing LyX 2.2.0\n");
	if(!run_command("$sourcefilesdir\\setup.exe /S")){
		output("LyX didn't install\n");
		return 0;
	}
	else{
		output("Installation complete! \n");
	}
   return 1;
}

sub postinstall{
	output("removing desktop icons \n");
	run_command("del /q /F \"$audesktop\\LyX 2.2.lnk\"");
	
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling','virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
	install_sub =&gt; \&amp;install,
	postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);


</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\lyx.2_2_2\prod\update.pl</FullName>
    <Length>1558</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-05-25T10:19:38.1432121-05:00</CreationTime>
    <CreationTimeUtc>2017-05-25T15:19:38.1432121Z</CreationTimeUtc>
    <LastWriteTime>2017-06-21T13:29:37.8858084-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-21T18:29:37.8858084Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-19T11:34:29-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-19T16:34:29Z</LastAccessTimeUtc>
    <Text># LyX 2.2.2
# Package Created May 25, 2017
# Packaged by Austin Wall
# Last Updated June 21, 2017 by Austin Wall

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'lyx.2_2_2',
        package_revision =&gt; '20170621T1329',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
my $audesktop=$ENV{"public"}."\\desktop";
# MiKTeX should be installed before trying to install LyX.
sub install {
    output("Installing LyX 2.2.2\n");
    if(!run_command("$sourcefilesdir\\LyX-222-Installer-4.exe /S")){
        output("LyX didn't install\n$!");
        return 0;
    }
    else{
        output("Installation complete! \n");
    }
    return 1;
}

sub postinstall{
    output("removing desktop icons \n");
    run_command("del /q /F \"$audesktop\\LyX 2.2.lnk\"") or output("Error removing desktop icons!\n$!"); # The second condition of an 'or' is only evaluated if the first is false.

}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling','virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);


</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\lyx.2_2_3\prod\update.pl</FullName>
    <Length>1568</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-07T11:34:20.7883873-05:00</CreationTime>
    <CreationTimeUtc>2018-06-07T16:34:20.7883873Z</CreationTimeUtc>
    <LastWriteTime>2018-06-07T13:57:00.2795111-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-07T18:57:00.2795111Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-19T11:34:29-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-19T16:34:29Z</LastAccessTimeUtc>
    <Text># LyX 2.2.3
# Package Created June 07, 2018
# Packaged by Benjamin Krueger
# Last Updated June 21, 2018 by Benjamin Krueger

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'lyx.2_2_3',
        package_revision =&gt; '20180607T1136',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
my $audesktop=$ENV{"public"}."\\desktop";
# MiKTeX should be installed before trying to install LyX.
sub install {
    output("Installing LyX 2.2.3\n");
    if(!run_command("$sourcefilesdir\\LyX-223-Bundle-2.exe /S")){
        output("LyX didn't install\n$!");
        return 0;
    }
    else{
        output("Installation complete! \n");
    }
    return 1;
}

sub postinstall{
    output("removing desktop icons \n");
    run_command("del /q /F \"$audesktop\\LyX 2.2.3.lnk\"") or output("Error removing desktop icons!\n$!"); # The second condition of an 'or' is only evaluated if the first is false.

}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling','virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);


</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\magma.5_3\prod\update.pl</FullName>
    <Length>8599</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-06-07T11:41:05.3763624-05:00</CreationTime>
    <CreationTimeUtc>2016-06-07T16:41:05.3763624Z</CreationTimeUtc>
    <LastWriteTime>2016-09-08T15:49:36.7581037-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-09-08T20:49:36.7581037Z</LastWriteTimeUtc>
    <LastAccessTime>2016-06-07T11:41:05.4075628-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-06-07T16:41:05.4075628Z</LastAccessTimeUtc>
    <Text># Magma 5.3
# Package Created June 7, 2016
# Packaged by Ronith (based on Eric Boyer's 5.2 package)
# Last Updated 2016-09-08 by Grayson Gratop

=pod

Begin-Doc
Modified: $Date$
Name: MAGMAsoft v5.3.0.10 package
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'magma.5_3',
        package_revision =&gt; '20160607T1100',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

use File::Basename;

#
# Usage MAGMA5-Setup.exe [options ...]
# 
# Available Options:
#   /help                      display this information
#   /mode [ARG]                set the mode to run the installer in
#                              Available values: console, default, silent, or
#                              standard
#   /prefix [ARG]              set the installation directory
#   /response-file [ARG]       a file to read installer responses from
#   /save-response-file [ARG]  a file to write installer responses to when the
#                              installer exits
#   /temp [ARG]                set the temporary directory used by this program
#   /version                   display installer version information
# 
# 

########################################################################
# BEGIN Configuration

# The MAGMAsoft installer is in the 'magma' directory in srcfiles.
my $install_source = build_path(get_pkg_sourcefiles(),'magma');

my $install_dir = build_path($ENV{SystemDrive},'MAGMA5','v5.3.0');
my $bin_dir = build_path($install_dir,'WINDOWS64','bin');
my $license_server = 'magmasoft.lic.mst.edu';

# The Foseco Pro installer is in the 'FosecoDB' directory in srcfiles.
my $fosecodb_source = build_path(get_pkg_sourcefiles(),'FosecoDB');
my $fosecodb_dest = build_path($install_dir,'lib','FosecoDB');

my %response_replacements = (
    __INSTALLDIR__ =&gt; $install_dir,
    __LICENSESERVER__ =&gt; $license_server,
);

# END Configuration
########################################################################


sub install {
    my $response_file = create_response_file($install_source);
    my @command = (
        cmd_quote(build_path($install_source,'MAGMA5-Setup.exe')),
        '/mode', 'silent',
        '/response-file', cmd_quote(basename($response_file)),
        );

    output("Installing MagmaSoft 5.3:");
    # The installer really wants the CWD to be where MAGMA5-Setup.exe is.
    push_dir(build_path($install_source));
    #start_global_MSI_logging();
    my $outcome = run_command(join(' ',@command),
                              'Description' =&gt; 'installing MAGMAsoft');
    #sleep(80);
    #run_command("pskill /accepteula install.exe");
    #finish_global_MSI_logging();
    output(($outcome?'SUCCESS':'FAILURE')."\n");
    pop_dir();
    return $outcome;
}


sub postinstall {
    my $success = 1;

    $success &amp;&amp;= install_FosecoDB();
    $success &amp;&amp;= configure_firewall();
    $success &amp;&amp;= grant_access();
    
    return $success;
}

do_install( 
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [qw(clc desktop traveling virtual-clc virtual-desktop)],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);
IM_Exit(EXIT_SUCCESS);


########################################################################

# Begin-Doc
################################
# Name: create_response_file()
# Description: Create a response file (based on the template in the __DATA__
#   section) with the values that will be used on this machine.
# Returns: the path to the response file or undef on error.
# Requires: The data used to create the template was created using the
#    /save-response-file flag of the MAGMA-setup.exe installer.
# LastUpdated: 
# LastUpdatedBy: 
################################
# End-Doc
sub create_response_file {
    my $target_dir = shift;
    my $response_file = build_path($target_dir,
                                   'mst_install.response.txt');
    if (open(my $RESPONSE,'&gt;',$response_file)) {
        for my $line (&lt;DATA&gt;) {
            foreach my $kw (keys(%response_replacements)) {
                my $repl = $response_replacements{$kw};
                $line =~ s/$kw/$repl/g;
            }
            print $RESPONSE $line;
        }
        close($RESPONSE);
    } else {
        output("Error creating installer response file '${response_file}': $!\n");
        return undef;
    }

    output(join("\n",
                "Installer Response File:",
                ('-' x 60),
                get_file_contents($response_file),
                ('-' x 60),
                ''),
           LOG_ONLY);
    return $response_file;
}

# Begin-Doc
################################
# Name: install_FosecoDB()
# Description: install the Foseco Pro module for MAGMA5
# Returns: 
# Requires: 
# LastUpdated: 
# LastUpdatedBy:
################################
# End-Doc
sub install_FosecoDB {
    # Install FosecoDB
    output("Installing FosecoDB: ");
    my @command = (
        'xcopy.exe', '/Y','/E','/I',
        cmd_quote($fosecodb_source),
        cmd_quote($fosecodb_dest),
        );
    if(!run_command(join(' ',@command),
                    'Description' =&gt; 'installing FosecoDB')) {
        output( "FAILED\n" );
        return 0;
    }
    output("OK\n");
    return 1;
}


# Begin-Doc
################################
# Name: configure_firewall()
# Description: Precreate firewall rules so that Windows doesn't bother the
#   (first-run) user with "Windows firewall has blocked..." messages.
# Returns: true/false on the composite success/failure of the rule creations.
# LastUpdated: 
# LastUpdatedBy: 
################################
# End-Doc
sub configure_firewall {
    my @programs = map { build_path($bin_dir,$_) }
                       qw(ms.exe magmapvs.exe magmagui_helper.exe
                          MAGMAcad.exe MAGMArun.exe MAGMAdata.exe
                          MAGMAsolver_hpSHM.exe mpid.exe mpirun.exe);

    # I'm fairly certain that none of these programs need to be accessed
    #   remotely via IP under normal circumstances.
    # We're going to precreate firewall rules so that the user isn't bothered
    #   by the notifications that Windows gives the first time the application
    #   is run.
    my $success = 1;
    foreach my $program (@programs) {
        my @command = (
            'netsh.exe',
            'advfirewall', 'firewall',
            'add','rule','"MAGMAsoft - '.basename($program,'.exe').'"',
            'dir=in',
            'action=block',
            'enable=yes',
            'profile=any',
            'program="'.$program.'"'
            );
        if (! run_command(join(' ',@command),
                          'Description' =&gt; 'adding MAGMAsoft firewall rule for'.
                                           ' '.basename($program))) {
            $success = 0;
        }

    }

    return $success;
}

# Begin-Doc
################################
# Name: grant_access()
# Description: Grants all users access to the C:\VULCAN_HOME directory
# Returns: true/false on the composite success/failure of granting access.
# LastUpdated: 2016-09-08
# LastUpdatedBy: Grayson Gratop
################################
sub grant_access {
    output("Granting access to C:\\VULCAN_HOME: ");

    my $success = 1;

    if (!(-d "C:\\VULCAN_HOME")) {
        $success &amp;= run_command("mkdir C:\\VULCAN_HOME");
    }

    $success &amp;= run_command("icacls \"C:\\VULCAN_HOME\" /grant Users:(OI)(CI)F /T");

    if ($success) {
        output("OK\n");
        return 1;
    }
    else {
        output("FAILED\n");
        return 0;
    }
}

__DATA__
CreateDesktopShortcut: No
CreateQuickLaunchShortcut: No
InstallDir: __INSTALLDIR__
InstallMode: Standard
InstallType: Custom
LaunchApplication: No
ProgramFolderName: MAGMA5.3
SelectedComponents: WG-MAGMA5,WG-WINDOWS64
ViewReadme: Yes
LicCmPort: 22350
LicM5Host: __LICENSESERVER__
LicM5Port1: 6997
LicServer: Client
MAGMA5runtime: 0.0
M5SelectedComponents: WG-MAGMA5 WG-WINDOWS64
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\magma.5_3_1_0\dev\update.pl</FullName>
    <Length>9500</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-08-17T14:53:07.4712862-05:00</CreationTime>
    <CreationTimeUtc>2017-08-17T19:53:07.4712862Z</CreationTimeUtc>
    <LastWriteTime>2017-08-22T14:40:29.2670807-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-08-22T19:40:29.2670807Z</LastWriteTimeUtc>
    <LastAccessTime>2017-08-17T14:53:07.4712862-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-08-17T19:53:07.4712862Z</LastAccessTimeUtc>
    <Text># Magma 5.3.1.0
# Package Created August 17, 2017
# Packaged by Jason S. Holm (with code by Ronith and based on Eric Boyer's 5.2 package with updates by Grayson Gratop)
# Last Update: August 22, 2017
=pod

Begin-Doc
Modified: $Date$
Name: MAGMAsoft v5.3.1.0 package
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'magma.5_3_1_0',
        package_revision =&gt; '20170822T0910',
    );
}
my $umrinst = $ENV{'WINDIR'}.'\\SYSTEM32\\UMRINST';
use lib (
    '\\\\minerfiles.mst.edu\\dfs\\software\\loginscripts\\im',
    '$umrinst',
    'C:\\temp',
);

use InstallMonkey::Shared;

use File::Basename;

#
# Usage MAGMA5-Setup.exe [options ...]
# 
# Available Options:
#   /help                      display this information
#   /mode [ARG]                set the mode to run the installer in
#                              Available values: console, default, silent, or
#                              standard
#   /prefix [ARG]              set the installation directory
#   /response-file [ARG]       a file to read installer responses from
#   /save-response-file [ARG]  a file to write installer responses to when the
#                              installer exits
#   /temp [ARG]                set the temporary directory used by this program
#   /version                   display installer version information
# 
# 

########################################################################
# BEGIN Configuration

# The MAGMAsoft installer is in the 'magma' directory in srcfiles.
my $install_source  = build_path(
                                 get_pkg_sourcefiles(),
                                 'magma'
								);

my $install_dir     = build_path(
                                 $ENV{SystemDrive},
								 'MAGMA5',
								 'v5.3.1.0'
								 );

my $bin_dir         = build_path(
                                 $install_dir,
                                 'WINDOWS64',
								 'bin'
								 );
								 
my $license_server  = 'magmasoft.lic.mst.edu';

# The Foseco Pro installer is in the 'FosecoDB' directory in srcfiles.

my $fosecodb_source = build_path(
                                 get_pkg_sourcefiles(),
								 'FosecoDB'
								 );

my $fosecodb_dest   = build_path(
                                 $install_dir,
                                 'lib',
								 'FosecoDB'
								 );

my %response_replacements = (
                             __INSTALLDIR__    =&gt; $install_dir,
                             __LICENSESERVER__ =&gt; $license_server,
                             );

							 
# END Configuration
########################################################################


sub install {
    my $response_file = create_response_file($install_source);
    my @command = (
	               cmd_quote(build_path($install_source,'MAGMA5-Setup.exe')),
                   '/mode',
				   'silent',
                   '/response-file',
				   cmd_quote(basename($response_file)),
                  );

    output("Installing MagmaSoft 5.3.1.0:");
    
	# The installer really wants the CWD to be where MAGMA5-Setup.exe is.
    push_dir(build_path($install_source));
    
	#start_global_MSI_logging();

    my $outcome = run_command(
	                          join(' ',@command),
                              'Description' =&gt; 'Installing MAGMAsoft');
    #sleep(80);
    #run_command("pskill /accepteula install.exe");
    #finish_global_MSI_logging();

    output(($outcome?'SUCCESS':'FAILURE')."\n");
    pop_dir();
    return $outcome;
}


sub postinstall {
    my $success = 1;

    $success &amp;&amp;= install_FosecoDB();
    $success &amp;&amp;= configure_firewall();
    $success &amp;&amp;= grant_access();
    
    return $success;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);
IM_Exit(EXIT_SUCCESS);


########################################################################

# Begin-Doc
################################
# Name:        create_response_file()
# Description: Create a response file (based on the template in the __DATA__
#              section) with the values that will be used on this machine.
# Returns:     Path to the response file or undef on error.
# Requires:    The data used to create the template was created using the
#              /save-response-file flag of the MAGMA-setup.exe installer.
#              One might need to create a new response file for each
#              updated version of the software.
# Last Update: n/a
# Updated By:  n/a
################################
# End-Doc
sub create_response_file {
    my $target_dir    = shift;
    my $response_file = build_path(
	                               $target_dir,
                                   'mst_install.response.txt'
								  );
								  
    if (open(my $RESPONSE,'&gt;',$response_file)) {
        for my $line (&lt;DATA&gt;) {
            foreach my $kw (keys(%response_replacements)) {
                my $repl = $response_replacements{$kw};
                $line =~ s/$kw/$repl/g;
            }
            print $RESPONSE $line;
        }
        close($RESPONSE);
    } else {
        output("Error creating installer response file '${response_file}': $!\n");
        return undef;
    }

    output(join("\n",
                "Installer Response File:",
                ('-' x 60),
                get_file_contents($response_file),
                ('-' x 60),
                ''),
           LOG_ONLY);
    return $response_file;
}

# Begin-Doc
################################
# Name: install_FosecoDB()
# Description: install the Foseco Pro module for MAGMA5
# Returns: 
# Requires: 
# LastUpdated: 
# LastUpdatedBy:
################################
# End-Doc
sub install_FosecoDB {
    # Install FosecoDB
    output("Installing FosecoDB: ");
    my @command = (
        'xcopy.exe', '/Y','/E','/I',
        cmd_quote($fosecodb_source),
        cmd_quote($fosecodb_dest),
        );
    if(!run_command(join(' ',@command),
                    'Description' =&gt; 'installing FosecoDB')) {
        output( "FAILED\n" );
        return 0;
    }
    output("OK\n");
    return 1;
}


# Begin-Doc
################################
# Name: configure_firewall()
# Description: Precreate firewall rules so that Windows doesn't bother the
#   (first-run) user with "Windows firewall has blocked..." messages.
# Returns: true/false on the composite success/failure of the rule creations.
# LastUpdated: 
# LastUpdatedBy: 
################################
# End-Doc
sub configure_firewall {
    my @programs = map { build_path($bin_dir,$_) }
                       qw(ms.exe magmapvs.exe magmagui_helper.exe
                          MAGMAcad.exe MAGMArun.exe MAGMAdata.exe
                          MAGMAsolver_hpSHM.exe mpid.exe mpirun.exe);

    # I'm fairly certain that none of these programs need to be accessed
    #   remotely via IP under normal circumstances.
    # We're going to precreate firewall rules so that the user isn't bothered
    #   by the notifications that Windows gives the first time the application
    #   is run.
    my $success = 1;
    foreach my $program (@programs) {
        my @command = (
            'netsh.exe',
            'advfirewall', 'firewall',
            'add','rule','"MAGMAsoft - '.basename($program,'.exe').'"',
            'dir=in',
            'action=block',
            'enable=yes',
            'profile=any',
            'program="'.$program.'"'
            );
        if (! run_command(join(' ',@command),
                          'Description' =&gt; 'adding MAGMAsoft firewall rule for'.
                                           ' '.basename($program))) {
            $success = 0;
        }

    }

    return $success;
}

# Begin-Doc
################################
# Name: grant_access()
# Description: Grants all users access to the C:\VULCAN_HOME directory
# Returns: true/false on the composite success/failure of granting access.
# LastUpdated: 2016-09-08
# LastUpdatedBy: Grayson Gratop
################################
sub grant_access {
    output("Granting access to C:\\VULCAN_HOME: ");

    my $success = 1;

    if (!(-d "C:\\VULCAN_HOME")) {
        $success &amp;= run_command("mkdir C:\\VULCAN_HOME");
    }

    $success &amp;= run_command("icacls \"C:\\VULCAN_HOME\" /grant Users:(OI)(CI)F /T");

    if ($success) {
        output("OK\n");
        return 1;
    }
    else {
        output("FAILED\n");
        return 0;
    }
}

__DATA__
CreateDesktopShortcut: No
CreateQuickLaunchShortcut: No
InstallDir: __INSTALLDIR__
InstallMode: Standard
InstallType: Custom
LaunchApplication: No
ProgramFolderName: MAGMA5.3.1.0
SelectedComponents: WG-MAGMA5,WG-WINDOWS64
ViewReadme: Yes
LicCmPort: 22350
LicM5Host: __LICENSESERVER__
LicM5Port1: 6997
LicServer: Client
MAGMA5runtime: 0.0
M5SelectedComponents: WG-MAGMA5 WG-WINDOWS64
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\magma.5_3_1_0\prod\update.pl</FullName>
    <Length>9490</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-08-22T09:57:38.7154635-05:00</CreationTime>
    <CreationTimeUtc>2017-08-22T14:57:38.7154635Z</CreationTimeUtc>
    <LastWriteTime>2017-08-22T09:11:31.6848067-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-08-22T14:11:31.6848067Z</LastWriteTimeUtc>
    <LastAccessTime>2017-08-22T09:57:38.7154635-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-08-22T14:57:38.7154635Z</LastAccessTimeUtc>
    <Text># Magma 5.3.1.0
# Package Created August 17, 2017
# Packaged by Jason S. Holm (with code by Ronith and based on Eric Boyer's 5.2 package with updates by Grayson Gratop)
# Last Update: August 22, 2017
=pod

Begin-Doc
Modified: $Date$
Name: MAGMAsoft v5.3.1.0 package
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'magma.5_3_1_0',
        package_revision =&gt; '20170822T0910',
    );
}
my $umrinst = $ENV{'WINDIR'}.'\\SYSTEM32\\UMRINST';
use lib (
    '\\\\minerfiles.mst.edu\\dfs\\software\\loginscripts\\im',
    '$umrinst',
    'C:\\temp',
);

use InstallMonkey::Shared;

use File::Basename;

#
# Usage MAGMA5-Setup.exe [options ...]
# 
# Available Options:
#   /help                      display this information
#   /mode [ARG]                set the mode to run the installer in
#                              Available values: console, default, silent, or
#                              standard
#   /prefix [ARG]              set the installation directory
#   /response-file [ARG]       a file to read installer responses from
#   /save-response-file [ARG]  a file to write installer responses to when the
#                              installer exits
#   /temp [ARG]                set the temporary directory used by this program
#   /version                   display installer version information
# 
# 

########################################################################
# BEGIN Configuration

# The MAGMAsoft installer is in the 'magma' directory in srcfiles.
my $install_source  = build_path(
                                 get_pkg_sourcefiles(),
                                 'magma'
								);

my $install_dir     = build_path(
                                 $ENV{SystemDrive},
								 'MAGMA5',
								 'v5.3.1.0'
								 );

my $bin_dir         = build_path(
                                 $install_dir,
                                 'WINDOWS64',
								 'bin'
								 );
								 
my $license_server  = 'magmasoft.lic.mst.edu';

# The Foseco Pro installer is in the 'FosecoDB' directory in srcfiles.

my $fosecodb_source = build_path(
                                 get_pkg_sourcefiles(),
								 'FosecoDB'
								 );

my $fosecodb_dest   = build_path(
                                 $install_dir,
                                 'lib',
								 'FosecoDB'
								 );

my %response_replacements = (
                             __INSTALLDIR__    =&gt; $install_dir,
                             __LICENSESERVER__ =&gt; $license_server,
                             );

							 
# END Configuration
########################################################################


sub install {
    my $response_file = create_response_file($install_source);
    my @command = (
	               cmd_quote(build_path($install_source,'MAGMA5-Setup.exe')),
                   '/mode',
				   'silent',
                   '/response-file',
				   cmd_quote(basename($response_file)),
                  );

    output("Installing MagmaSoft 5.3.1.0:");
    
	# The installer really wants the CWD to be where MAGMA5-Setup.exe is.
    push_dir(build_path($install_source));
    
	#start_global_MSI_logging();

    my $outcome = run_command(
	                          join(' ',@command),
                              'Description' =&gt; 'Installing MAGMAsoft');
    #sleep(80);
    #run_command("pskill /accepteula install.exe");
    #finish_global_MSI_logging();

    output(($outcome?'SUCCESS':'FAILURE')."\n");
    pop_dir();
    return $outcome;
}


sub postinstall {
    my $success = 1;

    $success &amp;&amp;= install_FosecoDB();
    $success &amp;&amp;= configure_firewall();
    $success &amp;&amp;= grant_access();
    
    return $success;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; [qw(clc desktop traveling virtual-clc virtual-desktop)],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);
IM_Exit(EXIT_SUCCESS);


########################################################################

# Begin-Doc
################################
# Name:        create_response_file()
# Description: Create a response file (based on the template in the __DATA__
#              section) with the values that will be used on this machine.
# Returns:     Path to the response file or undef on error.
# Requires:    The data used to create the template was created using the
#              /save-response-file flag of the MAGMA-setup.exe installer.
#              One might need to create a new response file for each
#              updated version of the software.
# Last Update: n/a
# Updated By:  n/a
################################
# End-Doc
sub create_response_file {
    my $target_dir    = shift;
    my $response_file = build_path(
	                               $target_dir,
                                   'mst_install.response.txt'
								  );
								  
    if (open(my $RESPONSE,'&gt;',$response_file)) {
        for my $line (&lt;DATA&gt;) {
            foreach my $kw (keys(%response_replacements)) {
                my $repl = $response_replacements{$kw};
                $line =~ s/$kw/$repl/g;
            }
            print $RESPONSE $line;
        }
        close($RESPONSE);
    } else {
        output("Error creating installer response file '${response_file}': $!\n");
        return undef;
    }

    output(join("\n",
                "Installer Response File:",
                ('-' x 60),
                get_file_contents($response_file),
                ('-' x 60),
                ''),
           LOG_ONLY);
    return $response_file;
}

# Begin-Doc
################################
# Name: install_FosecoDB()
# Description: install the Foseco Pro module for MAGMA5
# Returns: 
# Requires: 
# LastUpdated: 
# LastUpdatedBy:
################################
# End-Doc
sub install_FosecoDB {
    # Install FosecoDB
    output("Installing FosecoDB: ");
    my @command = (
        'xcopy.exe', '/Y','/E','/I',
        cmd_quote($fosecodb_source),
        cmd_quote($fosecodb_dest),
        );
    if(!run_command(join(' ',@command),
                    'Description' =&gt; 'installing FosecoDB')) {
        output( "FAILED\n" );
        return 0;
    }
    output("OK\n");
    return 1;
}


# Begin-Doc
################################
# Name: configure_firewall()
# Description: Precreate firewall rules so that Windows doesn't bother the
#   (first-run) user with "Windows firewall has blocked..." messages.
# Returns: true/false on the composite success/failure of the rule creations.
# LastUpdated: 
# LastUpdatedBy: 
################################
# End-Doc
sub configure_firewall {
    my @programs = map { build_path($bin_dir,$_) }
                       qw(ms.exe magmapvs.exe magmagui_helper.exe
                          MAGMAcad.exe MAGMArun.exe MAGMAdata.exe
                          MAGMAsolver_hpSHM.exe mpid.exe mpirun.exe);

    # I'm fairly certain that none of these programs need to be accessed
    #   remotely via IP under normal circumstances.
    # We're going to precreate firewall rules so that the user isn't bothered
    #   by the notifications that Windows gives the first time the application
    #   is run.
    my $success = 1;
    foreach my $program (@programs) {
        my @command = (
            'netsh.exe',
            'advfirewall', 'firewall',
            'add','rule','"MAGMAsoft - '.basename($program,'.exe').'"',
            'dir=in',
            'action=block',
            'enable=yes',
            'profile=any',
            'program="'.$program.'"'
            );
        if (! run_command(join(' ',@command),
                          'Description' =&gt; 'adding MAGMAsoft firewall rule for'.
                                           ' '.basename($program))) {
            $success = 0;
        }

    }

    return $success;
}

# Begin-Doc
################################
# Name: grant_access()
# Description: Grants all users access to the C:\VULCAN_HOME directory
# Returns: true/false on the composite success/failure of granting access.
# LastUpdated: 2016-09-08
# LastUpdatedBy: Grayson Gratop
################################
sub grant_access {
    output("Granting access to C:\\VULCAN_HOME: ");

    my $success = 1;

    if (!(-d "C:\\VULCAN_HOME")) {
        $success &amp;= run_command("mkdir C:\\VULCAN_HOME");
    }

    $success &amp;= run_command("icacls \"C:\\VULCAN_HOME\" /grant Users:(OI)(CI)F /T");

    if ($success) {
        output("OK\n");
        return 1;
    }
    else {
        output("FAILED\n");
        return 0;
    }
}

__DATA__
CreateDesktopShortcut: No
CreateQuickLaunchShortcut: No
InstallDir: __INSTALLDIR__
InstallMode: Standard
InstallType: Custom
LaunchApplication: No
ProgramFolderName: MAGMA5.3.1.0
SelectedComponents: WG-MAGMA5,WG-WINDOWS64
ViewReadme: Yes
LicCmPort: 22350
LicM5Host: __LICENSESERVER__
LicM5Port1: 6997
LicServer: Client
MAGMA5runtime: 0.0
M5SelectedComponents: WG-MAGMA5 WG-WINDOWS64
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\maple.2016\prod\update.pl</FullName>
    <Length>6442</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-04-26T15:59:53.3192136-05:00</CreationTime>
    <CreationTimeUtc>2016-04-26T20:59:53.3192136Z</CreationTimeUtc>
    <LastWriteTime>2016-07-27T12:50:40.9987769-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-07-27T17:50:40.9987769Z</LastWriteTimeUtc>
    <LastAccessTime>2016-04-26T15:59:53.3192136-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-04-26T20:59:53.3192136Z</LastAccessTimeUtc>
    <Text># Maple 2016 - MATLAB tools
# Package Created June 2016
# Packaged by Ronith
# Last Updated ...

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
      package_id =&gt; 'maple.2016',
      package_revision =&gt; '20160627T1400',
  );
}

# Add InstallMonkey Library to the path
use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use Getopt::Long;
use InstallMonkey::Shared;


my $srcfilesdir = get_pkg_sourcefiles();
my $allUsersDesktop = get_allusers_desktop();
my $allUsersStartmenu = get_allusers_start_menu();
my $startmenudir = "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs";


sub preInstall {
	####
	#Tell Maple where the installation of the newest Matlab is by editing the installer.properties file
	####
	output("Configuring install options...\n");
	
	#grab install config file
	open(FILE, "$srcfilesdir\\installer-vm.properties");
	undef $/;
	my $config = &lt;FILE&gt;;
	close(FILE);
	#get the last directory in the Matlab dir (last one when alphabetically-sorted should be the newest version)
	opendir(DIR, 'C:\\Program Files\\Matlab');
	my @installs = grep { (!/^\.\.?$/) &amp;&amp; (-d "C:\\Program Files\\Matlab\\$_") } readdir(DIR);
	closedir(DIR);

	if (!(scalar @installs)){
		output("MATLAB isn't installed anywhere! Toolbox requires MATLAB to be installed\n");
		$config=~ s/REPLACEYO/""/;
	}
	else{
		my $version = @installs[(scalar @installs)-1];
		my $path = "C:\\Program Files\\Matlab\\$version";
		output("MATLAB $version found.");
		$config =~ s/REPLACEYO/$path/;
    }
	my $machine_type = get_machine_type();
	my $if_virtual ="virtual";
	if(index($machine_type,$if_virtual) != -1){
		open(FILE, '&gt;', "$srcfilesdir\\installer-vm.properties");
		print FILE $config;
		close(FILE);
	}
	else{
		open(FILE, '&gt;', "$srcfilesdir\\installer.properties");
		print FILE $config;
		close(FILE);
	}
	
	#installation of fonts provided by maple causes the installation to fail in win10 
	#pre-installing them seems to fix the issue
	#these fonts have been obtained from unpacking the setup file
	output("installing fonts\n");
	run_command("\"$srcfilesdir\\fonts.bat\"");
    return 1;
}

sub install {
    my $if_virtual = "virtual";
	my $machine_type = get_machine_type();
	if(index($machine_type,$if_virtual) != -1){
		my @installCommands = (
			["\"$srcfilesdir\\Maple2016.0WindowsX64Installer\" --optionfile \"$srcfilesdir\\installer-vm.properties\"", 0]
		); 
		my $success = 0;
		my $allDone = 1;
		output("Installing Maple 2016... \n");
		for (my $i = 0; $i &lt; scalar @installCommands; $i++) {
			output("\t" . $installCommands[$i][0] . ": ");
			$success = run_command($installCommands[$i][0]);
			output($success ? "Done!\n" : "FAILED: $!\n");
			$allDone &amp;&amp;= $installCommands[$i][1] || $success;
			if (!$allDone) {
				output("\nSomething went wrong!\n");
				return 0;
			}
		}
		output("\nLooks like it was a success!\n");
	}
	else{
		my @installCommands = (
			["\"$srcfilesdir\\Maple2016.0WindowsX64Installer\" --optionfile \"$srcfilesdir\\installer.properties\"",0]
		); 
		my $success = 0;
		my $allDone = 1;
		output("Installing Maple 2016... \n");
		for (my $i = 0; $i &lt; scalar @installCommands; $i++) {
			output("\t" . $installCommands[$i][0] . ": ");
			$success = run_command($installCommands[$i][0]);
			output($success ? "Done!\n" : "FAILED: $!\n");
			$allDone &amp;&amp;= $installCommands[$i][1] || $success;
			if (!$allDone) {
				output("\nSomething went wrong!\n");
				return 0;
			}
		}
		output("\nLooks like it was a success!\n");
	}
	return 1;
}


sub postinstall
{
	#######################################################################
    #Add a firewall rule so that the user isn't bothered with unnecessary #
    # firewall dialogs when running Maple for the first time              #
    #######################################################################
    run_command("netsh advfirewall firewall add rule name=\"Maple 2016\" dir=in action=allow program=\"C:\\Program Files\\Maple 2016\\bin.X86_64_WINDOWS\\maplew.exe\"");
	run_command("netsh advfirewall firewall add rule name=\"Maple 2016\" dir=out action=allow program=\"C:\\Program Files\\Maple 2016\\bin.X86_64_WINDOWS\\maplew.exe\"");
	run_command("netsh advfirewall firewall add rule name=\"JavaW\" dir=in action=allow program=\"C:\\Program Files\\Maple 2016\\jre\\bin\\javaw.exe\"");
	run_command("netsh advfirewall firewall add rule name=\"JavaW\" dir=out action=allow program=\"C:\\Program Files\\Maple 2016\\jre\\bin\\javaw.exe\"");
	run_command("netsh advfirewall firewall add rule name=\"cmaple\" dir=in action=allow program=\"C:\\Progran Files\\Maple 2016\\bin.X86_64_WINDOWS\\cmaple.exe\"");
	run_command("netsh advfirewall firewall add rule name=\"cmaple\" dir=out action=allow program=\"C:\\Progran Files\\Maple 2016\\bin.X86_64_WINDOWS\\cmaple.exe\"");
	run_command("netsh advfirewall firewall add rule name=\"mserver\" dir=in action=allow program=\"C:\\Progran Files\\Maple 2016\\bin.X86_64_WINDOWS\\mserver.exe\"");
	run_command("netsh advfirewall firewall add rule name=\"mserver\" dir=out action=allow program=\"C:\\Progran Files\\Maple 2016\\bin.X86_64_WINDOWS\\mserver.exe\"");
	run_command("netsh advfirewall firewall add rule name=\"maplejava\" dir=in action=allow program=\"C:\\Progran Files\\Maple 2016\\bin.X86_64_WINDOWS\\maplejava.exe\"");
	run_command("netsh advfirewall firewall add rule name=\"maplejava\" dir=out action=allow program=\"C:\\Progran Files\\Maple 2016\\bin.X86_64_WINDOWS\\maplejava.exe\"");
    return 1;
}


do_install( 
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  preinstall_sub =&gt; \&amp;preInstall,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\maple.2017\prod\update.pl</FullName>
    <Length>5344</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-14T15:56:01.9513618-05:00</CreationTime>
    <CreationTimeUtc>2017-06-14T20:56:01.9513618Z</CreationTimeUtc>
    <LastWriteTime>2017-07-10T08:22:35.4966147-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-07-10T13:22:35.4966147Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-14T15:56:01.9513618-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-14T20:56:01.9513618Z</LastAccessTimeUtc>
    <Text># Maple 2017
# Package created by Sergey Gruzdev
# Package created 6/13/2017
# Package last edited 6/13/2017 by Sergey Gruzdev

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'maple.2017',
		package_revision =&gt; '20170613T1256',
	);
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

my $src = get_pkg_sourcefiles();
my $dest = "C:\\Program Files\\Maple 2017";
our $install = "$src\\Maple2017.0WindowsX64Installer.exe";

GetOptions('uninstall' =&gt; sub{exit(uninstall())});

sub uninstall
{
  print "Uninstalling Maple 2017...\n";
  # Run uninstaller
  if(!run_command("\"$dest\\uninstall\\uninstall.exe\" --mode unattended"))
  {
    print "Error: could not uninstall Maple 2017!\n";
	return 0;
  }
  print "Success!\n";
  # Delete reg key
  print "Deleting registry product key...\n";
  if(!delete_product_registry_key(get_package_name().".".get_version()))
  {
    print "Error: could not delete registry key, try again!\n";
	return 0;
  }
  print "Success! Uninstall complete!\n";
}

sub preinstall
{
  print "Configuring installer options...\n";
  # Set up installation command
  # Disable UI in unattended mode
  $install = $install." --unattendedmodeui none";
  # Unattended mode
  $install = $install." --mode unattended";
  # Find whether or not we have MatLab
  my $matlab = 0;
  opendir(MATLABS, 'C:\\Program Files\\Matlab');
  my @mats = readdir(MATLABS);
  closedir(MATLABS);
  if(scalar(@mats))
  {
    $matlab = 'C:\\Program Files\\Matlab\\'.$mats[(scalar(@mats)) - 1];
  }
  else
  {
    $matlab = 0;
  }
  print "Found matlab: $matlab\n";  
  if($matlab)
  {    
	# Get latest MatLab version
    $install = $install." --configureMATLAB 1";
	$install = $install." --matlabpath \"$matlab\"";
  }
  else
  {
    print "MATLAB is not installed on this machine! Toolbox requries MATLAB!\n";
	$install = $install." --configureMATLAB 0";
  }
  # License type
  $install = $install." --licenseType network";
  $install = $install." --singleOrRedundant single";
  # License server and port
  $install = $install." --serverName maple.lic.mst.edu";
  $install = $install." --portNumber 1151";
  # Disable updates
  $install = $install." --enableUpdates 0";
  $install = $install." --checkForUpdatesNow 0";
  # Disable icon
  $install = $install." --desktopshortcut 0";
  
  # Preinstall fonts or else maple (apparently) hangs :/
  print "Preinstalling fonts...\n";
  run_command("\"$src\\fonts.bat\"");
  return 1;
}

sub install
{
  print "Installing Maple 2017...\n";
  # Run install command
  if(!run_command($install))
  {
    print "Error: could not install Maple 2017!\n";
	return 0;
  }
  print "Maple 2017 installed!\n";
  return 1;
}

sub postinstall
{
  print "Adding firewall exceptions...\n";
  # Add firewall exceptions
  run_command("netsh advfirewall firewall add rule name=\"Maple 2016\" dir=in action=allow program=\"C:\\Program Files\\Maple 2017\\bin.X86_64_WINDOWS\\maplew.exe\"");
  run_command("netsh advfirewall firewall add rule name=\"Maple 2016\" dir=out action=allow program=\"C:\\Program Files\\Maple 2017\\bin.X86_64_WINDOWS\\maplew.exe\"");
  run_command("netsh advfirewall firewall add rule name=\"JavaW\" dir=in action=allow program=\"C:\\Program Files\\Maple 2017\\jre\\bin\\javaw.exe\"");
  run_command("netsh advfirewall firewall add rule name=\"JavaW\" dir=out action=allow program=\"C:\\Program Files\\Maple 2017\\jre\\bin\\javaw.exe\"");
  run_command("netsh advfirewall firewall add rule name=\"cmaple\" dir=in action=allow program=\"C:\\Progran Files\\Maple 2017\\bin.X86_64_WINDOWS\\cmaple.exe\"");
  run_command("netsh advfirewall firewall add rule name=\"cmaple\" dir=out action=allow program=\"C:\\Progran Files\\Maple 2017\\bin.X86_64_WINDOWS\\cmaple.exe\"");
  run_command("netsh advfirewall firewall add rule name=\"mserver\" dir=in action=allow program=\"C:\\Progran Files\\Maple 2017\\bin.X86_64_WINDOWS\\mserver.exe\"");
  run_command("netsh advfirewall firewall add rule name=\"mserver\" dir=out action=allow program=\"C:\\Progran Files\\Maple 2017\\bin.X86_64_WINDOWS\\mserver.exe\"");
  run_command("netsh advfirewall firewall add rule name=\"maplejava\" dir=in action=allow program=\"C:\\Progran Files\\Maple 2017\\bin.X86_64_WINDOWS\\maplejava.exe\"");
  run_command("netsh advfirewall firewall add rule name=\"maplejava\" dir=out action=allow program=\"C:\\Progran Files\\Maple 2017\\bin.X86_64_WINDOWS\\maplejava.exe\"");
  print "Done! Installation complete!\n";
  return 1;
}

do_install
(
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'virtual-clc', 'desktop', 'virtual-desktop', 'traveling'],
  exit_on_failure =&gt; 1,
  preinstall_sub =&gt; \&amp;preinstall,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\maple.2018\prod\update.pl</FullName>
    <Length>5333</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-22T15:34:03.2840953-05:00</CreationTime>
    <CreationTimeUtc>2018-05-22T20:34:03.2840953Z</CreationTimeUtc>
    <LastWriteTime>2018-05-22T15:38:06.8971801-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-22T20:38:06.8971801Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-22T15:34:03.2840953-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-22T20:34:03.2840953Z</LastAccessTimeUtc>
    <Text># Maple 2018
# Package created by Cameron Loren
# Package created 5/22/2018
# Package last edited 5/22/2018 by Cameron Loren

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'maple.2018',
		package_revision =&gt; '20180522T1536',
	);
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

my $src = get_pkg_sourcefiles();
my $dest = "C:\\Program Files\\Maple 2018";
our $install = "$src\\Maple2018.0WindowsX64Installer.exe";

GetOptions('uninstall' =&gt; sub{exit(uninstall())});

sub uninstall
{
  print "Uninstalling Maple 2018...\n";
  # Run uninstaller
  if(!run_command("\"$dest\\uninstall\\uninstall.exe\" --mode unattended"))
  {
    print "Error: could not uninstall Maple 2018!\n";
	return 0;
  }
  print "Success!\n";
  # Delete reg key
  print "Deleting registry product key...\n";
  if(!delete_product_registry_key(get_package_name().".".get_version()))
  {
    print "Error: could not delete registry key, try again!\n";
	return 0;
  }
  print "Success! Uninstall complete!\n";
}

sub preinstall
{
  print "Configuring installer options...\n";
  # Set up installation command
  # Disable UI in unattended mode
  $install = $install." --unattendedmodeui none";
  # Unattended mode
  $install = $install." --mode unattended";
  # Find whether or not we have MatLab
  my $matlab = 0;
  opendir(MATLABS, 'C:\\Program Files\\Matlab');
  my @mats = readdir(MATLABS);
  closedir(MATLABS);
  if(scalar(@mats))
  {
    $matlab = 'C:\\Program Files\\Matlab\\'.$mats[(scalar(@mats)) - 1];
  }
  else
  {
    $matlab = 0;
  }
  print "Found matlab: $matlab\n";
  if($matlab)
  {
	# Get latest MatLab version
    $install = $install." --configureMATLAB 1";
	$install = $install." --matlabpath \"$matlab\"";
  }
  else
  {
    print "MATLAB is not installed on this machine! Toolbox requries MATLAB!\n";
	$install = $install." --configureMATLAB 0";
  }
  # License type
  $install = $install." --licenseType network";
  $install = $install." --singleOrRedundant single";
  # License server and port
  $install = $install." --serverName maple.lic.mst.edu";
  $install = $install." --portNumber 1151";
  # Disable updates
  $install = $install." --enableUpdates 0";
  $install = $install." --checkForUpdatesNow 0";
  # Disable icon
  $install = $install." --desktopshortcut 0";

  # Preinstall fonts or else maple (apparently) hangs :/
  print "Preinstalling fonts...\n";
  run_command("\"$src\\fonts.bat\"");
  return 1;
}

sub install
{
  print "Installing Maple 2018...\n";
  # Run install command
  if(!run_command($install))
  {
    print "Error: could not install Maple 2018!\n";
	return 0;
  }
  print "Maple 2018 installed!\n";
  return 1;
}

sub postinstall
{
  print "Adding firewall exceptions...\n";
  # Add firewall exceptions
  run_command("netsh advfirewall firewall add rule name=\"Maple 2016\" dir=in action=allow program=\"C:\\Program Files\\Maple 2018\\bin.X86_64_WINDOWS\\maplew.exe\"");
  run_command("netsh advfirewall firewall add rule name=\"Maple 2016\" dir=out action=allow program=\"C:\\Program Files\\Maple 2018\\bin.X86_64_WINDOWS\\maplew.exe\"");
  run_command("netsh advfirewall firewall add rule name=\"JavaW\" dir=in action=allow program=\"C:\\Program Files\\Maple 2018\\jre\\bin\\javaw.exe\"");
  run_command("netsh advfirewall firewall add rule name=\"JavaW\" dir=out action=allow program=\"C:\\Program Files\\Maple 2018\\jre\\bin\\javaw.exe\"");
  run_command("netsh advfirewall firewall add rule name=\"cmaple\" dir=in action=allow program=\"C:\\Progran Files\\Maple 2018\\bin.X86_64_WINDOWS\\cmaple.exe\"");
  run_command("netsh advfirewall firewall add rule name=\"cmaple\" dir=out action=allow program=\"C:\\Progran Files\\Maple 2018\\bin.X86_64_WINDOWS\\cmaple.exe\"");
  run_command("netsh advfirewall firewall add rule name=\"mserver\" dir=in action=allow program=\"C:\\Progran Files\\Maple 2018\\bin.X86_64_WINDOWS\\mserver.exe\"");
  run_command("netsh advfirewall firewall add rule name=\"mserver\" dir=out action=allow program=\"C:\\Progran Files\\Maple 2018\\bin.X86_64_WINDOWS\\mserver.exe\"");
  run_command("netsh advfirewall firewall add rule name=\"maplejava\" dir=in action=allow program=\"C:\\Progran Files\\Maple 2018\\bin.X86_64_WINDOWS\\maplejava.exe\"");
  run_command("netsh advfirewall firewall add rule name=\"maplejava\" dir=out action=allow program=\"C:\\Progran Files\\Maple 2018\\bin.X86_64_WINDOWS\\maplejava.exe\"");
  print "Done! Installation complete!\n";
  return 1;
}

do_install
(
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'virtual-clc', 'desktop', 'virtual-desktop', 'traveling'],
  exit_on_failure =&gt; 1,
  preinstall_sub =&gt; \&amp;preinstall,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\mathcad_15_m050\dev\update.pl</FullName>
    <Length>2786</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-05T14:54:04.874656-05:00</CreationTime>
    <CreationTimeUtc>2018-06-05T19:54:04.874656Z</CreationTimeUtc>
    <LastWriteTime>2018-06-06T14:57:07.0765271-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-06T19:57:07.0765271Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-05T14:54:04.874656-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-05T19:54:04.874656Z</LastAccessTimeUtc>
    <Text># mathcad_15_m50
# Package Created June 5, 2018
# Packaged by Robert Smith
# Last Updated June 6, 2018

BEGIN
{
  %::INSTALLMONKEY_OPTIONS = (
  package_id =&gt; 'mathcad_15_m050',
  package_revision =&gt; '20180606T0839',
  );
}

use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

sub preinstall
{
	#Check if MSXML 4.0 SP2 is installed, and if not install it. This is required for Mathcad.
	if(!IsAppInstalled('AppID' =&gt; '{716E0306-8318-4364-8B8F-0CC4E9376BAC}'))
	{
		output("\nA MSXML 4.0 SP2 installation was not found.\n\nInstalling MSXML 4.0 SP2 now!.\n");
		#if(!run_command("msiexec /qn /i \"$srcfiles\\mathcad_15_m050\\PreReq\\msxml.msi\"") )
    if(!install_msi(msi =&gt; "$srcfiles\\mathcad_15_m050\\PreReq\\msxml.msi"))
		{
			output("Error installing prereq 'msxml.msi'. Aborting install.\n");
			return 0;
		}
		output("\nMSXML installed successfully!\n")
	}
	else
	{
		output("\nMSXML 4.0 SP2 was detected! Continuing with Installation.\n");
	}
}

sub install
{
  output("Installing Mathcad 15.0 M050\n");

  if(!run_command("msiexec.exe /i \"$srcfiles\\Mathcad15WixInstaller.msi\" INSTALLLOCATION=\"C:\\Program Files (x86)\\Mathcad\\Mathcad 15\""))
  {
    output("Mathcad did not install correctly\n");
    return 0;
  }
  else
  {
    output("Installation part 1 successful!\n");
  }

# If Adobe Acrobat Distiller is not installed (should be - it's mandatory)
=pod
  if(!run_command("msiexec.exe /qb /i \"$srcfiles\\mathcad_15_m050\\adobe\\Distillr.msi\" ISX_SERIALNUMBER=\"1071-1006-8094-6401-2690-6767\" TRANSFORMS=\"$appdeploy\\adobe\\MathCAD.mst\""))
  {
    output("Mathcad did not install correctly\n");
    return 0;
  }
  else
  {
    output("Installation part 2 successful!\n");
  }
=cut

  return 1;
}

sub postinstall
{
  #Deleting desktop icon
	output("\nGetting rid of desktop icon\n");
  my $allusersdesktop = get_allusers_desktop();
	if(!run_command("del /q /f \"$allusersdesktop\\Mathcad 15.lnk\""))
	{
		output("\nDeletion failed!\n");

    return 0;
	}

    return 1;
}

do_install(
    exit_on_failure =&gt; 1,
    allowed_versions          =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures  =&gt; [ OSARCH_x64 ],
    allowed_regs              =&gt; [ "clc", "desktop", "traveling", "virtual-desktop", "virtual-clc" ],
    preinstall_sub            =&gt; \&amp;preinstall,
    install_sub               =&gt; \&amp;install,
    postinstall_sub           =&gt; \&amp;postinstall,

);

IM_Exit(EXIT_SUCCESS);

########################################################################
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\mathcad_15_m050\prod\update.pl</FullName>
    <Length>4886</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-07T08:30:54.5733653-05:00</CreationTime>
    <CreationTimeUtc>2018-06-07T13:30:54.5733653Z</CreationTimeUtc>
    <LastWriteTime>2018-06-13T09:33:42.0041912-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-13T14:33:42.0041912Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-06T11:15:16.8057591-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-06T16:15:16.8057591Z</LastAccessTimeUtc>
    <Text># Mathcad 15 M050
# Package Created June 2018
# Packaged by Robert Smith
# based on Mark's M045 package

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'mathcad_15_m050',
        package_revision =&gt; '20180607T0808',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;
use Getopt::Long;

my $sourcefilesdir = get_pkg_sourcefiles();
my $applog = get_default_app_log();

######
GetOptions(
    'uninstall' =&gt; sub { exit(!uninstall()); },
) || die "Usage: $!";
######

sub uninstall
{
	#my $success = run_command("msiexe /uninstall
	my @command = (
		   'msiexec.exe', '/uninstall', cmd_quote(build_path($sourcefilesdir, 'mathcad', 'Mathcad15WixInstaller.msi')),
		   '/quiet', #'/LOG="$applog\$log"',
		);
	my $success = run_command(join(' ',@command));

	if ($success)
	{
		output("Removing leftover folder in Program Files (x86)\n");
		run_command("rmdir /q /s \"\%programfiles(x86)\%\\Mathcad\\\"");
		output("Removing registry key.\n");
		delete_product_registry_key('mathcad_15_m050');
		output("Mathcad removed successfully!");
		return 1;
	}
	else
	{
		output("Issue removing Mathcad: $!");
		return 0;
	}
}

sub preinst_sub
{
	#Check if MSXML 4.0 SP2 is installed, and if not install it. This is required for Mathcad.
	if(!IsAppInstalled('AppID' =&gt; '{716E0306-8318-4364-8B8F-0CC4E9376BAC}'))
	{
		output("\nA MSXML 4.0 SP2 installation was not found.\n\nInstalling MSXML 4.0 SP2 now!.\n");
		if(!run_command("msiexec /i \"$sourcefilesdir\\PreReq\\msxml.msi\" /qn /norestart") )
		{
			output("Error installing prereq 'msxml.msi'. Aborting install.\n");
			return 0;
		}
		output("\nMSXML installed successfully!\n")
	}
	else
	{
		output("\nMSXML 4.0 SP2 was detected! Continuing with Installation.\n");
	}

  #######################################################################
  #Check for Visual C++ Redistributable x86 and install if not installed#
  #######################################################################

  if(!IsAppInstalled('AppID' =&gt; '{A49F249F-0C91-497F-86DF-B2585E8E76B7}'))
  {
    output("A Visual C++ 2005 Redistributable (x86) installation was not found.\n\n");
    output("Installing Visual C++ 2005 Redistributable (x86) now...\n");

    if(!run_command("msiexec /i \"$sourcefilesdir\\PreReq\\vcredist.msi\" /qn /norestart"))
    {
        output("Error installing prereq 'vcredist.msi'.  Aborting install.\n");

        return 0;
    }

    output("\nVisual C++ 2005 Redistributable (x86) installed successfully!\n");
  }
  else
  {
    output("\nVisual C++ 2005 Redistributable (x86) was detected!  Continuing with installation.\n");
  }

	return 1;
}

sub install
{
	my $logfilesdir = get_applogs_dir();
#	if(!run_command("msiexec.exe /qb /i \"$sourcefilesdir\\mathcad\\Mathcad15WixInstaller.msi\" /l* \"$logfilesdir\\Mathcad15.txt\" /norestart"))
  if(!run_command("msiexec.exe /i \"$sourcefilesdir\\mathcad\\Mathcad15WixInstaller.msi\" /l* \"$logfilesdir\\Mathcad15.txt\" /qn /norestart"))
	{
		output("\nMathcad 15 install has failed!\n");
		return 0;
	}
	else
	{
		output("\nMathcad 15 install was successful.\n");
	}
	return 1;
}

sub postinst_sub
{
	my $allusersdesktop = get_allusers_desktop();

	#Deleating desktop icon
	output("\nGetting rid of desktop icon\n");
	if(!run_command("del /q /f \"$allusersdesktop\\Mathcad 15.lnk\""))
	{
		output("\nDeletion failed!\n");
		return 0;
	}
	#importing registry value for license server
		output("\nImporting license information\n");
	if(is_XP())
	{
		if(!run_command("regedit /s \"$sourcefilesdir\\license\\license_XP_32.reg\""))
		{
			output("\nRegistry key was NOT installed correctly\n");
			return 0;
		}
		output("\nThe registry key has been installed correctly!\n");
	}
	else
	{
		if(!run_command("regedit /s \"$sourcefilesdir\\license\\license_Win7_32.reg\""))
		{
			output("\nRegistry key was NOT installed correctly\n");
			return 0;
		}
	}
	return 1;
}

do_install(
    allowed_versions =&gt; [ OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_XP_32, OSVER_WIN8_SP0, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    preinstall_sub =&gt; \&amp;preinst_sub,
	  install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinst_sub,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\mathcad_prime.4_0\dev\update.pl</FullName>
    <Length>1801</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-05-26T16:44:58.1056314-05:00</CreationTime>
    <CreationTimeUtc>2017-05-26T21:44:58.1056314Z</CreationTimeUtc>
    <LastWriteTime>2017-06-22T11:04:54.6286181-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-22T16:04:54.6286181Z</LastWriteTimeUtc>
    <LastAccessTime>2017-05-26T16:44:58.1056314-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-05-26T21:44:58.1056314Z</LastAccessTimeUtc>
    <Text>
    # mathcad_prime
    # Package Created May 26, 2017
    # Packaged by Krueger, Benjamin (S&amp;T IT Student Employee)
    # Last Updated --

    BEGIN {
        %::INSTALLMONKEY_OPTIONS = (
            package_id =&gt; 'mathcad_prime.4_0',
            package_revision =&gt; '20170526T1644',
        );
    }

    use lib (
        '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
        $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
        'C:\temp',
    );
    use InstallMonkey::Shared;

    my $srcfiles = get_pkg_sourcefiles();
    my $log_dir = get_applogs_dir();

    sub install {
        install_msi(msi =&gt; $srcfiles."\\ptcsh0\\PrimeWixInstaller_64bit.msi");
    }
    sub postinstall
    {
    #licensing with reg key
    my $src = build_path($srcfiles,"MathcadPrime.exe.config");
    my $dest= build_path("C:","ProgramData","PTC","Mathcad Prime");
    if(!run_command("COPY ${src} \"${dest}\""))
	{
		output("\nConfig File not copied.\n");
		return 0;
	}
    my $allusersdesktop = get_allusers_desktop();
	
	#Deleating desktop icon
	output("\nGetting rid of desktop icon\n");
	if(!run_command("del /q /f \"$allusersdesktop\\PTC Mathcad Prime 4.0.lnk\""))
	{
		output("\nDeletion failed!\n");
	}

    return 1;
    }
    do_install( 
        exit_on_failure =&gt; 1,
        allowed_versions          =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
        allowed_os_architectures  =&gt; [ OSARCH_x64 ],
        allowed_regs              =&gt; [ "clc", "desktop", "traveling", "virtual-desktop", "virtual-clc" ],
        install_sub               =&gt; \&amp;install,
        postinstall_sub           =&gt; \&amp;postinstall,
        
    );

    IM_Exit(EXIT_SUCCESS);

    ########################################################################
    </Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\mathematica.11_1_1\prod\update.pl</FullName>
    <Length>2226</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-07-05T09:17:20.2590739-05:00</CreationTime>
    <CreationTimeUtc>2017-07-05T14:17:20.2590739Z</CreationTimeUtc>
    <LastWriteTime>2017-07-05T08:48:55.1196373-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-07-05T13:48:55.1196373Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-05T09:17:20.2590739-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-05T14:17:20.2590739Z</LastAccessTimeUtc>
    <Text># Package Created May 2015
# Packaged by Kyle Knudsen (edit: Sam Pilla) and fixed by Billy Rhoades
# Last Updated 7/5/2017 by Sergey Gruzdev

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'mathematica.11_1_1',
        package_revision =&gt; '20160705T0846',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;
use Getopt::Long;

my $src = get_pkg_sourcefiles();
my $pgdata = $ENV{"ProgramData"};

GetOptions('uninstall' =&gt; sub{exit(!uninstall());});

sub install
{ 
  output("Installing Mathematica 11.1.1: ");

  if( !(run_command("start /wait \"\" \"$src\\setup.exe\" /VERYSILENT")))
  {
    output("FAILED\n");
    return 0;
  } 

  output("SUCCESS\n");
  return 1;
}

sub uninstall
{

  output("Uninstalling Wolfram Mathematica: ");
  my $outcome = 
  run_command("start /wait \"\"  \"C:\\Program Files\\Wolfram Research\\Mathematica\\11.1\\SystemFiles\\UninstallFiles\\Windows\\unins000.exe\" /silent /suppressmsgboxes /norestart");
  
  run_command("rmdir \"$pgdata\\Mathematica\\Licensing\" /S /Q") if($outcome);
  
  output(($outcome?'OK':'FAILED')."\n");

  delete_product_registry_key(get_package_name().".".get_version()) if($outcome);

  return $outcome;	
}

 
sub postinstall
{
  my $licdir = "$pgdata\\Mathematica\\Licensing";

  output("Creating  License directory: ");
  if(!(-e $licdir) &amp;&amp; !(run_command("mkdir \"$licdir\"")))
  {
    output("FAILED\n");
    return 0;
  }
  output("SUCCESS\n");

  output("Copying License files: ");
  if(!(run_command("copy \"$src\\mathpass\" \"$pgdata\\Mathematica\\Licensing\"")))
  {
    output("FAILED\n");
    return 0;
  }
  output("SUCCESS\n");


  return 1;
}

do_install( 
  allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\mathtype.6_9d\prod\update.pl</FullName>
    <Length>2887</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-03-30T14:45:09.6720902-05:00</CreationTime>
    <CreationTimeUtc>2018-03-30T19:45:09.6720902Z</CreationTimeUtc>
    <LastWriteTime>2018-06-14T16:19:58.1762293-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-14T21:19:58.1762293Z</LastWriteTimeUtc>
    <LastAccessTime>2018-03-30T14:45:09.6720902-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-03-30T19:45:09.6720902Z</LastAccessTimeUtc>
    <Text># Package Created March 2018
# Package created by Ben Krueger
# Last Updated 2018-6-14 by Robert Smith

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
  %INSTALLMONKEY_OPTIONS =
	(
    package_id =&gt; 'mathtype.6_9d',
    package_revision =&gt; '20180614T1400',
  );
}


use lib
(
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);


use InstallMonkey::Shared;
use Getopt::Long;

GetOptions(
  'uninstall' =&gt; sub { exit(!uninstall()); },
);

sub uninstall
{
  output("Uninstalling MathType: ");
  my $file = "%ProgramFiles(x86)%\\Design Science\\MathType\\Setup.exe";
  my $outcome = 0;
  if(-e $file)
  {
    $outcome = run_command("\"$file\" -R -Q");
  }
  output(($outcome?'OK':'FAILED')."\n");

  delete_product_registry_key( get_package_name(). "." .get_version() );
}

sub install
{
  my $sourcefilesdir = get_pkg_sourcefiles();
  my $installdir     = build_path(get_arch_programfiles(OSARCH_x86),'Design Science','MathType');

  ##########################################################################################################################
  # IMPORTANT:                                                                                                             #
	# To setup the default registration information, you need to run the command:                                            #
	# setup.exe -UNLOCK "RegFirstName=Joe&amp;RegLastName=Miner&amp;RegOrg=UMR&amp;RegNum=MTWE691-XXXXXX-XXXXX&amp;RegEmail=turner@mst.edu"  #
	# Where RegNum is the product key (found in \cdimages\Windows\MathType\MathType6.9b) (6.9d uses the same key as 6.9d).   #
  # This only ever needs to be done once -- after making the package and before doing the first test install.              #
  ##########################################################################################################################

  print("running command"."$sourcefilesdir\\setup.exe -D \"$installdir\" -Q");
  if(!run_command("$sourcefilesdir\\setup.exe -D \"$installdir\" -Q"))
  {
      output("\n");
      output("Error installing MathType 6.9d! Please make sure all instances of Microsoft Office, Outlook, or Powerpoint are closed and try again.\n");
      output("\n");

      return 0;
  }

  return 1;
}


do_install
(
  allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
  allowed_os_architectures =&gt; [ OSARCH_x64 ],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc',
                      'virtual-desktop'],

  exit_on_failure =&gt; 1,

  install_sub =&gt; \&amp;install,
);


IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\mathtype.7_1_2_373\prod\update.pl</FullName>
    <Length>2867</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-07-02T09:34:11.1258837-05:00</CreationTime>
    <CreationTimeUtc>2018-07-02T14:34:11.1258837Z</CreationTimeUtc>
    <LastWriteTime>2018-07-02T11:39:52.7470218-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-02T16:39:52.7470218Z</LastWriteTimeUtc>
    <LastAccessTime>2018-07-02T09:34:11.1258837-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-07-02T14:34:11.1258837Z</LastAccessTimeUtc>
    <Text># Package Created July 2018
# Package created by Robert Smith
# Last Updated 2018-7-2 by Robert Smith

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
  %INSTALLMONKEY_OPTIONS =
	(
    package_id =&gt; 'mathtype.7_1_2_373',
    package_revision =&gt; '20180702T1028',
  );
}


use lib
(
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);


use InstallMonkey::Shared;
use Getopt::Long;

GetOptions(
  'uninstall' =&gt; sub { exit(!uninstall()); },
);


my $sourcefilesdir = get_pkg_sourcefiles();


sub uninstall
{
  output("Uninstalling MathType: ");
  my $file = "%ProgramFiles(x86)%\\Design Science\\MathType\\Setup.exe";
  my $outcome = 0;
  if(-e $file)
  {
    $outcome = run_command("\"$file\" -R -Q");
  }
  output(($outcome?'OK':'FAILED')."\n");

  $file = "%ProgramFiles(x86)%\\MathType\\Setup.exe";
  $outcome = 0;
  if(-e $file)
  {
    $outcome = run_command("\"$file\" -R -Q");
  }
  output(($outcome?'OK':'FAILED')."\n");

  delete_product_registry_key( get_package_name(). "." .get_version() );
}

sub install
{
my $installdir = build_path(get_arch_programfiles(OSARCH_x86),'Design Science','MathType');

  ##########################################################################################################################
  # IMPORTANT:                                                                                                             #
	# Install instructions have changed from MathType 6 to 7, these are the new install instructions:                        #
	# docs.wiris.com/en/mathtype/mathtype_desktop/network_administrators_manual?s[]=silent#silent_installation_windows       #
  ##########################################################################################################################

  print("Running setup: ");
  if(!run_command("$sourcefilesdir\\MathType-win-en.exe /S /p 5AX6M-K5BR5-VYKLG-2RNOY-NMLUU /n Joe Miner /e turner\@mst.edu /a"))
  {
      output("\n");
      output("Error installing MathType 7.1.2.373! Please make sure all instances of Microsoft Office, Outlook, or Powerpoint are closed and try again.\n");
      output("\n");

      return 0;
  }
  output("Done\n");
  return 1;
}

do_install
(
  allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
  allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc',
                   'virtual-desktop'],

  exit_on_failure =&gt; 1,

  install_sub =&gt; \&amp;install,
);


IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update-academic-x86.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2014b\prod32\update-academic-x86.pl</FullName>
    <Length>1837</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-03-10T14:21:01.7328539-06:00</CreationTime>
    <CreationTimeUtc>2016-03-10T20:21:01.7328539Z</CreationTimeUtc>
    <LastWriteTime>2016-03-10T14:22:22.9324154-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-03-10T20:22:22.9324154Z</LastWriteTimeUtc>
    <LastAccessTime>2016-03-10T14:21:01.7328539-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-03-10T20:21:01.7328539Z</LastAccessTimeUtc>
    <Text># Matlab R2014b Academic Install Script
# Package Created June 2014
# Packaged by Hannah
# Updated on 2016-03-03 by Grayson Gratop

$x86_only = 1;

BEGIN
{  
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'matlab_2014b.x86',
    package_revision =&gt; 'academic-20160310T1416',
  );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'c:\temp',
);
use InstallMonkey::Shared;


########################################################################
# Begin Package Configuration
########################################################################

# This sets which folder to use for the license setup.
# It should be the only real difference between the Academic and Classroom scripts
$license_dat = get_pkg_sourcefiles().'\license.dat';
# Delete this file before exiting. It contains the install key (fik).
#   The clients shouldn't need it for heal/repair operations and it
#   could be abused if known.
$installer_ini = $ENV{'TEMP'}.'\installer.ini';

# installer.ini data
# New FIK (acquired 2016-02-08)
$fik = '29559-02224-30936-06219-34503-22489-38614-43778-58970-24010-07305-39997-23629-48977-30347';

$install_log = get_default_app_log();
# This is the default. I suspect it needs to be in 8.3 format. At least,
#   That's how the default installer.ini file specifies it.
# license.dat data
$license_server = 'matlab-academic.lic.mst.edu';
$license_server_port = '1711';
$license_dat_comment = q/
# Matlab classroom license file for research and individual use.
/;

########################################################################
# End Package Configuration
########################################################################

# Do the install.

use lib(cwd());
require('update-common.pl');</Text>
  </Script>
  <Script>
    <Name>update-classroom-x86.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2014b\prod32\update-classroom-x86.pl</FullName>
    <Length>1832</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-03-10T14:21:02.3724662-06:00</CreationTime>
    <CreationTimeUtc>2016-03-10T20:21:02.3724662Z</CreationTimeUtc>
    <LastWriteTime>2016-03-10T14:22:21.5907896-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-03-10T20:22:21.5907896Z</LastWriteTimeUtc>
    <LastAccessTime>2016-03-10T14:21:02.3724662-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-03-10T20:21:02.3724662Z</LastAccessTimeUtc>
    <Text># Matlab R2014b Academic Install Script
# Package Created June 2014
# Packaged by Hannah
# Updated on 2016-03-03 by Grayson Gratop

$x86_only = 1;

BEGIN
{
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'matlab_2014b.x86',
    package_revision =&gt; 'academic-20160310T1416',
  );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'c:\temp',
);
use InstallMonkey::Shared;


########################################################################
# Begin Package Configuration
########################################################################

# This sets which folder to use for the license setup.
# It should be the only real difference between the Academic and Classroom scripts
$license_dat = get_pkg_sourcefiles().'\license.dat';
# Delete this file before exiting. It contains the install key (fik).
#   The clients shouldn't need it for heal/repair operations and it
#   could be abused if known.
$installer_ini = $ENV{'TEMP'}.'\installer.ini';

# installer.ini data
# New FIK (acquired 2015-10-07)
$fik = '51490-45038-49543-19091-56834-32852-56497-39515-49195-38153-30892-51394-60647-11395';

$install_log = get_default_app_log();
# This is the default. I suspect it needs to be in 8.3 format. At least,
#   That's how the default installer.ini file specifies it.
# license.dat data
$license_server = 'matlab-classroom.lic.mst.edu';
$license_server_port = '1711';
$license_dat_comment = q/
# Matlab classroom license file for research and individual use.
/;

########################################################################
# End Package Configuration
########################################################################

# Do the install.

use lib(cwd());
require('update-common.pl');
</Text>
  </Script>
  <Script>
    <Name>update-common.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2014b\prod32\update-common.pl</FullName>
    <Length>10004</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-03-10T14:21:02.4036668-06:00</CreationTime>
    <CreationTimeUtc>2016-03-10T20:21:02.4036668Z</CreationTimeUtc>
    <LastWriteTime>2016-03-03T14:32:25.9830048-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-03-03T20:32:25.9830048Z</LastWriteTimeUtc>
    <LastAccessTime>2016-03-10T14:21:02.4036668-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-03-10T20:21:02.4036668Z</LastAccessTimeUtc>
    <Text>#perl -w

########################################
# DIFFERENCES BETWEEN x86/x64 VERSIONS:
#     INSTALL LOCATION
#     START MENU LINK
#     PACKAGE ID
#     DATA DIRECTORY
########################################

use Win32::OLE;
use Win32::Shortcut;
use Getopt::Long;
$pre_only = 0;
$post_only = 0;
$no_source_files = 0;
GetOptions(
  'preinstall' =&gt; \$pre_only,
  'nosource' =&gt; \$no_source_files,
  'postinstall' =&gt; \$post_only,
);


####TESTING FUNCTIONS#####
if($pre_only)
{
  preinstall();
  postinstall();
  exit(0);
}
elsif($post_only)
{
  postinstall();
  exit(0);
}
##########################

# Change the Installation Directory
if($x86_only)
{
    if (is_x86()) {
        $install_location = $ENV{'ProgramFiles'}.'\Matlab\R2014b';
    } else {
        $install_location = $ENV{'ProgramFiles(x86)'}.'\Matlab\R2014b';
    }
}
elsif($x64_only)
{
  $install_location = $ENV{'ProgramFiles'}.'\Matlab\R2014b';
}

# Delete any sensitive information upon cleanup.
sub cleanup {
    $SIG{BREAK} = 'DEFAULT';
    $SIG{TERM} = 'DEFAULT';
    $SIG{INT} = 'DEFAULT';
    $SIG{QUIT} = 'DEFAULT';
    $SIG{KILL} = 'DEFAULT';

    output("    Cleaning up...\n");
    run_command("cmd /c DEL /Y /F /Q \"${installer_ini}\"");
}
$SIG{EXIT} = \&amp;cleanup;
$SIG{QUIT} = \&amp;cleanup;
$SIG{BREAK} = \&amp;cleanup;
$SIG{INT} = \&amp;cleanup;
$SIG{KILL} = \&amp;cleanup;


if($x86_only)
{
    do_install( 
        allowed_versions =&gt; [  OSVER_XP_32, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
        allowed_regs =&gt; ["clc", "desktop", "traveling", "virtual-desktop", "virtual-clc"],
        allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
        exit_on_failure =&gt; 1,
        data_dir =&gt; 'data32',
        preinstall_sub =&gt; \&amp;preinstall,
        install_sub =&gt; \&amp;install,
        postinstall_sub =&gt; \&amp;postinstall,
        need_reboot =&gt; 1, # The install docs recommend a reboot.
        no_source_files =&gt; $no_source_files
    );
    IM_Exit(EXIT_SUCCESS);
}
if($x64_only)
{
    do_install( 
        allowed_versions =&gt; [  OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
        allowed_regs =&gt; ["clc", "desktop", "traveling", "virtual-clc", "virtual-desktop" ],
        allowed_os_architectures =&gt; [ OSARCH_x64, OSARCH_x86 ],
        exit_on_failure =&gt; 1,
        data_dir =&gt; 'data64',
        preinstall_sub =&gt; \&amp;preinstall,
        install_sub =&gt; \&amp;install,
        postinstall_sub =&gt; \&amp;postinstall,
        need_reboot =&gt; 1, # The install docs recommend a reboot.
        no_source_files =&gt; $no_source_files,
    );
    IM_Exit(EXIT_SUCCESS);
}

# Create the setup configuration files for the correct license
#   and install features.
# Unchanged for x86 or x64
sub preinstall
{
    output("    Generating install config files...\n");

    if (! -d $install_location) {
        if (!run_command("cmd /c mkdir \"${install_location}\"")) {
            output("      Cannot create install directory ".
                   "'${install_location}'.\n      Preinstall failed. ".
                   "Aborting...\n");
            exit(0);
        }
    }
    touch($install_log); # create the file so we can get the short name

    if (!generate_license_dat($license_dat,$license_server,
                              $license_server_port,$license_dat_comment)) {
        output("      Preinstall failed (license.dat creation). ".
               "Aborting...\n");
        return 0;
    }

    if (!generate_installer_ini($installer_ini,
                                get_short_path_name($install_location),
                                $fik,
                                get_short_path_name($install_log),
                                get_short_path_name($license_dat))) {
        output("      Preinstall failed (installer.ini creation). ".
               "Aborting...\n");
        return 0;
    }

    output("    Complete!\n");
        
    return 1;
}
# Changed $setup_dir for x86 and x64
sub install {
    my $sourcefilesdir = get_pkg_sourcefiles();        
    output("    Starting install...\n");

    if($x86_only)
    {
      $setup_dir = 'win32';
    }
    if($x64_only)
    {
      $setup_dir = 'win64';
    }
    # Starts the setup.exe using a batch script
    if (run_command("cmd /c \"".get_pkg_sourcefiles().
                               "\\bin\\${setup_dir}\\setup.exe\" ".
                    "-inputFile ".get_short_path_name($installer_ini))) {
        output("    Install complete!\n");
        return 1;
    } else {
        output("    FAILURE!\n");
        return 0;
    }
}

# Changed Start Menu Links for x86 and x64
sub postinstall {
    my $groupdir = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB\R2014b';
    
    # Move 32-bit directory to the standard directory scheme
    if($x86_only &amp;&amp; !is_XP())
    {
        if (! -d "${groupdir}")
        {
            run_command("cmd /c MKDIR \"${groupdir}\"");
        }
        run_command("cmd /c XCOPY /Y /E /C /Q \"${groupdir} (32-bit)\" \"${groupdir}\"");
        run_command("cmd /c RMDIR /S /Q \"${groupdir} (32-bit)\"");
    }
    
    # Remove [de]activate icons.
    my @todel = ('Activate MATLAB R2014b.lnk',
                 'Deactivate MATLAB R2014b.lnk',
                 );
    output("    Removing activation shortcuts...\n");
    foreach my $file (@todel) {
        run_command("cmd /c DEL /Q \"${groupdir}\\${file}\"");
    }

    output("    Removing extra shortcut...\n");
    my $extra_del = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB R2014b.lnk';
    if($x86_only &amp;&amp; !is_XP())
    {
        $extra_del = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB R2014b (32-bit).lnk';
        
    }
    run_command("cmd /c DEL /Q \"${extra_del}\"");
    
    # Rename links to (x86) and (x64) respectively
    # Issues with variable names in "REN" command. Used static text instead.
    # Changed:
    #    Rename "MATLAB R2014b.lnk" to "MATLAB2012a (x86).lnk"
    # or Rename "MATLAB R2014b.lnk" to "MATLAB2012a (x64).lnk"
    output("    Renaming Links...");
    if($x86_only)
    {
      if(-e "$groupdir\\MATLAB R2014b (x86).lnk")
      {
        output(" [OK]\n");
      }
      elsif(is_XP())
      {
        # For XP, we won't worry about renaming it to x86, since it can only be x86.
        output(" [OK]\n");
      }
      elsif(!run_command("cmd /c REN \"${groupdir}\\MATLAB R2014b (32-bit).lnk\" \"MATLAB R2014b (x86).lnk\""))
      {
        output("    Error renaming x86 links. Check the file names.\n");
      }
      else
      {
        output(" [OK]\n");
      }
    }
    if($x64_only)
    {
      if(-e "$groupdir\\MATLAB R2014b (x64).lnk")
      {
        output(" [OK]\n");
      }
      elsif(!run_command("cmd /c REN \"${groupdir}\\MATLAB R2014b.lnk\" \"MATLAB R2014b (x64).lnk\""))
      {
        output("    Error renaming x64 links. Check the file names.\n");
      }
      else
      {
        output(" [OK]\n");
      }
    }
    return 1;
}
# Generate the correct license.dat
sub generate_license_dat {
    my $target_location = shift;
    my $server = shift;
    my $port = shift;
    my $comment = shift;

    my $license_dat_template = &lt;&lt;LICENSE_DAT_TEMPLATE
\%s
# Autogenerated by S\&amp;T installer.
SERVER \%s 0 \%s
USE_SERVER
LICENSE_DAT_TEMPLATE
;

    my $license_dat_data = sprintf($license_dat_template,
                                   $comment,$server,$port);
    local *OUTPUT;
    if (open(OUTPUT,'&gt;',$target_location)) {
        print OUTPUT $license_dat_data;
        close(OUTPUT);
    } else {
        output("      ERROR: Cannot open concurrent license config file ".
               "'${target_location}': $!\n");
        return 0;
    }

    return 1;
}

#Nothing Changed
sub generate_installer_ini {
    my $target_location = shift;
    my $install_dir = shift;
    my $fik = shift;
    my $output_log = shift;
    my $license_dat_loc = shift;

    # This is a printf format string that uses three string variables
    #  0) install dir
    #  1) fik (file installation key)
    #  2) location of install output log
    #  3) path to license.dat file
	
# use File::Basename;
# use Win32;

# my $cwd = dirname($0);
# my $scriptdir = Win32::GetFullPathName($cwd);
# activationPropertiesFile=$scriptdir;
	
    my $installer_ini_format = &lt;&lt;INSTALLER_INI
destinationFolder=\%s
fileInstallationKey=\%s
agreeToLicense=yes
outputFile=\%s
mode=silent
automatedModeTimeout=1000
#activationPropertiesFile=
licensePath=\%s
lmgrFiles=false
lmgrService=false
desktopShortcut=false
startMenuShortcut=true
INSTALLER_INI
;

    my $installer_ini_data = sprintf($installer_ini_format,$install_dir,
                                     $fik,$output_log,$license_dat_loc);

    local *OUTPUT;
    if (open(OUTPUT,'&gt;',$target_location)) {
        print OUTPUT $installer_ini_data;
        close(OUTPUT);
    } else {
        output("      ERROR: Cannot create automated installer config file '${target_location}': $!\n");
        return 0;
    }

    return 1;
}


#
# The file/directory must exist for this function to work.
#
sub get_short_path_name {
    my $path = shift;
    my $fso = Win32::OLE-&gt;CreateObject('Scripting.FileSystemObject');
    if (Win32::OLE-&gt;LastError) {
        output("Error creating FS object: ".Win32::OLE-&gt;LastError."\n");
    }
    if (-d $path) {
        my $dir = $fso-&gt;GetFolder($path);
        return $dir-&gt;ShortPath;
    } else {
        my $file = $fso-&gt;GetFile($path);
        return $file-&gt;ShortPath;
    }
}

sub touch {
    my $file = shift;

    local *TOUCH;
    if (open(TOUCH,'&gt;&gt;',$file)) {
        close(TOUCH);
        return 1;
    } else {
        output("Cannot open file for append '${file}': $!\n");
        return 0;
    }
}
</Text>
  </Script>
  <Script>
    <Name>update-academic-x64.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2014b\prod64\update-academic-x64.pl</FullName>
    <Length>1837</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-03-03T14:30:54.315642-06:00</CreationTime>
    <CreationTimeUtc>2016-03-03T20:30:54.315642Z</CreationTimeUtc>
    <LastWriteTime>2016-03-07T15:34:39.5335017-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-03-07T21:34:39.5335017Z</LastWriteTimeUtc>
    <LastAccessTime>2016-03-03T14:30:54.315642-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-03-03T20:30:54.315642Z</LastAccessTimeUtc>
    <Text># Matlab R2014b Academic Install Script
# Package Created June 2014
# Packaged by Hannah
# Updated on 2016-03-03 by Grayson Gratop

$x64_only = 1;

BEGIN
{  
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'matlab_2014b.x64',
    package_revision =&gt; 'academic-20160303T1436',
  );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'c:\temp',
);
use InstallMonkey::Shared;


########################################################################
# Begin Package Configuration
########################################################################

# This sets which folder to use for the license setup.
# It should be the only real difference between the Academic and Classroom scripts
$license_dat = get_pkg_sourcefiles().'\license.dat';
# Delete this file before exiting. It contains the install key (fik).
#   The clients shouldn't need it for heal/repair operations and it
#   could be abused if known.
$installer_ini = $ENV{'TEMP'}.'\installer.ini';

# installer.ini data
# New FIK (acquired 2016-02-08)
$fik = '29559-02224-30936-06219-34503-22489-38614-43778-58970-24010-07305-39997-23629-48977-30347';

$install_log = get_default_app_log();
# This is the default. I suspect it needs to be in 8.3 format. At least,
#   That's how the default installer.ini file specifies it.
# license.dat data
$license_server = 'matlab-academic.lic.mst.edu';
$license_server_port = '1711';
$license_dat_comment = q/
# Matlab classroom license file for research and individual use.
/;

########################################################################
# End Package Configuration
########################################################################

# Do the install.

use lib(cwd());
require('update-common.pl');</Text>
  </Script>
  <Script>
    <Name>update-classroom-x64.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2014b\prod64\update-classroom-x64.pl</FullName>
    <Length>1833</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-03-03T14:30:54.3312423-06:00</CreationTime>
    <CreationTimeUtc>2016-03-03T20:30:54.3312423Z</CreationTimeUtc>
    <LastWriteTime>2016-04-05T14:19:06.9214273-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-04-05T19:19:06.9214273Z</LastWriteTimeUtc>
    <LastAccessTime>2016-03-03T14:30:54.3312423-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-03-03T20:30:54.3312423Z</LastAccessTimeUtc>
    <Text># Matlab R2014b Academic Install Script
# Package Created June 2014
# Packaged by Hannah
# Updated on 2016-03-03 by Grayson Gratop

$x64_only = 1;

BEGIN
{
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'matlab_2014b.x64',
    package_revision =&gt; 'classroom-20160303T1436',
  );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'c:\temp',
);
use InstallMonkey::Shared;


########################################################################
# Begin Package Configuration
########################################################################

# This sets which folder to use for the license setup.
# It should be the only real difference between the Academic and Classroom scripts
$license_dat = get_pkg_sourcefiles().'\license.dat';
# Delete this file before exiting. It contains the install key (fik).
#   The clients shouldn't need it for heal/repair operations and it
#   could be abused if known.
$installer_ini = $ENV{'TEMP'}.'\installer.ini';

# installer.ini data
# New FIK (acquired 2015-10-07)
$fik = '51490-45038-49543-19091-56834-32852-56497-39515-49195-38153-30892-51394-60647-11395';

$install_log = get_default_app_log();
# This is the default. I suspect it needs to be in 8.3 format. At least,
#   That's how the default installer.ini file specifies it.
# license.dat data
$license_server = 'matlab-classroom.lic.mst.edu';
$license_server_port = '1711';
$license_dat_comment = q/
# Matlab classroom license file for research and individual use.
/;

########################################################################
# End Package Configuration
########################################################################

# Do the install.

use lib(cwd());
require('update-common.pl');
</Text>
  </Script>
  <Script>
    <Name>update-common.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2014b\prod64\update-common.pl</FullName>
    <Length>10004</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-03-03T14:30:54.0972378-06:00</CreationTime>
    <CreationTimeUtc>2016-03-03T20:30:54.0972378Z</CreationTimeUtc>
    <LastWriteTime>2016-03-03T14:32:25.9830048-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-03-03T20:32:25.9830048Z</LastWriteTimeUtc>
    <LastAccessTime>2016-03-03T14:30:54.0972378-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-03-03T20:30:54.0972378Z</LastAccessTimeUtc>
    <Text>#perl -w

########################################
# DIFFERENCES BETWEEN x86/x64 VERSIONS:
#     INSTALL LOCATION
#     START MENU LINK
#     PACKAGE ID
#     DATA DIRECTORY
########################################

use Win32::OLE;
use Win32::Shortcut;
use Getopt::Long;
$pre_only = 0;
$post_only = 0;
$no_source_files = 0;
GetOptions(
  'preinstall' =&gt; \$pre_only,
  'nosource' =&gt; \$no_source_files,
  'postinstall' =&gt; \$post_only,
);


####TESTING FUNCTIONS#####
if($pre_only)
{
  preinstall();
  postinstall();
  exit(0);
}
elsif($post_only)
{
  postinstall();
  exit(0);
}
##########################

# Change the Installation Directory
if($x86_only)
{
    if (is_x86()) {
        $install_location = $ENV{'ProgramFiles'}.'\Matlab\R2014b';
    } else {
        $install_location = $ENV{'ProgramFiles(x86)'}.'\Matlab\R2014b';
    }
}
elsif($x64_only)
{
  $install_location = $ENV{'ProgramFiles'}.'\Matlab\R2014b';
}

# Delete any sensitive information upon cleanup.
sub cleanup {
    $SIG{BREAK} = 'DEFAULT';
    $SIG{TERM} = 'DEFAULT';
    $SIG{INT} = 'DEFAULT';
    $SIG{QUIT} = 'DEFAULT';
    $SIG{KILL} = 'DEFAULT';

    output("    Cleaning up...\n");
    run_command("cmd /c DEL /Y /F /Q \"${installer_ini}\"");
}
$SIG{EXIT} = \&amp;cleanup;
$SIG{QUIT} = \&amp;cleanup;
$SIG{BREAK} = \&amp;cleanup;
$SIG{INT} = \&amp;cleanup;
$SIG{KILL} = \&amp;cleanup;


if($x86_only)
{
    do_install( 
        allowed_versions =&gt; [  OSVER_XP_32, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
        allowed_regs =&gt; ["clc", "desktop", "traveling", "virtual-desktop", "virtual-clc"],
        allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
        exit_on_failure =&gt; 1,
        data_dir =&gt; 'data32',
        preinstall_sub =&gt; \&amp;preinstall,
        install_sub =&gt; \&amp;install,
        postinstall_sub =&gt; \&amp;postinstall,
        need_reboot =&gt; 1, # The install docs recommend a reboot.
        no_source_files =&gt; $no_source_files
    );
    IM_Exit(EXIT_SUCCESS);
}
if($x64_only)
{
    do_install( 
        allowed_versions =&gt; [  OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
        allowed_regs =&gt; ["clc", "desktop", "traveling", "virtual-clc", "virtual-desktop" ],
        allowed_os_architectures =&gt; [ OSARCH_x64, OSARCH_x86 ],
        exit_on_failure =&gt; 1,
        data_dir =&gt; 'data64',
        preinstall_sub =&gt; \&amp;preinstall,
        install_sub =&gt; \&amp;install,
        postinstall_sub =&gt; \&amp;postinstall,
        need_reboot =&gt; 1, # The install docs recommend a reboot.
        no_source_files =&gt; $no_source_files,
    );
    IM_Exit(EXIT_SUCCESS);
}

# Create the setup configuration files for the correct license
#   and install features.
# Unchanged for x86 or x64
sub preinstall
{
    output("    Generating install config files...\n");

    if (! -d $install_location) {
        if (!run_command("cmd /c mkdir \"${install_location}\"")) {
            output("      Cannot create install directory ".
                   "'${install_location}'.\n      Preinstall failed. ".
                   "Aborting...\n");
            exit(0);
        }
    }
    touch($install_log); # create the file so we can get the short name

    if (!generate_license_dat($license_dat,$license_server,
                              $license_server_port,$license_dat_comment)) {
        output("      Preinstall failed (license.dat creation). ".
               "Aborting...\n");
        return 0;
    }

    if (!generate_installer_ini($installer_ini,
                                get_short_path_name($install_location),
                                $fik,
                                get_short_path_name($install_log),
                                get_short_path_name($license_dat))) {
        output("      Preinstall failed (installer.ini creation). ".
               "Aborting...\n");
        return 0;
    }

    output("    Complete!\n");
        
    return 1;
}
# Changed $setup_dir for x86 and x64
sub install {
    my $sourcefilesdir = get_pkg_sourcefiles();        
    output("    Starting install...\n");

    if($x86_only)
    {
      $setup_dir = 'win32';
    }
    if($x64_only)
    {
      $setup_dir = 'win64';
    }
    # Starts the setup.exe using a batch script
    if (run_command("cmd /c \"".get_pkg_sourcefiles().
                               "\\bin\\${setup_dir}\\setup.exe\" ".
                    "-inputFile ".get_short_path_name($installer_ini))) {
        output("    Install complete!\n");
        return 1;
    } else {
        output("    FAILURE!\n");
        return 0;
    }
}

# Changed Start Menu Links for x86 and x64
sub postinstall {
    my $groupdir = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB\R2014b';
    
    # Move 32-bit directory to the standard directory scheme
    if($x86_only &amp;&amp; !is_XP())
    {
        if (! -d "${groupdir}")
        {
            run_command("cmd /c MKDIR \"${groupdir}\"");
        }
        run_command("cmd /c XCOPY /Y /E /C /Q \"${groupdir} (32-bit)\" \"${groupdir}\"");
        run_command("cmd /c RMDIR /S /Q \"${groupdir} (32-bit)\"");
    }
    
    # Remove [de]activate icons.
    my @todel = ('Activate MATLAB R2014b.lnk',
                 'Deactivate MATLAB R2014b.lnk',
                 );
    output("    Removing activation shortcuts...\n");
    foreach my $file (@todel) {
        run_command("cmd /c DEL /Q \"${groupdir}\\${file}\"");
    }

    output("    Removing extra shortcut...\n");
    my $extra_del = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB R2014b.lnk';
    if($x86_only &amp;&amp; !is_XP())
    {
        $extra_del = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB R2014b (32-bit).lnk';
        
    }
    run_command("cmd /c DEL /Q \"${extra_del}\"");
    
    # Rename links to (x86) and (x64) respectively
    # Issues with variable names in "REN" command. Used static text instead.
    # Changed:
    #    Rename "MATLAB R2014b.lnk" to "MATLAB2012a (x86).lnk"
    # or Rename "MATLAB R2014b.lnk" to "MATLAB2012a (x64).lnk"
    output("    Renaming Links...");
    if($x86_only)
    {
      if(-e "$groupdir\\MATLAB R2014b (x86).lnk")
      {
        output(" [OK]\n");
      }
      elsif(is_XP())
      {
        # For XP, we won't worry about renaming it to x86, since it can only be x86.
        output(" [OK]\n");
      }
      elsif(!run_command("cmd /c REN \"${groupdir}\\MATLAB R2014b (32-bit).lnk\" \"MATLAB R2014b (x86).lnk\""))
      {
        output("    Error renaming x86 links. Check the file names.\n");
      }
      else
      {
        output(" [OK]\n");
      }
    }
    if($x64_only)
    {
      if(-e "$groupdir\\MATLAB R2014b (x64).lnk")
      {
        output(" [OK]\n");
      }
      elsif(!run_command("cmd /c REN \"${groupdir}\\MATLAB R2014b.lnk\" \"MATLAB R2014b (x64).lnk\""))
      {
        output("    Error renaming x64 links. Check the file names.\n");
      }
      else
      {
        output(" [OK]\n");
      }
    }
    return 1;
}
# Generate the correct license.dat
sub generate_license_dat {
    my $target_location = shift;
    my $server = shift;
    my $port = shift;
    my $comment = shift;

    my $license_dat_template = &lt;&lt;LICENSE_DAT_TEMPLATE
\%s
# Autogenerated by S\&amp;T installer.
SERVER \%s 0 \%s
USE_SERVER
LICENSE_DAT_TEMPLATE
;

    my $license_dat_data = sprintf($license_dat_template,
                                   $comment,$server,$port);
    local *OUTPUT;
    if (open(OUTPUT,'&gt;',$target_location)) {
        print OUTPUT $license_dat_data;
        close(OUTPUT);
    } else {
        output("      ERROR: Cannot open concurrent license config file ".
               "'${target_location}': $!\n");
        return 0;
    }

    return 1;
}

#Nothing Changed
sub generate_installer_ini {
    my $target_location = shift;
    my $install_dir = shift;
    my $fik = shift;
    my $output_log = shift;
    my $license_dat_loc = shift;

    # This is a printf format string that uses three string variables
    #  0) install dir
    #  1) fik (file installation key)
    #  2) location of install output log
    #  3) path to license.dat file
	
# use File::Basename;
# use Win32;

# my $cwd = dirname($0);
# my $scriptdir = Win32::GetFullPathName($cwd);
# activationPropertiesFile=$scriptdir;
	
    my $installer_ini_format = &lt;&lt;INSTALLER_INI
destinationFolder=\%s
fileInstallationKey=\%s
agreeToLicense=yes
outputFile=\%s
mode=silent
automatedModeTimeout=1000
#activationPropertiesFile=
licensePath=\%s
lmgrFiles=false
lmgrService=false
desktopShortcut=false
startMenuShortcut=true
INSTALLER_INI
;

    my $installer_ini_data = sprintf($installer_ini_format,$install_dir,
                                     $fik,$output_log,$license_dat_loc);

    local *OUTPUT;
    if (open(OUTPUT,'&gt;',$target_location)) {
        print OUTPUT $installer_ini_data;
        close(OUTPUT);
    } else {
        output("      ERROR: Cannot create automated installer config file '${target_location}': $!\n");
        return 0;
    }

    return 1;
}


#
# The file/directory must exist for this function to work.
#
sub get_short_path_name {
    my $path = shift;
    my $fso = Win32::OLE-&gt;CreateObject('Scripting.FileSystemObject');
    if (Win32::OLE-&gt;LastError) {
        output("Error creating FS object: ".Win32::OLE-&gt;LastError."\n");
    }
    if (-d $path) {
        my $dir = $fso-&gt;GetFolder($path);
        return $dir-&gt;ShortPath;
    } else {
        my $file = $fso-&gt;GetFile($path);
        return $file-&gt;ShortPath;
    }
}

sub touch {
    my $file = shift;

    local *TOUCH;
    if (open(TOUCH,'&gt;&gt;',$file)) {
        close(TOUCH);
        return 1;
    } else {
        output("Cannot open file for append '${file}': $!\n");
        return 0;
    }
}
</Text>
  </Script>
  <Script>
    <Name>update-academic-x86.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2015a\prod32\update-academic-x86.pl</FullName>
    <Length>1837</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-03-10T14:15:11.4125171-06:00</CreationTime>
    <CreationTimeUtc>2016-03-10T20:15:11.4125171Z</CreationTimeUtc>
    <LastWriteTime>2016-03-10T14:18:37.0556717-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-03-10T20:18:37.0556717Z</LastWriteTimeUtc>
    <LastAccessTime>2016-03-10T14:15:11.4125171-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-03-10T20:15:11.4125171Z</LastAccessTimeUtc>
    <Text># Matlab R2015a Academic Install Script
# Package Created June 2014
# Packaged by Hannah
# Updated on 2016-02-24 by Grayson Gratop

$x86_only = 1;

BEGIN
{
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'matlab_2015a.x86',
    package_revision =&gt; 'academic-20160310T1416',
  );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'c:\temp',
);
use InstallMonkey::Shared;


########################################################################
# Begin Package Configuration
########################################################################

# This sets which folder to use for the license setup.
# It should be the only real difference between the Academic and Classroom scripts
$license_dat = get_pkg_sourcefiles().'\license.dat';
# Delete this file before exiting. It contains the install key (fik).
#   The clients shouldn't need it for heal/repair operations and it
#   could be abused if known.
$installer_ini = $ENV{'TEMP'}.'\installer.ini';

# installer.ini data
# New FIK (acquired 2016-02-08)
$fik = '13286-31092-64031-05861-34876-05596-08567-16420-07437-13887-01907-59830-35854-11953-08419';

$install_log = get_default_app_log();
# This is the default. I suspect it needs to be in 8.3 format. At least,
#   That's how the default installer.ini file specifies it.
# license.dat data
$license_server = 'matlab-academic.lic.mst.edu';
$license_server_port = '1711';
$license_dat_comment = q/
# Matlab classroom license file for research and individual use.
/;

########################################################################
# End Package Configuration
########################################################################

# Do the install.

use lib(cwd());
require('update-common.pl');
</Text>
  </Script>
  <Script>
    <Name>update-classroom-x86.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2015a\prod32\update-classroom-x86.pl</FullName>
    <Length>1929</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-03-10T14:15:11.4437177-06:00</CreationTime>
    <CreationTimeUtc>2016-03-10T20:15:11.4437177Z</CreationTimeUtc>
    <LastWriteTime>2016-03-10T14:18:55.4640257-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-03-10T20:18:55.4640257Z</LastWriteTimeUtc>
    <LastAccessTime>2016-03-10T14:15:11.4437177-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-03-10T20:15:11.4437177Z</LastAccessTimeUtc>
    <Text># Matlab R2012a Classroom Install Script
# Package Created June 2014
# Packaged by Hannah
# Updated on 2016-02-24 by Grayson Gratop

$x86_only = 1;

BEGIN
{
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'matlab_2015a.x86',
    package_revision =&gt; 'classroom-20160310T1416',
  );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'c:\temp',
);
use InstallMonkey::Shared;

$sourcefilesdir = get_pkg_sourcefiles();

########################################################################
# Begin Package Configuration
########################################################################

# This sets which folder to use for the license setup.
# It should be the only real difference between the Academic and Classroom scripts
$license_dat = get_pkg_sourcefiles().'\license.dat';
# Delete this file before exiting. It contains the install key (fik).
#   The clients shouldn't need it for heal/repair operations and it
#   could be abused if known.
$installer_ini = $ENV{'TEMP'}.'\installer.ini';

# installer.ini data
# New FIK (acquired 2015-07-10)
$fik = '51490-45038-49543-19091-56834-32852-56497-39515-49195-38153-30892-51394-60647-11395';

$install_log = get_default_app_log();
# This is the default. I suspect it needs to be in 8.3 format. At least,
#   That's how the default installer.ini file specifies it.
# license.dat data
$license_server = 'matlab-classroom.lic.mst.edu';
$license_server_port = '1711';
$license_dat_comment = q/
# Matlab classroom license file for CLC's
# This license is for use in instructional classes only. Not for research.
/;

########################################################################
# End Package Configuration
########################################################################

# Do the install.
use lib(cwd());

require('update-common.pl');
</Text>
  </Script>
  <Script>
    <Name>update-common.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2015a\prod32\update-common.pl</FullName>
    <Length>10004</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-03-10T14:15:11.459318-06:00</CreationTime>
    <CreationTimeUtc>2016-03-10T20:15:11.459318Z</CreationTimeUtc>
    <LastWriteTime>2016-03-10T14:17:08.8827761-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-03-10T20:17:08.8827761Z</LastWriteTimeUtc>
    <LastAccessTime>2016-03-10T14:15:11.459318-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-03-10T20:15:11.459318Z</LastAccessTimeUtc>
    <Text>#perl -w

########################################
# DIFFERENCES BETWEEN x86/x64 VERSIONS:
#     INSTALL LOCATION
#     START MENU LINK
#     PACKAGE ID
#     DATA DIRECTORY
########################################

use Win32::OLE;
use Win32::Shortcut;
use Getopt::Long;
$pre_only = 0;
$post_only = 0;
$no_source_files = 0;
GetOptions(
  'preinstall' =&gt; \$pre_only,
  'nosource' =&gt; \$no_source_files,
  'postinstall' =&gt; \$post_only,
);


####TESTING FUNCTIONS#####
if($pre_only)
{
  preinstall();
  postinstall();
  exit(0);
}
elsif($post_only)
{
  postinstall();
  exit(0);
}
##########################

# Change the Installation Directory
if($x86_only)
{
    if (is_x86()) {
        $install_location = $ENV{'ProgramFiles'}.'\Matlab\R2015a';
    } else {
        $install_location = $ENV{'ProgramFiles(x86)'}.'\Matlab\R2015a';
    }
}
elsif($x64_only)
{
  $install_location = $ENV{'ProgramFiles'}.'\Matlab\R2015a';
}

# Delete any sensitive information upon cleanup.
sub cleanup {
    $SIG{BREAK} = 'DEFAULT';
    $SIG{TERM} = 'DEFAULT';
    $SIG{INT} = 'DEFAULT';
    $SIG{QUIT} = 'DEFAULT';
    $SIG{KILL} = 'DEFAULT';

    output("    Cleaning up...\n");
    run_command("cmd /c DEL /Y /F /Q \"${installer_ini}\"");
}
$SIG{EXIT} = \&amp;cleanup;
$SIG{QUIT} = \&amp;cleanup;
$SIG{BREAK} = \&amp;cleanup;
$SIG{INT} = \&amp;cleanup;
$SIG{KILL} = \&amp;cleanup;


if($x86_only)
{
    do_install( 
        allowed_versions =&gt; [  OSVER_XP_32, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
        allowed_regs =&gt; ["clc", "desktop", "traveling", "virtual-desktop", "virtual-clc"],
        allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
        exit_on_failure =&gt; 1,
        data_dir =&gt; 'data32',
        preinstall_sub =&gt; \&amp;preinstall,
        install_sub =&gt; \&amp;install,
        postinstall_sub =&gt; \&amp;postinstall,
        need_reboot =&gt; 1, # The install docs recommend a reboot.
        no_source_files =&gt; $no_source_files
    );
    IM_Exit(EXIT_SUCCESS);
}
if($x64_only)
{
    do_install( 
        allowed_versions =&gt; [  OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
        allowed_regs =&gt; ["clc", "desktop", "traveling", "virtual-clc", "virtual-desktop" ],
        allowed_os_architectures =&gt; [ OSARCH_x64, OSARCH_x86 ],
        exit_on_failure =&gt; 1,
        data_dir =&gt; 'data64',
        preinstall_sub =&gt; \&amp;preinstall,
        install_sub =&gt; \&amp;install,
        postinstall_sub =&gt; \&amp;postinstall,
        need_reboot =&gt; 1, # The install docs recommend a reboot.
        no_source_files =&gt; $no_source_files,
    );
    IM_Exit(EXIT_SUCCESS);
}

# Create the setup configuration files for the correct license
#   and install features.
# Unchanged for x86 or x64
sub preinstall
{
    output("    Generating install config files...\n");

    if (! -d $install_location) {
        if (!run_command("cmd /c mkdir \"${install_location}\"")) {
            output("      Cannot create install directory ".
                   "'${install_location}'.\n      Preinstall failed. ".
                   "Aborting...\n");
            exit(0);
        }
    }
    touch($install_log); # create the file so we can get the short name

    if (!generate_license_dat($license_dat,$license_server,
                              $license_server_port,$license_dat_comment)) {
        output("      Preinstall failed (license.dat creation). ".
               "Aborting...\n");
        return 0;
    }

    if (!generate_installer_ini($installer_ini,
                                get_short_path_name($install_location),
                                $fik,
                                get_short_path_name($install_log),
                                get_short_path_name($license_dat))) {
        output("      Preinstall failed (installer.ini creation). ".
               "Aborting...\n");
        return 0;
    }

    output("    Complete!\n");
        
    return 1;
}
# Changed $setup_dir for x86 and x64
sub install {
    my $sourcefilesdir = get_pkg_sourcefiles();        
    output("    Starting install...\n");

    if($x86_only)
    {
      $setup_dir = 'win32';
    }
    if($x64_only)
    {
      $setup_dir = 'win64';
    }
    # Starts the setup.exe using a batch script
    if (run_command("cmd /c \"".get_pkg_sourcefiles().
                               "\\bin\\${setup_dir}\\setup.exe\" ".
                    "-inputFile ".get_short_path_name($installer_ini))) {
        output("    Install complete!\n");
        return 1;
    } else {
        output("    FAILURE!\n");
        return 0;
    }
}

# Changed Start Menu Links for x86 and x64
sub postinstall {
    my $groupdir = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB\R2015a';
    
    # Move 32-bit directory to the standard directory scheme
    if($x86_only &amp;&amp; !is_XP())
    {
        if (! -d "${groupdir}")
        {
            run_command("cmd /c MKDIR \"${groupdir}\"");
        }
        run_command("cmd /c XCOPY /Y /E /C /Q \"${groupdir} (32-bit)\" \"${groupdir}\"");
        run_command("cmd /c RMDIR /S /Q \"${groupdir} (32-bit)\"");
    }
    
    # Remove [de]activate icons.
    my @todel = ('Activate MATLAB R2015a.lnk',
                 'Deactivate MATLAB R2015a.lnk',
                 );
    output("    Removing activation shortcuts...\n");
    foreach my $file (@todel) {
        run_command("cmd /c DEL /Q \"${groupdir}\\${file}\"");
    }

    output("    Removing extra shortcut...\n");
    my $extra_del = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB R2015a.lnk';
    if($x86_only &amp;&amp; !is_XP())
    {
        $extra_del = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB R2015a (32-bit).lnk';
        
    }
    run_command("cmd /c DEL /Q \"${extra_del}\"");
    
    # Rename links to (x86) and (x64) respectively
    # Issues with variable names in "REN" command. Used static text instead.
    # Changed:
    #    Rename "MATLAB R2015a.lnk" to "MATLAB2012a (x86).lnk"
    # or Rename "MATLAB R2015a.lnk" to "MATLAB2012a (x64).lnk"
    output("    Renaming Links...");
    if($x86_only)
    {
      if(-e "$groupdir\\MATLAB R2015a (x86).lnk")
      {
        output(" [OK]\n");
      }
      elsif(is_XP())
      {
        # For XP, we won't worry about renaming it to x86, since it can only be x86.
        output(" [OK]\n");
      }
      elsif(!run_command("cmd /c REN \"${groupdir}\\MATLAB R2015a (32-bit).lnk\" \"MATLAB R2015a (x86).lnk\""))
      {
        output("    Error renaming x86 links. Check the file names.\n");
      }
      else
      {
        output(" [OK]\n");
      }
    }
    if($x64_only)
    {
      if(-e "$groupdir\\MATLAB R2015a (x64).lnk")
      {
        output(" [OK]\n");
      }
      elsif(!run_command("cmd /c REN \"${groupdir}\\MATLAB R2015a.lnk\" \"MATLAB R2015a (x64).lnk\""))
      {
        output("    Error renaming x64 links. Check the file names.\n");
      }
      else
      {
        output(" [OK]\n");
      }
    }
    return 1;
}
# Generate the correct license.dat
sub generate_license_dat {
    my $target_location = shift;
    my $server = shift;
    my $port = shift;
    my $comment = shift;

    my $license_dat_template = &lt;&lt;LICENSE_DAT_TEMPLATE
\%s
# Autogenerated by S\&amp;T installer.
SERVER \%s 0 \%s
USE_SERVER
LICENSE_DAT_TEMPLATE
;

    my $license_dat_data = sprintf($license_dat_template,
                                   $comment,$server,$port);
    local *OUTPUT;
    if (open(OUTPUT,'&gt;',$target_location)) {
        print OUTPUT $license_dat_data;
        close(OUTPUT);
    } else {
        output("      ERROR: Cannot open concurrent license config file ".
               "'${target_location}': $!\n");
        return 0;
    }

    return 1;
}

#Nothing Changed
sub generate_installer_ini {
    my $target_location = shift;
    my $install_dir = shift;
    my $fik = shift;
    my $output_log = shift;
    my $license_dat_loc = shift;

    # This is a printf format string that uses three string variables
    #  0) install dir
    #  1) fik (file installation key)
    #  2) location of install output log
    #  3) path to license.dat file
	
# use File::Basename;
# use Win32;

# my $cwd = dirname($0);
# my $scriptdir = Win32::GetFullPathName($cwd);
# activationPropertiesFile=$scriptdir;
	
    my $installer_ini_format = &lt;&lt;INSTALLER_INI
destinationFolder=\%s
fileInstallationKey=\%s
agreeToLicense=yes
outputFile=\%s
mode=silent
automatedModeTimeout=1000
#activationPropertiesFile=
licensePath=\%s
lmgrFiles=false
lmgrService=false
desktopShortcut=false
startMenuShortcut=true
INSTALLER_INI
;

    my $installer_ini_data = sprintf($installer_ini_format,$install_dir,
                                     $fik,$output_log,$license_dat_loc);

    local *OUTPUT;
    if (open(OUTPUT,'&gt;',$target_location)) {
        print OUTPUT $installer_ini_data;
        close(OUTPUT);
    } else {
        output("      ERROR: Cannot create automated installer config file '${target_location}': $!\n");
        return 0;
    }

    return 1;
}


#
# The file/directory must exist for this function to work.
#
sub get_short_path_name {
    my $path = shift;
    my $fso = Win32::OLE-&gt;CreateObject('Scripting.FileSystemObject');
    if (Win32::OLE-&gt;LastError) {
        output("Error creating FS object: ".Win32::OLE-&gt;LastError."\n");
    }
    if (-d $path) {
        my $dir = $fso-&gt;GetFolder($path);
        return $dir-&gt;ShortPath;
    } else {
        my $file = $fso-&gt;GetFile($path);
        return $file-&gt;ShortPath;
    }
}

sub touch {
    my $file = shift;

    local *TOUCH;
    if (open(TOUCH,'&gt;&gt;',$file)) {
        close(TOUCH);
        return 1;
    } else {
        output("Cannot open file for append '${file}': $!\n");
        return 0;
    }
}
</Text>
  </Script>
  <Script>
    <Name>update-academic-x64.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2015a\prod64\update-academic-x64.pl</FullName>
    <Length>1837</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-03-03T14:25:54.1190691-06:00</CreationTime>
    <CreationTimeUtc>2016-03-03T20:25:54.1190691Z</CreationTimeUtc>
    <LastWriteTime>2016-03-03T14:37:15.0253632-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-03-03T20:37:15.0253632Z</LastWriteTimeUtc>
    <LastAccessTime>2016-03-03T14:25:54.1190691-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-03-03T20:25:54.1190691Z</LastAccessTimeUtc>
    <Text># Matlab R2015a Academic Install Script
# Package Created June 2014
# Packaged by Hannah
# Updated on 2016-03-03 by Grayson Gratop

$x64_only = 1;

BEGIN
{  
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'matlab_2015a.x64',
    package_revision =&gt; 'academic-20160303T1436',
  );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'c:\temp',
);
use InstallMonkey::Shared;


########################################################################
# Begin Package Configuration
########################################################################

# This sets which folder to use for the license setup.
# It should be the only real difference between the Academic and Classroom scripts
$license_dat = get_pkg_sourcefiles().'\license.dat';
# Delete this file before exiting. It contains the install key (fik).
#   The clients shouldn't need it for heal/repair operations and it
#   could be abused if known.
$installer_ini = $ENV{'TEMP'}.'\installer.ini';

# installer.ini data
# New FIK (acquired 2016-02-08)
$fik = '13286-31092-64031-05861-34876-05596-08567-16420-07437-13887-01907-59830-35854-11953-08419';

$install_log = get_default_app_log();
# This is the default. I suspect it needs to be in 8.3 format. At least,
#   That's how the default installer.ini file specifies it.
# license.dat data
$license_server = 'matlab-academic.lic.mst.edu';
$license_server_port = '1711';
$license_dat_comment = q/
# Matlab classroom license file for research and individual use.
/;

########################################################################
# End Package Configuration
########################################################################

# Do the install.

use lib(cwd());
require('update-common.pl');</Text>
  </Script>
  <Script>
    <Name>update-classroom-x64.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2015a\prod64\update-classroom-x64.pl</FullName>
    <Length>1833</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-03-03T14:25:54.16587-06:00</CreationTime>
    <CreationTimeUtc>2016-03-03T20:25:54.16587Z</CreationTimeUtc>
    <LastWriteTime>2016-04-05T14:18:45.1744697-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-04-05T19:18:45.1744697Z</LastWriteTimeUtc>
    <LastAccessTime>2016-03-03T14:25:54.16587-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-03-03T20:25:54.16587Z</LastAccessTimeUtc>
    <Text># Matlab R2015a Academic Install Script
# Package Created June 2014
# Packaged by Hannah
# Updated on 2016-03-03 by Grayson Gratop

$x64_only = 1;

BEGIN
{
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'matlab_2015a.x64',
    package_revision =&gt; 'classroom-20160303T1436',
  );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'c:\temp',
);
use InstallMonkey::Shared;


########################################################################
# Begin Package Configuration
########################################################################

# This sets which folder to use for the license setup.
# It should be the only real difference between the Academic and Classroom scripts
$license_dat = get_pkg_sourcefiles().'\license.dat';
# Delete this file before exiting. It contains the install key (fik).
#   The clients shouldn't need it for heal/repair operations and it
#   could be abused if known.
$installer_ini = $ENV{'TEMP'}.'\installer.ini';

# installer.ini data
# New FIK (acquired 2015-10-07)
$fik = '51490-45038-49543-19091-56834-32852-56497-39515-49195-38153-30892-51394-60647-11395';

$install_log = get_default_app_log();
# This is the default. I suspect it needs to be in 8.3 format. At least,
#   That's how the default installer.ini file specifies it.
# license.dat data
$license_server = 'matlab-classroom.lic.mst.edu';
$license_server_port = '1711';
$license_dat_comment = q/
# Matlab classroom license file for research and individual use.
/;

########################################################################
# End Package Configuration
########################################################################

# Do the install.

use lib(cwd());
require('update-common.pl');
</Text>
  </Script>
  <Script>
    <Name>update-common.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2015a\prod64\update-common.pl</FullName>
    <Length>10004</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-03-03T14:25:54.2126709-06:00</CreationTime>
    <CreationTimeUtc>2016-03-03T20:25:54.2126709Z</CreationTimeUtc>
    <LastWriteTime>2016-03-03T14:29:22.8042822-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-03-03T20:29:22.8042822Z</LastWriteTimeUtc>
    <LastAccessTime>2016-03-03T14:25:54.2126709-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-03-03T20:25:54.2126709Z</LastAccessTimeUtc>
    <Text>#perl -w

########################################
# DIFFERENCES BETWEEN x86/x64 VERSIONS:
#     INSTALL LOCATION
#     START MENU LINK
#     PACKAGE ID
#     DATA DIRECTORY
########################################

use Win32::OLE;
use Win32::Shortcut;
use Getopt::Long;
$pre_only = 0;
$post_only = 0;
$no_source_files = 0;
GetOptions(
  'preinstall' =&gt; \$pre_only,
  'nosource' =&gt; \$no_source_files,
  'postinstall' =&gt; \$post_only,
);


####TESTING FUNCTIONS#####
if($pre_only)
{
  preinstall();
  postinstall();
  exit(0);
}
elsif($post_only)
{
  postinstall();
  exit(0);
}
##########################

# Change the Installation Directory
if($x86_only)
{
    if (is_x86()) {
        $install_location = $ENV{'ProgramFiles'}.'\Matlab\R2015a';
    } else {
        $install_location = $ENV{'ProgramFiles(x86)'}.'\Matlab\R2015a';
    }
}
elsif($x64_only)
{
  $install_location = $ENV{'ProgramFiles'}.'\Matlab\R2015a';
}

# Delete any sensitive information upon cleanup.
sub cleanup {
    $SIG{BREAK} = 'DEFAULT';
    $SIG{TERM} = 'DEFAULT';
    $SIG{INT} = 'DEFAULT';
    $SIG{QUIT} = 'DEFAULT';
    $SIG{KILL} = 'DEFAULT';

    output("    Cleaning up...\n");
    run_command("cmd /c DEL /Y /F /Q \"${installer_ini}\"");
}
$SIG{EXIT} = \&amp;cleanup;
$SIG{QUIT} = \&amp;cleanup;
$SIG{BREAK} = \&amp;cleanup;
$SIG{INT} = \&amp;cleanup;
$SIG{KILL} = \&amp;cleanup;


if($x86_only)
{
    do_install( 
        allowed_versions =&gt; [  OSVER_XP_32, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
        allowed_regs =&gt; ["clc", "desktop", "traveling", "virtual-desktop", "virtual-clc"],
        allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
        exit_on_failure =&gt; 1,
        data_dir =&gt; 'data32',
        preinstall_sub =&gt; \&amp;preinstall,
        install_sub =&gt; \&amp;install,
        postinstall_sub =&gt; \&amp;postinstall,
        need_reboot =&gt; 1, # The install docs recommend a reboot.
        no_source_files =&gt; $no_source_files
    );
    IM_Exit(EXIT_SUCCESS);
}
if($x64_only)
{
    do_install( 
        allowed_versions =&gt; [  OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
        allowed_regs =&gt; ["clc", "desktop", "traveling", "virtual-clc", "virtual-desktop" ],
        allowed_os_architectures =&gt; [ OSARCH_x64, OSARCH_x86 ],
        exit_on_failure =&gt; 1,
        data_dir =&gt; 'data64',
        preinstall_sub =&gt; \&amp;preinstall,
        install_sub =&gt; \&amp;install,
        postinstall_sub =&gt; \&amp;postinstall,
        need_reboot =&gt; 1, # The install docs recommend a reboot.
        no_source_files =&gt; $no_source_files,
    );
    IM_Exit(EXIT_SUCCESS);
}

# Create the setup configuration files for the correct license
#   and install features.
# Unchanged for x86 or x64
sub preinstall
{
    output("    Generating install config files...\n");

    if (! -d $install_location) {
        if (!run_command("cmd /c mkdir \"${install_location}\"")) {
            output("      Cannot create install directory ".
                   "'${install_location}'.\n      Preinstall failed. ".
                   "Aborting...\n");
            exit(0);
        }
    }
    touch($install_log); # create the file so we can get the short name

    if (!generate_license_dat($license_dat,$license_server,
                              $license_server_port,$license_dat_comment)) {
        output("      Preinstall failed (license.dat creation). ".
               "Aborting...\n");
        return 0;
    }

    if (!generate_installer_ini($installer_ini,
                                get_short_path_name($install_location),
                                $fik,
                                get_short_path_name($install_log),
                                get_short_path_name($license_dat))) {
        output("      Preinstall failed (installer.ini creation). ".
               "Aborting...\n");
        return 0;
    }

    output("    Complete!\n");
        
    return 1;
}
# Changed $setup_dir for x86 and x64
sub install {
    my $sourcefilesdir = get_pkg_sourcefiles();        
    output("    Starting install...\n");

    if($x86_only)
    {
      $setup_dir = 'win32';
    }
    if($x64_only)
    {
      $setup_dir = 'win64';
    }
    # Starts the setup.exe using a batch script
    if (run_command("cmd /c \"".get_pkg_sourcefiles().
                               "\\bin\\${setup_dir}\\setup.exe\" ".
                    "-inputFile ".get_short_path_name($installer_ini))) {
        output("    Install complete!\n");
        return 1;
    } else {
        output("    FAILURE!\n");
        return 0;
    }
}

# Changed Start Menu Links for x86 and x64
sub postinstall {
    my $groupdir = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB\R2015a';
    
    # Move 32-bit directory to the standard directory scheme
    if($x86_only &amp;&amp; !is_XP())
    {
        if (! -d "${groupdir}")
        {
            run_command("cmd /c MKDIR \"${groupdir}\"");
        }
        run_command("cmd /c XCOPY /Y /E /C /Q \"${groupdir} (32-bit)\" \"${groupdir}\"");
        run_command("cmd /c RMDIR /S /Q \"${groupdir} (32-bit)\"");
    }
    
    # Remove [de]activate icons.
    my @todel = ('Activate MATLAB R2015a.lnk',
                 'Deactivate MATLAB R2015a.lnk',
                 );
    output("    Removing activation shortcuts...\n");
    foreach my $file (@todel) {
        run_command("cmd /c DEL /Q \"${groupdir}\\${file}\"");
    }

    output("    Removing extra shortcut...\n");
    my $extra_del = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB R2015a.lnk';
    if($x86_only &amp;&amp; !is_XP())
    {
        $extra_del = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB R2015a (32-bit).lnk';
        
    }
    run_command("cmd /c DEL /Q \"${extra_del}\"");
    
    # Rename links to (x86) and (x64) respectively
    # Issues with variable names in "REN" command. Used static text instead.
    # Changed:
    #    Rename "MATLAB R2015a.lnk" to "MATLAB2012a (x86).lnk"
    # or Rename "MATLAB R2015a.lnk" to "MATLAB2012a (x64).lnk"
    output("    Renaming Links...");
    if($x86_only)
    {
      if(-e "$groupdir\\MATLAB R2015a (x86).lnk")
      {
        output(" [OK]\n");
      }
      elsif(is_XP())
      {
        # For XP, we won't worry about renaming it to x86, since it can only be x86.
        output(" [OK]\n");
      }
      elsif(!run_command("cmd /c REN \"${groupdir}\\MATLAB R2015a (32-bit).lnk\" \"MATLAB R2015a (x86).lnk\""))
      {
        output("    Error renaming x86 links. Check the file names.\n");
      }
      else
      {
        output(" [OK]\n");
      }
    }
    if($x64_only)
    {
      if(-e "$groupdir\\MATLAB R2015a (x64).lnk")
      {
        output(" [OK]\n");
      }
      elsif(!run_command("cmd /c REN \"${groupdir}\\MATLAB R2015a.lnk\" \"MATLAB R2015a (x64).lnk\""))
      {
        output("    Error renaming x64 links. Check the file names.\n");
      }
      else
      {
        output(" [OK]\n");
      }
    }
    return 1;
}
# Generate the correct license.dat
sub generate_license_dat {
    my $target_location = shift;
    my $server = shift;
    my $port = shift;
    my $comment = shift;

    my $license_dat_template = &lt;&lt;LICENSE_DAT_TEMPLATE
\%s
# Autogenerated by S\&amp;T installer.
SERVER \%s 0 \%s
USE_SERVER
LICENSE_DAT_TEMPLATE
;

    my $license_dat_data = sprintf($license_dat_template,
                                   $comment,$server,$port);
    local *OUTPUT;
    if (open(OUTPUT,'&gt;',$target_location)) {
        print OUTPUT $license_dat_data;
        close(OUTPUT);
    } else {
        output("      ERROR: Cannot open concurrent license config file ".
               "'${target_location}': $!\n");
        return 0;
    }

    return 1;
}

#Nothing Changed
sub generate_installer_ini {
    my $target_location = shift;
    my $install_dir = shift;
    my $fik = shift;
    my $output_log = shift;
    my $license_dat_loc = shift;

    # This is a printf format string that uses three string variables
    #  0) install dir
    #  1) fik (file installation key)
    #  2) location of install output log
    #  3) path to license.dat file
	
# use File::Basename;
# use Win32;

# my $cwd = dirname($0);
# my $scriptdir = Win32::GetFullPathName($cwd);
# activationPropertiesFile=$scriptdir;
	
    my $installer_ini_format = &lt;&lt;INSTALLER_INI
destinationFolder=\%s
fileInstallationKey=\%s
agreeToLicense=yes
outputFile=\%s
mode=silent
automatedModeTimeout=1000
#activationPropertiesFile=
licensePath=\%s
lmgrFiles=false
lmgrService=false
desktopShortcut=false
startMenuShortcut=true
INSTALLER_INI
;

    my $installer_ini_data = sprintf($installer_ini_format,$install_dir,
                                     $fik,$output_log,$license_dat_loc);

    local *OUTPUT;
    if (open(OUTPUT,'&gt;',$target_location)) {
        print OUTPUT $installer_ini_data;
        close(OUTPUT);
    } else {
        output("      ERROR: Cannot create automated installer config file '${target_location}': $!\n");
        return 0;
    }

    return 1;
}


#
# The file/directory must exist for this function to work.
#
sub get_short_path_name {
    my $path = shift;
    my $fso = Win32::OLE-&gt;CreateObject('Scripting.FileSystemObject');
    if (Win32::OLE-&gt;LastError) {
        output("Error creating FS object: ".Win32::OLE-&gt;LastError."\n");
    }
    if (-d $path) {
        my $dir = $fso-&gt;GetFolder($path);
        return $dir-&gt;ShortPath;
    } else {
        my $file = $fso-&gt;GetFile($path);
        return $file-&gt;ShortPath;
    }
}

sub touch {
    my $file = shift;

    local *TOUCH;
    if (open(TOUCH,'&gt;&gt;',$file)) {
        close(TOUCH);
        return 1;
    } else {
        output("Cannot open file for append '${file}': $!\n");
        return 0;
    }
}
</Text>
  </Script>
  <Script>
    <Name>update-academic-x86.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2015b\prod32\update-academic-x86.pl</FullName>
    <Length>1843</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-02-24T13:22:09.1555937-06:00</CreationTime>
    <CreationTimeUtc>2016-02-24T19:22:09.1555937Z</CreationTimeUtc>
    <LastWriteTime>2017-03-21T15:38:45.3153663-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-03-21T20:38:45.3153663Z</LastWriteTimeUtc>
    <LastAccessTime>2016-02-24T13:22:09.1555937-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-02-24T19:22:09.1555937Z</LastAccessTimeUtc>
    <Text># Matlab R2015b Academic Install Script
# Package Created June 2014
# Packaged by Hannah
# Updated on 2016-02-24 by Grayson Gratop

$x86_only = 1;

BEGIN
{
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'matlab_2015b.x86',
    package_revision =&gt; 'academic-20160224T1324',
  );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'c:\temp',
);
use InstallMonkey::Shared;


########################################################################
# Begin Package Configuration
########################################################################

# This sets which folder to use for the license setup.
# It should be the only real difference between the Academic and Classroom scripts
$license_dat = get_pkg_sourcefiles().'\license.dat';
# Delete this file before exiting. It contains the install key (fik).
#   The clients shouldn't need it for heal/repair operations and it
#   could be abused if known.
$installer_ini = $ENV{'TEMP'}.'\installer.ini';

# installer.ini data
# New FIK (acquired 2017-03-15)
$fik = '51376-28657-56737-60148-32947-63197-24275-59375-34227-47577-18543-46312-38724-12224-00858-39278';

$install_log = get_default_app_log();
# This is the default. I suspect it needs to be in 8.3 format. At least,
#   That's how the default installer.ini file specifies it.
# license.dat data
$license_server = 'matlab-academic.lic.mst.edu';
$license_server_port = '1711';
$license_dat_comment = q/
# Matlab classroom license file for research and individual use.
/;

########################################################################
# End Package Configuration
########################################################################

# Do the install.

use lib(cwd());
require('update-common.pl');
</Text>
  </Script>
  <Script>
    <Name>update-classroom-x86.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2015b\prod32\update-classroom-x86.pl</FullName>
    <Length>1929</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-02-24T13:22:09.2647958-06:00</CreationTime>
    <CreationTimeUtc>2016-02-24T19:22:09.2647958Z</CreationTimeUtc>
    <LastWriteTime>2016-03-10T14:16:40.4746298-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-03-10T20:16:40.4746298Z</LastWriteTimeUtc>
    <LastAccessTime>2016-02-24T13:22:09.2647958-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-02-24T19:22:09.2647958Z</LastAccessTimeUtc>
    <Text># Matlab R2012a Classroom Install Script
# Package Created June 2014
# Packaged by Hannah
# Updated on 2016-02-24 by Grayson Gratop

$x86_only = 1;

BEGIN
{
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'matlab_2015b.x86',
    package_revision =&gt; 'classroom-20160310T1416',
  );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'c:\temp',
);
use InstallMonkey::Shared;

$sourcefilesdir = get_pkg_sourcefiles();

########################################################################
# Begin Package Configuration
########################################################################

# This sets which folder to use for the license setup.
# It should be the only real difference between the Academic and Classroom scripts
$license_dat = get_pkg_sourcefiles().'\license.dat';
# Delete this file before exiting. It contains the install key (fik).
#   The clients shouldn't need it for heal/repair operations and it
#   could be abused if known.
$installer_ini = $ENV{'TEMP'}.'\installer.ini';

# installer.ini data
# New FIK (acquired 2015-07-10)
$fik = '26782-25424-36314-18379-55551-39564-38149-63526-16677-11731-59386-58099-01370-20895';

$install_log = get_default_app_log();
# This is the default. I suspect it needs to be in 8.3 format. At least,
#   That's how the default installer.ini file specifies it.
# license.dat data
$license_server = 'matlab-classroom.lic.mst.edu';
$license_server_port = '1711';
$license_dat_comment = q/
# Matlab classroom license file for CLC's
# This license is for use in instructional classes only. Not for research.
/;

########################################################################
# End Package Configuration
########################################################################

# Do the install.
use lib(cwd());

require('update-common.pl');
</Text>
  </Script>
  <Script>
    <Name>update-common.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2015b\prod32\update-common.pl</FullName>
    <Length>10004</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-02-24T13:22:09.2959964-06:00</CreationTime>
    <CreationTimeUtc>2016-02-24T19:22:09.2959964Z</CreationTimeUtc>
    <LastWriteTime>2016-02-24T13:27:19.2483067-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-02-24T19:27:19.2483067Z</LastWriteTimeUtc>
    <LastAccessTime>2016-02-24T13:22:09.2959964-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-02-24T19:22:09.2959964Z</LastAccessTimeUtc>
    <Text>#perl -w

########################################
# DIFFERENCES BETWEEN x86/x64 VERSIONS:
#     INSTALL LOCATION
#     START MENU LINK
#     PACKAGE ID
#     DATA DIRECTORY
########################################

use Win32::OLE;
use Win32::Shortcut;
use Getopt::Long;
$pre_only = 0;
$post_only = 0;
$no_source_files = 0;
GetOptions(
  'preinstall' =&gt; \$pre_only,
  'nosource' =&gt; \$no_source_files,
  'postinstall' =&gt; \$post_only,
);


####TESTING FUNCTIONS#####
if($pre_only)
{
  preinstall();
  postinstall();
  exit(0);
}
elsif($post_only)
{
  postinstall();
  exit(0);
}
##########################

# Change the Installation Directory
if($x86_only)
{
    if (is_x86()) {
        $install_location = $ENV{'ProgramFiles'}.'\Matlab\R2015b';
    } else {
        $install_location = $ENV{'ProgramFiles(x86)'}.'\Matlab\R2015b';
    }
}
elsif($x64_only)
{
  $install_location = $ENV{'ProgramFiles'}.'\Matlab\R2015b';
}

# Delete any sensitive information upon cleanup.
sub cleanup {
    $SIG{BREAK} = 'DEFAULT';
    $SIG{TERM} = 'DEFAULT';
    $SIG{INT} = 'DEFAULT';
    $SIG{QUIT} = 'DEFAULT';
    $SIG{KILL} = 'DEFAULT';

    output("    Cleaning up...\n");
    run_command("cmd /c DEL /Y /F /Q \"${installer_ini}\"");
}
$SIG{EXIT} = \&amp;cleanup;
$SIG{QUIT} = \&amp;cleanup;
$SIG{BREAK} = \&amp;cleanup;
$SIG{INT} = \&amp;cleanup;
$SIG{KILL} = \&amp;cleanup;


if($x86_only)
{
    do_install( 
        allowed_versions =&gt; [  OSVER_XP_32, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
        allowed_regs =&gt; ["clc", "desktop", "traveling", "virtual-desktop", "virtual-clc"],
        allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
        exit_on_failure =&gt; 1,
        data_dir =&gt; 'data32',
        preinstall_sub =&gt; \&amp;preinstall,
        install_sub =&gt; \&amp;install,
        postinstall_sub =&gt; \&amp;postinstall,
        need_reboot =&gt; 1, # The install docs recommend a reboot.
        no_source_files =&gt; $no_source_files
    );
    IM_Exit(EXIT_SUCCESS);
}
if($x64_only)
{
    do_install( 
        allowed_versions =&gt; [  OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
        allowed_regs =&gt; ["clc", "desktop", "traveling", "virtual-clc", "virtual-desktop" ],
        allowed_os_architectures =&gt; [ OSARCH_x64, OSARCH_x86 ],
        exit_on_failure =&gt; 1,
        data_dir =&gt; 'data64',
        preinstall_sub =&gt; \&amp;preinstall,
        install_sub =&gt; \&amp;install,
        postinstall_sub =&gt; \&amp;postinstall,
        need_reboot =&gt; 1, # The install docs recommend a reboot.
        no_source_files =&gt; $no_source_files,
    );
    IM_Exit(EXIT_SUCCESS);
}

# Create the setup configuration files for the correct license
#   and install features.
# Unchanged for x86 or x64
sub preinstall
{
    output("    Generating install config files...\n");

    if (! -d $install_location) {
        if (!run_command("cmd /c mkdir \"${install_location}\"")) {
            output("      Cannot create install directory ".
                   "'${install_location}'.\n      Preinstall failed. ".
                   "Aborting...\n");
            exit(0);
        }
    }
    touch($install_log); # create the file so we can get the short name

    if (!generate_license_dat($license_dat,$license_server,
                              $license_server_port,$license_dat_comment)) {
        output("      Preinstall failed (license.dat creation). ".
               "Aborting...\n");
        return 0;
    }

    if (!generate_installer_ini($installer_ini,
                                get_short_path_name($install_location),
                                $fik,
                                get_short_path_name($install_log),
                                get_short_path_name($license_dat))) {
        output("      Preinstall failed (installer.ini creation). ".
               "Aborting...\n");
        return 0;
    }

    output("    Complete!\n");
        
    return 1;
}
# Changed $setup_dir for x86 and x64
sub install {
    my $sourcefilesdir = get_pkg_sourcefiles();        
    output("    Starting install...\n");

    if($x86_only)
    {
      $setup_dir = 'win32';
    }
    if($x64_only)
    {
      $setup_dir = 'win64';
    }
    # Starts the setup.exe using a batch script
    if (run_command("cmd /c \"".get_pkg_sourcefiles().
                               "\\bin\\${setup_dir}\\setup.exe\" ".
                    "-inputFile ".get_short_path_name($installer_ini))) {
        output("    Install complete!\n");
        return 1;
    } else {
        output("    FAILURE!\n");
        return 0;
    }
}

# Changed Start Menu Links for x86 and x64
sub postinstall {
    my $groupdir = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB\R2015b';
    
    # Move 32-bit directory to the standard directory scheme
    if($x86_only &amp;&amp; !is_XP())
    {
        if (! -d "${groupdir}")
        {
            run_command("cmd /c MKDIR \"${groupdir}\"");
        }
        run_command("cmd /c XCOPY /Y /E /C /Q \"${groupdir} (32-bit)\" \"${groupdir}\"");
        run_command("cmd /c RMDIR /S /Q \"${groupdir} (32-bit)\"");
    }
    
    # Remove [de]activate icons.
    my @todel = ('Activate MATLAB R2015b.lnk',
                 'Deactivate MATLAB R2015b.lnk',
                 );
    output("    Removing activation shortcuts...\n");
    foreach my $file (@todel) {
        run_command("cmd /c DEL /Q \"${groupdir}\\${file}\"");
    }

    output("    Removing extra shortcut...\n");
    my $extra_del = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB R2015b.lnk';
    if($x86_only &amp;&amp; !is_XP())
    {
        $extra_del = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB R2015b (32-bit).lnk';
        
    }
    run_command("cmd /c DEL /Q \"${extra_del}\"");
    
    # Rename links to (x86) and (x64) respectively
    # Issues with variable names in "REN" command. Used static text instead.
    # Changed:
    #    Rename "MATLAB R2015b.lnk" to "MATLAB2012a (x86).lnk"
    # or Rename "MATLAB R2015b.lnk" to "MATLAB2012a (x64).lnk"
    output("    Renaming Links...");
    if($x86_only)
    {
      if(-e "$groupdir\\MATLAB R2015b (x86).lnk")
      {
        output(" [OK]\n");
      }
      elsif(is_XP())
      {
        # For XP, we won't worry about renaming it to x86, since it can only be x86.
        output(" [OK]\n");
      }
      elsif(!run_command("cmd /c REN \"${groupdir}\\MATLAB R2015b (32-bit).lnk\" \"MATLAB R2015b (x86).lnk\""))
      {
        output("    Error renaming x86 links. Check the file names.\n");
      }
      else
      {
        output(" [OK]\n");
      }
    }
    if($x64_only)
    {
      if(-e "$groupdir\\MATLAB R2015b (x64).lnk")
      {
        output(" [OK]\n");
      }
      elsif(!run_command("cmd /c REN \"${groupdir}\\MATLAB R2015b.lnk\" \"MATLAB R2015b (x64).lnk\""))
      {
        output("    Error renaming x64 links. Check the file names.\n");
      }
      else
      {
        output(" [OK]\n");
      }
    }
    return 1;
}
# Generate the correct license.dat
sub generate_license_dat {
    my $target_location = shift;
    my $server = shift;
    my $port = shift;
    my $comment = shift;

    my $license_dat_template = &lt;&lt;LICENSE_DAT_TEMPLATE
\%s
# Autogenerated by S\&amp;T installer.
SERVER \%s 0 \%s
USE_SERVER
LICENSE_DAT_TEMPLATE
;

    my $license_dat_data = sprintf($license_dat_template,
                                   $comment,$server,$port);
    local *OUTPUT;
    if (open(OUTPUT,'&gt;',$target_location)) {
        print OUTPUT $license_dat_data;
        close(OUTPUT);
    } else {
        output("      ERROR: Cannot open concurrent license config file ".
               "'${target_location}': $!\n");
        return 0;
    }

    return 1;
}

#Nothing Changed
sub generate_installer_ini {
    my $target_location = shift;
    my $install_dir = shift;
    my $fik = shift;
    my $output_log = shift;
    my $license_dat_loc = shift;

    # This is a printf format string that uses three string variables
    #  0) install dir
    #  1) fik (file installation key)
    #  2) location of install output log
    #  3) path to license.dat file
	
# use File::Basename;
# use Win32;

# my $cwd = dirname($0);
# my $scriptdir = Win32::GetFullPathName($cwd);
# activationPropertiesFile=$scriptdir;
	
    my $installer_ini_format = &lt;&lt;INSTALLER_INI
destinationFolder=\%s
fileInstallationKey=\%s
agreeToLicense=yes
outputFile=\%s
mode=silent
automatedModeTimeout=1000
#activationPropertiesFile=
licensePath=\%s
lmgrFiles=false
lmgrService=false
desktopShortcut=false
startMenuShortcut=true
INSTALLER_INI
;

    my $installer_ini_data = sprintf($installer_ini_format,$install_dir,
                                     $fik,$output_log,$license_dat_loc);

    local *OUTPUT;
    if (open(OUTPUT,'&gt;',$target_location)) {
        print OUTPUT $installer_ini_data;
        close(OUTPUT);
    } else {
        output("      ERROR: Cannot create automated installer config file '${target_location}': $!\n");
        return 0;
    }

    return 1;
}


#
# The file/directory must exist for this function to work.
#
sub get_short_path_name {
    my $path = shift;
    my $fso = Win32::OLE-&gt;CreateObject('Scripting.FileSystemObject');
    if (Win32::OLE-&gt;LastError) {
        output("Error creating FS object: ".Win32::OLE-&gt;LastError."\n");
    }
    if (-d $path) {
        my $dir = $fso-&gt;GetFolder($path);
        return $dir-&gt;ShortPath;
    } else {
        my $file = $fso-&gt;GetFile($path);
        return $file-&gt;ShortPath;
    }
}

sub touch {
    my $file = shift;

    local *TOUCH;
    if (open(TOUCH,'&gt;&gt;',$file)) {
        close(TOUCH);
        return 1;
    } else {
        output("Cannot open file for append '${file}': $!\n");
        return 0;
    }
}
</Text>
  </Script>
  <Script>
    <Name>update-academic-x64.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2015b\prod64\update-academic-x64.pl</FullName>
    <Length>1843</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-02-23T16:17:51.8271551-06:00</CreationTime>
    <CreationTimeUtc>2016-02-23T22:17:51.8271551Z</CreationTimeUtc>
    <LastWriteTime>2017-03-21T15:41:59.1022929-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-03-21T20:41:59.1022929Z</LastWriteTimeUtc>
    <LastAccessTime>2016-02-23T16:17:51.8271551-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-02-23T22:17:51.8271551Z</LastAccessTimeUtc>
    <Text># Matlab R2015b Academic Install Script
# Package Created June 2014
# Packaged by Hannah
# Updated on 2016-02-23 by Grayson Gratop

$x64_only = 1;

BEGIN
{  
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'matlab_2015b.x64',
    package_revision =&gt; 'academic-20160223T1622',
  );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'c:\temp',
);
use InstallMonkey::Shared;


########################################################################
# Begin Package Configuration
########################################################################

# This sets which folder to use for the license setup.
# It should be the only real difference between the Academic and Classroom scripts
$license_dat = get_pkg_sourcefiles().'\license.dat';
# Delete this file before exiting. It contains the install key (fik).
#   The clients shouldn't need it for heal/repair operations and it
#   could be abused if known.
$installer_ini = $ENV{'TEMP'}.'\installer.ini';

# installer.ini data
# New FIK (acquired 2017-03-15)
$fik = '51376-28657-56737-60148-32947-63197-24275-59375-34227-47577-18543-46312-38724-12224-00858-39278';

$install_log = get_default_app_log();
# This is the default. I suspect it needs to be in 8.3 format. At least,
#   That's how the default installer.ini file specifies it.
# license.dat data
$license_server = 'matlab-academic.lic.mst.edu';
$license_server_port = '1711';
$license_dat_comment = q/
# Matlab classroom license file for research and individual use.
/;

########################################################################
# End Package Configuration
########################################################################

# Do the install.

use lib(cwd());
require('update-common.pl');</Text>
  </Script>
  <Script>
    <Name>update-classroom-x64.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2015b\prod64\update-classroom-x64.pl</FullName>
    <Length>1833</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-02-23T16:17:51.9363572-06:00</CreationTime>
    <CreationTimeUtc>2016-02-23T22:17:51.9363572Z</CreationTimeUtc>
    <LastWriteTime>2016-04-05T14:18:16.1889265-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-04-05T19:18:16.1889265Z</LastWriteTimeUtc>
    <LastAccessTime>2016-02-23T16:17:51.9363572-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-02-23T22:17:51.9363572Z</LastAccessTimeUtc>
    <Text># Matlab R2015b Academic Install Script
# Package Created June 2014
# Packaged by Hannah
# Updated on 2016-02-23 by Grayson Gratop

$x64_only = 1;

BEGIN
{
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'matlab_2015b.x64',
    package_revision =&gt; 'classroom-20160223T1622',
  );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'c:\temp',
);
use InstallMonkey::Shared;


########################################################################
# Begin Package Configuration
########################################################################

# This sets which folder to use for the license setup.
# It should be the only real difference between the Academic and Classroom scripts
$license_dat = get_pkg_sourcefiles().'\license.dat';
# Delete this file before exiting. It contains the install key (fik).
#   The clients shouldn't need it for heal/repair operations and it
#   could be abused if known.
$installer_ini = $ENV{'TEMP'}.'\installer.ini';

# installer.ini data
# New FIK (acquired 2015-07-10)
$fik = '26782-25424-36314-18379-55551-39564-38149-63526-16677-11731-59386-58099-01370-20895';

$install_log = get_default_app_log();
# This is the default. I suspect it needs to be in 8.3 format. At least,
#   That's how the default installer.ini file specifies it.
# license.dat data
$license_server = 'matlab-classroom.lic.mst.edu';
$license_server_port = '1711';
$license_dat_comment = q/
# Matlab classroom license file for research and individual use.
/;

########################################################################
# End Package Configuration
########################################################################

# Do the install.

use lib(cwd());
require('update-common.pl');
</Text>
  </Script>
  <Script>
    <Name>update-common.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2015b\prod64\update-common.pl</FullName>
    <Length>10004</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-02-23T16:17:51.9831581-06:00</CreationTime>
    <CreationTimeUtc>2016-02-23T22:17:51.9831581Z</CreationTimeUtc>
    <LastWriteTime>2016-02-23T16:26:35.7008294-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-02-23T22:26:35.7008294Z</LastWriteTimeUtc>
    <LastAccessTime>2016-02-23T16:17:51.9831581-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-02-23T22:17:51.9831581Z</LastAccessTimeUtc>
    <Text>#perl -w

########################################
# DIFFERENCES BETWEEN x86/x64 VERSIONS:
#     INSTALL LOCATION
#     START MENU LINK
#     PACKAGE ID
#     DATA DIRECTORY
########################################

use Win32::OLE;
use Win32::Shortcut;
use Getopt::Long;
$pre_only = 0;
$post_only = 0;
$no_source_files = 0;
GetOptions(
  'preinstall' =&gt; \$pre_only,
  'nosource' =&gt; \$no_source_files,
  'postinstall' =&gt; \$post_only,
);


####TESTING FUNCTIONS#####
if($pre_only)
{
  preinstall();
  postinstall();
  exit(0);
}
elsif($post_only)
{
  postinstall();
  exit(0);
}
##########################

# Change the Installation Directory
if($x86_only)
{
    if (is_x86()) {
        $install_location = $ENV{'ProgramFiles'}.'\Matlab\R2015b';
    } else {
        $install_location = $ENV{'ProgramFiles(x86)'}.'\Matlab\R2015b';
    }
}
elsif($x64_only)
{
  $install_location = $ENV{'ProgramFiles'}.'\Matlab\R2015b';
}

# Delete any sensitive information upon cleanup.
sub cleanup {
    $SIG{BREAK} = 'DEFAULT';
    $SIG{TERM} = 'DEFAULT';
    $SIG{INT} = 'DEFAULT';
    $SIG{QUIT} = 'DEFAULT';
    $SIG{KILL} = 'DEFAULT';

    output("    Cleaning up...\n");
    run_command("cmd /c DEL /Y /F /Q \"${installer_ini}\"");
}
$SIG{EXIT} = \&amp;cleanup;
$SIG{QUIT} = \&amp;cleanup;
$SIG{BREAK} = \&amp;cleanup;
$SIG{INT} = \&amp;cleanup;
$SIG{KILL} = \&amp;cleanup;


if($x86_only)
{
    do_install( 
        allowed_versions =&gt; [  OSVER_XP_32, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
        allowed_regs =&gt; ["clc", "desktop", "traveling", "virtual-desktop", "virtual-clc"],
        allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
        exit_on_failure =&gt; 1,
        data_dir =&gt; 'data32',
        preinstall_sub =&gt; \&amp;preinstall,
        install_sub =&gt; \&amp;install,
        postinstall_sub =&gt; \&amp;postinstall,
        need_reboot =&gt; 1, # The install docs recommend a reboot.
        no_source_files =&gt; $no_source_files
    );
    IM_Exit(EXIT_SUCCESS);
}
if($x64_only)
{
    do_install( 
        allowed_versions =&gt; [  OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
        allowed_regs =&gt; ["clc", "desktop", "traveling", "virtual-clc", "virtual-desktop" ],
        allowed_os_architectures =&gt; [ OSARCH_x64, OSARCH_x86 ],
        exit_on_failure =&gt; 1,
        data_dir =&gt; 'data64',
        preinstall_sub =&gt; \&amp;preinstall,
        install_sub =&gt; \&amp;install,
        postinstall_sub =&gt; \&amp;postinstall,
        need_reboot =&gt; 1, # The install docs recommend a reboot.
        no_source_files =&gt; $no_source_files,
    );
    IM_Exit(EXIT_SUCCESS);
}

# Create the setup configuration files for the correct license
#   and install features.
# Unchanged for x86 or x64
sub preinstall
{
    output("    Generating install config files...\n");

    if (! -d $install_location) {
        if (!run_command("cmd /c mkdir \"${install_location}\"")) {
            output("      Cannot create install directory ".
                   "'${install_location}'.\n      Preinstall failed. ".
                   "Aborting...\n");
            exit(0);
        }
    }
    touch($install_log); # create the file so we can get the short name

    if (!generate_license_dat($license_dat,$license_server,
                              $license_server_port,$license_dat_comment)) {
        output("      Preinstall failed (license.dat creation). ".
               "Aborting...\n");
        return 0;
    }

    if (!generate_installer_ini($installer_ini,
                                get_short_path_name($install_location),
                                $fik,
                                get_short_path_name($install_log),
                                get_short_path_name($license_dat))) {
        output("      Preinstall failed (installer.ini creation). ".
               "Aborting...\n");
        return 0;
    }

    output("    Complete!\n");
        
    return 1;
}
# Changed $setup_dir for x86 and x64
sub install {
    my $sourcefilesdir = get_pkg_sourcefiles();        
    output("    Starting install...\n");

    if($x86_only)
    {
      $setup_dir = 'win32';
    }
    if($x64_only)
    {
      $setup_dir = 'win64';
    }
    # Starts the setup.exe using a batch script
    if (run_command("cmd /c \"".get_pkg_sourcefiles().
                               "\\bin\\${setup_dir}\\setup.exe\" ".
                    "-inputFile ".get_short_path_name($installer_ini))) {
        output("    Install complete!\n");
        return 1;
    } else {
        output("    FAILURE!\n");
        return 0;
    }
}

# Changed Start Menu Links for x86 and x64
sub postinstall {
    my $groupdir = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB\R2015b';
    
    # Move 32-bit directory to the standard directory scheme
    if($x86_only &amp;&amp; !is_XP())
    {
        if (! -d "${groupdir}")
        {
            run_command("cmd /c MKDIR \"${groupdir}\"");
        }
        run_command("cmd /c XCOPY /Y /E /C /Q \"${groupdir} (32-bit)\" \"${groupdir}\"");
        run_command("cmd /c RMDIR /S /Q \"${groupdir} (32-bit)\"");
    }
    
    # Remove [de]activate icons.
    my @todel = ('Activate MATLAB R2015b.lnk',
                 'Deactivate MATLAB R2015b.lnk',
                 );
    output("    Removing activation shortcuts...\n");
    foreach my $file (@todel) {
        run_command("cmd /c DEL /Q \"${groupdir}\\${file}\"");
    }

    output("    Removing extra shortcut...\n");
    my $extra_del = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB R2015b.lnk';
    if($x86_only &amp;&amp; !is_XP())
    {
        $extra_del = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB R2015b (32-bit).lnk';
        
    }
    run_command("cmd /c DEL /Q \"${extra_del}\"");
    
    # Rename links to (x86) and (x64) respectively
    # Issues with variable names in "REN" command. Used static text instead.
    # Changed:
    #    Rename "MATLAB R2015b.lnk" to "MATLAB2012a (x86).lnk"
    # or Rename "MATLAB R2015b.lnk" to "MATLAB2012a (x64).lnk"
    output("    Renaming Links...");
    if($x86_only)
    {
      if(-e "$groupdir\\MATLAB R2015b (x86).lnk")
      {
        output(" [OK]\n");
      }
      elsif(is_XP())
      {
        # For XP, we won't worry about renaming it to x86, since it can only be x86.
        output(" [OK]\n");
      }
      elsif(!run_command("cmd /c REN \"${groupdir}\\MATLAB R2015b (32-bit).lnk\" \"MATLAB R2015b (x86).lnk\""))
      {
        output("    Error renaming x86 links. Check the file names.\n");
      }
      else
      {
        output(" [OK]\n");
      }
    }
    if($x64_only)
    {
      if(-e "$groupdir\\MATLAB R2015b (x64).lnk")
      {
        output(" [OK]\n");
      }
      elsif(!run_command("cmd /c REN \"${groupdir}\\MATLAB R2015b.lnk\" \"MATLAB R2015b (x64).lnk\""))
      {
        output("    Error renaming x64 links. Check the file names.\n");
      }
      else
      {
        output(" [OK]\n");
      }
    }
    return 1;
}
# Generate the correct license.dat
sub generate_license_dat {
    my $target_location = shift;
    my $server = shift;
    my $port = shift;
    my $comment = shift;

    my $license_dat_template = &lt;&lt;LICENSE_DAT_TEMPLATE
\%s
# Autogenerated by S\&amp;T installer.
SERVER \%s 0 \%s
USE_SERVER
LICENSE_DAT_TEMPLATE
;

    my $license_dat_data = sprintf($license_dat_template,
                                   $comment,$server,$port);
    local *OUTPUT;
    if (open(OUTPUT,'&gt;',$target_location)) {
        print OUTPUT $license_dat_data;
        close(OUTPUT);
    } else {
        output("      ERROR: Cannot open concurrent license config file ".
               "'${target_location}': $!\n");
        return 0;
    }

    return 1;
}

#Nothing Changed
sub generate_installer_ini {
    my $target_location = shift;
    my $install_dir = shift;
    my $fik = shift;
    my $output_log = shift;
    my $license_dat_loc = shift;

    # This is a printf format string that uses three string variables
    #  0) install dir
    #  1) fik (file installation key)
    #  2) location of install output log
    #  3) path to license.dat file
	
# use File::Basename;
# use Win32;

# my $cwd = dirname($0);
# my $scriptdir = Win32::GetFullPathName($cwd);
# activationPropertiesFile=$scriptdir;
	
    my $installer_ini_format = &lt;&lt;INSTALLER_INI
destinationFolder=\%s
fileInstallationKey=\%s
agreeToLicense=yes
outputFile=\%s
mode=silent
automatedModeTimeout=1000
#activationPropertiesFile=
licensePath=\%s
lmgrFiles=false
lmgrService=false
desktopShortcut=false
startMenuShortcut=true
INSTALLER_INI
;

    my $installer_ini_data = sprintf($installer_ini_format,$install_dir,
                                     $fik,$output_log,$license_dat_loc);

    local *OUTPUT;
    if (open(OUTPUT,'&gt;',$target_location)) {
        print OUTPUT $installer_ini_data;
        close(OUTPUT);
    } else {
        output("      ERROR: Cannot create automated installer config file '${target_location}': $!\n");
        return 0;
    }

    return 1;
}


#
# The file/directory must exist for this function to work.
#
sub get_short_path_name {
    my $path = shift;
    my $fso = Win32::OLE-&gt;CreateObject('Scripting.FileSystemObject');
    if (Win32::OLE-&gt;LastError) {
        output("Error creating FS object: ".Win32::OLE-&gt;LastError."\n");
    }
    if (-d $path) {
        my $dir = $fso-&gt;GetFolder($path);
        return $dir-&gt;ShortPath;
    } else {
        my $file = $fso-&gt;GetFile($path);
        return $file-&gt;ShortPath;
    }
}

sub touch {
    my $file = shift;

    local *TOUCH;
    if (open(TOUCH,'&gt;&gt;',$file)) {
        close(TOUCH);
        return 1;
    } else {
        output("Cannot open file for append '${file}': $!\n");
        return 0;
    }
}
</Text>
  </Script>
  <Script>
    <Name>update-academic-x64.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2016a\dev64\update-academic-x64.pl</FullName>
    <Length>1837</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-10-18T15:24:05.5589827-05:00</CreationTime>
    <CreationTimeUtc>2016-10-18T20:24:05.5589827Z</CreationTimeUtc>
    <LastWriteTime>2016-04-05T14:26:08.3350325-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-04-05T19:26:08.3350325Z</LastWriteTimeUtc>
    <LastAccessTime>2016-10-18T15:24:05.5589827-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-10-18T20:24:05.5589827Z</LastAccessTimeUtc>
    <Text># Matlab R2016a Academic Install Script
# Package Created June 2014
# Packaged by Hannah
# Updated on 2016-04-05 by Grayson Gratop

$x64_only = 1;

BEGIN
{  
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'matlab_2016a.x64',
    package_revision =&gt; 'academic-20160405T1417',
  );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'c:\temp',
);
use InstallMonkey::Shared;


########################################################################
# Begin Package Configuration
########################################################################

# This sets which folder to use for the license setup.
# It should be the only real difference between the Academic and Classroom scripts
$license_dat = get_pkg_sourcefiles().'\license.dat';
# Delete this file before exiting. It contains the install key (fik).
#   The clients shouldn't need it for heal/repair operations and it
#   could be abused if known.
$installer_ini = $ENV{'TEMP'}.'\installer.ini';

# installer.ini data
# New FIK (acquired 2016-03-15)
$fik = '28449-47306-02107-27452-63764-30160-49146-07234-07291-04924-42577-60629-12042-35952-03787';

$install_log = get_default_app_log();
# This is the default. I suspect it needs to be in 8.3 format. At least,
#   That's how the default installer.ini file specifies it.
# license.dat data
$license_server = 'matlab-academic.lic.mst.edu';
$license_server_port = '1711';
$license_dat_comment = q/
# Matlab classroom license file for research and individual use.
/;

########################################################################
# End Package Configuration
########################################################################

# Do the install.

use lib(cwd());
require('update-common.pl');</Text>
  </Script>
  <Script>
    <Name>update-classroom-x64-fix.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2016a\dev64\update-classroom-x64-fix.pl</FullName>
    <Length>2162</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-10-18T15:24:05.6057836-05:00</CreationTime>
    <CreationTimeUtc>2016-10-18T20:24:05.6057836Z</CreationTimeUtc>
    <LastWriteTime>2016-08-31T08:39:36.8423192-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-08-31T13:39:36.8423192Z</LastWriteTimeUtc>
    <LastAccessTime>2016-10-18T15:24:05.6057836-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-10-18T20:24:05.6057836Z</LastAccessTimeUtc>
    <Text># Matlab R2016a Academic Install Script
# Package Created June 2014
# Packaged by Hannah
# Updated on 2016-04-05 by Grayson Gratop

$x64_only = 1;

BEGIN
{
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'matlab_2016a.x64',
    package_revision =&gt; 'classroom-20160405T1417',
  );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'c:\temp',
);
use InstallMonkey::Shared;


########################################################################
# Begin Package Configuration
########################################################################

# This sets which folder to use for the license setup.
# It should be the only real difference between the Academic and Classroom scripts
$license_dat = get_pkg_sourcefiles().'\license.dat';
# Delete this file before exiting. It contains the install key (fik).
#   The clients shouldn't need it for heal/repair operations and it
#   could be abused if known.
$installer_ini = $ENV{'TEMP'}.'\installer.ini';

# installer.ini data
# New FIK (acquired 2016-04-05)
$fik = '13283-11878-22690-47240-13216-47309-27023-23837-28451-45306-01536-02606-06960-44282';

$install_log = get_default_app_log();
# This is the default. I suspect it needs to be in 8.3 format. At least,
#   That's how the default installer.ini file specifies it.
# license.dat data
$license_server = 'matlab-classroom.lic.mst.edu';
$license_server_port = '1711';
$license_dat_comment = q/
# Matlab classroom license file for research and individual use.
/;

########################################################################
# End Package Configuration
########################################################################

# Remove existing registry keys

#if(!run_command("regedit.exe /s rmkeys.reg")){
if(!run_command("reg delete HKEY_LOCAL_MACHINE\\SOFTWARE\\UMR\\INSTALL\\Product_List\\matlab_2016a.x64 /f")){
	output("Previous registry entry could not be removed! Exiting\n.");
	return 0;
}
output("Previous registry entry removed.\n");

# Do the install.

use lib(cwd());
require('update-common.pl');
</Text>
  </Script>
  <Script>
    <Name>update-classroom-x64.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2016a\dev64\update-classroom-x64.pl</FullName>
    <Length>1833</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-10-18T15:24:05.6057836-05:00</CreationTime>
    <CreationTimeUtc>2016-10-18T20:24:05.6057836Z</CreationTimeUtc>
    <LastWriteTime>2016-04-05T15:53:45.8570373-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-04-05T20:53:45.8570373Z</LastWriteTimeUtc>
    <LastAccessTime>2016-10-18T15:24:05.6057836-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-10-18T20:24:05.6057836Z</LastAccessTimeUtc>
    <Text># Matlab R2016a Academic Install Script
# Package Created June 2014
# Packaged by Hannah
# Updated on 2016-04-05 by Grayson Gratop

$x64_only = 1;

BEGIN
{
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'matlab_2016a.x64',
    package_revision =&gt; 'classroom-20160405T1417',
  );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'c:\temp',
);
use InstallMonkey::Shared;


########################################################################
# Begin Package Configuration
########################################################################

# This sets which folder to use for the license setup.
# It should be the only real difference between the Academic and Classroom scripts
$license_dat = get_pkg_sourcefiles().'\license.dat';
# Delete this file before exiting. It contains the install key (fik).
#   The clients shouldn't need it for heal/repair operations and it
#   could be abused if known.
$installer_ini = $ENV{'TEMP'}.'\installer.ini';

# installer.ini data
# New FIK (acquired 2016-04-05)
$fik = '13283-11878-22690-47240-13216-47309-27023-23837-28451-45306-01536-02606-06960-44282';

$install_log = get_default_app_log();
# This is the default. I suspect it needs to be in 8.3 format. At least,
#   That's how the default installer.ini file specifies it.
# license.dat data
$license_server = 'matlab-classroom.lic.mst.edu';
$license_server_port = '1711';
$license_dat_comment = q/
# Matlab classroom license file for research and individual use.
/;

########################################################################
# End Package Configuration
########################################################################

# Do the install.

use lib(cwd());
require('update-common.pl');
</Text>
  </Script>
  <Script>
    <Name>update-common.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2016a\dev64\update-common.pl</FullName>
    <Length>10528</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-10-18T15:24:05.6369842-05:00</CreationTime>
    <CreationTimeUtc>2016-10-18T20:24:05.6369842Z</CreationTimeUtc>
    <LastWriteTime>2016-10-18T15:38:33.6261312-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-10-18T20:38:33.6261312Z</LastWriteTimeUtc>
    <LastAccessTime>2016-10-18T15:24:05.6369842-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-10-18T20:24:05.6369842Z</LastAccessTimeUtc>
    <Text>#perl -w

########################################
# DIFFERENCES BETWEEN x86/x64 VERSIONS:
#     INSTALL LOCATION
#     START MENU LINK
#     PACKAGE ID
#     DATA DIRECTORY
########################################

use Win32::OLE;
use Win32::Shortcut;
use Getopt::Long;
$pre_only = 0;
$post_only = 0;
$no_source_files = 0;
GetOptions(
  'preinstall' =&gt; \$pre_only,
  'nosource' =&gt; \$no_source_files,
  'postinstall' =&gt; \$post_only,
);


####TESTING FUNCTIONS#####
if($pre_only)
{
  preinstall();
  postinstall();
  exit(0);
}
elsif($post_only)
{
  postinstall();
  exit(0);
}
##########################

# Change the Installation Directory
if($x86_only)
{
    if (is_x86()) {
        $install_location = $ENV{'ProgramFiles'}.'\Matlab\R2016a';
    } else {
        $install_location = $ENV{'ProgramFiles(x86)'}.'\Matlab\R2016a';
    }
}
elsif($x64_only)
{
  $install_location = $ENV{'ProgramFiles'}.'\Matlab\R2016a';
}

# Delete any sensitive information upon cleanup.
sub cleanup {
    $SIG{BREAK} = 'DEFAULT';
    $SIG{TERM} = 'DEFAULT';
    $SIG{INT} = 'DEFAULT';
    $SIG{QUIT} = 'DEFAULT';
    $SIG{KILL} = 'DEFAULT';

    output("    Cleaning up...\n");
    run_command("cmd /c DEL /Y /F /Q \"${installer_ini}\"");
}
$SIG{EXIT} = \&amp;cleanup;
$SIG{QUIT} = \&amp;cleanup;
$SIG{BREAK} = \&amp;cleanup;
$SIG{INT} = \&amp;cleanup;
$SIG{KILL} = \&amp;cleanup;


if($x86_only)
{
    do_install( 
        allowed_versions =&gt; [  OSVER_XP_32, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
        allowed_regs =&gt; ["clc", "desktop", "traveling", "virtual-desktop", "virtual-clc"],
        allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
        exit_on_failure =&gt; 1,
        data_dir =&gt; 'data32',
        preinstall_sub =&gt; \&amp;preinstall,
        install_sub =&gt; \&amp;install,
        postinstall_sub =&gt; \&amp;postinstall,
        need_reboot =&gt; 1, # The install docs recommend a reboot.
        no_source_files =&gt; $no_source_files
    );
    IM_Exit(EXIT_SUCCESS);
}
if($x64_only)
{
    do_install( 
        allowed_versions =&gt; [  OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
        allowed_regs =&gt; ["clc", "desktop", "traveling", "virtual-clc", "virtual-desktop" ],
        allowed_os_architectures =&gt; [ OSARCH_x64, OSARCH_x86 ],
        exit_on_failure =&gt; 1,
        data_dir =&gt; 'data64',
        preinstall_sub =&gt; \&amp;preinstall,
        install_sub =&gt; \&amp;install,
        postinstall_sub =&gt; \&amp;postinstall,
        need_reboot =&gt; 1, # The install docs recommend a reboot.
        no_source_files =&gt; $no_source_files,
    );
    IM_Exit(EXIT_SUCCESS);
}

# Create the setup configuration files for the correct license
#   and install features.
# Unchanged for x86 or x64
sub preinstall
{
    output("    Generating install config files...\n");

    if (! -d $install_location) {
        if (!run_command("cmd /c mkdir \"${install_location}\"")) {
            output("      Cannot create install directory ".
                   "'${install_location}'.\n      Preinstall failed. ".
                   "Aborting...\n");
            exit(0);
        }
    }
    touch($install_log); # create the file so we can get the short name

    if (!generate_license_dat($license_dat,$license_server,
                              $license_server_port,$license_dat_comment)) {
        output("      Preinstall failed (license.dat creation). ".
               "Aborting...\n");
        return 0;
    }

    if (!generate_installer_ini($installer_ini,
                                get_short_path_name($install_location),
                                $fik,
                                get_short_path_name($install_log),
                                get_short_path_name($license_dat))) {
        output("      Preinstall failed (installer.ini creation). ".
               "Aborting...\n");
        return 0;
    }

    output("    Complete!\n");
        
    return 1;
}
# Changed $setup_dir for x86 and x64
sub install {
    my $sourcefilesdir = get_pkg_sourcefiles();        
    output("    Starting install...\n");

    if($x86_only)
    {
      $setup_dir = 'win32';
    }
    if($x64_only)
    {
      $setup_dir = 'win64';
    }
    # Starts the setup.exe using a batch script
    if (run_command("cmd /c \"".get_pkg_sourcefiles().
                               "\\bin\\${setup_dir}\\setup.exe\" ".
                    "-inputFile ".get_short_path_name($installer_ini))) {
        output("    Install complete!\n");
        return 1;
    } else {
        output("    FAILURE!\n");
        return 0;
    }
}

# Changed Start Menu Links for x86 and x64
sub postinstall {
    my $groupdir = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB\R2016a';
    
    # Move 32-bit directory to the standard directory scheme
    if($x86_only &amp;&amp; !is_XP())
    {
        if (! -d "${groupdir}")
        {
            run_command("cmd /c MKDIR \"${groupdir}\"");
        }
        run_command("cmd /c XCOPY /Y /E /C /Q \"${groupdir} (32-bit)\" \"${groupdir}\"");
        run_command("cmd /c RMDIR /S /Q \"${groupdir} (32-bit)\"");
    }
    
    # Remove [de]activate icons.
    my @todel = ('Activate MATLAB R2016a.lnk',
                 'Deactivate MATLAB R2016a.lnk',
                 );
    output("    Removing activation shortcuts...\n");
    foreach my $file (@todel) {
        run_command("cmd /c DEL /Q \"${groupdir}\\${file}\"");
    }

    output("    Removing extra shortcut...\n");
    my $extra_del = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB R2016a.lnk';
    if($x86_only &amp;&amp; !is_XP())
    {
        $extra_del = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB R2016a (32-bit).lnk';
        
    }
    run_command("cmd /c DEL /Q \"${extra_del}\"");
    
    # Rename links to (x86) and (x64) respectively
    # Issues with variable names in "REN" command. Used static text instead.
    # Changed:
    #    Rename "MATLAB R2016a.lnk" to "MATLAB2012a (x86).lnk"
    # or Rename "MATLAB R2016a.lnk" to "MATLAB2012a (x64).lnk"
    output("    Renaming Links...");
    if($x86_only)
    {
      if(-e "$groupdir\\MATLAB R2016a (x86).lnk")
      {
        output(" [OK]\n");
      }
      elsif(is_XP())
      {
        # For XP, we won't worry about renaming it to x86, since it can only be x86.
        output(" [OK]\n");
      }
      elsif(!run_command("cmd /c REN \"${groupdir}\\MATLAB R2016a (32-bit).lnk\" \"MATLAB R2016a (x86).lnk\""))
      {
        output("    Error renaming x86 links. Check the file names.\n");
      }
      else
      {
        output(" [OK]\n");
      }
    }
    if($x64_only)
    {
      if(-e "$groupdir\\MATLAB R2016a (x64).lnk")
      {
        output(" [OK]\n");
      }
      elsif(!run_command("cmd /c REN \"${groupdir}\\MATLAB R2016a.lnk\" \"MATLAB R2016a (x64).lnk\""))
      {
        output("    Error renaming x64 links. Check the file names.\n");
      }
      else
      {
        output(" [OK]\n");
      }
    }
	
	#remove start menu "activate/deactivate" shortcuts
	my $activate_lnk = $ENV{'ProgramData'} . '\Microsoft\Windows\Start Menu\Programs\MATLAB R2016a\Activate MATLAB R2016a.lnk';
	my $deactivate_lnk = $ENV{'ProgramData'} . '\Microsoft\Windows\Start Menu\Programs\MATLAB R2016a\Deactivate MATLAB R2016a.lnk';
	if(!run_command("del \"$activate_lnk\"")){
		output("Error deleting the activation shortcut\n");
	}
	if(!run_command("del \"$deactivate_lnk\"")){
		output("Error deleting the deactivation shortcut\n");
	}
    return 1;
}
# Generate the correct license.dat
sub generate_license_dat {
    my $target_location = shift;
    my $server = shift;
    my $port = shift;
    my $comment = shift;

    my $license_dat_template = &lt;&lt;LICENSE_DAT_TEMPLATE
\%s
# Autogenerated by S\&amp;T installer.
SERVER \%s 0 \%s
USE_SERVER
LICENSE_DAT_TEMPLATE
;

    my $license_dat_data = sprintf($license_dat_template,
                                   $comment,$server,$port);
    local *OUTPUT;
    if (open(OUTPUT,'&gt;',$target_location)) {
        print OUTPUT $license_dat_data;
        close(OUTPUT);
    } else {
        output("      ERROR: Cannot open concurrent license config file ".
               "'${target_location}': $!\n");
        return 0;
    }

    return 1;
}

#Nothing Changed
sub generate_installer_ini {
    my $target_location = shift;
    my $install_dir = shift;
    my $fik = shift;
    my $output_log = shift;
    my $license_dat_loc = shift;

    # This is a printf format string that uses three string variables
    #  0) install dir
    #  1) fik (file installation key)
    #  2) location of install output log
    #  3) path to license.dat file
	
# use File::Basename;
# use Win32;

# my $cwd = dirname($0);
# my $scriptdir = Win32::GetFullPathName($cwd);
# activationPropertiesFile=$scriptdir;
	
    my $installer_ini_format = &lt;&lt;INSTALLER_INI
destinationFolder=\%s
fileInstallationKey=\%s
agreeToLicense=yes
outputFile=\%s
mode=silent
automatedModeTimeout=1000
#activationPropertiesFile=
licensePath=\%s
lmgrFiles=false
lmgrService=false
desktopShortcut=false
startMenuShortcut=true
INSTALLER_INI
;

    my $installer_ini_data = sprintf($installer_ini_format,$install_dir,
                                     $fik,$output_log,$license_dat_loc);

    local *OUTPUT;
    if (open(OUTPUT,'&gt;',$target_location)) {
        print OUTPUT $installer_ini_data;
        close(OUTPUT);
    } else {
        output("      ERROR: Cannot create automated installer config file '${target_location}': $!\n");
        return 0;
    }

    return 1;
}


#
# The file/directory must exist for this function to work.
#
sub get_short_path_name {
    my $path = shift;
    my $fso = Win32::OLE-&gt;CreateObject('Scripting.FileSystemObject');
    if (Win32::OLE-&gt;LastError) {
        output("Error creating FS object: ".Win32::OLE-&gt;LastError."\n");
    }
    if (-d $path) {
        my $dir = $fso-&gt;GetFolder($path);
        return $dir-&gt;ShortPath;
    } else {
        my $file = $fso-&gt;GetFile($path);
        return $file-&gt;ShortPath;
    }
}

sub touch {
    my $file = shift;

    local *TOUCH;
    if (open(TOUCH,'&gt;&gt;',$file)) {
        close(TOUCH);
        return 1;
    } else {
        output("Cannot open file for append '${file}': $!\n");
        return 0;
    }
}
</Text>
  </Script>
  <Script>
    <Name>update-academic-x64.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2016a\prod64\update-academic-x64.pl</FullName>
    <Length>1843</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-04-05T14:15:12.2290097-05:00</CreationTime>
    <CreationTimeUtc>2016-04-05T19:15:12.2290097Z</CreationTimeUtc>
    <LastWriteTime>2017-03-21T15:45:08.0531265-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-03-21T20:45:08.0531265Z</LastWriteTimeUtc>
    <LastAccessTime>2016-04-05T14:15:12.2290097-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-04-05T19:15:12.2290097Z</LastAccessTimeUtc>
    <Text># Matlab R2016a Academic Install Script
# Package Created June 2014
# Packaged by Hannah
# Updated on 2016-04-05 by Grayson Gratop

$x64_only = 1;

BEGIN
{  
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'matlab_2016a.x64',
    package_revision =&gt; 'academic-20160405T1417',
  );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'c:\temp',
);
use InstallMonkey::Shared;


########################################################################
# Begin Package Configuration
########################################################################

# This sets which folder to use for the license setup.
# It should be the only real difference between the Academic and Classroom scripts
$license_dat = get_pkg_sourcefiles().'\license.dat';
# Delete this file before exiting. It contains the install key (fik).
#   The clients shouldn't need it for heal/repair operations and it
#   could be abused if known.
$installer_ini = $ENV{'TEMP'}.'\installer.ini';

# installer.ini data
# New FIK (acquired 2017-03-15)
$fik = '46032-36414-15452-34705-61969-12758-36523-09374-15725-38023-01969-52463-45382-13498-36102-34549';

$install_log = get_default_app_log();
# This is the default. I suspect it needs to be in 8.3 format. At least,
#   That's how the default installer.ini file specifies it.
# license.dat data
$license_server = 'matlab-academic.lic.mst.edu';
$license_server_port = '1711';
$license_dat_comment = q/
# Matlab classroom license file for research and individual use.
/;

########################################################################
# End Package Configuration
########################################################################

# Do the install.

use lib(cwd());
require('update-common.pl');</Text>
  </Script>
  <Script>
    <Name>update-classroom-x64-fix.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2016a\prod64\update-classroom-x64-fix.pl</FullName>
    <Length>2162</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-08-30T14:37:17.1686326-05:00</CreationTime>
    <CreationTimeUtc>2016-08-30T19:37:17.1686326Z</CreationTimeUtc>
    <LastWriteTime>2016-08-31T08:39:36.8423192-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-08-31T13:39:36.8423192Z</LastWriteTimeUtc>
    <LastAccessTime>2016-08-30T14:37:17.1686326-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-08-30T19:37:17.1686326Z</LastAccessTimeUtc>
    <Text># Matlab R2016a Academic Install Script
# Package Created June 2014
# Packaged by Hannah
# Updated on 2016-04-05 by Grayson Gratop

$x64_only = 1;

BEGIN
{
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'matlab_2016a.x64',
    package_revision =&gt; 'classroom-20160405T1417',
  );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'c:\temp',
);
use InstallMonkey::Shared;


########################################################################
# Begin Package Configuration
########################################################################

# This sets which folder to use for the license setup.
# It should be the only real difference between the Academic and Classroom scripts
$license_dat = get_pkg_sourcefiles().'\license.dat';
# Delete this file before exiting. It contains the install key (fik).
#   The clients shouldn't need it for heal/repair operations and it
#   could be abused if known.
$installer_ini = $ENV{'TEMP'}.'\installer.ini';

# installer.ini data
# New FIK (acquired 2016-04-05)
$fik = '13283-11878-22690-47240-13216-47309-27023-23837-28451-45306-01536-02606-06960-44282';

$install_log = get_default_app_log();
# This is the default. I suspect it needs to be in 8.3 format. At least,
#   That's how the default installer.ini file specifies it.
# license.dat data
$license_server = 'matlab-classroom.lic.mst.edu';
$license_server_port = '1711';
$license_dat_comment = q/
# Matlab classroom license file for research and individual use.
/;

########################################################################
# End Package Configuration
########################################################################

# Remove existing registry keys

#if(!run_command("regedit.exe /s rmkeys.reg")){
if(!run_command("reg delete HKEY_LOCAL_MACHINE\\SOFTWARE\\UMR\\INSTALL\\Product_List\\matlab_2016a.x64 /f")){
	output("Previous registry entry could not be removed! Exiting\n.");
	return 0;
}
output("Previous registry entry removed.\n");

# Do the install.

use lib(cwd());
require('update-common.pl');
</Text>
  </Script>
  <Script>
    <Name>update-classroom-x64.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2016a\prod64\update-classroom-x64.pl</FullName>
    <Length>1833</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-04-05T14:15:12.2602105-05:00</CreationTime>
    <CreationTimeUtc>2016-04-05T19:15:12.2602105Z</CreationTimeUtc>
    <LastWriteTime>2016-04-05T15:53:45.8570373-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-04-05T20:53:45.8570373Z</LastWriteTimeUtc>
    <LastAccessTime>2016-04-05T14:15:12.2602105-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-04-05T19:15:12.2602105Z</LastAccessTimeUtc>
    <Text># Matlab R2016a Academic Install Script
# Package Created June 2014
# Packaged by Hannah
# Updated on 2016-04-05 by Grayson Gratop

$x64_only = 1;

BEGIN
{
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'matlab_2016a.x64',
    package_revision =&gt; 'classroom-20160405T1417',
  );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'c:\temp',
);
use InstallMonkey::Shared;


########################################################################
# Begin Package Configuration
########################################################################

# This sets which folder to use for the license setup.
# It should be the only real difference between the Academic and Classroom scripts
$license_dat = get_pkg_sourcefiles().'\license.dat';
# Delete this file before exiting. It contains the install key (fik).
#   The clients shouldn't need it for heal/repair operations and it
#   could be abused if known.
$installer_ini = $ENV{'TEMP'}.'\installer.ini';

# installer.ini data
# New FIK (acquired 2016-04-05)
$fik = '13283-11878-22690-47240-13216-47309-27023-23837-28451-45306-01536-02606-06960-44282';

$install_log = get_default_app_log();
# This is the default. I suspect it needs to be in 8.3 format. At least,
#   That's how the default installer.ini file specifies it.
# license.dat data
$license_server = 'matlab-classroom.lic.mst.edu';
$license_server_port = '1711';
$license_dat_comment = q/
# Matlab classroom license file for research and individual use.
/;

########################################################################
# End Package Configuration
########################################################################

# Do the install.

use lib(cwd());
require('update-common.pl');
</Text>
  </Script>
  <Script>
    <Name>update-common.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2016a\prod64\update-common.pl</FullName>
    <Length>10004</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-04-05T14:15:12.3382125-05:00</CreationTime>
    <CreationTimeUtc>2016-04-05T19:15:12.3382125Z</CreationTimeUtc>
    <LastWriteTime>2016-10-18T15:41:44.850697-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-10-18T20:41:44.850697Z</LastWriteTimeUtc>
    <LastAccessTime>2016-04-05T14:15:12.3382125-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-04-05T19:15:12.3382125Z</LastAccessTimeUtc>
    <Text>#perl -w

########################################
# DIFFERENCES BETWEEN x86/x64 VERSIONS:
#     INSTALL LOCATION
#     START MENU LINK
#     PACKAGE ID
#     DATA DIRECTORY
########################################

use Win32::OLE;
use Win32::Shortcut;
use Getopt::Long;
$pre_only = 0;
$post_only = 0;
$no_source_files = 0;
GetOptions(
  'preinstall' =&gt; \$pre_only,
  'nosource' =&gt; \$no_source_files,
  'postinstall' =&gt; \$post_only,
);


####TESTING FUNCTIONS#####
if($pre_only)
{
  preinstall();
  postinstall();
  exit(0);
}
elsif($post_only)
{
  postinstall();
  exit(0);
}
##########################

# Change the Installation Directory
if($x86_only)
{
    if (is_x86()) {
        $install_location = $ENV{'ProgramFiles'}.'\Matlab\R2016a';
    } else {
        $install_location = $ENV{'ProgramFiles(x86)'}.'\Matlab\R2016a';
    }
}
elsif($x64_only)
{
  $install_location = $ENV{'ProgramFiles'}.'\Matlab\R2016a';
}

# Delete any sensitive information upon cleanup.
sub cleanup {
    $SIG{BREAK} = 'DEFAULT';
    $SIG{TERM} = 'DEFAULT';
    $SIG{INT} = 'DEFAULT';
    $SIG{QUIT} = 'DEFAULT';
    $SIG{KILL} = 'DEFAULT';

    output("    Cleaning up...\n");
    run_command("cmd /c DEL /Y /F /Q \"${installer_ini}\"");
}
$SIG{EXIT} = \&amp;cleanup;
$SIG{QUIT} = \&amp;cleanup;
$SIG{BREAK} = \&amp;cleanup;
$SIG{INT} = \&amp;cleanup;
$SIG{KILL} = \&amp;cleanup;


if($x86_only)
{
    do_install( 
        allowed_versions =&gt; [  OSVER_XP_32, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
        allowed_regs =&gt; ["clc", "desktop", "traveling", "virtual-desktop", "virtual-clc"],
        allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
        exit_on_failure =&gt; 1,
        data_dir =&gt; 'data32',
        preinstall_sub =&gt; \&amp;preinstall,
        install_sub =&gt; \&amp;install,
        postinstall_sub =&gt; \&amp;postinstall,
        need_reboot =&gt; 1, # The install docs recommend a reboot.
        no_source_files =&gt; $no_source_files
    );
    IM_Exit(EXIT_SUCCESS);
}
if($x64_only)
{
    do_install( 
        allowed_versions =&gt; [  OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
        allowed_regs =&gt; ["clc", "desktop", "traveling", "virtual-clc", "virtual-desktop" ],
        allowed_os_architectures =&gt; [ OSARCH_x64, OSARCH_x86 ],
        exit_on_failure =&gt; 1,
        data_dir =&gt; 'data64',
        preinstall_sub =&gt; \&amp;preinstall,
        install_sub =&gt; \&amp;install,
        postinstall_sub =&gt; \&amp;postinstall,
        need_reboot =&gt; 1, # The install docs recommend a reboot.
        no_source_files =&gt; $no_source_files,
    );
    IM_Exit(EXIT_SUCCESS);
}

# Create the setup configuration files for the correct license
#   and install features.
# Unchanged for x86 or x64
sub preinstall
{
    output("    Generating install config files...\n");

    if (! -d $install_location) {
        if (!run_command("cmd /c mkdir \"${install_location}\"")) {
            output("      Cannot create install directory ".
                   "'${install_location}'.\n      Preinstall failed. ".
                   "Aborting...\n");
            exit(0);
        }
    }
    touch($install_log); # create the file so we can get the short name

    if (!generate_license_dat($license_dat,$license_server,
                              $license_server_port,$license_dat_comment)) {
        output("      Preinstall failed (license.dat creation). ".
               "Aborting...\n");
        return 0;
    }

    if (!generate_installer_ini($installer_ini,
                                get_short_path_name($install_location),
                                $fik,
                                get_short_path_name($install_log),
                                get_short_path_name($license_dat))) {
        output("      Preinstall failed (installer.ini creation). ".
               "Aborting...\n");
        return 0;
    }

    output("    Complete!\n");
        
    return 1;
}
# Changed $setup_dir for x86 and x64
sub install {
    my $sourcefilesdir = get_pkg_sourcefiles();        
    output("    Starting install...\n");

    if($x86_only)
    {
      $setup_dir = 'win32';
    }
    if($x64_only)
    {
      $setup_dir = 'win64';
    }
    # Starts the setup.exe using a batch script
    if (run_command("cmd /c \"".get_pkg_sourcefiles().
                               "\\bin\\${setup_dir}\\setup.exe\" ".
                    "-inputFile ".get_short_path_name($installer_ini))) {
        output("    Install complete!\n");
        return 1;
    } else {
        output("    FAILURE!\n");
        return 0;
    }
}

# Changed Start Menu Links for x86 and x64
sub postinstall {
    my $groupdir = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB R2016a';
    
    # Move 32-bit directory to the standard directory scheme
    if($x86_only &amp;&amp; !is_XP())
    {
        if (! -d "${groupdir}")
        {
            run_command("cmd /c MKDIR \"${groupdir}\"");
        }
        run_command("cmd /c XCOPY /Y /E /C /Q \"${groupdir} (32-bit)\" \"${groupdir}\"");
        run_command("cmd /c RMDIR /S /Q \"${groupdir} (32-bit)\"");
    }
    
    # Remove [de]activate icons.
    my @todel = ('Activate MATLAB R2016a.lnk',
                 'Deactivate MATLAB R2016a.lnk',
                 );
    output("    Removing activation shortcuts...\n");
    foreach my $file (@todel) {
        run_command("cmd /c DEL /Q \"${groupdir}\\${file}\"");
    }

    output("    Removing extra shortcut...\n");
    my $extra_del = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB R2016a.lnk';
    if($x86_only &amp;&amp; !is_XP())
    {
        $extra_del = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB R2016a (32-bit).lnk';
        
    }
    run_command("cmd /c DEL /Q \"${extra_del}\"");
    
    # Rename links to (x86) and (x64) respectively
    # Issues with variable names in "REN" command. Used static text instead.
    # Changed:
    #    Rename "MATLAB R2016a.lnk" to "MATLAB2012a (x86).lnk"
    # or Rename "MATLAB R2016a.lnk" to "MATLAB2012a (x64).lnk"
    output("    Renaming Links...");
    if($x86_only)
    {
      if(-e "$groupdir\\MATLAB R2016a (x86).lnk")
      {
        output(" [OK]\n");
      }
      elsif(is_XP())
      {
        # For XP, we won't worry about renaming it to x86, since it can only be x86.
        output(" [OK]\n");
      }
      elsif(!run_command("cmd /c REN \"${groupdir}\\MATLAB R2016a (32-bit).lnk\" \"MATLAB R2016a (x86).lnk\""))
      {
        output("    Error renaming x86 links. Check the file names.\n");
      }
      else
      {
        output(" [OK]\n");
      }
    }
    if($x64_only)
    {
      if(-e "$groupdir\\MATLAB R2016a (x64).lnk")
      {
        output(" [OK]\n");
      }
      elsif(!run_command("cmd /c REN \"${groupdir}\\MATLAB R2016a.lnk\" \"MATLAB R2016a (x64).lnk\""))
      {
        output("    Error renaming x64 links. Check the file names.\n");
      }
      else
      {
        output(" [OK]\n");
      }
    }
    return 1;
}
# Generate the correct license.dat
sub generate_license_dat {
    my $target_location = shift;
    my $server = shift;
    my $port = shift;
    my $comment = shift;

    my $license_dat_template = &lt;&lt;LICENSE_DAT_TEMPLATE
\%s
# Autogenerated by S\&amp;T installer.
SERVER \%s 0 \%s
USE_SERVER
LICENSE_DAT_TEMPLATE
;

    my $license_dat_data = sprintf($license_dat_template,
                                   $comment,$server,$port);
    local *OUTPUT;
    if (open(OUTPUT,'&gt;',$target_location)) {
        print OUTPUT $license_dat_data;
        close(OUTPUT);
    } else {
        output("      ERROR: Cannot open concurrent license config file ".
               "'${target_location}': $!\n");
        return 0;
    }

    return 1;
}

#Nothing Changed
sub generate_installer_ini {
    my $target_location = shift;
    my $install_dir = shift;
    my $fik = shift;
    my $output_log = shift;
    my $license_dat_loc = shift;

    # This is a printf format string that uses three string variables
    #  0) install dir
    #  1) fik (file installation key)
    #  2) location of install output log
    #  3) path to license.dat file
	
# use File::Basename;
# use Win32;

# my $cwd = dirname($0);
# my $scriptdir = Win32::GetFullPathName($cwd);
# activationPropertiesFile=$scriptdir;
	
    my $installer_ini_format = &lt;&lt;INSTALLER_INI
destinationFolder=\%s
fileInstallationKey=\%s
agreeToLicense=yes
outputFile=\%s
mode=silent
automatedModeTimeout=1000
#activationPropertiesFile=
licensePath=\%s
lmgrFiles=false
lmgrService=false
desktopShortcut=false
startMenuShortcut=true
INSTALLER_INI
;

    my $installer_ini_data = sprintf($installer_ini_format,$install_dir,
                                     $fik,$output_log,$license_dat_loc);

    local *OUTPUT;
    if (open(OUTPUT,'&gt;',$target_location)) {
        print OUTPUT $installer_ini_data;
        close(OUTPUT);
    } else {
        output("      ERROR: Cannot create automated installer config file '${target_location}': $!\n");
        return 0;
    }

    return 1;
}


#
# The file/directory must exist for this function to work.
#
sub get_short_path_name {
    my $path = shift;
    my $fso = Win32::OLE-&gt;CreateObject('Scripting.FileSystemObject');
    if (Win32::OLE-&gt;LastError) {
        output("Error creating FS object: ".Win32::OLE-&gt;LastError."\n");
    }
    if (-d $path) {
        my $dir = $fso-&gt;GetFolder($path);
        return $dir-&gt;ShortPath;
    } else {
        my $file = $fso-&gt;GetFile($path);
        return $file-&gt;ShortPath;
    }
}

sub touch {
    my $file = shift;

    local *TOUCH;
    if (open(TOUCH,'&gt;&gt;',$file)) {
        close(TOUCH);
        return 1;
    } else {
        output("Cannot open file for append '${file}': $!\n");
        return 0;
    }
}
</Text>
  </Script>
  <Script>
    <Name>update-academic-x64.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2016b\prod64\update-academic-x64.pl</FullName>
    <Length>1843</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-11-15T15:46:10.4382842-06:00</CreationTime>
    <CreationTimeUtc>2016-11-15T21:46:10.4382842Z</CreationTimeUtc>
    <LastWriteTime>2017-03-21T15:47:49.7970369-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-03-21T20:47:49.7970369Z</LastWriteTimeUtc>
    <LastAccessTime>2016-11-15T15:46:10.4382842-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-11-15T21:46:10.4382842Z</LastAccessTimeUtc>
    <Text># Matlab R2016b Academic Install Script
# Package Created June 2014
# Packaged by Hannah
# Updated on 2016-04-05 by Grayson Gratop

$x64_only = 1;

BEGIN
{  
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'matlab_2016b.x64',
    package_revision =&gt; 'academic-20161115T1548',
  );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'c:\temp',
);
use InstallMonkey::Shared;


########################################################################
# Begin Package Configuration
########################################################################

# This sets which folder to use for the license setup.
# It should be the only real difference between the Academic and Classroom scripts
$license_dat = get_pkg_sourcefiles().'\license.dat';
# Delete this file before exiting. It contains the install key (fik).
#   The clients shouldn't need it for heal/repair operations and it
#   could be abused if known.
$installer_ini = $ENV{'TEMP'}.'\installer.ini';

# installer.ini data
# New FIK (acquired 2017-03-15)
$fik = '62204-03945-54582-53037-34554-32138-36226-16779-59165-18641-13071-48102-00204-42591-15057-61325';

$install_log = get_default_app_log();
# This is the default. I suspect it needs to be in 8.3 format. At least,
#   That's how the default installer.ini file specifies it.
# license.dat data
$license_server = 'matlab-academic.lic.mst.edu';
$license_server_port = '1711';
$license_dat_comment = q/
# Matlab classroom license file for research and individual use.
/;

########################################################################
# End Package Configuration
########################################################################

# Do the install.

use lib(cwd());
require('update-common.pl');</Text>
  </Script>
  <Script>
    <Name>update-classroom-x64.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2016b\prod64\update-classroom-x64.pl</FullName>
    <Length>2174</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-11-15T15:46:10.4694848-06:00</CreationTime>
    <CreationTimeUtc>2016-11-15T21:46:10.4694848Z</CreationTimeUtc>
    <LastWriteTime>2016-11-28T11:10:03.3614295-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-11-28T17:10:03.3614295Z</LastWriteTimeUtc>
    <LastAccessTime>2016-11-15T15:46:10.4694848-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-11-15T21:46:10.4694848Z</LastAccessTimeUtc>
    <Text># Matlab R2016b Academic Install Script
# Package Created June 2014
# Packaged by Hannah
# Updated on 2016-04-05 by Grayson Gratop

$x64_only = 1;

BEGIN
{
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'matlab_2016b.x64',
    package_revision =&gt; 'classroom-20161115T1548',
  );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'c:\temp',
);
use InstallMonkey::Shared;


########################################################################
# Begin Package Configuration
########################################################################

# This sets which folder to use for the license setup.
# It should be the only real difference between the Academic and Classroom scripts
$license_dat = get_pkg_sourcefiles().'\license.dat';
# Delete this file before exiting. It contains the install key (fik).
#   The clients shouldn't need it for heal/repair operations and it
#   could be abused if known.
$installer_ini = $ENV{'TEMP'}.'\installer.ini';

# installer.ini data
# New FIK (acquired 2016-11-11)
$fik = '42266-15574-27578-36336-38328-29633-20260-46735-34011-52201-26334-29548-31381-55443';

$install_log = get_default_app_log();
# This is the default. I suspect it needs to be in 8.3 format. At least,
#   That's how the default installer.ini file specifies it.
# license.dat data
$license_server = 'matlab-classroom.lic.mst.edu';
$license_server_port = '1711';
$license_dat_comment = q/
# Matlab classroom license file for research and individual use.
/;

########################################################################
# End Package Configuration
########################################################################

# Remove existing registry keys

# #if(!run_command("regedit.exe /s rmkeys.reg")){
# if(!run_command("reg delete HKEY_LOCAL_MACHINE\\SOFTWARE\\UMR\\INSTALL\\Product_List\\matlab_2016b.x64 /f")){
# 	output("Previous registry entry could not be removed! Exiting\n.");
# 	return 0;
# }
# output("Previous registry entry removed.\n");

# Do the install.

use lib(cwd());
require('update-common.pl');
</Text>
  </Script>
  <Script>
    <Name>update-common.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2016b\prod64\update-common.pl</FullName>
    <Length>10004</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-11-15T15:46:10.531886-06:00</CreationTime>
    <CreationTimeUtc>2016-11-15T21:46:10.531886Z</CreationTimeUtc>
    <LastWriteTime>2016-11-15T15:50:22.8823388-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-11-15T21:50:22.8823388Z</LastWriteTimeUtc>
    <LastAccessTime>2016-11-15T15:46:10.531886-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-11-15T21:46:10.531886Z</LastAccessTimeUtc>
    <Text>#perl -w

########################################
# DIFFERENCES BETWEEN x86/x64 VERSIONS:
#     INSTALL LOCATION
#     START MENU LINK
#     PACKAGE ID
#     DATA DIRECTORY
########################################

use Win32::OLE;
use Win32::Shortcut;
use Getopt::Long;
$pre_only = 0;
$post_only = 0;
$no_source_files = 0;
GetOptions(
  'preinstall' =&gt; \$pre_only,
  'nosource' =&gt; \$no_source_files,
  'postinstall' =&gt; \$post_only,
);


####TESTING FUNCTIONS#####
if($pre_only)
{
  preinstall();
  postinstall();
  exit(0);
}
elsif($post_only)
{
  postinstall();
  exit(0);
}
##########################

# Change the Installation Directory
if($x86_only)
{
    if (is_x86()) {
        $install_location = $ENV{'ProgramFiles'}.'\Matlab\R2016b';
    } else {
        $install_location = $ENV{'ProgramFiles(x86)'}.'\Matlab\R2016b';
    }
}
elsif($x64_only)
{
  $install_location = $ENV{'ProgramFiles'}.'\Matlab\R2016b';
}

# Delete any sensitive information upon cleanup.
sub cleanup {
    $SIG{BREAK} = 'DEFAULT';
    $SIG{TERM} = 'DEFAULT';
    $SIG{INT} = 'DEFAULT';
    $SIG{QUIT} = 'DEFAULT';
    $SIG{KILL} = 'DEFAULT';

    output("    Cleaning up...\n");
    run_command("cmd /c DEL /Y /F /Q \"${installer_ini}\"");
}
$SIG{EXIT} = \&amp;cleanup;
$SIG{QUIT} = \&amp;cleanup;
$SIG{BREAK} = \&amp;cleanup;
$SIG{INT} = \&amp;cleanup;
$SIG{KILL} = \&amp;cleanup;


if($x86_only)
{
    do_install( 
        allowed_versions =&gt; [  OSVER_XP_32, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
        allowed_regs =&gt; ["clc", "desktop", "traveling", "virtual-desktop", "virtual-clc"],
        allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
        exit_on_failure =&gt; 1,
        data_dir =&gt; 'data32',
        preinstall_sub =&gt; \&amp;preinstall,
        install_sub =&gt; \&amp;install,
        postinstall_sub =&gt; \&amp;postinstall,
        need_reboot =&gt; 1, # The install docs recommend a reboot.
        no_source_files =&gt; $no_source_files
    );
    IM_Exit(EXIT_SUCCESS);
}
if($x64_only)
{
    do_install( 
        allowed_versions =&gt; [  OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
        allowed_regs =&gt; ["clc", "desktop", "traveling", "virtual-clc", "virtual-desktop" ],
        allowed_os_architectures =&gt; [ OSARCH_x64, OSARCH_x86 ],
        exit_on_failure =&gt; 1,
        data_dir =&gt; 'data64',
        preinstall_sub =&gt; \&amp;preinstall,
        install_sub =&gt; \&amp;install,
        postinstall_sub =&gt; \&amp;postinstall,
        need_reboot =&gt; 1, # The install docs recommend a reboot.
        no_source_files =&gt; $no_source_files,
    );
    IM_Exit(EXIT_SUCCESS);
}

# Create the setup configuration files for the correct license
#   and install features.
# Unchanged for x86 or x64
sub preinstall
{
    output("    Generating install config files...\n");

    if (! -d $install_location) {
        if (!run_command("cmd /c mkdir \"${install_location}\"")) {
            output("      Cannot create install directory ".
                   "'${install_location}'.\n      Preinstall failed. ".
                   "Aborting...\n");
            exit(0);
        }
    }
    touch($install_log); # create the file so we can get the short name

    if (!generate_license_dat($license_dat,$license_server,
                              $license_server_port,$license_dat_comment)) {
        output("      Preinstall failed (license.dat creation). ".
               "Aborting...\n");
        return 0;
    }

    if (!generate_installer_ini($installer_ini,
                                get_short_path_name($install_location),
                                $fik,
                                get_short_path_name($install_log),
                                get_short_path_name($license_dat))) {
        output("      Preinstall failed (installer.ini creation). ".
               "Aborting...\n");
        return 0;
    }

    output("    Complete!\n");
        
    return 1;
}
# Changed $setup_dir for x86 and x64
sub install {
    my $sourcefilesdir = get_pkg_sourcefiles();        
    output("    Starting install...\n");

    if($x86_only)
    {
      $setup_dir = 'win32';
    }
    if($x64_only)
    {
      $setup_dir = 'win64';
    }
    # Starts the setup.exe using a batch script
    if (run_command("cmd /c \"".get_pkg_sourcefiles().
                               "\\bin\\${setup_dir}\\setup.exe\" ".
                    "-inputFile ".get_short_path_name($installer_ini))) {
        output("    Install complete!\n");
        return 1;
    } else {
        output("    FAILURE!\n");
        return 0;
    }
}

# Changed Start Menu Links for x86 and x64
sub postinstall {
    my $groupdir = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB R2016b';
    
    # Move 32-bit directory to the standard directory scheme
    if($x86_only &amp;&amp; !is_XP())
    {
        if (! -d "${groupdir}")
        {
            run_command("cmd /c MKDIR \"${groupdir}\"");
        }
        run_command("cmd /c XCOPY /Y /E /C /Q \"${groupdir} (32-bit)\" \"${groupdir}\"");
        run_command("cmd /c RMDIR /S /Q \"${groupdir} (32-bit)\"");
    }
    
    # Remove [de]activate icons.
    my @todel = ('Activate MATLAB R2016b.lnk',
                 'Deactivate MATLAB R2016b.lnk',
                 );
    output("    Removing activation shortcuts...\n");
    foreach my $file (@todel) {
        run_command("cmd /c DEL /Q \"${groupdir}\\${file}\"");
    }

    output("    Removing extra shortcut...\n");
    my $extra_del = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB R2016b.lnk';
    if($x86_only &amp;&amp; !is_XP())
    {
        $extra_del = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB R2016b (32-bit).lnk';
        
    }
    run_command("cmd /c DEL /Q \"${extra_del}\"");
    
    # Rename links to (x86) and (x64) respectively
    # Issues with variable names in "REN" command. Used static text instead.
    # Changed:
    #    Rename "MATLAB R2016b.lnk" to "MATLAB2012a (x86).lnk"
    # or Rename "MATLAB R2016b.lnk" to "MATLAB2012a (x64).lnk"
    output("    Renaming Links...");
    if($x86_only)
    {
      if(-e "$groupdir\\MATLAB R2016b (x86).lnk")
      {
        output(" [OK]\n");
      }
      elsif(is_XP())
      {
        # For XP, we won't worry about renaming it to x86, since it can only be x86.
        output(" [OK]\n");
      }
      elsif(!run_command("cmd /c REN \"${groupdir}\\MATLAB R2016b (32-bit).lnk\" \"MATLAB R2016b (x86).lnk\""))
      {
        output("    Error renaming x86 links. Check the file names.\n");
      }
      else
      {
        output(" [OK]\n");
      }
    }
    if($x64_only)
    {
      if(-e "$groupdir\\MATLAB R2016b (x64).lnk")
      {
        output(" [OK]\n");
      }
      elsif(!run_command("cmd /c REN \"${groupdir}\\MATLAB R2016b.lnk\" \"MATLAB R2016b (x64).lnk\""))
      {
        output("    Error renaming x64 links. Check the file names.\n");
      }
      else
      {
        output(" [OK]\n");
      }
    }
    return 1;
}
# Generate the correct license.dat
sub generate_license_dat {
    my $target_location = shift;
    my $server = shift;
    my $port = shift;
    my $comment = shift;

    my $license_dat_template = &lt;&lt;LICENSE_DAT_TEMPLATE
\%s
# Autogenerated by S\&amp;T installer.
SERVER \%s 0 \%s
USE_SERVER
LICENSE_DAT_TEMPLATE
;

    my $license_dat_data = sprintf($license_dat_template,
                                   $comment,$server,$port);
    local *OUTPUT;
    if (open(OUTPUT,'&gt;',$target_location)) {
        print OUTPUT $license_dat_data;
        close(OUTPUT);
    } else {
        output("      ERROR: Cannot open concurrent license config file ".
               "'${target_location}': $!\n");
        return 0;
    }

    return 1;
}

#Nothing Changed
sub generate_installer_ini {
    my $target_location = shift;
    my $install_dir = shift;
    my $fik = shift;
    my $output_log = shift;
    my $license_dat_loc = shift;

    # This is a printf format string that uses three string variables
    #  0) install dir
    #  1) fik (file installation key)
    #  2) location of install output log
    #  3) path to license.dat file
	
# use File::Basename;
# use Win32;

# my $cwd = dirname($0);
# my $scriptdir = Win32::GetFullPathName($cwd);
# activationPropertiesFile=$scriptdir;
	
    my $installer_ini_format = &lt;&lt;INSTALLER_INI
destinationFolder=\%s
fileInstallationKey=\%s
agreeToLicense=yes
outputFile=\%s
mode=silent
automatedModeTimeout=1000
#activationPropertiesFile=
licensePath=\%s
lmgrFiles=false
lmgrService=false
desktopShortcut=false
startMenuShortcut=true
INSTALLER_INI
;

    my $installer_ini_data = sprintf($installer_ini_format,$install_dir,
                                     $fik,$output_log,$license_dat_loc);

    local *OUTPUT;
    if (open(OUTPUT,'&gt;',$target_location)) {
        print OUTPUT $installer_ini_data;
        close(OUTPUT);
    } else {
        output("      ERROR: Cannot create automated installer config file '${target_location}': $!\n");
        return 0;
    }

    return 1;
}


#
# The file/directory must exist for this function to work.
#
sub get_short_path_name {
    my $path = shift;
    my $fso = Win32::OLE-&gt;CreateObject('Scripting.FileSystemObject');
    if (Win32::OLE-&gt;LastError) {
        output("Error creating FS object: ".Win32::OLE-&gt;LastError."\n");
    }
    if (-d $path) {
        my $dir = $fso-&gt;GetFolder($path);
        return $dir-&gt;ShortPath;
    } else {
        my $file = $fso-&gt;GetFile($path);
        return $file-&gt;ShortPath;
    }
}

sub touch {
    my $file = shift;

    local *TOUCH;
    if (open(TOUCH,'&gt;&gt;',$file)) {
        close(TOUCH);
        return 1;
    } else {
        output("Cannot open file for append '${file}': $!\n");
        return 0;
    }
}
</Text>
  </Script>
  <Script>
    <Name>update-academic-x64.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2017a\prod64\update-academic-x64.pl</FullName>
    <Length>1843</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-05-05T12:36:57.9221929-05:00</CreationTime>
    <CreationTimeUtc>2017-05-05T17:36:57.9221929Z</CreationTimeUtc>
    <LastWriteTime>2017-05-11T14:46:52.8365585-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-05-11T19:46:52.8365585Z</LastWriteTimeUtc>
    <LastAccessTime>2017-05-05T12:36:57.9221929-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-05-05T17:36:57.9221929Z</LastAccessTimeUtc>
    <Text># Matlab R2017a Academic Install Script
# Package Created June 2014
# Packaged by Hannah
# Updated on 2016-04-05 by Grayson Gratop

$x64_only = 1;

BEGIN
{  
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'matlab_2017a.x64',
    package_revision =&gt; 'academic-20170511T1548',
  );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'c:\temp',
);
use InstallMonkey::Shared;


########################################################################
# Begin Package Configuration
########################################################################

# This sets which folder to use for the license setup.
# It should be the only real difference between the Academic and Classroom scripts
$license_dat = get_pkg_sourcefiles().'\license.dat';
# Delete this file before exiting. It contains the install key (fik).
#   The clients shouldn't need it for heal/repair operations and it
#   could be abused if known.
$installer_ini = $ENV{'TEMP'}.'\installer.ini';

# installer.ini data
# New FIK (acquired 2017-03-15)
$fik = '48523-29397-34962-37850-24891-49105-00392-60360-61747-34307-63490-54365-49114-01836-10978-08539';

$install_log = get_default_app_log();
# This is the default. I suspect it needs to be in 8.3 format. At least,
#   That's how the default installer.ini file specifies it.
# license.dat data
$license_server = 'matlab-academic.lic.mst.edu';
$license_server_port = '1711';
$license_dat_comment = q/
# Matlab classroom license file for research and individual use.
/;

########################################################################
# End Package Configuration
########################################################################

# Do the install.

use lib(cwd());
require('update-common.pl');</Text>
  </Script>
  <Script>
    <Name>update-classroom-x64.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2017a\prod64\update-classroom-x64.pl</FullName>
    <Length>2174</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-05-05T12:36:57.9533935-05:00</CreationTime>
    <CreationTimeUtc>2017-05-05T17:36:57.9533935Z</CreationTimeUtc>
    <LastWriteTime>2017-05-11T14:36:03.0528629-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-05-11T19:36:03.0528629Z</LastWriteTimeUtc>
    <LastAccessTime>2017-05-05T12:36:57.9533935-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-05-05T17:36:57.9533935Z</LastAccessTimeUtc>
    <Text># Matlab R2017a Academic Install Script
# Package Created June 2014
# Packaged by Hannah
# Updated on 2016-04-05 by Grayson Gratop

$x64_only = 1;

BEGIN
{
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'matlab_2017a.x64',
    package_revision =&gt; 'classroom-20170510T1548',
  );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'c:\temp',
);
use InstallMonkey::Shared;


########################################################################
# Begin Package Configuration
########################################################################

# This sets which folder to use for the license setup.
# It should be the only real difference between the Academic and Classroom scripts
$license_dat = get_pkg_sourcefiles().'\license.dat';
# Delete this file before exiting. It contains the install key (fik).
#   The clients shouldn't need it for heal/repair operations and it
#   could be abused if known.
$installer_ini = $ENV{'TEMP'}.'\installer.ini';

# installer.ini data
# New FIK (acquired 2017-03-15)
$fik = '42200-25757-58304-19972-13013-09320-63337-28648-19074-03067-48563-24227-35659-15621';

$install_log = get_default_app_log();
# This is the default. I suspect it needs to be in 8.3 format. At least,
#   That's how the default installer.ini file specifies it.
# license.dat data
$license_server = 'matlab-classroom.lic.mst.edu';
$license_server_port = '1711';
$license_dat_comment = q/
# Matlab classroom license file for research and individual use.
/;

########################################################################
# End Package Configuration
########################################################################

# Remove existing registry keys

# #if(!run_command("regedit.exe /s rmkeys.reg")){
# if(!run_command("reg delete HKEY_LOCAL_MACHINE\\SOFTWARE\\UMR\\INSTALL\\Product_List\\matlab_2017a.x64 /f")){
# 	output("Previous registry entry could not be removed! Exiting\n.");
# 	return 0;
# }
# output("Previous registry entry removed.\n");

# Do the install.

use lib(cwd());
require('update-common.pl');
</Text>
  </Script>
  <Script>
    <Name>update-common.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2017a\prod64\update-common.pl</FullName>
    <Length>10004</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-05-05T12:36:57.9689938-05:00</CreationTime>
    <CreationTimeUtc>2017-05-05T17:36:57.9689938Z</CreationTimeUtc>
    <LastWriteTime>2017-05-10T15:02:50.278424-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-05-10T20:02:50.278424Z</LastWriteTimeUtc>
    <LastAccessTime>2017-05-05T12:36:57.9689938-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-05-05T17:36:57.9689938Z</LastAccessTimeUtc>
    <Text>#perl -w

########################################
# DIFFERENCES BETWEEN x86/x64 VERSIONS:
#     INSTALL LOCATION
#     START MENU LINK
#     PACKAGE ID
#     DATA DIRECTORY
########################################

use Win32::OLE;
use Win32::Shortcut;
use Getopt::Long;
$pre_only = 0;
$post_only = 0;
$no_source_files = 0;
GetOptions(
  'preinstall' =&gt; \$pre_only,
  'nosource' =&gt; \$no_source_files,
  'postinstall' =&gt; \$post_only,
);


####TESTING FUNCTIONS#####
if($pre_only)
{
  preinstall();
  postinstall();
  exit(0);
}
elsif($post_only)
{
  postinstall();
  exit(0);
}
##########################

# Change the Installation Directory
if($x86_only)
{
    if (is_x86()) {
        $install_location = $ENV{'ProgramFiles'}.'\Matlab\R2017a';
    } else {
        $install_location = $ENV{'ProgramFiles(x86)'}.'\Matlab\R2017a';
    }
}
elsif($x64_only)
{
  $install_location = $ENV{'ProgramFiles'}.'\Matlab\R2017a';
}

# Delete any sensitive information upon cleanup.
sub cleanup {
    $SIG{BREAK} = 'DEFAULT';
    $SIG{TERM} = 'DEFAULT';
    $SIG{INT} = 'DEFAULT';
    $SIG{QUIT} = 'DEFAULT';
    $SIG{KILL} = 'DEFAULT';

    output("    Cleaning up...\n");
    run_command("cmd /c DEL /Y /F /Q \"${installer_ini}\"");
}
$SIG{EXIT} = \&amp;cleanup;
$SIG{QUIT} = \&amp;cleanup;
$SIG{BREAK} = \&amp;cleanup;
$SIG{INT} = \&amp;cleanup;
$SIG{KILL} = \&amp;cleanup;


if($x86_only)
{
    do_install( 
        allowed_versions =&gt; [  OSVER_XP_32, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
        allowed_regs =&gt; ["clc", "desktop", "traveling", "virtual-desktop", "virtual-clc"],
        allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
        exit_on_failure =&gt; 1,
        data_dir =&gt; 'data32',
        preinstall_sub =&gt; \&amp;preinstall,
        install_sub =&gt; \&amp;install,
        postinstall_sub =&gt; \&amp;postinstall,
        need_reboot =&gt; 1, # The install docs recommend a reboot.
        no_source_files =&gt; $no_source_files
    );
    IM_Exit(EXIT_SUCCESS);
}
if($x64_only)
{
    do_install( 
        allowed_versions =&gt; [  OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
        allowed_regs =&gt; ["clc", "desktop", "traveling", "virtual-clc", "virtual-desktop" ],
        allowed_os_architectures =&gt; [ OSARCH_x64, OSARCH_x86 ],
        exit_on_failure =&gt; 1,
        data_dir =&gt; 'data64',
        preinstall_sub =&gt; \&amp;preinstall,
        install_sub =&gt; \&amp;install,
        postinstall_sub =&gt; \&amp;postinstall,
        need_reboot =&gt; 1, # The install docs recommend a reboot.
        no_source_files =&gt; $no_source_files,
    );
    IM_Exit(EXIT_SUCCESS);
}

# Create the setup configuration files for the correct license
#   and install features.
# Unchanged for x86 or x64
sub preinstall
{
    output("    Generating install config files...\n");

    if (! -d $install_location) {
        if (!run_command("cmd /c mkdir \"${install_location}\"")) {
            output("      Cannot create install directory ".
                   "'${install_location}'.\n      Preinstall failed. ".
                   "Aborting...\n");
            exit(0);
        }
    }
    touch($install_log); # create the file so we can get the short name

    if (!generate_license_dat($license_dat,$license_server,
                              $license_server_port,$license_dat_comment)) {
        output("      Preinstall failed (license.dat creation). ".
               "Aborting...\n");
        return 0;
    }

    if (!generate_installer_ini($installer_ini,
                                get_short_path_name($install_location),
                                $fik,
                                get_short_path_name($install_log),
                                get_short_path_name($license_dat))) {
        output("      Preinstall failed (installer.ini creation). ".
               "Aborting...\n");
        return 0;
    }

    output("    Complete!\n");
        
    return 1;
}
# Changed $setup_dir for x86 and x64
sub install {
    my $sourcefilesdir = get_pkg_sourcefiles();        
    output("    Starting install...\n");

    if($x86_only)
    {
      $setup_dir = 'win32';
    }
    if($x64_only)
    {
      $setup_dir = 'win64';
    }
    # Starts the setup.exe using a batch script
    if (run_command("cmd /c \"".get_pkg_sourcefiles().
                               "\\bin\\${setup_dir}\\setup.exe\" ".
                    "-inputFile ".get_short_path_name($installer_ini))) {
        output("    Install complete!\n");
        return 1;
    } else {
        output("    FAILURE!\n");
        return 0;
    }
}

# Changed Start Menu Links for x86 and x64
sub postinstall {
    my $groupdir = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB R2017a';
    
    # Move 32-bit directory to the standard directory scheme
    if($x86_only &amp;&amp; !is_XP())
    {
        if (! -d "${groupdir}")
        {
            run_command("cmd /c MKDIR \"${groupdir}\"");
        }
        run_command("cmd /c XCOPY /Y /E /C /Q \"${groupdir} (32-bit)\" \"${groupdir}\"");
        run_command("cmd /c RMDIR /S /Q \"${groupdir} (32-bit)\"");
    }
    
    # Remove [de]activate icons.
    my @todel = ('Activate MATLAB R2017a.lnk',
                 'Deactivate MATLAB R2017a.lnk',
                 );
    output("    Removing activation shortcuts...\n");
    foreach my $file (@todel) {
        run_command("cmd /c DEL /Q \"${groupdir}\\${file}\"");
    }

    output("    Removing extra shortcut...\n");
    my $extra_del = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB R2017a.lnk';
    if($x86_only &amp;&amp; !is_XP())
    {
        $extra_del = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB R2017a (32-bit).lnk';
        
    }
    run_command("cmd /c DEL /Q \"${extra_del}\"");
    
    # Rename links to (x86) and (x64) respectively
    # Issues with variable names in "REN" command. Used static text instead.
    # Changed:
    #    Rename "MATLAB R2017a.lnk" to "MATLAB2012a (x86).lnk"
    # or Rename "MATLAB R2017a.lnk" to "MATLAB2012a (x64).lnk"
    output("    Renaming Links...");
    if($x86_only)
    {
      if(-e "$groupdir\\MATLAB R2017a (x86).lnk")
      {
        output(" [OK]\n");
      }
      elsif(is_XP())
      {
        # For XP, we won't worry about renaming it to x86, since it can only be x86.
        output(" [OK]\n");
      }
      elsif(!run_command("cmd /c REN \"${groupdir}\\MATLAB R2017a (32-bit).lnk\" \"MATLAB R2017a (x86).lnk\""))
      {
        output("    Error renaming x86 links. Check the file names.\n");
      }
      else
      {
        output(" [OK]\n");
      }
    }
    if($x64_only)
    {
      if(-e "$groupdir\\MATLAB R2017a (x64).lnk")
      {
        output(" [OK]\n");
      }
      elsif(!run_command("cmd /c REN \"${groupdir}\\MATLAB R2017a.lnk\" \"MATLAB R2017a (x64).lnk\""))
      {
        output("    Error renaming x64 links. Check the file names.\n");
      }
      else
      {
        output(" [OK]\n");
      }
    }
    return 1;
}
# Generate the correct license.dat
sub generate_license_dat {
    my $target_location = shift;
    my $server = shift;
    my $port = shift;
    my $comment = shift;

    my $license_dat_template = &lt;&lt;LICENSE_DAT_TEMPLATE
\%s
# Autogenerated by S\&amp;T installer.
SERVER \%s 0 \%s
USE_SERVER
LICENSE_DAT_TEMPLATE
;

    my $license_dat_data = sprintf($license_dat_template,
                                   $comment,$server,$port);
    local *OUTPUT;
    if (open(OUTPUT,'&gt;',$target_location)) {
        print OUTPUT $license_dat_data;
        close(OUTPUT);
    } else {
        output("      ERROR: Cannot open concurrent license config file ".
               "'${target_location}': $!\n");
        return 0;
    }

    return 1;
}

#Nothing Changed
sub generate_installer_ini {
    my $target_location = shift;
    my $install_dir = shift;
    my $fik = shift;
    my $output_log = shift;
    my $license_dat_loc = shift;

    # This is a printf format string that uses three string variables
    #  0) install dir
    #  1) fik (file installation key)
    #  2) location of install output log
    #  3) path to license.dat file
	
# use File::Basename;
# use Win32;

# my $cwd = dirname($0);
# my $scriptdir = Win32::GetFullPathName($cwd);
# activationPropertiesFile=$scriptdir;
	
    my $installer_ini_format = &lt;&lt;INSTALLER_INI
destinationFolder=\%s
fileInstallationKey=\%s
agreeToLicense=yes
outputFile=\%s
mode=silent
automatedModeTimeout=1000
#activationPropertiesFile=
licensePath=\%s
lmgrFiles=false
lmgrService=false
desktopShortcut=false
startMenuShortcut=true
INSTALLER_INI
;

    my $installer_ini_data = sprintf($installer_ini_format,$install_dir,
                                     $fik,$output_log,$license_dat_loc);

    local *OUTPUT;
    if (open(OUTPUT,'&gt;',$target_location)) {
        print OUTPUT $installer_ini_data;
        close(OUTPUT);
    } else {
        output("      ERROR: Cannot create automated installer config file '${target_location}': $!\n");
        return 0;
    }

    return 1;
}


#
# The file/directory must exist for this function to work.
#
sub get_short_path_name {
    my $path = shift;
    my $fso = Win32::OLE-&gt;CreateObject('Scripting.FileSystemObject');
    if (Win32::OLE-&gt;LastError) {
        output("Error creating FS object: ".Win32::OLE-&gt;LastError."\n");
    }
    if (-d $path) {
        my $dir = $fso-&gt;GetFolder($path);
        return $dir-&gt;ShortPath;
    } else {
        my $file = $fso-&gt;GetFile($path);
        return $file-&gt;ShortPath;
    }
}

sub touch {
    my $file = shift;

    local *TOUCH;
    if (open(TOUCH,'&gt;&gt;',$file)) {
        close(TOUCH);
        return 1;
    } else {
        output("Cannot open file for append '${file}': $!\n");
        return 0;
    }
}
</Text>
  </Script>
  <Script>
    <Name>update-academic-x64.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2018a\prod64\update-academic-x64.pl</FullName>
    <Length>1842</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-13T09:45:47.6783913-05:00</CreationTime>
    <CreationTimeUtc>2018-06-13T14:45:47.6783913Z</CreationTimeUtc>
    <LastWriteTime>2018-06-13T09:48:01.3215034-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-13T14:48:01.3215034Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-13T09:45:47.6783913-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-13T14:45:47.6783913Z</LastAccessTimeUtc>
    <Text># Matlab R2018a Academic Install Script
# Package Created June 2014
# Packaged by Hannah
# Updated on 2018-06-13 by Cameron Loren

$x64_only = 1;

BEGIN
{
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'matlab_2018a.x64',
    package_revision =&gt; 'academic-20180613T0946',
  );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'c:\temp',
);
use InstallMonkey::Shared;


########################################################################
# Begin Package Configuration
########################################################################

# This sets which folder to use for the license setup.
# It should be the only real difference between the Academic and Classroom scripts
$license_dat = get_pkg_sourcefiles().'\license.dat';
# Delete this file before exiting. It contains the install key (fik).
#   The clients shouldn't need it for heal/repair operations and it
#   could be abused if known.
$installer_ini = $ENV{'TEMP'}.'\installer.ini';

# installer.ini data
# New FIK (acquired 2018-03-23)
$fik = '65066-55334-30500-25813-48588-24478-26073-32042-35849-59036-33232-08139-06022-16891-21659-48232';

$install_log = get_default_app_log();
# This is the default. I suspect it needs to be in 8.3 format. At least,
#   That's how the default installer.ini file specifies it.
# license.dat data
$license_server = 'matlab-academic.lic.mst.edu';
$license_server_port = '1711';
$license_dat_comment = q/
# Matlab classroom license file for research and individual use.
/;

########################################################################
# End Package Configuration
########################################################################

# Do the install.

use lib(cwd());
require('update-common.pl');
</Text>
  </Script>
  <Script>
    <Name>update-classroom-x64.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2018a\prod64\update-classroom-x64.pl</FullName>
    <Length>2180</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-13T09:45:47.7721435-05:00</CreationTime>
    <CreationTimeUtc>2018-06-13T14:45:47.7721435Z</CreationTimeUtc>
    <LastWriteTime>2018-06-13T09:48:50.8688243-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-13T14:48:50.8688243Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-13T09:45:47.7721435-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-13T14:45:47.7721435Z</LastAccessTimeUtc>
    <Text># Matlab R2018a Classroom Install Script
# Package Created June 2014
# Packaged by Hannah
# Updated on 2018-06-13 by Cameron Loren

$x64_only = 1;

BEGIN
{
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'matlab_2018a.x64',
    package_revision =&gt; 'classroom-20180613T0948',
  );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'c:\temp',
);
use InstallMonkey::Shared;


########################################################################
# Begin Package Configuration
########################################################################

# This sets which folder to use for the license setup.
# It should be the only real difference between the Academic and Classroom scripts
$license_dat = get_pkg_sourcefiles().'\license.dat';
# Delete this file before exiting. It contains the install key (fik).
#   The clients shouldn't need it for heal/repair operations and it
#   could be abused if known.
$installer_ini = $ENV{'TEMP'}.'\installer.ini';

# installer.ini data
# New FIK (acquired 2017-03-15)
$fik = '31166-00748-03184-47539-31131-61561-57140-56386-13252-53671-54024-42257-38473-64295-53586';

$install_log = get_default_app_log();
# This is the default. I suspect it needs to be in 8.3 format. At least,
#   That's how the default installer.ini file specifies it.
# license.dat data
$license_server = 'matlab-classroom.lic.mst.edu';
$license_server_port = '1711';
$license_dat_comment = q/
# Matlab classroom license file for research and individual use.
/;

########################################################################
# End Package Configuration
########################################################################

# Remove existing registry keys

# #if(!run_command("regedit.exe /s rmkeys.reg")){
# if(!run_command("reg delete HKEY_LOCAL_MACHINE\\SOFTWARE\\UMR\\INSTALL\\Product_List\\matlab_2017a.x64 /f")){
# 	output("Previous registry entry could not be removed! Exiting\n.");
# 	return 0;
# }
# output("Previous registry entry removed.\n");

# Do the install.

use lib(cwd());
require('update-common.pl');
</Text>
  </Script>
  <Script>
    <Name>update-common.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\matlab.2018a\prod64\update-common.pl</FullName>
    <Length>10072</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-13T09:45:47.8503606-05:00</CreationTime>
    <CreationTimeUtc>2018-06-13T14:45:47.8503606Z</CreationTimeUtc>
    <LastWriteTime>2018-06-15T10:57:27.8702515-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-15T15:57:27.8702515Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-13T09:45:47.8503606-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-13T14:45:47.8503606Z</LastAccessTimeUtc>
    <Text>#perl -w

########################################
# DIFFERENCES BETWEEN x86/x64 VERSIONS:
#     INSTALL LOCATION
#     START MENU LINK
#     PACKAGE ID
#     DATA DIRECTORY
########################################

use Win32::OLE;
use Win32::Shortcut;
use Getopt::Long;
$pre_only = 0;
$post_only = 0;
$no_source_files = 0;
GetOptions(
  'preinstall' =&gt; \$pre_only,
  'nosource' =&gt; \$no_source_files,
  'postinstall' =&gt; \$post_only,
);


####TESTING FUNCTIONS#####
if($pre_only)
{
  preinstall();
  postinstall();
  exit(0);
}
elsif($post_only)
{
  postinstall();
  exit(0);
}
##########################

# Change the Installation Directory
if($x86_only)
{
    if (is_x86()) {
        $install_location = $ENV{'ProgramFiles'}.'\Matlab\R2018a';
    } else {
        $install_location = $ENV{'ProgramFiles(x86)'}.'\Matlab\R2018a';
    }
}
elsif($x64_only)
{
  $install_location = $ENV{'ProgramFiles'}.'\Matlab\R2018a';
}

# Delete any sensitive information upon cleanup.
sub cleanup {
    $SIG{BREAK} = 'DEFAULT';
    $SIG{TERM} = 'DEFAULT';
    $SIG{INT} = 'DEFAULT';
    $SIG{QUIT} = 'DEFAULT';
    $SIG{KILL} = 'DEFAULT';

    output("    Cleaning up...\n");
    run_command("cmd /c DEL /Y /F /Q \"${installer_ini}\"");
}
$SIG{EXIT} = \&amp;cleanup;
$SIG{QUIT} = \&amp;cleanup;
$SIG{BREAK} = \&amp;cleanup;
$SIG{INT} = \&amp;cleanup;
$SIG{KILL} = \&amp;cleanup;


if($x86_only)
{
    do_install(
        allowed_versions =&gt; [  OSVER_XP_32, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
        allowed_regs =&gt; ["clc", "desktop", "traveling", "virtual-desktop", "virtual-clc"],
        allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
        exit_on_failure =&gt; 1,
        data_dir =&gt; 'data32',
        preinstall_sub =&gt; \&amp;preinstall,
        install_sub =&gt; \&amp;install,
        postinstall_sub =&gt; \&amp;postinstall,
        need_reboot =&gt; 1, # The install docs recommend a reboot.
        no_source_files =&gt; $no_source_files
    );
    IM_Exit(EXIT_SUCCESS);
}
if($x64_only)
{
    do_install(
        allowed_versions =&gt; [  OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
        allowed_regs =&gt; ["clc", "desktop", "traveling", "virtual-clc", "virtual-desktop" ],
        allowed_os_architectures =&gt; [ OSARCH_x64, OSARCH_x86 ],
        exit_on_failure =&gt; 1,
        data_dir =&gt; 'data64',
        preinstall_sub =&gt; \&amp;preinstall,
        install_sub =&gt; \&amp;install,
        postinstall_sub =&gt; \&amp;postinstall,
        need_reboot =&gt; 1, # The install docs recommend a reboot.
        no_source_files =&gt; $no_source_files,
    );
    IM_Exit(EXIT_SUCCESS);
}

# Create the setup configuration files for the correct license
#   and install features.
# Unchanged for x86 or x64
sub preinstall
{
    output("    Generating install config files...\n");

    if (! -d $install_location) {
        if (!run_command("cmd /c mkdir \"${install_location}\"")) {
            output("      Cannot create install directory ".
                   "'${install_location}'.\n      Preinstall failed. ".
                   "Aborting...\n");
            exit(0);
        }
    }
    touch($install_log); # create the file so we can get the short name

    if (!generate_license_dat($license_dat,$license_server,
                              $license_server_port,$license_dat_comment)) {
        output("      Preinstall failed (license.dat creation). ".
               "Aborting...\n");
        return 0;
    }

    if (!generate_installer_ini($installer_ini,
                                get_short_path_name($install_location),
                                $fik,
                                get_short_path_name($install_log),
                                get_short_path_name($license_dat))) {
        output("      Preinstall failed (installer.ini creation). ".
               "Aborting...\n");
        return 0;
    }

    output("    Complete!\n");

    return 1;
}
# Changed $setup_dir for x86 and x64
sub install {
    my $sourcefilesdir = get_pkg_sourcefiles();
    output("    Starting install...\n");

    if($x86_only)
    {
      $setup_dir = 'win32';
    }
    if($x64_only)
    {
      $setup_dir = 'win64';
    }
    output("    Installer.ini location: ".get_short_path_name($installer_ini));
    # Starts the setup.exe using a batch script
    if (run_command("\"".get_pkg_sourcefiles().
                               "\\bin\\${setup_dir}\\setup.exe\" ".
                    "-inputFile ".get_short_path_name($installer_ini))) {
        output("    Install complete!\n");
        return 1;
    } else {
        output("    FAILURE!\n");
        return 0;
    }
}

# Changed Start Menu Links for x86 and x64
sub postinstall {
    my $groupdir = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB R2018a';

    # Move 32-bit directory to the standard directory scheme
    if($x86_only &amp;&amp; !is_XP())
    {
        if (! -d "${groupdir}")
        {
            run_command("cmd /c MKDIR \"${groupdir}\"");
        }
        run_command("cmd /c XCOPY /Y /E /C /Q \"${groupdir} (32-bit)\" \"${groupdir}\"");
        run_command("cmd /c RMDIR /S /Q \"${groupdir} (32-bit)\"");
    }

    # Remove [de]activate icons.
    my @todel = ('Activate MATLAB R2018a.lnk',
                 'Deactivate MATLAB R2018a.lnk',
                 );
    output("    Removing activation shortcuts...\n");
    foreach my $file (@todel) {
        run_command("cmd /c DEL /Q \"${groupdir}\\${file}\"");
    }

    output("    Removing extra shortcut...\n");
    my $extra_del = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB R2018a.lnk';
    if($x86_only &amp;&amp; !is_XP())
    {
        $extra_del = $ENV{'ALLUSERSPROFILE'}.'\Start Menu\Programs\MATLAB R2018a (32-bit).lnk';

    }
    run_command("cmd /c DEL /Q \"${extra_del}\"");

    # Rename links to (x86) and (x64) respectively
    # Issues with variable names in "REN" command. Used static text instead.
    # Changed:
    #    Rename "MATLAB R2018a.lnk" to "MATLAB2012a (x86).lnk"
    # or Rename "MATLAB R2018a.lnk" to "MATLAB2012a (x64).lnk"
    output("    Renaming Links...");
    if($x86_only)
    {
      if(-e "$groupdir\\MATLAB R2018a (x86).lnk")
      {
        output(" [OK]\n");
      }
      elsif(is_XP())
      {
        # For XP, we won't worry about renaming it to x86, since it can only be x86.
        output(" [OK]\n");
      }
      elsif(!run_command("cmd /c REN \"${groupdir}\\MATLAB R2018a (32-bit).lnk\" \"MATLAB R2018a (x86).lnk\""))
      {
        output("    Error renaming x86 links. Check the file names.\n");
      }
      else
      {
        output(" [OK]\n");
      }
    }
    if($x64_only)
    {
      if(-e "$groupdir\\MATLAB R2018a (x64).lnk")
      {
        output(" [OK]\n");
      }
      elsif(!run_command("cmd /c REN \"${groupdir}\\MATLAB R2018a.lnk\" \"MATLAB R2018a (x64).lnk\""))
      {
        output("    Error renaming x64 links. Check the file names.\n");
      }
      else
      {
        output(" [OK]\n");
      }
    }
    return 1;
}
# Generate the correct license.dat
sub generate_license_dat {
    my $target_location = shift;
    my $server = shift;
    my $port = shift;
    my $comment = shift;

    my $license_dat_template = &lt;&lt;LICENSE_DAT_TEMPLATE
\%s
# Autogenerated by S\&amp;T installer.
SERVER \%s 0 \%s
USE_SERVER
LICENSE_DAT_TEMPLATE
;

    my $license_dat_data = sprintf($license_dat_template,
                                   $comment,$server,$port);
    local *OUTPUT;
    if (open(OUTPUT,'&gt;',$target_location)) {
        print OUTPUT $license_dat_data;
        close(OUTPUT);
    } else {
        output("      ERROR: Cannot open concurrent license config file ".
               "'${target_location}': $!\n");
        return 0;
    }

    return 1;
}

#Nothing Changed
sub generate_installer_ini {
    my $target_location = shift;
    my $install_dir = shift;
    my $fik = shift;
    my $output_log = shift;
    my $license_dat_loc = shift;

    # This is a printf format string that uses three string variables
    #  0) install dir
    #  1) fik (file installation key)
    #  2) location of install output log
    #  3) path to license.dat file

# use File::Basename;
# use Win32;

# my $cwd = dirname($0);
# my $scriptdir = Win32::GetFullPathName($cwd);
# activationPropertiesFile=$scriptdir;

    my $installer_ini_format = &lt;&lt;INSTALLER_INI
destinationFolder=\%s
fileInstallationKey=\%s
agreeToLicense=yes
outputFile=\%s
mode=silent
automatedModeTimeout=1000
#activationPropertiesFile=
licensePath=\%s
lmgrFiles=false
lmgrService=false
desktopShortcut=false
startMenuShortcut=true
INSTALLER_INI
;

    my $installer_ini_data = sprintf($installer_ini_format,$install_dir,
                                     $fik,$output_log,$license_dat_loc);

    local *OUTPUT;
    if (open(OUTPUT,'&gt;',$target_location)) {
        print OUTPUT $installer_ini_data;
        close(OUTPUT);
    } else {
        output("      ERROR: Cannot create automated installer config file '${target_location}': $!\n");
        return 0;
    }

    return 1;
}


#
# The file/directory must exist for this function to work.
#
sub get_short_path_name {
    my $path = shift;
    my $fso = Win32::OLE-&gt;CreateObject('Scripting.FileSystemObject');
    if (Win32::OLE-&gt;LastError) {
        output("Error creating FS object: ".Win32::OLE-&gt;LastError."\n");
    }
    if (-d $path) {
        my $dir = $fso-&gt;GetFolder($path);
        return $dir-&gt;ShortPath;
    } else {
        my $file = $fso-&gt;GetFile($path);
        return $file-&gt;ShortPath;
    }
}

sub touch {
    my $file = shift;

    local *TOUCH;
    if (open(TOUCH,'&gt;&gt;',$file)) {
        close(TOUCH);
        return 1;
    } else {
        output("Cannot open file for append '${file}': $!\n");
        return 0;
    }
}
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\microlab_fs-528.8_3_12\prod\update.pl</FullName>
    <Length>1604</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-03T15:14:49.4487082-05:00</CreationTime>
    <CreationTimeUtc>2017-11-03T20:14:49.4487082Z</CreationTimeUtc>
    <LastWriteTime>2017-11-03T16:00:03.3454728-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-11-03T21:00:03.3454728Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-03T15:14:49.4487082-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-03T20:14:49.4487082Z</LastAccessTimeUtc>
    <Text># Microlab FS-528 v8.3.12
# Package Created Fall 2017
# Packaged by Alex Schrimpf
# Last Updated Fall 2017 by Alex Schrimpf

=pod

Begin-Doc
Modified: 
Name: 
Type:
Description: 
Language: Perl
LastUpdatedBy:
Version:
Doc-Package-Info
Doc-SVN-Repository:
RCSId:
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'microlab_fs-528.8.3.12',
        package_revision =&gt; '',
    );
}

use lib ( '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 'C:\temp' );

use InstallMonkey::Shared;
use Archive::Extract;
use File::Copy;

my $sourceFiles = get_pkg_sourcefiles();

our %INSTALLMONKEY_OPTIONS;

sub install{
    output(": EXTRACTING...\n");
    if(!Archive::Extract-&gt;new(archive=&gt;$sourceFiles.'\MicroLab_528-8.3.12.zip')-&gt;extract(to=&gt;'C:/Program Files (x86)')){
        output(":: FAILED\n");
        return 0;
    }
    output(": DONE\n");
    output(": ADDING START MENU SHORTCUT... \n");
    if(!copy($sourceFiles.'\MicroLab 528-8.3.12.lnk','C:\ProgramData\Microsoft\Windows\Start Menu\Programs')){
        output(":: FAILED\n");
        return 0;
    }
    output(": DONE\n");
    return 1;
}


do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling','virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\microsoft_net_framework.4_5_2\prod\update.pl</FullName>
    <Length>1906</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-09-06T14:01:52.076091-05:00</CreationTime>
    <CreationTimeUtc>2016-09-06T19:01:52.076091Z</CreationTimeUtc>
    <LastWriteTime>2016-09-07T14:28:25.0643317-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-09-07T19:28:25.0643317Z</LastWriteTimeUtc>
    <LastAccessTime>2016-09-06T14:01:52.076091-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-09-06T19:01:52.076091Z</LastAccessTimeUtc>
    <Text># Atom 1.8.0
# Package Created September 6th 2016
# Packaged by Ryan Andrews (For windows 10)
# Last Update ...

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'microsoft_net_framework.4_5_2',
        package_revision =&gt; '20160906T1406',
    );
}

# Add InstallMonkey Library to the path
use lib (
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
my $applogs=get_applogs_dir();
my $programfiles = get_arch_programfiles(OSARCH_x64);

#The msi installs Atom installer to the machine, whenever a new user logs in the atom installer kicks in
#The actual software is installed to the user profile
#As of June 2016 this is the only way Atom allows installation to all users on the machine

sub install{
	output("Installing Microsoft .NET Framework 4.5.2\n");
    my $command = run_command("$sourcefilesdir\\net-framework-4.6.2.exe /q /norestart");
    output($command ? "FAILED: $!" : "Done!");
    return $command;
}

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                     'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
	need_reboot =&gt; 0,
	install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\microsoft_surface_pro_3\prod\update.pl</FullName>
    <Length>1129</Length>
    <Extension>.pl</Extension>
    <CreationTime>2015-11-19T16:37:05.7206076-06:00</CreationTime>
    <CreationTimeUtc>2015-11-19T22:37:05.7206076Z</CreationTimeUtc>
    <LastWriteTime>2015-11-19T16:53:29.6066348-06:00</LastWriteTime>
    <LastWriteTimeUtc>2015-11-19T22:53:29.6066348Z</LastWriteTimeUtc>
    <LastAccessTime>2015-11-19T16:37:05.7206076-06:00</LastAccessTime>
    <LastAccessTimeUtc>2015-11-19T22:37:05.7206076Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Package Created 2015-11-19
# Packaged by Dillon Lustick

=begin
Begin-Doc
Modified:
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy:
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc
=cut
  
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'microsoft_surface_pro_3.1',
        package_revision =&gt; '20151119T1500',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

do_install( 
    allowed_versions =&gt; [ OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_XP_32 ],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['desktop', 'traveling', 'virtual-desktop', 'clc', 'virtual-clc'],
    exit_on_failure =&gt; 0,
    msi_name =&gt; "SurfacePro3_Win10_151026_1.msi",
    msi_ignore_exit_codes =&gt; [ 3010 ],
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\microsoft_surface_pro_4\prod\update.pl</FullName>
    <Length>1129</Length>
    <Extension>.pl</Extension>
    <CreationTime>2015-12-08T13:57:01.68668-06:00</CreationTime>
    <CreationTimeUtc>2015-12-08T19:57:01.68668Z</CreationTimeUtc>
    <LastWriteTime>2015-12-08T13:59:02.19977-06:00</LastWriteTime>
    <LastWriteTimeUtc>2015-12-08T19:59:02.19977Z</LastWriteTimeUtc>
    <LastAccessTime>2015-12-08T13:57:01.68668-06:00</LastAccessTime>
    <LastAccessTimeUtc>2015-12-08T19:57:01.68668Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Package Created 2015-12-08
# Packaged by Dillon Lustick

=begin
Begin-Doc
Modified:
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy:
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc
=cut
  
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'microsoft_surface_pro_4.1',
        package_revision =&gt; '20151208T1500',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

do_install( 
    allowed_versions =&gt; [ OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_XP_32 ],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['desktop', 'traveling', 'virtual-desktop', 'clc', 'virtual-clc'],
    exit_on_failure =&gt; 0,
    msi_name =&gt; "SurfacePro4_Win10_151203_0.msi",
    msi_ignore_exit_codes =&gt; [ 3010 ],
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\miktex.2_9_6022\Prod\update.pl</FullName>
    <Length>7639</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-08-12T11:41:51.6791637-05:00</CreationTime>
    <CreationTimeUtc>2016-08-12T16:41:51.6791637Z</CreationTimeUtc>
    <LastWriteTime>2016-08-19T10:31:26.3256613-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-08-19T15:31:26.3256613Z</LastWriteTimeUtc>
    <LastAccessTime>2016-08-16T13:01:02.8278839-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-08-16T18:01:02.8278839Z</LastAccessTimeUtc>
    <Text># Package Created August 2016
# Packaged by Todd Hartman
# Last Updated August 2016 by Ben Krueger

=pod

Begin-Doc
Modified: $Date: 2011-07-18 06:16:21 -0500 (Mon, 18 Jul 2011) $
Name: MiKTeX 2.9 Installer
Type: script
Description: Install and configure MiKTeX 2.9.
Language: Perl
LastUpdatedBy: $Author: thartman $
Version: $Revision: 765 $
Doc-Package-Info: https://wiki.mst.edu/deskinst/change/applications/testing/miktex.2_9
Doc-SVN-Repository: $URL: https://svn.mst.edu/project/itwindist/trunk/win7/appdist/miktex.2_9/prod/update.pl $
RCSId: $Id: update.pl 765 2011-07-18 11:16:21Z thartman $
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'miktex.2_9_6022',
        package_revision =&gt; '20160811T1348',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

use File::Spec;
use File::Path;
use File::Basename;

use Getopt::Long;

# The repository path will likely need to be updated manually. I have
# been relatively unsuccessful at querying the repository
# programmatically.
my ($download_dir,$download_mirror) = ('','http://www.math.washington.edu/tex-archive/systems/win32/miktex/tm/packages/');
my $pkg_dir = 'miktex_2.9_packages';
GetOptions(
    'download=s'    =&gt; \$download_dir,
    'mirror=s'      =&gt; \$download_mirror,
    'package-dir=s' =&gt; \$pkg_dir,
);

########################################################################
# BEGIN Configuration

#my $srcfiles = get_pkg_sourcefiles();
#my $setup_exe = build_path($srcfiles,'basic-miktex-2.9.6022.exe');
#for appdist install
my $srcfiles = "\\\\minerfiles.mst.edu\\dfs\\Software\\itwindist\\appdeploy\\miktex.2_9_6022\\Prod\\data";
my $setup_exe = "basic-miktex-2.9.6022.exe";
my $install_directory = $ENV{'SystemDrive'}.'\\miktex';

my @setup_flags = (
    '--common-install="'.$install_directory.'"',
    '--install-from-local-repository',
    '--local-package-repository="'.build_path($srcfiles,$pkg_dir).'"',
    '--package=complete',
    '--shared',
    '--unattended',

    '--paper-size=Letter', # We're in America, not Europe.
    '--auto-install=yes', # This seems like a feature people would prefer.
       # If users need packages that aren't installed system-wide, they
       # will get installed in the user profile: %AppData%\MiKTeX\2.9\
);

# Regex matching the install log.
my $install_log_dir = $install_directory.'\\miktex\\config';
my $install_log_re = qr/setup-\d+-\d+-\d+-\d+-\d+\.log/;

# END Configuration
########################################################################



if ($download_dir) {
    exit(!download_packages());
}


do_install(
    allowed_versions =&gt; [ OSVER_XP_32,
                          OSVER_VISTA_SP1, OSVER_VISTA_SP2,
                          OSVER_WIN7_SP0, OSVER_WIN7_SP1,
    ],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs =&gt; [ 'desktop', 'clc', 'traveling',
                      'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    no_source_files =&gt; 1,
    install_sub =&gt; \&amp;install,
);
IM_Exit(EXIT_SUCCESS);

# Begin-Doc
################################
# Name: install()
# Description: Invoke the vendor-supplied installer and copy the
#   install log to the default location.
################################
# End-Doc
sub install {
    my $cmd = "\"${srcfiles}\\${setup_exe}\" ".
        join(' ',@setup_flags);

    output("   Running MiKTeX installer...\n");
    my $outcome = 1;
    if (!run_command($cmd)) {
        $outcome = 0;
    }
    copy_miktex_log();

    return $outcome;
}



########################################################################

# Begin-Doc
################################
# Name: copy_miktex_log()
# Description: Copy the default (and unchangeable) install log to AppLogs.
#   Because the log file has an embedded timestamp, we have to be a little
#   intelligent about locating it. Otherwise, this would amount to a simple
#   copy command.
# Returns: true/false on success/failure
# LastUpdated: 2011-07-14
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub copy_miktex_log {
    output("   Copying install log to default log directory...\n");
    # Find the MiKTeX install log and copy it to the applogs dir.
    my $DIR;
    if (!opendir($DIR,$install_log_dir)) {
	output("Cannot open MiKTeX config directory '${install_log_dir}': $!\n");
	return 1; # This isn't really a fatal error.
    }
    my @logs = ();
    while (my $entry = readdir($DIR)) {
	if ($entry =~ /$install_log_re/) {
	    push(@logs,$entry);
	}
    }
    closedir($DIR);

    my $latest_log = $install_log_dir.'\\'.(sort { $b cmp $a } @logs)[0];
    output("     ${latest_log}\n");
    my $cmd = "COPY /Y \"${latest_log}\" \"".get_default_app_log()."\"";
    run_command($cmd,
		'Description' =&gt; "Copying install log to default log directory."
	);

    return 1;
}


# Begin-Doc
################################
# Name: download_packages()
# Description: Download the *TeX packages.
#   Updating the app package usually means downloading the latest *TeX packages.
#   Have the installer download them to the specified directory.
# Returns: true/false on success/failure
# LastUpdated: 2011-07-14
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub download_packages {
    (mkpath($download_dir)
     or die("Error creating target dir for package download: $!"))
        if (! -d $download_dir);

    my $readme = build_path($download_dir,'MST_README.TXT');
    my $README;
    if (open($README,'&gt;',$readme)) {
        print $README
            "Package download started on ".ISO_timestamp()."\n",
            "  From Mirror: ${download_mirror}\n\n";
    } else {
        output("Error opening download-readme for writing (${readme}): $!\n");
    }

    output("Downloading MiKTeK 2.9 packages...\n  via ${download_mirror}\n");
    my $dl_command =
        join(' ',
             basename($setup_exe),
             '--unattended',
             '--download-only',
             '--package-set=complete',
             '--local-package-repository="'.$download_dir.'"',
             '--remote-package-repository="'.$download_mirror.'"',
        );

    my $outcome =
        run_command($dl_command,
                    'Description' =&gt; 'downloading MiKTeX packages');

    print $README
        "  Finished ".($outcome?'successfully':'UNSUCCESSFULLY').
        "at ".ISO_timestamp()."\n",
    close($README);

    return $outcome;
}

########################################################################

__END__

Usage: setupwiz [OPTIONS]

Options:

  --allow-unattended-reboot
  --auto-install=yes
  --auto-install=no
  --auto-install=ask
  --common-config=DIR
  --common-data=DIR
  --common-install=DIR
  --common-roots=DIRS
  --download-only
  --dry-run
  --help
  --install-from-local-repository
  --local-package-repository=DIR
  --no-additional-roots
  --no-registry
  --package-set=SET
  --paper-size=A4
  --paper-size=Letter
  --portable
  --private
  --program-folder=NAME
  --remote-package-repository=URL
  --shared
  --unattended
  --user-config=DIR
  --user-data=DIR
  --user-install=DIR
  --user-roots=DIRS

setupwiz reads its arguments from setupwiz.opt, if such a file exists.
See the MiKTeX Manual for more information.
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\minesight.2017_r7\prod\update.pl</FullName>
    <Length>5293</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-15T15:12:00.7709865-06:00</CreationTime>
    <CreationTimeUtc>2017-11-15T21:12:00.7709865Z</CreationTimeUtc>
    <LastWriteTime>2017-11-17T16:22:37.2430336-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-11-17T22:22:37.2430336Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-15T15:12:00.7709865-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-15T21:12:00.7709865Z</LastAccessTimeUtc>
    <Text># Package created 11/14/2017
# Package created by Sergey Gruzdev
# Last Updated 11/14/2017 by Sergey Gruzdev

=pod

Begin-Doc
Modified: $Date$
Name: $Name$
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'minesight.2017_r7',
        package_revision =&gt; '20171311T1635',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $src = get_pkg_sourcefiles()."\\components";

sub install
{
  # Install minesight component by component (12 of em)
  # Set up some common aspects for all the components
  my $args = "/shortcutPath=\"MineSight\" /shellContext=\"ALL\" /S /D=C:\\MineSight";
  
  #01) MSLUA
  print "Installing 01/12: MSLUA\n";
  print "~~~~~~~~~~~~~~~~~~~~~~~\n";
  if(!run_command("$src\\MSLUA-1-5-0[b1381].exe $args"))
  {
    print "!!!Component MSLUA FAILED!!!!\n\n";
	return 0;
  }
  print "~~~~~~~~Complete~~~~~~~\n\n";
  
  #02) MS3D (MineSight3D)
  print "Installing 02/12: MS3D\n";
  print "~~~~~~~~~~~~~~~~~~~~~~\n";
  if(!run_command("$src\\MS3D-11-60-Minimal-x64[r72185-b248].exe $args"))
  {
    print "!!!Component MS3D FAILED!!!!\n\n";
	return 0;
  }
  print "~~~~~~~Complete~~~~~~~\n\n";
  
  #03) Atlas
  print "Installing 03/12: Atlas\n";
  print "~~~~~~~~~~~~~~~~~~~~~~~\n";
  if(!run_command("$src\\Atlas_with_Planner-3-5-AnyCPU[r39259-b6773].exe $args"))
  {
    print "!!!Component Atlas FAILED!!!!\n\n";
	return 0;
  }
  print "~~~~~~~~Complete~~~~~~~\n\n";
  
  #04) HxMBlast (Hexagon Mining Blast)
  print "Installing 04/12: HxMBlast\n";
  print "~~~~~~~~~~~~~~~~~~~~~~~~~~\n";
  if(!run_command("$src\\HxMBlast-2-70-x64[r39276-b11418].exe $args"))
  {
    print "!!!Component HxMBlast FAILED!!!!\n\n";
	return 0;
  }
  print "~~~~~~~~~Complete~~~~~~~~~\n\n";
  
  #05) MSBasis (MineSight Basis)
  print "Installing 05/12: MSBasis\n";
  print "~~~~~~~~~~~~~~~~~~~~~~~~~\n";
  if(!run_command("$src\\MSBasis-17-0-Minimal-x64[r8817-b1232].exe $args"))
  {
    print "!!!Component MSBasis FAILED!!!!\n\n";
	return 0;
  }
  print "~~~~~~~~~Complete~~~~~~~~\n\n";
  
  #06) MSDA (MineSight Data Analyst)
  print "Installing 06/12: MSDA\n";
  print "~~~~~~~~~~~~~~~~~~~~~~\n";
  if(!run_command("$src\\msda-3-30-5-Minimal-x64[r12885-b2202].exe $args"))
  {
    print "!!!Component MSDA FAILED!!!!\n\n";
	return 0;
  }
  print "~~~~~~~Complete~~~~~~~\n\n";
  
  #07) MSEP (MineSight Economic Planner)
  print "Installing 07/12: MSEP\n";
  print "~~~~~~~~~~~~~~~~~~~~~~\n";
  if(!run_command("$src\\msep-4-0-5-minimal-x64[r1997-b568].exe /shortcutPath=\"MineSight\" /shellContext=\"All\" /S /medexePath=C:\MineSight /metlibPath=C:\MineSight\METLIB"))
  {
    print "!!!Component MSEP FAILED!!!!\n\n";
	return 0;
  }
  print "~~~~~~~Complete~~~~~~~\n\n";
  
  #08) MSSO (MineSight Schedule Optimizer)
  print "Installing 08/12: MSSO\n";
  print "~~~~~~~~~~~~~~~~~~~~~~\n";
  if(!run_command("$src\\MSSO-9-60-5-Minimal-x64[r14925-b9574].exe $args"))
  {
    print "!!!Component MSSO FAILED!!!!\n\n";
	return 0;
  }
  print "~~~~~~~Complete~~~~~~~\n\n";
  
  #09) MSSP (MineSight Strategic Planner)
  print "Installing 09/12: MSSP\n";
  print "~~~~~~~~~~~~~~~~~~~~~~\n";
  if(!run_command("$src\\mssp-3-70-3-Minimal-x64[r1512-b466].exe $args"))
  {
    print "!!!Component MSSP FAILED!!!!\n\n";
	return 0;
  }
  print "~~~~~~~Complete~~~~~~~\n\n";
  
  #10) MSTorque (MineSight Torque)
  print "Installing 10/12: MSTorque\n";
  print "~~~~~~~~~~~~~~~~~~~~~~~~~~\n";
  if(!run_command("$src\\MSTorque-5-20-x64[r12372-b5465].exe $args"))
  {
    print "!!!Component MSTorque FAILED!!!!\n\n";
	return 0;
  }
  print "~~~~~~~~~Complete~~~~~~~~~\n\n";
  
  #11) MSTools (MineSight Tools)
  print "Installing 11/12: MSTools\n";
  print "~~~~~~~~~~~~~~~~~~~~~~~~~\n";
  if(!run_command("$src\\MSTOOLS-1-50-04-Minimal[b422].exe $args"))
  {
    print "!!!Component MSTools FAILED!!!!\n\n";
	return 0;
  }
  print "~~~~~~~~Complete~~~~~~~~~\n\n";
  
  #12) MSRE (MineSight Runtime Environment)
  print "Installing 12/12: MSRE\n";
  print "~~~~~~~~~~~~~~~~~~~~~~\n";
  if(!run_command("$src\\MRE-1-11-9-x64[r570-b65].exe $args"))
  {
    print "!!!Component MSRE FAILED!!!!\n\n";
	return 0;
  }
  print "~~~~~~~Complete~~~~~~~\n\n";
  
  
  # Set license env var
  print "Setting License Variable\n";
  print "~~~~~~~~~~~~~~~~~~~~~~~~\n";
  if(!run_command("setx MINTEC_LICENSE \"5053\@minesight-01.licsrv.mst.edu\" /M"))
  {
    print "!!!FAILED!!!!\n\n";
	return 0;
  }
  print "~~~~~~~~Complete~~~~~~~~\n\n";
  print "Installation complete!\n";
  return 1;
}

do_install
(
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  install_sub =&gt;\&amp;install,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\minitab.18_1\prod\update.pl</FullName>
    <Length>2546</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-07-25T10:12:19.9570681-05:00</CreationTime>
    <CreationTimeUtc>2017-07-25T15:12:19.9570681Z</CreationTimeUtc>
    <LastWriteTime>2017-08-02T13:25:10.7252944-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-08-02T18:25:10.7252944Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-25T10:12:19.9570681-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-25T15:12:19.9570681Z</LastAccessTimeUtc>
    <Text># Minitab 17.3.1
# Package Created May 2016
# Packaged by Ronith
# Last Updated 7/17 for 17.3.1 fix

=pod

Begin-Doc
Modified: $May 13, 2016$
Name: Minitab 17 Package Installer
Type: script
Description: invokes the vendor-supplied installer
Language: Perl
LastUpdatedBy: $Ronith$
Version: $17.3.1$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;
use Getopt::Long;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'minitab.18_1',
		package_revision =&gt; '20170719T1000',
	);
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
my $src = get_pkg_sourcefiles();

sub preinstall {
	output("Installing redistributables... ");
	if(!run_command("$src\\vcredist_x86.exe /quiet /norestart")){
		output("FAILED: $!\n");
		return 0;
	}
	output("OK\n");
	my $minitabdata = "$ENV{'PROGRAMDATA'}\\Minitab";
	output("Creating Directory...	");
	if(-d $minitabdata) {
		#do nothing it's already there
	}
	else {
		if(!run_command("md \"$minitabdata\"")) {
			output("FAILED: $!\n");
			return 0;
		}
	}
	output("OK\nPlacing ProgramData... ");
	#For whatever reason this is necessary for licensing to succeed.
	if(!run_command("xcopy \"$src\\Minitab\" \"$ENV{'PROGRAMDATA'}\\Minitab\" /Y/E/F/I")){
		output("FAILED: $!\n");
		return 0;
	}
	output("OK\n");
	return 1;
}

sub install {
  output("Installation in progress...");
  if(!run_command("$src\\minitab18.1.0.0setup.exe /exenoui /qn /l*v \"C:\\install.log\" ACCEPT_EULA=1 LICENSE_SERVER=minitab.lic.mst.edu LICENSE_SERVER_PORT=1798")){
  		output("FAILED: $!\n");
		return 0;
	}
	output("OK\n");
  return 1;
}

sub postinstall {
	output("Deleting desktop icons...");
	my $desktop = get_allusers_desktop();
	run_command("del /q \"$desktop\\Minitab 18.lnk\"");
}

do_install(
  allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                   'virtual-clc', 'virtual-desktop' ],
  exit_on_failure =&gt; 1,
	preinstall_sub =&gt; \&amp;preinstall,
	install_sub =&gt; \&amp;install,
	postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\mplabx.2_35\prod\update.pl</FullName>
    <Length>3908</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-02-12T13:15:56.823591-06:00</CreationTime>
    <CreationTimeUtc>2016-02-12T19:15:56.823591Z</CreationTimeUtc>
    <LastWriteTime>2016-02-18T13:21:45.1594948-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-02-18T19:21:45.1594948Z</LastWriteTimeUtc>
    <LastAccessTime>2016-02-12T13:15:56.823591-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-02-12T19:15:56.823591Z</LastAccessTimeUtc>
    <Text># MPLAB X IDE - an IDE for PIC microcontrollers
# Package generated with GenGen on 2016-Feb-12 13:15
# Packaged by Grayson Gratop

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
      package_id =&gt; 'mplabx.2_35',
      package_revision =&gt; '20160212T1315',
  );
}

# Add InstallMonkey Library to the path
use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use Getopt::Long;
use InstallMonkey::Shared;

GetOptions(
  'uninstall' =&gt; sub { exit(!uninstall()); },
);

my $srcfilesdir = get_pkg_sourcefiles();
my $allUsersDesktop = get_allusers_desktop();
my $allUsersStartmenu = get_allusers_start_menu();


sub install {
  #thanks, creator of python 2.7 package. second argument is whether or not it's okay if the command fails
  my @installCommands = (
    ["certutil -addstore \"TrustedPublisher\" \"$srcfilesdir\\microchip.cer\"", 0],
    ["\"$srcfilesdir\\xc8-v1.34-full-install-windows-installer.exe\" --unattendedmodeui minimal --mode unattended --netservername \"\" --MCC_INCLUDE 1 --UPDATE_MPLAB 1 --LINK_ASM_LIB 1", 0],
    ["\"$srcfilesdir\\xc16-v1.24-full-install-windows-installer.exe\" --unattendedmodeui minimal --mode unattended --netservername \"\"", 0],
    ["\"$srcfilesdir\\xc32-v1.34-full-install-windows-installer.exe\" --unattendedmodeui minimal --mode unattended --netservername \"\"", 0],
    ["\"$srcfilesdir\\MPLABX-v2.35-windows-installer.exe\" --unattendedmodeui minimal --mode unattended", 0],
  );

  my $success = 0;
  my $allDone = 1;
  
  output("Installing MPLAB X IDE... \n");
  
  for (my $i = 0; $i &lt; scalar @installCommands; $i++) {
    output("\t" . $installCommands[$i][0] . ": ");
    $success = run_command($installCommands[$i][0]);
    output($success ? "Done!\n" : "FAILED: $!\n");
    $allDone &amp;&amp;= $installCommands[$i][1] || $success;
  }

  if ($allDone) {
    output("Looks like it was a success!\n");
  }
  else {
    output("Something went wrong!\n");
  }

  return $allDone;
}


sub postInstall {
  my $iconSuccess = 1;

  #Delete icons in every user's Desktop folder (excluding Default). Thanks, StackOverflow
  opendir(DIR, 'C:\\Users');
  my @users = grep { (!/^\.\.?$/) &amp;&amp; (-d "C:\\Users\\$_") &amp;&amp; ($_ ne 'Default') } readdir(DIR);
  closedir(DIR);

  foreach my $place (@users) {
    run_command("DEL /Q \"C:\\Users\\$place\\Desktop\\MPLAB X IDE v2.35.lnk\"");
    run_command("DEL /Q \"C:\\Users\\$place\\Desktop\\MPLAB IPE v2.35.lnk\"");
    run_command("DEL /Q \"C:\\Users\\$place\\Desktop\\MPLAB driver switcher.lnk\"");
  }

  output("Desktop icons removed.\n");

  my $startMenu = "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\";

  run_command("DEL /Q \"$startMenu\\Microchip\\MPLAB X IDE\\Uninstall MPLAB X IDE v2.35.lnk\"");
  run_command("DEL /Q \"$startMenu\\Microchip\\MPLAB XC8\\Uninstall MPLAB XC8 C Compiler.lnk\"");
  run_command("RMDIR /S /Q \"$startMenu\\Microchip\\MPLAB XC32\"");
  run_command("RMDIR /S /Q \"$startMenu\\MPLAB XC16 C Compiler\"");

  output("Start menu uninstall shortcuts removed.\n");

  return 1;
}


do_install( 
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
  allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postInstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\mplabx.2_35 - Copy\prod\update.pl</FullName>
    <Length>3908</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-08-11T12:44:01.4447286-05:00</CreationTime>
    <CreationTimeUtc>2016-08-11T17:44:01.4447286Z</CreationTimeUtc>
    <LastWriteTime>2016-02-18T13:21:45.1594948-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-02-18T19:21:45.1594948Z</LastWriteTimeUtc>
    <LastAccessTime>2016-08-11T12:44:01.4447286-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-08-11T17:44:01.4447286Z</LastAccessTimeUtc>
    <Text># MPLAB X IDE - an IDE for PIC microcontrollers
# Package generated with GenGen on 2016-Feb-12 13:15
# Packaged by Grayson Gratop

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
      package_id =&gt; 'mplabx.2_35',
      package_revision =&gt; '20160212T1315',
  );
}

# Add InstallMonkey Library to the path
use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use Getopt::Long;
use InstallMonkey::Shared;

GetOptions(
  'uninstall' =&gt; sub { exit(!uninstall()); },
);

my $srcfilesdir = get_pkg_sourcefiles();
my $allUsersDesktop = get_allusers_desktop();
my $allUsersStartmenu = get_allusers_start_menu();


sub install {
  #thanks, creator of python 2.7 package. second argument is whether or not it's okay if the command fails
  my @installCommands = (
    ["certutil -addstore \"TrustedPublisher\" \"$srcfilesdir\\microchip.cer\"", 0],
    ["\"$srcfilesdir\\xc8-v1.34-full-install-windows-installer.exe\" --unattendedmodeui minimal --mode unattended --netservername \"\" --MCC_INCLUDE 1 --UPDATE_MPLAB 1 --LINK_ASM_LIB 1", 0],
    ["\"$srcfilesdir\\xc16-v1.24-full-install-windows-installer.exe\" --unattendedmodeui minimal --mode unattended --netservername \"\"", 0],
    ["\"$srcfilesdir\\xc32-v1.34-full-install-windows-installer.exe\" --unattendedmodeui minimal --mode unattended --netservername \"\"", 0],
    ["\"$srcfilesdir\\MPLABX-v2.35-windows-installer.exe\" --unattendedmodeui minimal --mode unattended", 0],
  );

  my $success = 0;
  my $allDone = 1;
  
  output("Installing MPLAB X IDE... \n");
  
  for (my $i = 0; $i &lt; scalar @installCommands; $i++) {
    output("\t" . $installCommands[$i][0] . ": ");
    $success = run_command($installCommands[$i][0]);
    output($success ? "Done!\n" : "FAILED: $!\n");
    $allDone &amp;&amp;= $installCommands[$i][1] || $success;
  }

  if ($allDone) {
    output("Looks like it was a success!\n");
  }
  else {
    output("Something went wrong!\n");
  }

  return $allDone;
}


sub postInstall {
  my $iconSuccess = 1;

  #Delete icons in every user's Desktop folder (excluding Default). Thanks, StackOverflow
  opendir(DIR, 'C:\\Users');
  my @users = grep { (!/^\.\.?$/) &amp;&amp; (-d "C:\\Users\\$_") &amp;&amp; ($_ ne 'Default') } readdir(DIR);
  closedir(DIR);

  foreach my $place (@users) {
    run_command("DEL /Q \"C:\\Users\\$place\\Desktop\\MPLAB X IDE v2.35.lnk\"");
    run_command("DEL /Q \"C:\\Users\\$place\\Desktop\\MPLAB IPE v2.35.lnk\"");
    run_command("DEL /Q \"C:\\Users\\$place\\Desktop\\MPLAB driver switcher.lnk\"");
  }

  output("Desktop icons removed.\n");

  my $startMenu = "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\";

  run_command("DEL /Q \"$startMenu\\Microchip\\MPLAB X IDE\\Uninstall MPLAB X IDE v2.35.lnk\"");
  run_command("DEL /Q \"$startMenu\\Microchip\\MPLAB XC8\\Uninstall MPLAB XC8 C Compiler.lnk\"");
  run_command("RMDIR /S /Q \"$startMenu\\Microchip\\MPLAB XC32\"");
  run_command("RMDIR /S /Q \"$startMenu\\MPLAB XC16 C Compiler\"");

  output("Start menu uninstall shortcuts removed.\n");

  return 1;
}


do_install( 
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
  allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postInstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\msc_software.2015\prod\update.pl</FullName>
    <Length>1889</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-10-27T15:34:17.9204413-05:00</CreationTime>
    <CreationTimeUtc>2016-10-27T20:34:17.9204413Z</CreationTimeUtc>
    <LastWriteTime>2016-11-08T15:23:10.4404658-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-11-08T21:23:10.4404658Z</LastWriteTimeUtc>
    <LastAccessTime>2016-10-27T15:34:17.9204413-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-10-27T20:34:17.9204413Z</LastAccessTimeUtc>
    <Text># MSC Software 2015
# Original 2012 package Created November 15, 2012
# Packaged by Eric Boyer
# Last Updated August 27, 2015 by Ryan Andrews
# Package updated for 2015 edition by Grayson Gratop, October 24, 2016

=pod

Begin-Doc
Modified: $Date$
Name: MSC Software Suite 2015
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
    # same name as the appdist directory
    package_id =&gt; 'msc_software.2015',

    # some unique id that's updated any time the package undergoes
    #  any sort of minor revision
    package_revision =&gt; '20161024T1615',
  );
}

# Add InstallMonkey Library to the path
use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
sub install
{
  my @subPackages = (
    'Adams 2015.1', 'Nastran 2014.1', 'Easy5 2013', 'Marc 2014.1'
  );

  my $success = 1;

  foreach my $sp (@subPackages) {
    (my $folderName = $sp =~ s/\./_/r) =~ s/\s/\./;
    output("Installing $sp: ");
    $success &amp;&amp;= run_command("perl \"$srcfiles\\$folderName\\update.pl\"");
    output($success ? "Success!\n" : "FAILED: $!\n");
  }

  return $success;
}

do_install(
    allowed_versions =&gt; [ OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-desktop', 'virtual-clc'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\mstenableUAC.1\update.pl</FullName>
    <Length>1859</Length>
    <Extension>.pl</Extension>
    <CreationTime>2015-11-19T14:59:57.9415812-06:00</CreationTime>
    <CreationTimeUtc>2015-11-19T20:59:57.9415812Z</CreationTimeUtc>
    <LastWriteTime>2015-11-23T13:30:14.7341918-06:00</LastWriteTime>
    <LastWriteTimeUtc>2015-11-23T19:30:14.7341918Z</LastWriteTimeUtc>
    <LastAccessTime>2015-11-19T14:59:57.9415812-06:00</LastAccessTime>
    <LastAccessTimeUtc>2015-11-19T20:59:57.9415812Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Package Created 2015-11-19
# Packaged by Dillon Lustick
# Windows store apps won't work if UAC is disabled.

=begin
Begin-Doc
Modified:
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy:
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc
=cut
  
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'mstenableUAC.1',
        package_revision =&gt; '20151119T1500',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;


sub install {
    output("Enabling UAC in registry: ");
    my @keys = ("ConsentPromptBehaviorAdmin", 
                "ConsentPromptBehaviorUser", 
                "PromptOnSecureDesktop");
    my $kloc = 'HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System';
    foreach my $key (@keys) {
        if( !run_command("reg add $kloc /v $key /t REG_DWORD /d 0 /f") ) {
            output("Failed to set key \'$kloc\\$key\': $!\n");
            return 0;
        }
    }
    if( !run_command("reg add $kloc /v EnableLUA /t REG_DWORD /d 1 /f") ) {
        output("Failed to set key \'$kloc\\EnableLUA\': $!\n");
        return 0;
    }
    output("OK\n");
    
    return 1;
}

do_install( 
    allowed_versions =&gt; [ OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_XP_32 ],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['desktop', 'traveling', 'virtual-desktop', 'clc', 'virtual-clc'],
    no_source_files =&gt; 1,
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\mstloginscripts.3_1\update.pl</FullName>
    <Length>6697</Length>
    <Extension>.pl</Extension>
    <CreationTime>2015-11-23T15:19:19.7884094-06:00</CreationTime>
    <CreationTimeUtc>2015-11-23T21:19:19.7884094Z</CreationTimeUtc>
    <LastWriteTime>2015-12-11T12:50:43.4654233-06:00</LastWriteTime>
    <LastWriteTimeUtc>2015-12-11T18:50:43.4654233Z</LastWriteTimeUtc>
    <LastAccessTime>2015-11-23T15:19:19.7884094-06:00</LastAccessTime>
    <LastAccessTimeUtc>2015-11-23T21:19:19.7884094Z</LastAccessTimeUtc>
    <Text>#######################################
# update.pl                           #
#  v3.1                               #
#  Installer for MST Drivemap Scripts #
#   Last Updated 11/23/2015           #
#######################################

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'mstloginscripts.3_1',
        package_revision =&gt; '20151123T0945',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;


sub install {
    my $scriptpath = &amp;cwd();                               #current working directory --&gt; C:\SourceFiles\mstloginscript.3_0         ##This is an installmonkey function (see shared.pm)
   #my $instpath   = &amp;get_inst() . "\\scripts";                # local protected area --&gt; %systemroot%\system32\umrinst\scripts     ##This is an installmonkey function (see shared.pm)
    my $allusers        = $ENV{'ALLUSERSPROFILE'};                                  # --&gt; %programdata%
    my $loginscripts    = $allusers.'\\mst\\standard\\login';                       # --&gt; %programdata%\mst\standard\login
    my $inst            = $ENV{'SystemRoot'} . '\\system32\\umrinst\\scripts';      # --&gt; %systemroot%\system32\umrinst\scripts
    $drivemap_customization = $allusers.'\\mst\\standard\\drivemap_customization';  # --&gt; %programdata%\mst\standard\drivemap_customization
    $systemdrives_custom = "$drivemap_customization\\systemdrives_custom.txt";      # --&gt; %programdata%\mst\standard\drivemap_customization\systemdrives_custom.txt
    $systemdrives_mandatory = "$loginscripts\\systemdrives_mandatory.txt";          # --&gt; %programdata%\mst\standard\login\systemdrives_mandatory.txt
    $systemdrives_old = "$loginscripts\\systemdrives.txt";                          # --&gt; %programdata%\mst\standard\login\systemdrives.txt
    $systemdrives_new = "$drivemap_customization\\systemdrives.txt";                # --&gt; %programdata%\mst\standard\drivemap_customization\systemdrives.txt

    output("  Updating Files...\n");    
    
    # Move systemdrives.txt file to new location and rename to new convention
    run_command("mkdir \"${drivemap_customization}\"",'IgnoreReturnCode'=&gt;1);
    if ( -f $systemdrives_old) {
        run_command("copy /y \"${systemdrives_old}\" \"${drivemap_customization}\"");
    }
    
    # Delete all the old stuff.
    output("  Deleting old files...\n");
    if ( -d "$inst" ) {
        run_command("rmdir /q /s \"${inst}\"",'IgnoreReturnCode'=&gt;1);
    }
    
    run_command("rmdir /s/q \"${loginscripts}\"",'IgnoreReturnCode'=&gt;1);

    # (Re-)Create the directories.
    #  Do the system ones just in case they don't exist.
    run_command("mkdir \"${allusers}\"",'IgnoreReturnCode'=&gt;1);
    run_command("mkdir \"${allusers}\\standard\"",'IgnoreReturnCode'=&gt;1);
    run_command("mkdir \"${allusers}\\custom\"",'IgnoreReturnCode'=&gt;1);
    run_command("mkdir \"${loginscripts}\"",'IgnoreReturnCode'=&gt;1);
    run_command("mkdir \"${inst}\"",'IgnoreReturnCode'=&gt;1);

    # Copy the new package files.
    output("  Copying new package files.\n");
    run_command("copy /y \"${scriptpath}\\data\\startup\\*.*\" \"${inst}\"");
    run_command("xcopy /y/e/s \"${scriptpath}\\data\\login\\*.*\" "."\"${loginscripts}\"");
    run_command("copy /y \"${scriptpath}\\data\\root\\*.*\" \"${allusers}\"");

    # Post-process systemdrives_custom.txt here.
    # Strip out any lines that map drives to R, S, W or Y.
    create_systemdrives_custom();

    # Import Win8 Reg Key if Win8
    # Required to let admins see mapped drives in non-elevated shells like Computer and Command Prompt
    if (is_Win8() || is_Win10()) {
        run_command("regedit /s \"${scriptpath}\\enable_linked_connections.reg\"");
    }

    # Cleanup 
    run_command("del /q \"${systemdrives_new}\"",'IgnoreReturnCode'=&gt;1);
    
    # Add registry entries to call login scripts
    # quiet.vbs is used to prevent visible cmd windows at login
    my $regkey = 'HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run';
    run_command('reg add '. $regkey .' /t REG_SZ /v "User Logon Scripts" /d "wscript '.$loginscripts.'\quiet.vbs '.$loginscripts.'\calluserlogin.cmd" /f');
    run_command('reg add '. $regkey .' /t REG_SZ /v "MST Logon Scripts" /d "wscript '.$loginscripts.'\quiet.vbs '.$loginscripts. '\logon.cmd" /f');
    
    
    return 1;
}

sub create_systemdrives_custom {
    
    # Put Standard Mappings into hash
    open( MANDFILE, "&lt;$systemdrives_mandatory" );
    while ($line=&lt;MANDFILE&gt;) {
        if ( $line =~ m/^([a-z]\:)\s+(\\\\.*|[a-z]:\\.*)/i ) {
            $letter = $1;
            $share = $2;
            $letter = uc($letter);
            $share = lc($share);
            $standard_mappings{$letter} = $share;
        }
    }
    close (MANDFILE);
    
    # Create systemdrives_custom.txt if it doesn't exist
    unless (-f "$systemdrives_custom") {
        open( NEWFILE, "&gt;$systemdrives_custom");
        print NEWFILE "\# Systemdrives_mandatory.txt\n";
        print NEWFILE "\# System-wide drivemap customizations go here.\n";
        print NEWFILE "\# Example:\n";
        print NEWFILE "\# Q: \\\\minerfiles.mst.edu\\dfs\\software\n";
        print NEWFILE " \n";
    }
    close (NEWFILE);
    
    # Append any additional non-standard drive mappings from systemdrives.txt if it exists
    if (-f "$systemdrives_new") {
        open( OLDFILE, "&lt;$systemdrives_new" );
        open( NEWFILE, "&gt;&gt;$systemdrives_custom" );
        print NEWFILE " \n";
        while ( $line = &lt;OLDFILE&gt; ) {
            $line = lc($line);
            if ( $line =~ m/^([a-z]\:)\s+(\\\\.*|[a-z]:\\.*)/i ) {
                $letter = $1;
                $letter = uc($letter);
                $share  = $2;
                $share  = lc($share);
                chomp ($letter);
                chomp ($share);
                unless ( exists $standard_mappings{$letter} ){
                    print NEWFILE "$letter $share\n";
                }
            }   
        }
    }    
    close (NEWFILE);
    close (OLDFILE);
}

do_install(
    allowed_versions =&gt; [ OSVER_WIN8_SP0, OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2, 
                          OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN81_SP0, OSVER_XP_32 ],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs     =&gt; [ "clc", "desktop", "traveling",
                          "virtual-clc", "virtual-desktop" ],
    install_sub      =&gt; \&amp;install
);
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\mstsolitaire.1\update.pl</FullName>
    <Length>1437</Length>
    <Extension>.pl</Extension>
    <CreationTime>2015-11-06T14:54:44.2781422-06:00</CreationTime>
    <CreationTimeUtc>2015-11-06T20:54:44.2781422Z</CreationTimeUtc>
    <LastWriteTime>2015-11-13T15:07:51.0205262-06:00</LastWriteTime>
    <LastWriteTimeUtc>2015-11-13T21:07:51.0205262Z</LastWriteTimeUtc>
    <LastAccessTime>2015-11-06T14:54:44.2781422-06:00</LastAccessTime>
    <LastAccessTimeUtc>2015-11-06T20:54:44.2781422Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Package Created 2015-11-06
# Packaged by Dillon Lustick
# Disable solitaire icon in start menu

=begin
Begin-Doc
Modified:
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy:
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc
=cut
  
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'mstsolitaire.1',
        package_revision =&gt; '20151106T1500',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;


sub install {
    # Remove Solitaire
    output("Removing Solitaire: ");
    if(!run_command("powershell.exe -C \"Get-AppxPackage *solitairecollection* | Remove-AppxPackage\"")) {
        output("Failed to remove solitaire: $!\n");
        return 0;
    }
    output("OK\n");
    
    return 1;
}

do_install( 
    allowed_versions =&gt; [ OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_XP_32 ],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['desktop', 'traveling', 'virtual-desktop', 'clc', 'virtual-clc'],
    no_source_files =&gt; 1,
    exit_on_failure =&gt; 0,
    install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update-configmgr.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\mst_admin_tools\update-configmgr.pl</FullName>
    <Length>1454</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-12-16T15:45:53.5447511-06:00</CreationTime>
    <CreationTimeUtc>2016-12-16T21:45:53.5447511Z</CreationTimeUtc>
    <LastWriteTime>2011-05-25T09:59:17.5534009-05:00</LastWriteTime>
    <LastWriteTimeUtc>2011-05-25T14:59:17.5534009Z</LastWriteTimeUtc>
    <LastAccessTime>2016-12-16T15:45:53.5447511-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-12-16T21:45:53.5447511Z</LastAccessTimeUtc>
    <Text># Package Created March 2009
# Packaged by Don Howdeshel
# Last Updated 2011-05-25 by Todd Hartman


BEGIN {
    %INSTALLMONKEY_OPTIONS = (
	package_id =&gt; 'mst_admin_tools.1',
	package_revision =&gt; '20110525T0830',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

use Win32::NetAdmin qw(UsersExist);

sub inst_sub{
	my $allusersstartmenu = $ENV{'ALLUSERSPROFILE'}.
	'\\Microsoft\\Windows\\Start Menu\\Programs';
	output("Copying Start Menu Shortcuts...\n");
	my $srcfiles=get_pkg_sourcefiles();
	if(!run_command("xcopy /Y /E \"$srcfiles\" \"$allusersstartmenu\"",
			'Description' =&gt; 'Copying Shortcuts')){
		return 0;
	}
	output("Setting Folder Permissions...\n");
	if(!run_command("icacls \"$allusersstartmenu\\IT Admin Tools\" /inheritance:r /remove Users /grant Administrators:F /grant SYSTEM:F /T",
			'Description' =&gt; 'Setting Permissions')) {
		return 0;
	}
  
  
	return 1;

}



do_install( 
    allowed_versions =&gt; [
        OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2,
        OSVER_WIN7_SP0, OSVER_WIN7_SP1,
    ],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                     'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;inst_sub,
);
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update-configmgrOLD.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\mst_admin_tools\update-configmgrOLD.pl</FullName>
    <Length>4647</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-12-16T15:45:53.5603514-06:00</CreationTime>
    <CreationTimeUtc>2016-12-16T21:45:53.5603514Z</CreationTimeUtc>
    <LastWriteTime>2010-02-22T10:32:26.2112378-06:00</LastWriteTime>
    <LastWriteTimeUtc>2010-02-22T16:32:26.2112378Z</LastWriteTimeUtc>
    <LastAccessTime>2016-12-16T15:45:53.5603514-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-12-16T21:45:53.5603514Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Package Created March 2009
# Packaged by ...
# Last Updated ...

#
# $Revision: 1.2 $
# $Date: 2009-02-10 20:12:24 $
#

# Global InstallMonkey options that must be specified before you load the
#   module.
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
	package_id =&gt; 'mst_admin_tools.1',

	# some unique id that's updated any time the package undergoes
	#  any sort of minor revision
	package_revision =&gt; '20090301T1500',

#         # if different from default location
#         output_log =&gt; 'path_to_output_log',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

# Be sure that any custom install subs (install_sub, preinstall_sub, or 
# postinstall_sub) return a success/failure value.
# If you don't do any error checking, at least return 1 so that the
# install will continue. The installer aborts (nicely) on failure.
#
# sub install {
#   ...
#
#   return 1;
# }

# You may want to use Getopt::Long to parse command-line flags.
# use Getopt::Long;
# $test = $license = $port = 0;
# @hosts = ();
# GetOptions(
#   'test' =&gt; \$test,
#   'license=s' =&gt; \$license,
#   'port=i' =&gt; \$port,
#   'hostname=s' =&gt; \@hosts,
# );

# Use run_command() instead of system() unless you really, really, REALLY
#   don't want to leave any trace of what you're doing. run_command() sends
#   lots of helpful information to the output log so that you don't have to
#   rerun the script with other options to see a reasonable amount of output.
# DIFFERENCE: run_command() returns a boolean value (true: success) whereas
#   system() returned the exit code (and signal) of the command.
#   If you used this:
#     $rc = system($command);
#     if ($rc) {
#        print("ERROR: $rc\n");
#     }
#   Consider using something like this instead:
#     if (run_command($command)) {
#        output("ERROR running command.\n");
#     }
#   For more verbose checking, consider using the 'ReturnCommandInfo'
#     option. See the InstallMonkey source code for more examples.

# If msi name cannot be "installer.msi" then add this line to do_install:
# msi_name =&gt; "foo_bar.msi",

sub inst_sub{
	my $allusersstartmenu = $ENV{'ALLUSERSPROFILE'}.
	'\\Microsoft\\Windows\\Start Menu\\Programs';
	output("Copying Start Menu Shortcuts...\n");
	my $srcfiles=get_pkg_sourcefiles();
	if(!run_command("xcopy /Y /E \"$srcfiles\" \"$allusersstartmenu\"",
			'Description' =&gt; 'Copying Shortcuts')){
		return 0;
	}
	output("Setting Folder Permissions...\n");
	if(!run_command("icacls \"$allusersstartmenu\\IT Admin Tools\" /inheritance:r /remove Users /grant Administrators:F /grant SYSTEM:F /T",
			'Description' =&gt; 'Setting Permissions')) {
		return 0;
	}
	return 1;

}



# Only add these as we plan to test them.
# allowed_versions:
#  OSVER_XP_32,  OSVER_VISTA_SP0,  OSVER_VISTA_SP1
# allowed_os_architectures:
#  OSARCH_x86,  OSARCH_x64
# allowed_regs:
#  'clc', 'desktop', 'traveling'
if (do_install( 
	allowed_versions =&gt; [OSVER_VISTA_SP0,  OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0],
	allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
	allowed_regs =&gt; ['clc', 'desktop', 'traveling'],
#        prerequisite_sub =&gt; \&amp;prereq_sub,
#        prerequisite_sub_x86 =&gt; \&amp;prereq86_sub,
#        prerequisite_sub_x64 =&gt; \&amp;prereq64_sub,
#        preinstall_sub =&gt; \&amp;preinst_sub,
#        preinstall_sub_x86 =&gt; \&amp;preinst86_sub,
#        preinstall_sub_x64 =&gt; \&amp;preinst64_sub,
  install_sub =&gt; \&amp;inst_sub,
#        install_sub_x86 =&gt; \&amp;inst86_sub,
#        install_sub_x64 =&gt; \&amp;inst64_sub,
#        postinstall_sub =&gt; \&amp;postinst_sub,
#        postinstall_sub_x86 =&gt; \&amp;postinst86_sub,
#        postinstall_sub_x64 =&gt; \&amp;postinst64_sub,
#        msi_name =&gt; 'installer.msi',
#        msi_name_x86 =&gt; 'installer64.msi',
#        msi_name_x64 =&gt; 'installer86.msi',
#        additional_msi_properties =&gt; 'REBOOT="ReallySuppress"',
#        additional_msi_properties_x86 =&gt; 'REBOOT="ReallySuppress"',
#        additional_msi_properties_x64 =&gt; 'REBOOT="ReallySuppress"',
)) {
    IM_Exit(EXIT_SUCCESS);
} else {
    # If you need to abort the install outside of do_install(), please
    #   use IM_Exit() and return an appropriate (shell) error code.
    #   0                =&gt; success
    #   1 (any non-zero) =&gt; failure
    # IM has a few predefined exit codes, EXIT_*
    IM_Exit(EXIT_FAILURE,"The install failed.\n");
}
</Text>
  </Script>
  <Script>
    <Name>update-SP1_Migration-20110609T064615.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\mst_admin_tools\update-SP1_Migration-20110609T064615.pl</FullName>
    <Length>2147</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-12-16T15:45:53.5603514-06:00</CreationTime>
    <CreationTimeUtc>2016-12-16T21:45:53.5603514Z</CreationTimeUtc>
    <LastWriteTime>2011-05-04T11:26:44.612434-05:00</LastWriteTime>
    <LastWriteTimeUtc>2011-05-04T16:26:44.612434Z</LastWriteTimeUtc>
    <LastAccessTime>2016-12-16T15:45:53.5603514-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-12-16T21:45:53.5603514Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Package Created March 2009
# Packaged by ...
# Last Updated Feb 15 by Eric Boyer - Gave ccadmin read permissions

#
# $Revision: 1.2 $
# $Date: 2009-02-10 20:12:24 $
#

# Global InstallMonkey options that must be specified before you load the
#   module.
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
	package_id =&gt; 'mst_admin_tools.1',

	# some unique id that's updated any time the package undergoes
	#  any sort of minor revision
	package_revision =&gt; '20090301T1500',

#         # if different from default location
#         output_log =&gt; 'path_to_output_log',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

sub inst_sub{
    my $src_folder = build_path(get_pkg_sourcefiles(),'IT Admin Tools');
    my $tools_folder = build_path(get_allusers_start_menu(),'Programs',
                                  'IT Admin Tools');

    output("Copying Start Menu Shortcuts...\n");
    # Remove it if it exists.
    run_command("rmdir /s /q \"${tools_folder}\"") if (-d $tools_folder);
    if(!run_command("move /y \"${src_folder}\" \"${tools_folder}\"",
                    'Description' =&gt; 'Copying Shortcuts')){
        return 0;
    }
    output("Setting Folder Permissions...\n");
    if(!run_command('icacls "'.$tools_folder.'" '.
                    '/inheritance:r '.
                    '/grant SYSTEM:(OI)(CI)(F) '.
                    '/grant cc-installer@mst.edu:(OI)(CI)(F) '.
                    '/grant '.$ENV{COMPUTERNAME}.'\ccadmin:(OI)(CI)(RX)',
                    'Description' =&gt; 'Setting Permissions')) {
        return 0;
    }
  
    return 1;
}

do_install( 
	allowed_versions =&gt; [OSVER_WIN7_SP0],
	allowed_os_architectures =&gt; [OSARCH_x64],
	allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                         'virtual-clc', 'virtual-desktop', ],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;inst_sub,
);

IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\mst_admin_tools\update.pl</FullName>
    <Length>2222</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-12-16T15:45:53.5759517-06:00</CreationTime>
    <CreationTimeUtc>2016-12-16T21:45:53.5759517Z</CreationTimeUtc>
    <LastWriteTime>2016-12-20T13:12:17.0781187-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-12-20T19:12:17.0781187Z</LastWriteTimeUtc>
    <LastAccessTime>2016-12-16T15:45:53.5759517-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-12-16T21:45:53.5759517Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Package Created March 2009
# Packaged by ...
# Last Updated Feb 15 by Eric Boyer - Gave ccadmin read permissions

#
# $Revision: 1.2 $
# $Date: 2009-02-10 20:12:24 $
#

# Global InstallMonkey options that must be specified before you load the
#   module.
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
	package_id =&gt; 'mst_admin_tools.1',

	# some unique id that's updated any time the package undergoes
	#  any sort of minor revision
	package_revision =&gt; '20090301T1500',

#         # if different from default location
#         output_log =&gt; 'path_to_output_log',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

sub inst_sub{
    my $src_folder = build_path(get_pkg_sourcefiles(),'IT Admin Tools');
    my $tools_folder = build_path(get_allusers_start_menu(),'Programs',
                                  'IT Admin Tools');

    output("Copying Start Menu Shortcuts...\n");
    # Remove it if it exists.
    run_command("rmdir /s /q \"${tools_folder}\"") if (-d $tools_folder);
    if(!run_command("move /y \"${src_folder}\" \"${tools_folder}\"",
                    'Description' =&gt; 'Copying Shortcuts')){
        return 0;
    }
    
    #output("Setting Folder Permissions...\n");
    #if(!run_command('icacls "'.$tools_folder.'" '.
    #                '/inheritance:r '.
    #                '/grant SYSTEM:(OI)(CI)(F) '.
    #                '/grant cc-installer@mst.edu:(OI)(CI)(F) '.
    #                '/grant '.$ENV{COMPUTERNAME}.'\ccadmin:(OI)(CI)(RX)',
    #                'Description' =&gt; 'Setting Permissions')) {
    #    return 0;
    #}
  
    return 1;
}

do_install( 
	allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN8_SP0,OSVER_WIN10_SP0],
	allowed_os_architectures =&gt; [OSARCH_x64,OSARCH_x86],
	allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                         'virtual-clc', 'virtual-desktop', ],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;inst_sub,
);

IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>updateOLD.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\mst_admin_tools\updateOLD.pl</FullName>
    <Length>1718</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-12-16T15:45:53.6071523-06:00</CreationTime>
    <CreationTimeUtc>2016-12-16T21:45:53.6071523Z</CreationTimeUtc>
    <LastWriteTime>2011-01-24T14:41:32.8017712-06:00</LastWriteTime>
    <LastWriteTimeUtc>2011-01-24T20:41:32.8017712Z</LastWriteTimeUtc>
    <LastAccessTime>2016-12-16T15:45:53.6071523-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-12-16T21:45:53.6071523Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Package Created March 2009
# Packaged by ...
# Last Updated ...

#
# $Revision: 1.2 $
# $Date: 2009-02-10 20:12:24 $
#

# Global InstallMonkey options that must be specified before you load the
#   module.
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
	package_id =&gt; 'mst_admin_tools.1',

	# some unique id that's updated any time the package undergoes
	#  any sort of minor revision
	package_revision =&gt; '20090301T1500',

#         # if different from default location
#         output_log =&gt; 'path_to_output_log',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

sub inst_sub{
	my $allusersstartmenu = $ENV{'ALLUSERSPROFILE'}.'\\Microsoft\\Windows\\Start Menu\\Programs';
	output("Copying Start Menu Shortcuts...\n");
	if(!run_command('move /y "'.get_pkg_sourcefiles().'\\IT Admin Tools" "'.$allusersstartmenu.'"',
			'Description' =&gt; 'Copying Shortcuts')){
		return 0;
	}
	output("Setting Folder Permissions...\n");
	if(!run_command('icacls "'.$allusersstartmenu.'\\IT Admin Tools" /inheritance:r /remove Users /remove Administrators /grant cc-installer:(OI)(CI)(F)',
			'Description' =&gt; 'Setting Permissions')) {
		return 0;
	}
	return 1;
}

do_install( 
	allowed_versions =&gt; [OSVER_WIN7_SP0],
	allowed_os_architectures =&gt; [OSARCH_x64],
	allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                         'virtual-clc', 'virtual-desktop', ],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;inst_sub,
);

IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\msys.2_20160205\prod\update.pl</FullName>
    <Length>1369</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-07-14T16:10:35.7155318-05:00</CreationTime>
    <CreationTimeUtc>2016-07-14T21:10:35.7155318Z</CreationTimeUtc>
    <LastWriteTime>2016-07-14T16:17:20.5745174-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-07-14T21:17:20.5745174Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-14T16:10:35.7155318-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-14T21:10:35.7155318Z</LastAccessTimeUtc>
    <Text># MSYS2 20160205 7/14/16
# Daniel T. Holtzclaw

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'msys.2_20160205',
        package_revision =&gt; '20160714T1441',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $src = get_pkg_sourcefiles();
my $command = "$src\\msys2-x86_64-20160205.exe --script $src\\auto.qs --platform minimal";

sub install {
  output("\nMSYS2 20160205:\n Command: $command\n Result: ");
  if(!run_command($command))
  {
    output("Failed: $!\n\n");
    return 0;
  }
  output("Succeeded\n\n");
  return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\netbeans.8_2\prod\update.pl</FullName>
    <Length>2421</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-11-28T11:10:21.8323031-06:00</CreationTime>
    <CreationTimeUtc>2016-11-28T17:10:21.8323031Z</CreationTimeUtc>
    <LastWriteTime>2016-11-28T11:19:38.3765731-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-11-28T17:19:38.3765731Z</LastWriteTimeUtc>
    <LastAccessTime>2016-11-28T11:10:21.8323031-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-11-28T17:10:21.8323031Z</LastAccessTimeUtc>
    <Text># Netbeans 8.2
# Package Created 2016-11-28
# Packaged by Dzu Pham
# Last Updated

=pod

Begin-Doc
Modified: $Date$
Name: $Name$
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'netbeans.8_2',
    package_revision =&gt; '20161128T1111',
  );
}


use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use InstallMonkey::Shared;
use Win32::TieRegistry;
use Getopt::Long;

GetOptions(
  'uninstall' =&gt; sub { exit(!uninstall()); },
);

my $srcfiles = get_pkg_sourcefiles();

# The installer does not include JDK by default and it will fail if it is not installed.
sub prereq {
  $Registry-&gt;Delimiter("/");
  my $key = $Registry-&gt;{"LMachine/Software/Wow6432Node/Javasoft/Java Development Kit/"};
  if($key) {
    output("\nJDK found!\n");
  }
  else {
    output("\nJDK not found!\nPlease install a Java Development Kit before continuing.\n\n");
    return 0;
  }
  
  return 1;
}

sub install {
  output("\nInstalling Netbeans IDE 8.2: ");
  if(!run_command("$srcfiles\\netbeans-8.2-windows.exe --silent")) {
    output("FAILURE\n");
    return 0;
  } else {
    output("SUCCESS\n");
  }

  return 1;
}

sub post {
  my $allusers_desktop = get_allusers_desktop();

  run_command("del /q \"$allusers_desktop\\NetBeans IDE 8.2.lnk\"");

  return 1;
}

sub uninstall {
  output("Uninstalling Netbeans 8.2... ");

  my $installdir = "C:\\Program Files\\NetBeans 8.2";
  my $success = run_command("\"$installdir\\uninstall.exe\" --silent");

  if ($success) {
    output("Success!\n");

    run_command("rmdir /s /q $installdir");
    delete_product_registry_key(get_package_name().".".get_version());
  }
  else {
    output("FAILED!\n");
  }

  return $success;
}

do_install( 
  allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [ OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  prerequisite_sub =&gt; \&amp;prereq,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;post,
    
);


IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\nodejs.10_1_0\prod\update.pl</FullName>
    <Length>1494</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-10T11:03:30.2676151-05:00</CreationTime>
    <CreationTimeUtc>2018-05-10T16:03:30.2676151Z</CreationTimeUtc>
    <LastWriteTime>2018-05-10T11:05:48.37103-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-10T16:05:48.37103Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-10T11:03:30.2676151-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-10T16:03:30.2676151Z</LastAccessTimeUtc>
    <Text># NodeJS	10.1.0
# Package created by Cameron Loren
# Package created 5/10/2018
# Package last edited 5/10/2018 by Cameron Loren

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'nodejs.10_1_0',
		package_revision =&gt; '20180510T1104',
	);
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

my $src = get_pkg_sourcefiles();
my $dest = "C:\\EES32";

GetOptions('uninstall' =&gt; sub{exit(uninstall())});

sub uninstall
{
  print "Uninstalling NodeJS 6.10.3...\n";
  if(!install_msi(app_id =&gt; "$src\\node-v6.10.3-x64.msi", msi_action_flag =&gt; 'x'))
  {
    print "Error uninstalling NodeJS: failed!\n";
	return 0;
  }

  delete_product_registry_key(get_package_name().".".get_version());

  print "Uninstalled NodeJS succesfully!\n";
  return 1;
}

do_install
(
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  msi_name =&gt; "node-v10.1.0-x64.msi",
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\nodejs.6_10_3\prod\update.pl</FullName>
    <Length>1501</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-22T09:10:55.0165262-05:00</CreationTime>
    <CreationTimeUtc>2017-06-22T14:10:55.0165262Z</CreationTimeUtc>
    <LastWriteTime>2017-06-22T09:06:02.3749756-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-22T14:06:02.3749756Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-22T09:10:55.0165262-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-22T14:10:55.0165262Z</LastAccessTimeUtc>
    <Text># NodeJS 6.10.3
# Package created by Sergey Gruzdev
# Package created 6/22/2017
# Package last edited 6/22/2017 by Sergey Gruzdev

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'nodejs.6_10_3',
		package_revision =&gt; '20170622T0901',
	);
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

my $src = get_pkg_sourcefiles();
my $dest = "C:\\EES32";

GetOptions('uninstall' =&gt; sub{exit(uninstall())});

sub uninstall
{
  print "Uninstalling NodeJS 6.10.3...\n";
  if(!install_msi(app_id =&gt; "$src\\node-v6.10.3-x64.msi", msi_action_flag =&gt; 'x'))
  {
    print "Error uninstalling NodeJS: failed!\n";
	return 0;
  }
  
  delete_product_registry_key(get_package_name().".".get_version());
  
  print "Uninstalled NodeJS succesfully!\n";
  return 1;
}

do_install
(
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  msi_name =&gt; "node-v6.10.3-x64.msi",
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\nodejs.6_9_1\prod\update.pl</FullName>
    <Length>1235</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-12-01T10:05:05.5319659-06:00</CreationTime>
    <CreationTimeUtc>2016-12-01T16:05:05.5319659Z</CreationTimeUtc>
    <LastWriteTime>2017-01-03T08:07:40.2840652-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-01-03T14:07:40.2840652Z</LastWriteTimeUtc>
    <LastAccessTime>2016-12-01T10:05:05.5319659-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-12-01T16:05:05.5319659Z</LastAccessTimeUtc>
    <Text>#Node.js 6.9.1
#Package Created July 2016 for 4.4.7
#Packaged by Ben Krueger
#Last Updated 2016-12-01 by Chris Schaaf


use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'node.js_6.9.1',
        package_revision =&gt; '201713T807'
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;
GetOptions('uninstall' =&gt; sub{exit(!uninstall());});
do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN8_SP0,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['virtual-desktop','desktop','clc','virtual-clc','traveling'],
    exit_on_failure =&gt; 1,
    msi_name_x64 =&gt; 'node-v6.9.1-x64.msi',
    msi_name_x86 =&gt; 'node-v6.9.1-x64.msi',
);
IM_Exit(EXIT_SUCCESS);
sub uninstall {
    output("");
    my $outcome = install_msi(app_id =&gt; '{672B5547-D20B-4D19-9BFD-B93C32BC77DA}',msi_action_flag =&gt; 'x');
    output(($outcome?'OK':'Failed')."\n");
    if($outcome)
    {
        delete_product_registry_key(get_package_name().".".get_version());
    }
}</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\notepadpp.7_3_3\prod\update.pl</FullName>
    <Length>1958</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-04-21T13:13:18.8166796-05:00</CreationTime>
    <CreationTimeUtc>2017-04-21T18:13:18.8166796Z</CreationTimeUtc>
    <LastWriteTime>2017-04-21T13:39:08.7220849-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-04-21T18:39:08.7220849Z</LastWriteTimeUtc>
    <LastAccessTime>2017-04-21T13:13:18.8166796-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-04-21T18:13:18.8166796Z</LastAccessTimeUtc>
    <Text># Package Created April 21, 2017 by Austin Wall
# Last Updated: 2017-04-21
# Last Updated by Austin Wall

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'notepad++.7_3_3',
        package_revision =&gt; '20170421T1316',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

my $install_dir = get_arch_programfiles(OSARCH_x64).'\Notepad++';
my $sourcefilesdir = get_pkg_sourcefiles();


GetOptions(
    'uninstall' =&gt; sub { exit(!uninstall()); },
);
####    UNINSTALL   ####
sub uninstall {
    output("Uninstall Notepad++: ");
    
    my $success = run_command("\"$install_dir\\uninstall.exe\" /S");
    
    if($success) {
        delete_product_registry_key(get_package_name() . "." . get_version());
        run_command("rmdir \"$install_dir\" /S /Q");
    }
    
    output($success ? "Success!\n" : "FAILED: $!\n");
    return $success;
}


####    INSTALL ####
sub install {
    my $success;
    
    output("Installing Notepad++ $webVer: ");
    $success = run_command("\"$sourcefilesdir\\npp.7.3.3.Installer.x64.exe\" /S");
    output($success ? "Success!\n\n" : "FAILED: $!\n\n");
    
    output("Disabling auto update: ");
    my $noupdate = run_command("move /y \"$install_dir\\updater\" \"$install_dir\\updater_disabled\"");
    $noupdate &amp;&amp;= run_command("del /q \"$install_dir\\plugins\\PluginManager.dll\"");
    output($noupdate ? "Success!\n" : "FAILED: $!\n");
    
    return $success &amp;&amp; $noupdate;
}


do_install( 
    allowed_versions =&gt; [ OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [ 'clc', 'desktop', 'traveling',
                      'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    no_install_check =&gt; 1,
    install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\notepadpp.7_4_1\prod\update.pl</FullName>
    <Length>1843</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-02T13:51:17.9246902-05:00</CreationTime>
    <CreationTimeUtc>2017-06-02T18:51:17.9246902Z</CreationTimeUtc>
    <LastWriteTime>2017-11-15T16:56:03.2534462-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-11-15T22:56:03.2534462Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-02T13:51:17.9246902-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-02T18:51:17.9246902Z</LastAccessTimeUtc>
    <Text># Notepad++ 7.4.1
# Package Created June 2, 2017
# Packaged by Sergey Gruzdev
# Last updated by Sergey Gruzdev

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut



#use strict;
use warnings

our %INSTALLMONKEY_OPTIONS;
BEGIN {
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'notepadplusplus.7_4_1',
		package_revision =&gt; '20170602T1030',
	);
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

my $src = get_pkg_sourcefiles();
my $dest = "C:\\Program Files (X86)\\EndNote";

GetOptions('uninstall' =&gt; sub{exit(uninstall())});



sub install
{
  print "\nInstalling Notepad++ 7.4.1: ";
  my $command = "\"$src\\npp.7.4.1.Installer.exe\" /S /D=\"$dest\"";
  if(!run_command($command))
  {
    print "FAIL\n";
	return 0;
  }
  else
  {
    print "OK\n";
  }
  return 1;
}

sub uninstall
{
  print "Uinstall Notepad++: ";
  
  # run uninstaller
  my $succes = run_command("\"$dest\\uninstall.exe\" /S");
  # del registry key and install directory
  if($sucess)
  {
    delete_product_registry_key(get_package_name().".".get_version());
	run_command("rmdir \"$dest\" /S /Q");
  }
  
  $sucess ? print "Success\n" : print "FAILED: $!\n";
  return $sucess;
}

do_install(
			allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN10_SP0],
			allowed_os_architectures =&gt; [OSARCH_x86, OSARCH_x64],
			allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
			exit_on_failure =&gt; 1,
			no_install_check =&gt; 1,
			install_sub =&gt; \&amp;install,
		   );
		   
IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\notepadpp.7_5_4\prod\update.pl</FullName>
    <Length>2190</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-02-09T11:43:20.6689827-06:00</CreationTime>
    <CreationTimeUtc>2018-02-09T17:43:20.6689827Z</CreationTimeUtc>
    <LastWriteTime>2018-02-09T11:33:17.0308617-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-02-09T17:33:17.0308617Z</LastWriteTimeUtc>
    <LastAccessTime>2018-02-09T11:43:20.6689827-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-02-09T17:43:20.6689827Z</LastAccessTimeUtc>
    <Text># Notepad++ 7.5.4
# Package Created February 9, 2018
# Packaged by Taylor Hasty
# Last updated by Taylor Hasty

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'notepad++.7_5_14',
        package_revision =&gt; '20180209T1132',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

my $install_dir = get_arch_programfiles(OSARCH_x64).'\Notepad++';
my $sourcefilesdir = get_pkg_sourcefiles();


GetOptions(
    'uninstall' =&gt; sub { exit(!uninstall()); },
);

####    UNINSTALL   ####
sub uninstall {
    output("Uninstall Notepad++: ");
    
    my $success = run_command("\"$install_dir\\uninstall.exe\" /S");
    
    if($success) {
        delete_product_registry_key(get_package_name() . "." . get_version());
        run_command("rmdir \"$install_dir\" /S /Q");
    }
    
    output($success ? "Success!\n" : "FAILED: $!\n");
    return $success;
}


####    INSTALL ####
sub install {
    my $success;
    
    output("Installing Notepad++ $webVer: ");
    $success = run_command("\"$sourcefilesdir\\npp.7.5.4.Installer.x64.exe\" /S");
    output($success ? "Success!\n\n" : "FAILED: $!\n\n");
    
#    output("Disabling auto update: ");
#    my $noupdate = run_command("move /y \"$install_dir\\updater\" \"$install_dir\\updater_disabled\"");
#    $noupdate &amp;&amp;= run_command("del /q \"$install_dir\\plugins\\PluginManager.dll\"");
#    output($noupdate ? "Success!\n" : "FAILED: $!\n");
    
    return $success; # &amp;&amp; $noupdate;
}

do_install( 
    allowed_versions =&gt; [ OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [ 'clc', 'desktop', 'traveling',
                      'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    no_install_check =&gt; 1,
    install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\notepadpp.7_5_6\prod\update.pl</FullName>
    <Length>1467</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-04-23T11:43:18.6402101-05:00</CreationTime>
    <CreationTimeUtc>2018-04-23T16:43:18.6402101Z</CreationTimeUtc>
    <LastWriteTime>2018-07-02T08:13:55.0119309-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-02T13:13:55.0119309Z</LastWriteTimeUtc>
    <LastAccessTime>2018-04-23T11:43:18.6402101-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-04-23T16:43:18.6402101Z</LastAccessTimeUtc>
    <Text>#Notepad++ 7.5.6
# Package Created April 23rd, 2018
# Packaged by Cameron Loren
# Last updated by Cameron Loren

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'notepadpp.7_5_6',
        package_revision =&gt; '20180423T1109',
    );
}

# Add InstallMonkey Library to the path
use lib (
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();

sub install{
	output("Installing Notepad++ 7.5.6 (x64)\n");
    if(!run_command("start $sourcefilesdir\\npp.7.5.6.Installer.x64.exe /S"))
    {
        output("Notepad++ 7.5.6 (x64) installation did not complete!\n");
        return 0;
    }
    else{
        output("Notepad++ 7.5.6 (x64) installation was successful!\n");
    }
    return 1;
}

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                     'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
	  need_reboot =&gt; 0,
    install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\notepadpp.7_5_7\dev\update.pl</FullName>
    <Length>1425</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-07-11T14:16:55.8741253-05:00</CreationTime>
    <CreationTimeUtc>2018-07-11T19:16:55.8741253Z</CreationTimeUtc>
    <LastWriteTime>2018-07-11T14:22:14.6216872-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-11T19:22:14.6216872Z</LastWriteTimeUtc>
    <LastAccessTime>2018-07-11T14:16:55.8741253-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-07-11T19:16:55.8741253Z</LastAccessTimeUtc>
    <Text>#Notepad++ 7.5.7
# Package Created July 11th, 2018
# Packaged by Alexander Matthes
# Last updated by 

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'notepadpp.7_5_7',
        package_revision =&gt; '20180711T1419',
    );
}

# Add InstallMonkey Library to the path
use lib (
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();

sub install{
	output("Installing Notepad++ 7.5.7 (x64)\n");
    if(!run_command("start $sourcefilesdir\\npp.7.5.7.Installer.x64.exe /S"))
    {
        output("Notepad++ 7.5.7 (x64) installation did not complete!\n");
        return 0;
    }
    else{
        output("Notepad++ 7.5.7 (x64) installation was successful!\n");
    }
    return 1;
}

do_install(
    allowed_versions =&gt; [ OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                     'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
	  need_reboot =&gt; 0,
    install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\nx.11\prod\update.pl</FullName>
    <Length>2933</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-08-28T13:56:49.5376296-05:00</CreationTime>
    <CreationTimeUtc>2017-08-28T18:56:49.5376296Z</CreationTimeUtc>
    <LastWriteTime>2018-01-19T16:26:44.4685329-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-19T22:26:44.4685329Z</LastWriteTimeUtc>
    <LastAccessTime>2017-08-28T13:56:49.5376296-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-08-28T18:56:49.5376296Z</LastAccessTimeUtc>
    <Text># NX 11.0
# Package Created September 2015
# Package by Dzu Pham
# Package updated 6/9/2017 by Sergey Gruzdev

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'nx.11',
		package_revision =&gt; '20170609T0950',
	);
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

my $src = get_pkg_sourcefiles();
my $installer = "$src\\nx110\\Siemens NX 11.0.msi";

GetOptions('uninstall' =&gt; sub{exit(uninstall())});

sub uninstall {
  # msi uninstall
  output("Uninstalling NX.11...\n");
  if(install_msi(app_id =&gt; "{DB388CC5-C37F-4131-A86E-B2BDC55BDDD4}", msi_action_flag =&gt; 'x'))
  {
    output("Uninstall success!\n");
	# Clean folder
	output("Removing leftover folder...\n");
	run_command("rmdir /q /s \"\%localappdata\%\\Siemens\\\"");
	# Remove registry key
	output("Removing registry key...\n");
	delete_product_registry_key(get_package_name().".".get_version());
  }
  else
  {
    output("Error: could not uninstall NX.11!\n");
	return 0;
  }
  
  output("Uninstallation complete!\n");
  return 1;
 
}

sub install {
	output("Installing NX 11.0: ");

	if(!run_command("\"$installer\" /qn SETUPTYPE=typical ADDLOCAL=all LICENSESERVER=1785\@nx.lic.mst.edu")) {
		output("FAIL: $!\n");
		return 0;
	}
	output("OK\n");
	return 1;
}

sub postinstall {
  # Set environment variables
  output("Setting environment variables...\n");
  if(!run_command('setx SPLM_LICENSE_SERVER 1785@nx.lic.mst.edu -m'))
  {
    output("Failed: could not set SPLM_LICENSE_SERVER env var!\n");
    return 0;
  }
  if(!run_command('setx UGS_LICENSE_BUNDLE "ACD30;ACD31" -m'))
  {
    output("Failed: could not set UGS_LICENSE_BUNDLE env var!\n");
	return 0;
  }
  output("Success!\n");
  
  # Add firewall exception
  output("Adding firewall exceptions...\n");
  if(!run_command('netsh advfirewall firewall add rule name=\"allow NX\" dir = in action=block program=\"C:\\Program Files\\siemens\\nx 11.0\\ugii\\ugraf.exe\" enable=yes profile=any'))
  {
    output("Failed: could not add firewall rule - please notfiy DI!\n");
	return 0;
  }
  
  output("Success!\n");
  return 1;
}

do_install
(
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'virtual-clc', 'desktop', 'virtual-desktop', 'traveling'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
  #msi_name =&gt; '\\nx-11.0.0\\nx110\\Siemens NX 11.0.msi',
  postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\nx.12\prod\update.pl</FullName>
    <Length>2986</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-11T15:08:34.6998619-05:00</CreationTime>
    <CreationTimeUtc>2018-06-11T20:08:34.6998619Z</CreationTimeUtc>
    <LastWriteTime>2018-07-10T11:07:15.5795577-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-10T16:07:15.5795577Z</LastWriteTimeUtc>
    <LastAccessTime>2017-08-28T13:56:49-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-08-28T18:56:49Z</LastAccessTimeUtc>
    <Text># NX 12.0
# Package Created September 2015
# Package by Dzu Pham
# Package updated 6/11/2018 by Benjamin Krueger

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'nx.12',
		package_revision =&gt; '20180611T1553',
	);
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

my $src = get_pkg_sourcefiles(); #"\\\\minerfiles.mst.edu\\dfs\\software\\appdeploy\\nx12";
my $installer = "$src\\nx120\\SiemensNX12.0.msi";

GetOptions('uninstall' =&gt; sub{exit(uninstall())});

sub uninstall {
  # msi uninstall
  output("Uninstalling NX.12...\n");
  if(install_msi(app_id =&gt; "{DB388CC5-C37F-4131-A86E-B2BDC55BDDD4}", msi_action_flag =&gt; 'x'))
  {
    output("Uninstall success!\n");
	# Clean folder
	output("Removing leftover folder...\n");
	run_command("rmdir /q /s \"\%localappdata\%\\Siemens\\\"");
	# Remove registry key
	output("Removing registry key...\n");
	delete_product_registry_key(get_package_name().".".get_version());
  }
  else
  {
    output("Error: could not uninstall NX.12!\n");
	  return 0;
  }
  
  output("Uninstallation complete!\n");
  return 1;
 
}

sub install {
	output("Installing NX 12.0: ");

	if(!run_command("\"$installer\" /qn SETUPTYPE=typical ADDLOCAL=all LICENSESERVER=1785\@nx.lic.mst.edu")) {
		output("FAIL: $!\n");
		return 0;
	}
	output("OK\n");
	return 1;
}

sub postinstall {
  # Set environment variables
  output("Setting environment variables...\n");
  if(!run_command('setx SPLM_LICENSE_SERVER 1785@nx.lic.mst.edu -m'))
  {
    output("Failed: could not set SPLM_LICENSE_SERVER env var!\n");
    return 0;
  }
  if(!run_command('setx UGS_LICENSE_BUNDLE "ACD30;ACD31" -m'))
  {
    output("Failed: could not set UGS_LICENSE_BUNDLE env var!\n");
	  return 0;
  }
  output("Success!\n");
  
  # Add firewall exception
  output("Adding firewall exceptions...\n");
  if(!run_command('netsh advfirewall firewall add rule name=\"allow NX\" dir = in action=block program=\"C:\\Program Files\\siemens\\nx 11.0\\ugii\\ugraf.exe\" enable=yes profile=any'))
  {
    output("Failed: could not add firewall rule - please notfiy DI!\n");
	  return 0;
  }
  
  output("Success!\n");
  return 1;
}

do_install
(
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'virtual-clc', 'desktop', 'virtual-desktop', 'traveling'],
  exit_on_failure =&gt; 1,
  #install_sub =&gt; \&amp;install,
  msi_name =&gt; '\\nx120\\SiemensNX12.0.msi',
  postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\oracle.12_2_0_1_0\dev\update.pl</FullName>
    <Length>1721</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-08-30T15:44:28.6894796-05:00</CreationTime>
    <CreationTimeUtc>2017-08-30T20:44:28.6894796Z</CreationTimeUtc>
    <LastWriteTime>2017-08-29T15:14:12.2514669-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-08-29T20:14:12.2514669Z</LastWriteTimeUtc>
    <LastAccessTime>2017-08-30T15:44:28.6894796-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-08-30T20:44:28.6894796Z</LastAccessTimeUtc>
    <Text># Oracle 12.2.0.1.0
# Packaged by Sergey Gruzdev
# Packaged on 8/28/2017
# Last edit: 8/28/2017

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'oracle.12_2_0_1_0',
		package_revision =&gt; '20170828T1503',
	);
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $src = get_pkg_sourcefiles();

sub install
{
  # Prep install dir
  print "Preparing installation directory...\n";
  if(! -e "C:\\Oracle\\Products\\Client")
  {
    if(!run_command("mkdir C:\\Oracle\\Products\\Client"))
    {
      print "Error (FATAL): failed to create \"C:\\Oracle\\Products\\Client\"!\n";
	  return 0;
    }
  }
  
  print "Installing Oracle 12.2.0.1.0...\n";
  # Run installer
  if(!run_command("$src\\setup.exe -waitForCompletion -noconfig -logLevel finest -silent \"$src\\response\\client_install.rsp\""))
  {
    print "Error (FATAL): installation failed!\n";
	return 0;
  }
  
  print "Installed successfully!\n";
  return 1;
}

sub postinstall
{
}

sub randomize
{
}

do_install
(
  allowed_versions =&gt; [OSVER_WIN10_SP0, OSVER_WIN7_SP1, OSVER_WIN7_SP0],
  allowed_os_architectures =&gt; [OSARCH_x86, OSARCH_x64],
  allowed_regs =&gt; ['clc', 'virtual-clc', 'desktop', 'virtual-desktop', 'traveling'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postinstall,
);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\oracle.12_2_0_1_0\prod\update.pl</FullName>
    <Length>2087</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-09-05T13:53:09.8413113-05:00</CreationTime>
    <CreationTimeUtc>2017-09-05T18:53:09.8413113Z</CreationTimeUtc>
    <LastWriteTime>2017-09-05T12:57:13.9367409-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-09-05T17:57:13.9367409Z</LastWriteTimeUtc>
    <LastAccessTime>2017-09-05T13:53:09.8413113-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-09-05T18:53:09.8413113Z</LastAccessTimeUtc>
    <Text># Oracle 12.2.0.1.0
# Packaged by Sergey Gruzdev
# Packaged on 8/28/2017
# Last edit: 8/28/2017

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'oracle.12_2_0_1_0',
		package_revision =&gt; '20170828T1503',
	);
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $src = get_pkg_sourcefiles();

sub preinstall
{
  print "Unzipping files\n";
  if(!run_command("\"$src\\7-zip\\7z.exe\" x -y \"$src\\data.7z\" -o\"$src\""))
  {
    print "Error (FATAL): failed to unzip data.7z!\n";
	return 0;
  }
  print "Installer files extracted!\n";
  return 1;
}

sub install
{
  # Prep install dir
  print "Preparing installation directory...\n";
  if(! -e "C:\\Oracle\\Products\\Client")
  {
    if(!run_command("mkdir C:\\Oracle\\Products\\Client"))
    {
      print "Error (FATAL): failed to create \"C:\\Oracle\\Products\\Client\"!\n";
	  return 0;
    }
  }
  
  print "Installing Oracle 12.2.0.1.0...\n";
  # Run installer
  if(!run_command("$src\\setup.exe -waitForCompletion -noconfig -noconsole -logLevel finest -silent -responseFile \"$src\\response\\client_install.rsp\""))
  {
    print "Error (FATAL): installation failed!\n";
	return 0;
  }
  
  print "Installed successfully!\n";
  return 1;
}

sub postinstall
{
  print "Cheezburger\n";
  return 1;
}

sub randomize
{
}

do_install
(
  allowed_versions =&gt; [OSVER_WIN10_SP0, OSVER_WIN7_SP1, OSVER_WIN7_SP0],
  allowed_os_architectures =&gt; [OSARCH_x86, OSARCH_x64],
  allowed_regs =&gt; ['clc', 'virtual-clc', 'desktop', 'virtual-desktop', 'traveling'],
  exit_on_failure =&gt; 1,
  preinstall_sub =&gt; \&amp;preinstall,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postinstall,
);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\OrCad.17_2\prod\update.pl</FullName>
    <Length>2094</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-30T17:22:34.1123593-06:00</CreationTime>
    <CreationTimeUtc>2017-11-30T23:22:34.1123593Z</CreationTimeUtc>
    <LastWriteTime>2018-01-24T13:12:55.8939802-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-24T19:12:55.8939802Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-30T17:22:34.1123593-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-30T23:22:34.1123593Z</LastAccessTimeUtc>
    <Text># OrCad 17.2
# Package Created Fall 2017
# Packaged by Alex Schrimpf
# Last Updated Fall 2017 by Alex Schrimpf


=pod

Begin-Doc
Modified: 
Name: 
Type:
Description: 
Language: Perl
LastUpdatedBy:
Version:
Doc-Package-Info
Doc-SVN-Repository:
RCSId:
End-Doc

=cut

use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'OrCad.17_2',
        package_revision =&gt; '',
    );
}

use lib ( '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 'C:\temp' );

use InstallMonkey::Shared;

use IM_helper(
    \%INSTALLMONKEY_OPTIONS,
    v4.04,
    (
        "INSTALL" =&gt; [
            sub {
                IM_helper::run_command(
                    description =&gt; 'OrCad Installer',
                    command =&gt; "\"$IM_helper::source_files\\17.2-2016_S024_OrCAD Lite_All Products\\setup.exe\" /s /f1\"$IM_helper::source_files\\Setup.iss\""
                )
            },
            sub {
                IM_helper::push_to_system_var(
                    name =&gt; "CDS_LIC_FILE",
                    value=&gt; "5280\@cadence.lic.mst.edu"
                );
            }
        ],
        "UNINSTALL" =&gt; [
        sub{
           IM_helper::uninstall_using_programs_and_features(
                display_name=&gt; "Cadence OrCad PCB Designer Lite 17.2"
            );
        },
        sub {
            delete_product_registry_key(get_package_id());
        },
       ]
 
    )
);

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt;
      [ 'clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    no_install_check =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    no_product_key =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    install_sub =&gt; $IM_helper::exec_call_stack_override || sub{IM_helper::exec_call_stacks(ids=&gt;["INSTALL"])}
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\panopto.5_4\prod\update.pl</FullName>
    <Length>1857</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-30T12:56:32.9601946-05:00</CreationTime>
    <CreationTimeUtc>2017-06-30T17:56:32.9601946Z</CreationTimeUtc>
    <LastWriteTime>2017-07-06T11:27:31.6256777-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-07-06T16:27:31.6256777Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-30T12:56:32.9601946-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-30T17:56:32.9601946Z</LastAccessTimeUtc>
    <Text># Panopto Recorder 5.4
# Package created by Sergey Gruzdev
# Package created 6/30/2017
# Package last edited 6/30/2017 by Sergey Gruzdev

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'panopto.5_4',
		package_revision =&gt; '20170630T1245',
	);
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

my $src = get_pkg_sourcefiles();

GetOptions('uninstall' =&gt; sub{exit(uninstall())});

sub uninstall
{
  print "Uninstalling Panopto Recorder 5.4...\n";
  # Uninstall via msi
  if(!run_command("msiexec /x \"$src\\panoptorecorder.msi\" /qn"))
  {
    print "Could not uninstall Panopto Recorder 5.4!\n";
	return 0;
  }
  print "Removing registry key...\n";
  delete_product_registry_key(get_package_name().".".get_version());
  print "Reg key deleted! Uninstallation complete!\n";
  return 1;
}

sub postinstall
{
  print "Deleting desktop icon...\n";
  # Delete icon
  if(!run_command("del \"".get_allusers_desktop()."\\Panopto.lnk\""))
  {
    print "Error: could not delete desktop icon!\n";
  }
  print "Installation complete!\n";
  return 1;
}

do_install
(
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x64, OSARCH_x86],
  allowed_regs =&gt; ['clc', 'desktop', 'virtual-clc', 'virtual-desktop', 'traveling'],
  exit_on_failure =&gt; 1,
  msi_name =&gt; 'panoptorecorder.msi',
  postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\panopto.5_7\prod\update.pl</FullName>
    <Length>1464</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-07-20T13:57:18.0189498-05:00</CreationTime>
    <CreationTimeUtc>2018-07-20T18:57:18.0189498Z</CreationTimeUtc>
    <LastWriteTime>2018-07-20T14:06:13.0788474-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-20T19:06:13.0788474Z</LastWriteTimeUtc>
    <LastAccessTime>2018-07-20T13:57:18.0189498-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-07-20T18:57:18.0189498Z</LastAccessTimeUtc>
    <Text># Panopto Recorder 5.7
# Package created by Cameron Loren
# Package created 7/20/2018

use warnings;
use strict;
our %INSTALLMONKEY_OPTIONS;
BEGIN {
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'panopto.5_7',
		package_revision =&gt; '20180720T1404',
	);
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

my $src = get_pkg_sourcefiles();

sub install
{
	if(!run_command("start /wait $src\\panoptorecorder.msi /quiet PANOPTO_SERVER=mst.hosted.panopto.com RECORDINGFOLDER=\"C:\\Panopto\\videos\" INSTALLLOCATION=\"C:\\Program Files\\Panopto\\\""))
	{
		print "Panopto 5.7 installation failed.\n";
		return 0;
	}
	else
	{
		print "Panopto 5.7 installed succesfully.\n";
		return 1;
	}
}

sub postinstall
{
  print "Deleting desktop icon...\n";
  # Delete icon
  if(!run_command("del \"".get_allusers_desktop()."\\Panopto.lnk\""))
  {
    print "Error: could not delete desktop icon!\n";
  }
  print "Installation complete!\n";
  return 1;
}

do_install
(
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x64, OSARCH_x86],
  allowed_regs =&gt; ['clc', 'desktop', 'virtual-clc', 'virtual-desktop', 'traveling'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\papercutclient.17_3_6\prod\update.pl</FullName>
    <Length>3067</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-14T12:03:58.5527855-06:00</CreationTime>
    <CreationTimeUtc>2017-11-14T18:03:58.5527855Z</CreationTimeUtc>
    <LastWriteTime>2017-12-15T09:08:16.5607491-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-12-15T15:08:16.5607491Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-14T12:03:58.5527855-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-14T18:03:58.5527855Z</LastAccessTimeUtc>
    <Text># InstallMonkey Package: Papercut NG Client 13.2
# Package Created: 2013-05-14
# Packaged by: Eric Boyer
# Last Updated:  Benjamin Krueger 12/15/17

=pod
Begin-Doc
Modified: 2013-05-14
Name: Eric Boyer
Type: Script
Description: Script to silently install Papercut NG Client 13.2
Language: Perl
LastUpdatedBy:
Version: 1.0
Doc-Package-Info: \\minerfiles.mst.edu\dfs\software\itwindist\win7\appdist\papercutclient.12_2\README.txt
Doc-SVN-Repository:
RCSId:
End-Doc
=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN{
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'papercutclient.17_3_6',
		package_revision =&gt; '20171114T1241',
	);
}

use lib(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

my $sourcefilesdir = get_pkg_sourcefiles();
my $installSource = "\\\\papercut.mst.edu\\pcclient\\win";
my $applog = get_default_app_log();

######
GetOptions(
    'uninstall' =&gt; sub { exit(!uninstall()); },
) || die "Usage: $!";
######

sub uninstall {
	my $log = get_default_app_log();
    $log =~ s/\.txt$/_uninstall.txt/i;
	my $DIR = $ENV{'programfiles(x86)'} . '\PaperCut NG Client';
	my $UninstallFile;

	opendir(my $D, $DIR);
	my @files = grep(/\.dat$/,readdir($D));
	closedir($D);

	if (scalar (@files) == 1)
	{
		$UninstallFile = $files[0];
		$UninstallFile =~ s/\.dat$/\.exe/i;
	}

	my @command = (
		   'start', '""', '/wait', cmd_quote(build_path(get_arch_programfiles(OSARCH_x86),'PaperCut NG Client',$UninstallFile)),
		   '/SILENT', #'/LOG="$applog\$log"',
		);
	my $success = run_command(join(' ',@command));

	sleep(2);
	if ($success)
	{
		output("Removing registry key.\n");
		delete_product_registry_key('papercutclient.17_3_6');
		output("PaperCut NG Client removed successfully");
		return 1;
	}
	else
	{
		output("Issue removing PaperCut NG Client");
		return 0;
	}
}

sub install{
	my $logFile = $ENV{'TEMP'}.'_papercut_client_setup.txt';
	my $success = 1;

	print "\nInstalling...  ";
	if(run_command("$sourcefilesdir\\client-local-install.exe /VERYSILENT /LOG=\"C:\\PaperCutLog.log\"")){
		print "DONE.\n\n";
	}else{
		print "Install reported failure.\n\n";
		$success = 0
	}
	return $success;
}

sub postinstall{
	print "Copying log file\n";
	if(run_command("move C:\\PaperCutLog.log \"$applog\"")){
		print "Copied C:\\PaperCutLog.log\n";
		if(run_command("del C:\\PaperCutLog.log")){
			print "Deleted C:\\PaperCutLog.log\n";
		}else{
			print "Could not delete C:\\PaperCutLog.log\n";
		}
		return 1;
	}else{
		print "Failed to copy log file.\n";
		return 0;
	}
}

do_install(
	allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1, OSVER_WIN10_SP0],
	allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
	allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
	exit_on_failure =&gt; 1,
	install_sub =&gt; \&amp;install,
 	postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\passwordsafe.3_46\prod\update.pl</FullName>
    <Length>1994</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-08T10:52:03.333913-05:00</CreationTime>
    <CreationTimeUtc>2018-06-08T15:52:03.333913Z</CreationTimeUtc>
    <LastWriteTime>2018-06-11T14:34:40.2689289-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-11T19:34:40.2689289Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-08T10:52:03.333913-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-08T15:52:03.333913Z</LastAccessTimeUtc>
    <Text>#Password Safe 3.46
# Package Created June 8th, 2018
# Packaged by Cameron Loren
# Last updated by Cameron Loren

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'passwordsafe.3_46',
        package_revision =&gt; '20180608T1053',
    );
}

# Add InstallMonkey Library to the path
use lib (
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
my $startMenu = "$ENV{'PROGRAMDATA'}\\Microsoft\\Windows\\Start Menu\\Programs";

sub install
{
	  output("Installing PasswordSafe 3.46\n");
    if(!run_command("start $sourcefilesdir\\pwsafe-3.46.0.msi /quiet"))
    {
        output("PasswordSafe 3.46 installation did not complete!\n");
        return 0;
    }
    else
    {
        run_command("copy /Y \"$sourcefilesdir\\Password Safe 3.46.lnk\" \"$startMenu\\Password Safe 3.46.lnk\"");
        output("PasswordSafe 3.46 installation was successful!\n");
    }
    return 1;
}

sub post
{
  #Waiting 5 seconds to ensure installation completes
  sleep(5);
  output("Removing icons from public: ");
  my $Remove = run_command("del \"%systemdrive%\\Users\\Public\\Desktop\\Password Safe.lnk\" /Q");
  output($Remove ? "Success!\n" : "FAILED: $!\n");

  return $Remove;
}

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                     'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
	  need_reboot =&gt; 0,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;post,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\perceptive.7_2_2\prod\update.pl</FullName>
    <Length>1677</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-04-09T11:02:36.029931-05:00</CreationTime>
    <CreationTimeUtc>2018-04-09T16:02:36.029931Z</CreationTimeUtc>
    <LastWriteTime>2018-06-03T19:55:48.0696567-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-04T00:55:48.0696567Z</LastWriteTimeUtc>
    <LastAccessTime>2018-04-09T11:02:36.342546-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-04-09T16:02:36.342546Z</LastAccessTimeUtc>
    <Text># InstallMonkey Package: Perform 7.2.2
# Package Created: 2018-04-09
# Packaged by: Sergey Gruzdev
# Last Updated:  Sergey Gruzdev 4/9/2018

=pod
Begin-Doc
Modified: 2013-05-14
Name: Eric Boyer
Type: Script
Description: Script to silently install Perform 7.2.2
Language: Perl
LastUpdatedBy:
Version: 1.0
Doc-Package-Info: \\minerfiles.mst.edu\dfs\software\itwindist\win7\appdist\papercutclient.12_2\README.txt
Doc-SVN-Repository:
RCSId:
End-Doc
=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN{
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'perform.7_2_2',
		package_revision =&gt; '20180409T1103',
	);
}

use lib(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
my $src = get_pkg_sourcefiles();


sub install
{
	print "Running installer...\n";
	if(!run_command("$src\\silent-inst.exe", IgnoreExitCodes=&gt;[3010]))
	{
		print "FATAL: installer failed!\n";
		return 0;
	}
	print "Success!\n";
	return 1;
}

sub postinstall
{
	print "Deleting desktop shortcut...\n";
	if(!run_command("del \"C:\\Users\\Public\\Desktop\\Perceptive Content.lnk\""))
	{
		print "Error: failed to delete desktop shorcut!\n";
		return 0;
	}
	print "Installation complete!\n";
	return 1;
}

do_install(
	allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
	allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
	allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
	exit_on_failure =&gt; 1,
	install_sub =&gt; \&amp;install,
 	postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\perform2013.1_1\prod\update.pl</FullName>
    <Length>1469</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-19T13:12:26.6618246-05:00</CreationTime>
    <CreationTimeUtc>2018-06-19T18:12:26.6618246Z</CreationTimeUtc>
    <LastWriteTime>2018-06-19T13:33:25.4380811-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-19T18:33:25.4380811Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-19T13:12:26.6618246-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-19T18:12:26.6618246Z</LastAccessTimeUtc>
    <Text>#Perform 2013 1.1
# Package Created June 19th, 2018
# Packaged by Cameron Loren
# Last updated by Cameron Loren

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'perform2013.1_1',
        package_revision =&gt; '20180619T1333',
    );
}

# Add InstallMonkey Library to the path
use lib (
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
sub install{
	output("Installing Perform 2013 1.1\n");
    if(!run_command("$sourcefilesdir\\perform_AutoIT.exe $sourcefilesdir\\\"Setup.exe\""))
    {
        output("Perform 2013 1.1 installation did not complete!\n");
        return 0;
    }
    else
    {
        output("Perform 2013 1.1 installation was successful!\n");
    }
    return 1;
}

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                     'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
	  need_reboot =&gt; 0,
    install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\pickit2.2_61\prod\update.pl</FullName>
    <Length>2756</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-02-12T12:23:38.5892415-06:00</CreationTime>
    <CreationTimeUtc>2016-02-12T18:23:38.5892415Z</CreationTimeUtc>
    <LastWriteTime>2016-02-12T12:23:38.5892415-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-02-12T18:23:38.5892415Z</LastWriteTimeUtc>
    <LastAccessTime>2016-02-12T12:23:38.5892415-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-02-12T18:23:38.5892415Z</LastAccessTimeUtc>
    <Text># PICkit 2 - application for interfacing with PICkit 2 microcontrollers
# Package generated with GenGen on 2016-Feb-12 12:23
# Packaged by Grayson Gratop

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
      package_id =&gt; 'pickit2.2_61',
      package_revision =&gt; '20160212T1223',
  );
}

# Add InstallMonkey Library to the path
use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use Getopt::Long;
use InstallMonkey::Shared;

GetOptions(
  'uninstall' =&gt; sub { exit(!uninstall()); },
);

my $srcfilesdir = get_pkg_sourcefiles();
my $allUsersDesktop = get_allusers_desktop();
my $allUsersStartmenu = get_allusers_start_menu();


sub install {
  #thanks, creator of python 2.7 package. second argument is whether or not it's okay if the command fails
  my @installCommands = (
    ["msiexec /qb /i \"$srcfilesdir\\PICkit2Setup.msi\" ", 0],
    ["icacls \"C:\\Program Files (x86)\\Microchip\" /grant Users:(OI)(CI)M", 0]
  );

  my $success = 0;
  my $allDone = 1;
  
  output("Installing PICkit 2... \n");
  
  for (my $i = 0; $i &lt; scalar @installCommands; $i++) {
    output("\t" . $installCommands[$i][0] . ": ");
    $success = run_command($installCommands[$i][0]);
    output($success ? "Done!\n" : "FAILED: $!\n");
    $allDone &amp;&amp;= $installCommands[$i][1] || $success;
  }

  if ($allDone) {
    output("Looks like it was a success!\n");
  }
  else {
    output("Something went wrong!\n");
  }

  return $allDone;
}


sub postInstall {
  my $iconSuccess = 1;

  #Delete icons in every user's Desktop folder (excluding Default). Thanks, StackOverflow
  opendir(DIR, 'C:\\Users');
  my @users = grep { (!/^\.\.?$/) &amp;&amp; (-d "C:\\Users\\$_") &amp;&amp; ($_ ne 'Default') } readdir(DIR);
  closedir(DIR);

  foreach my $place (@users) {
    run_command("DEL /Q \"C:\\Users\\$place\\Desktop\\PICkit 2 v2.61.lnk\"");
  }

  output("Desktop icons removed.\n");



  return 1;
}


do_install( 
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
  allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postInstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\pidgin.2_11_0\prod\update.pl</FullName>
    <Length>2745</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-10-07T09:28:57.3120251-05:00</CreationTime>
    <CreationTimeUtc>2016-10-07T14:28:57.3120251Z</CreationTimeUtc>
    <LastWriteTime>2016-10-07T10:25:02.4527381-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-10-07T15:25:02.4527381Z</LastWriteTimeUtc>
    <LastAccessTime>2016-10-07T09:28:57.3120251-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-10-07T14:28:57.3120251Z</LastAccessTimeUtc>
    <Text># Pidgin 2.10.11
# Package Created 2015-07-06
# Packaged by Dillon Lustick
# Last Updated 2016-10-07 for 2.11.0 by Chris Schaaf

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'pidgin.2_11_0',
        package_revision =&gt; '20161007T1000',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

my $srcfiles= get_pkg_sourcefiles();

GetOptions(
    '--uninstall' =&gt; sub { exit(!uninstall()); },
);

sub uninstall {
    my $c_path = "C:\\Program Files (x86)\\Pidgin";
    my $log = get_default_app_log();
    $log =~ s/\.txt$/_uninstall.txt/i;
    output("Uninstalling Pidgin: ");
    if(!run_command("\"$c_path\\Uninstall-pidgin-sipe.exe\" /S")) {
      print "FAILED!!\n";
      return 0;
    }
    if(!run_command("\"$c_path\\pidgin-uninst.exe\" /S")) {
      print "FAILED!!\n";
      return 0;
    }
    print "SUCCESS\n";
    delete_product_registry_key(get_package_name().".".get_version());
    return 1;
}

sub install {
    output("\nInstalling Pidgin: ");
    if(!run_command("$srcfiles\\pidgin-2.11.0-offline.exe /DS=0 /SMS=1 /S")) {
        print "FAILED!!\n";
        return 0;
    }
    output("Success\n");
    return 1;
}


sub postinstall {
    output("\nInstalling SIPE Pidgin Plugin: ");
    if(!run_command("\"$srcfiles\\pidgin-sipe-1.21.1-pidgin-2.10.12-win32-nsis-sspi.exe\" /S")) {
        print "FAILED!!\n";
        return 0;
    }
	#DLL included in the above installer is not for this version of Pidgin. Developer of SIPE has provided this as of 2016-09-24. https://sourceforge.net/projects/sipe/
    output("OK\nUpdating DLL: ");
	if(!run_command("copy /B/Y \"$srcfiles\\libsipe.dll\" \"C:\\Program Files (x86)\\Pidgin\\Plugins\\libsipe.dll\"")) {
		print("FAIL\n");
		return 0;
	}
	output("OK\nSuccess\n");
    add_environment_variable("NSS_SSL_CBC_RANDOM_IV", "0");
    return 1;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\pidgin.2_12_0\prod\update.pl</FullName>
    <Length>1207</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-08T11:46:09.3364065-05:00</CreationTime>
    <CreationTimeUtc>2018-06-08T16:46:09.3364065Z</CreationTimeUtc>
    <LastWriteTime>2018-06-08T11:50:56.7723132-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-08T16:50:56.7723132Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-08T11:46:09.3364065-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-08T16:46:09.3364065Z</LastAccessTimeUtc>
    <Text># Pidgin 2.12.11
# Package Created 2015-07-06
# Packaged by Dillon Lustick
# Last Updated 2018-06-08 for 2.12.0 by Cameron Loren

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'pidgin.2_12_0',
        package_revision =&gt; '20180608T1147',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

my $srcfiles= get_pkg_sourcefiles();

sub install
{
    output("\nInstalling Pidgin: ");
    if(!run_command("$srcfiles\\pidgin-2.12.0.exe /DS=0 /SMS=1 /S"))
    {
        print "FAILED!!\n";
        return 0;
    }
    output("Success\n");
    return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\plecs.4_0_3\dev\update.pl</FullName>
    <Length>6710</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-01-31T14:01:41.2983599-06:00</CreationTime>
    <CreationTimeUtc>2017-01-31T20:01:41.2983599Z</CreationTimeUtc>
    <LastWriteTime>2017-02-01T10:09:42.5715478-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-02-01T16:09:42.5715478Z</LastWriteTimeUtc>
    <LastAccessTime>2017-01-31T14:01:41.2983599-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-01-31T20:01:41.2983599Z</LastAccessTimeUtc>
    <Text># PLECS Installer
# Package Created November 2013
# Packaged by Charlie Hendricks
# Updated 2015-01-20 by Dillon Lustick
# Update for 4.0.3 on 2016-11-28 by Grayson Gratop
# Verification/Completion of 4.0.3 update on 2017-01-03 by John Stinson

=pod

Begin-Doc
Modified: $Date$
Name: PLECS Installer
Type: script
Description: PLECS is a MATLAB module.
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'plecs.4_0_3',
        package_revision =&gt; '20170119T1352',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::FlexLM;

use File::Basename;
use Getopt::Long;
use Win32::TieRegistry;
use File::Temp qw(tempfile);
use File::Copy;
use POSIX qw(strftime);

########################################################################
# BEGIN Configuration

# The MSI's were extracted from the downloaded(?) EXE's.
# I decided to extract the MSI's because the EXE's provided no extra
#   functionality and provided only a confusing way to pass MSI properties
#   to msiexec (in particular, it expected the set of properties to be enclosed
#   in double quotes---which assumes that the values themselves don't need
#   to be quoted, which isn't a valid assumption).
my $installer_x64 = 'plecs-standalone-4-0-3_win64.msi';


# This package attempts to install just the 64-bit version
#   (if possible). We arbitrarily decide to install the package to
#   '%ProgramFiles%\plexim' ('ProgramFiles\plecs' interferes with plecs blockset)
my $install_dir = 'plexim\plecs 4.0';

# END Configuration
########################################################################


my $srcfiles= get_pkg_sourcefiles();

sub usage {
    print qq(
usage: $0 [--help] [--uninstall]
);
}
GetOptions(
    'help' =&gt; sub { usage(); exit(0); },

    'uninstall' =&gt; sub { exit( ! uninstall() ); },
);


# Begin-Doc
################################
# Name: install_x64()
# Description: Install the 32- and 64-bit versions of PLECS
# Returns: true/false on success/failure (pass-through)
# LastUpdated: 2014-01-02
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub install_x64 {
    return install($installer_x64,'x64',
                build_path(get_arch_programfiles(OSARCH_x64),$install_dir));
}

# Begin-Doc
################################
# Name: install()
# Description: Install the specified MSI.
# Returns: true/false on success/failure (pass-through)
# LastUpdated: 2014-01-02
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub install {
    my $installer = shift;
    my $marker = shift; # appended to log file name
    my $install_dir = shift;

    my $logfile = basename(get_default_app_log());
    $logfile =~ s/\.txt$/_${marker}.txt/i;

    # By default, the (extracted) MSI installs to the 'Personal' shell folder.
    my @msi_props = (
        sprintf('INSTALLDIR="%s"',$install_dir),
        );

    output("   Installing ${marker}: ");
    my $success = 
        install_msi(
            msi =&gt; build_path($srcfiles,$installer),
            additional_msi_properties =&gt; join(' ',@msi_props),
            logfile_indirection =&gt; 1,
            logfile_name =&gt; $logfile,
        );
    output(($success?'OK':'FAILED')."\n");	
    return $success;
}

sub postinstall {
	#Configure license
	#Code adapted from Altera Quartus 12.0, previous methods for licensing PLECS conflict with how FlexLM handles things now.
	#Only changes made were to license server address and port, and changing "altera" to "plecs".
	return set_flexlm_environment_variable('1717', 'plecs');
	#return add_environment_variable('LM_LICENSE_FILE', "1717\@plecs.lic.mst.edu");
}

do_install( 
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [ qw(clc desktop traveling virtual-desktop virtual-clc)],
    exit_on_failure =&gt; 1,
    
    install_sub_x64 =&gt; \&amp;install_x64,
	postinstall_sub =&gt; \&amp;postinstall,
);
IM_Exit(EXIT_SUCCESS);


########################################################################


# Begin-Doc
################################
# Name: uninstall()
# Description: 
# Returns: 
# Requires: 
# LastUpdated: 
# LastUpdatedBy: 
################################
# End-Doc
sub uninstall {
    output("Uninstalling PLECS Standalone...\n");

    my $success = 1;
    my $count = 0;

    foreach my $appkey (IsAppInstalled('DisplayName' =&gt; qr/^PLECS Standalone/ )) {
        my $k = $Registry-&gt;{$appkey};
        my $dn = $k-&gt;{DisplayName};
        my $dv = $k-&gt;{DisplayVersion};
        my $app_id = basename($appkey);

        output("  ${dn} ${dv} (${app_id}): ");

        my $log = get_default_app_log();
        $log =~ s/(\.[^\.]+)$/_${app_id}_uninstall$1/;

        my $outcome = 
            install_msi( app_id =&gt; $app_id,
                         msi_action_flag =&gt; 'x',
                         logfile =&gt; $log );
        output(($outcome?'OK':'FAILED')."\n");

        $count++;
        $success &amp;&amp;= $outcome;
    }

    delete_product_registry_key(get_package_id());

    output("   No installed versions of PLECS Standalone found!\n")
        if ($count == 0);

    return $success;
}


### subroutine documentation block ###
# Begin-Doc
################################
# Name: 
# Description: 
# Returns: 
# Requires: 
# LastUpdated: 
# LastUpdatedBy: 
################################
# End-Doc

__END__

The EXE appears to be an unintelligent wrapper for the MSI.
Extract the MSI and use it for installation.

plecs-blockset-4-0-3_win64.exe /?

Installation options
    /extract "&lt;Directory&gt;"
        Extracts all installation packages to the specified directory
    /msicl "[PROPERTY=PropertyValue] ..."
        Properties to set for installation
    /lang &lt;LCID&gt;
        Locale ID of transform to apply to installation
    /quiet
        Quiet mode, no user interaction
    /passive
        Unattended mode - progress bar only
    /norestart
        Do not restart after the installation is complete
    /promptrestart
        Prompts the user for restart if necessary
    /forcerestart
        Always restart the computer after installation
    /uninstall
        Uninstalls the product
    /log "&lt;LogFile&gt;"
        Create a log

OK
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\plecs.4_0_3\prod\update.pl</FullName>
    <Length>7563</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-01-19T13:05:18.7764273-06:00</CreationTime>
    <CreationTimeUtc>2017-01-19T19:05:18.7764273Z</CreationTimeUtc>
    <LastWriteTime>2017-01-25T09:34:43.2615559-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-01-25T15:34:43.2615559Z</LastWriteTimeUtc>
    <LastAccessTime>2017-01-19T13:05:18.7764273-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-01-19T19:05:18.7764273Z</LastAccessTimeUtc>
    <Text># PLECS Installer
# Package Created November 2013
# Packaged by Charlie Hendricks
# Updated 2015-01-20 by Dillon Lustick
# Update for 4.0.3 on 2016-11-28 by Grayson Gratop
# Verification/Completion of 4.0.3 update on 2017-01-03 by John Stinson

=pod

Begin-Doc
Modified: $Date$
Name: PLECS Installer
Type: script
Description: PLECS is a MATLAB module.
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'plecs.4_0_3',
        package_revision =&gt; '20170119T1352',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

use File::Basename;
use Getopt::Long;
use Win32::TieRegistry;
use File::Temp qw(tempfile);
use File::Copy;
use POSIX qw(strftime);

########################################################################
# BEGIN Configuration

# The MSI's were extracted from the downloaded(?) EXE's.
# I decided to extract the MSI's because the EXE's provided no extra
#   functionality and provided only a confusing way to pass MSI properties
#   to msiexec (in particular, it expected the set of properties to be enclosed
#   in double quotes---which assumes that the values themselves don't need
#   to be quoted, which isn't a valid assumption).
my $installer_x64 = 'plecs-standalone-4-0-3_win64.msi';


# This package attempts to install just the 64-bit version
#   (if possible). We arbitrarily decide to install the package to
#   '%ProgramFiles%\plexim' ('ProgramFiles\plecs' interferes with plecs blockset)
my $install_dir = 'plexim\plecs 4.0';

# END Configuration
########################################################################


my $srcfiles= get_pkg_sourcefiles();

sub usage {
    print qq(
usage: $0 [--help] [--uninstall]
);
}
GetOptions(
    'help' =&gt; sub { usage(); exit(0); },

    'uninstall' =&gt; sub { exit( ! uninstall() ); },
);


# Begin-Doc
################################
# Name: install_x64()
# Description: Install the 32- and 64-bit versions of PLECS
# Returns: true/false on success/failure (pass-through)
# LastUpdated: 2014-01-02
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub install_x64 {
    return install($installer_x64,'x64',
                build_path(get_arch_programfiles(OSARCH_x64),$install_dir));
}

# Begin-Doc
################################
# Name: install()
# Description: Install the specified MSI.
# Returns: true/false on success/failure (pass-through)
# LastUpdated: 2014-01-02
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub install {
    my $installer = shift;
    my $marker = shift; # appended to log file name
    my $install_dir = shift;

    my $logfile = basename(get_default_app_log());
    $logfile =~ s/\.txt$/_${marker}.txt/i;

    # By default, the (extracted) MSI installs to the 'Personal' shell folder.
    my @msi_props = (
        sprintf('INSTALLDIR="%s"',$install_dir),
        );

    output("   Installing ${marker}: ");
    my $success = 
        install_msi(
            msi =&gt; build_path($srcfiles,$installer),
            additional_msi_properties =&gt; join(' ',@msi_props),
            logfile_indirection =&gt; 1,
            logfile_name =&gt; $logfile,
        );
    output(($success?'OK':'FAILED')."\n");	
    return $success;
}

sub postinstall {
	#Configure license
	#Code adapted from Altera Quartus 12.0, previous methods for licensing PLECS conflict with how FlexLM handles things now.
	#Only changes made were to license server address and port, and changing "altera" to "plecs".
		ShellNotify_WM_SETTINGSCHANGE();
    output("Adding PLECS License Variable...\n");

    my $lm_reg = checkReg('LM_LICENSE_FILE');

     if (!defined($lm_reg) || ($lm_reg !~ m/\b1717\@plecs\.lic\.mst\.edu\b/i))
    {
        output("Adding 1717\@plecs.lic.mst.edu to LM_LICENSE_FILE\n");

        my @paths = split(/;/,$lm_reg || '');
        push(@paths,'1717@plecs.lic.mst.edu');

        my @command = (
            'SETX.EXE',
            'LM_LICENSE_FILE',
            '"'.join(';',@paths).'"',
            (is_XP()?'-M':'/M'),
        );
        if(run_command(join(' ',@command)))
        {
            output("Success!\n");
        }
        else
        {
            output("Failed.\n");
			return 0;
        }
    }
	else {
		output("License already configured.\n");
	}
	return 1;
}

do_install( 
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [ qw(clc desktop traveling virtual-desktop virtual-clc)],
    exit_on_failure =&gt; 1,
    
    install_sub_x64 =&gt; \&amp;install_x64,
	postinstall_sub =&gt; \&amp;postinstall,
);
IM_Exit(EXIT_SUCCESS);


########################################################################

sub checkReg {
  my $env_var = shift;

  return $Registry-&gt;{"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment\\\\".$env_var};
}

# Begin-Doc
################################
# Name: uninstall()
# Description: 
# Returns: 
# Requires: 
# LastUpdated: 
# LastUpdatedBy: 
################################
# End-Doc
sub uninstall {
    output("Uninstalling PLECS Standalone...\n");

    my $success = 1;
    my $count = 0;

    foreach my $appkey (IsAppInstalled('DisplayName' =&gt; qr/^PLECS Standalone/ )) {
        my $k = $Registry-&gt;{$appkey};
        my $dn = $k-&gt;{DisplayName};
        my $dv = $k-&gt;{DisplayVersion};
        my $app_id = basename($appkey);

        output("  ${dn} ${dv} (${app_id}): ");

        my $log = get_default_app_log();
        $log =~ s/(\.[^\.]+)$/_${app_id}_uninstall$1/;

        my $outcome = 
            install_msi( app_id =&gt; $app_id,
                         msi_action_flag =&gt; 'x',
                         logfile =&gt; $log );
        output(($outcome?'OK':'FAILED')."\n");

        $count++;
        $success &amp;&amp;= $outcome;
    }

    delete_product_registry_key(get_package_id());

    output("   No installed versions of PLECS Standalone found!\n")
        if ($count == 0);

    return $success;
}


### subroutine documentation block ###
# Begin-Doc
################################
# Name: 
# Description: 
# Returns: 
# Requires: 
# LastUpdated: 
# LastUpdatedBy: 
################################
# End-Doc

__END__

The EXE appears to be an unintelligent wrapper for the MSI.
Extract the MSI and use it for installation.

plecs-blockset-4-0-3_win64.exe /?

Installation options
    /extract "&lt;Directory&gt;"
        Extracts all installation packages to the specified directory
    /msicl "[PROPERTY=PropertyValue] ..."
        Properties to set for installation
    /lang &lt;LCID&gt;
        Locale ID of transform to apply to installation
    /quiet
        Quiet mode, no user interaction
    /passive
        Unattended mode - progress bar only
    /norestart
        Do not restart after the installation is complete
    /promptrestart
        Prompts the user for restart if necessary
    /forcerestart
        Always restart the computer after installation
    /uninstall
        Uninstalls the product
    /log "&lt;LogFile&gt;"
        Create a log

OK
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\plecs.4_1_3\prod\update.pl</FullName>
    <Length>2578</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-01-12T09:21:29.6466399-06:00</CreationTime>
    <CreationTimeUtc>2018-01-12T15:21:29.6466399Z</CreationTimeUtc>
    <LastWriteTime>2018-02-28T10:05:14.2956925-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-02-28T16:05:14.2956925Z</LastWriteTimeUtc>
    <LastAccessTime>2018-01-12T09:21:29.7092281-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-01-12T15:21:29.7092281Z</LastAccessTimeUtc>
    <Text># PLECS 4.1.3
# Package Created Winter 2016
# Last Updated 2017-1-5 by Alex Schrimpf

=pod

Begin-Doc
Modified: 
Name: 
Type:
Description: 
Language: Perl
LastUpdatedBy:
Version:
Doc-Package-Info
Doc-SVN-Repository:
RCSId:
End-Doc

=cut

use strict;
use warnings;
our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'plecs.4_1_3',
        package_revision =&gt; '',
    );
}

use lib ( '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 'C:\temp' );

use InstallMonkey::Shared;

use IM_helper(
   \%INSTALLMONKEY_OPTIONS,
    v4.04,
    (
        "INSTALL" =&gt; 
        [
            sub {
                #Old installer said you have to change install directory because the default 'ProgramFiles\plecs' interferes with plecs blockset
                my $install_dir = "$ENV{PROGRAMFILES}\\plexim\\plecs 4.1.3";
                IM_helper::run_command(
                    description=&gt;'PLECS Installer',
                    command=&gt;"\"$IM_helper::source_files\\plecs-standalone-4-1-3_win64.msi\" INSTALLDIR=\"$install_dir\" /quiet"
                );
            },
            sub {
                IM_helper::push_to_system_var(
                    name=&gt;"LM_LICENSE_FILE",
                    value=&gt;"1717\@plecs.lic.mst.edu"
                )
            },
            sub {
                IM_helper::cp_file(
                    from=&gt; "$IM_helper::source_files\\PLECS 4.1.3 (64 bit).lnk",
                    to_dir=&gt; "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs"
                )
            }
        ],
        "UNINSTALL" =&gt;
        [
            sub {
                IM_helper::uninstall_using_programs_and_features(
                    display_name=&gt;'PLECS Standalone 4.1.3 (64 bit)'
                );
            },
            sub{
                delete_product_registry_key($INSTALLMONKEY_OPTIONS{package_id});
            },
        ]
    )
);

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt;
      [ 'clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    no_install_check =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    no_product_key =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    install_sub =&gt; $IM_helper::exec_call_stack_override || sub{IM_helper::exec_call_stacks(ids=&gt;["INSTALL"])}
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\plecs.4_1_3\prod.old\update.pl</FullName>
    <Length>7615</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-14T14:34:52.3749626-06:00</CreationTime>
    <CreationTimeUtc>2017-11-14T20:34:52.3749626Z</CreationTimeUtc>
    <LastWriteTime>2017-11-14T15:07:51.2994253-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-11-14T21:07:51.2994253Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-14T14:34:52.3749626-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-14T20:34:52.3749626Z</LastAccessTimeUtc>
    <Text># PLECS Installer
# Package Created November 2013
# Packaged by Charlie Hendricks
# Updated 2015-01-20 by Dillon Lustick
# Update for 4.1.3 on 2016-11-28 by Grayson Gratop
# Verification/Completion of 4.1.3 update on 2017-01-03 by John Stinson
# Update for 4.1.3 on 2017-11-14 by Grayson Gratop

=pod

Begin-Doc
Modified: $Date$
Name: PLECS Installer
Type: script
Description: PLECS is a MATLAB module.
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'plecs.4_1_3',
        package_revision =&gt; '20171114T1507',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

use File::Basename;
use Getopt::Long;
use Win32::TieRegistry;
use File::Temp qw(tempfile);
use File::Copy;
use POSIX qw(strftime);

########################################################################
# BEGIN Configuration

# The MSI's were extracted from the downloaded(?) EXE's.
# I decided to extract the MSI's because the EXE's provided no extra
#   functionality and provided only a confusing way to pass MSI properties
#   to msiexec (in particular, it expected the set of properties to be enclosed
#   in double quotes---which assumes that the values themselves don't need
#   to be quoted, which isn't a valid assumption).
my $installer_x64 = 'plecs-standalone-4-1-3_win64.msi';


# This package attempts to install just the 64-bit version
#   (if possible). We arbitrarily decide to install the package to
#   '%ProgramFiles%\plexim' ('ProgramFiles\plecs' interferes with plecs blockset)
my $install_dir = 'plexim\plecs 4.1';

# END Configuration
########################################################################


my $srcfiles= get_pkg_sourcefiles();

sub usage {
    print qq(
usage: $0 [--help] [--uninstall]
);
}
GetOptions(
    'help' =&gt; sub { usage(); exit(0); },

    'uninstall' =&gt; sub { exit( ! uninstall() ); },
);


# Begin-Doc
################################
# Name: install_x64()
# Description: Install the 32- and 64-bit versions of PLECS
# Returns: true/false on success/failure (pass-through)
# LastUpdated: 2014-01-02
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub install_x64 {
    return install($installer_x64,'x64',
                build_path(get_arch_programfiles(OSARCH_x64),$install_dir));
}

# Begin-Doc
################################
# Name: install()
# Description: Install the specified MSI.
# Returns: true/false on success/failure (pass-through)
# LastUpdated: 2014-01-02
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub install {
    my $installer = shift;
    my $marker = shift; # appended to log file name
    my $install_dir = shift;

    my $logfile = basename(get_default_app_log());
    $logfile =~ s/\.txt$/_${marker}.txt/i;

    # By default, the (extracted) MSI installs to the 'Personal' shell folder.
    my @msi_props = (
        sprintf('INSTALLDIR="%s"',$install_dir),
        );

    output("   Installing ${marker}: ");
    my $success = 
        install_msi(
            msi =&gt; build_path($srcfiles,$installer),
            additional_msi_properties =&gt; join(' ',@msi_props),
            logfile_indirection =&gt; 1,
            logfile_name =&gt; $logfile,
        );
    output(($success?'OK':'FAILED')."\n");	
    return $success;
}

sub postinstall {
	#Configure license
	#Code adapted from Altera Quartus 12.0, previous methods for licensing PLECS conflict with how FlexLM handles things now.
	#Only changes made were to license server address and port, and changing "altera" to "plecs".
		ShellNotify_WM_SETTINGSCHANGE();
    output("Adding PLECS License Variable...\n");

    my $lm_reg = checkReg('LM_LICENSE_FILE');

     if (!defined($lm_reg) || ($lm_reg !~ m/\b1717\@plecs\.lic\.mst\.edu\b/i))
    {
        output("Adding 1717\@plecs.lic.mst.edu to LM_LICENSE_FILE\n");

        my @paths = split(/;/,$lm_reg || '');
        push(@paths,'1717@plecs.lic.mst.edu');

        my @command = (
            'SETX.EXE',
            'LM_LICENSE_FILE',
            '"'.join(';',@paths).'"',
            (is_XP()?'-M':'/M'),
        );
        if(run_command(join(' ',@command)))
        {
            output("Success!\n");
        }
        else
        {
            output("Failed.\n");
			return 0;
        }
    }
	else {
		output("License already configured.\n");
	}
	return 1;
}

do_install( 
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [ qw(clc desktop traveling virtual-desktop virtual-clc)],
    exit_on_failure =&gt; 1,
    
    install_sub_x64 =&gt; \&amp;install_x64,
	postinstall_sub =&gt; \&amp;postinstall,
);
IM_Exit(EXIT_SUCCESS);


########################################################################

sub checkReg {
  my $env_var = shift;

  return $Registry-&gt;{"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment\\\\".$env_var};
}

# Begin-Doc
################################
# Name: uninstall()
# Description: 
# Returns: 
# Requires: 
# LastUpdated: 
# LastUpdatedBy: 
################################
# End-Doc
sub uninstall {
    output("Uninstalling PLECS Standalone...\n");

    my $success = 1;
    my $count = 0;

    foreach my $appkey (IsAppInstalled('DisplayName' =&gt; qr/^PLECS Standalone/ )) {
        my $k = $Registry-&gt;{$appkey};
        my $dn = $k-&gt;{DisplayName};
        my $dv = $k-&gt;{DisplayVersion};
        my $app_id = basename($appkey);

        output("  ${dn} ${dv} (${app_id}): ");

        my $log = get_default_app_log();
        $log =~ s/(\.[^\.]+)$/_${app_id}_uninstall$1/;

        my $outcome = 
            install_msi( app_id =&gt; $app_id,
                         msi_action_flag =&gt; 'x',
                         logfile =&gt; $log );
        output(($outcome?'OK':'FAILED')."\n");

        $count++;
        $success &amp;&amp;= $outcome;
    }

    delete_product_registry_key(get_package_id());

    output("   No installed versions of PLECS Standalone found!\n")
        if ($count == 0);

    return $success;
}


### subroutine documentation block ###
# Begin-Doc
################################
# Name: 
# Description: 
# Returns: 
# Requires: 
# LastUpdated: 
# LastUpdatedBy: 
################################
# End-Doc

__END__

The EXE appears to be an unintelligent wrapper for the MSI.
Extract the MSI and use it for installation.

plecs-blockset-4-0-3_win64.exe /?

Installation options
    /extract "&lt;Directory&gt;"
        Extracts all installation packages to the specified directory
    /msicl "[PROPERTY=PropertyValue] ..."
        Properties to set for installation
    /lang &lt;LCID&gt;
        Locale ID of transform to apply to installation
    /quiet
        Quiet mode, no user interaction
    /passive
        Unattended mode - progress bar only
    /norestart
        Do not restart after the installation is complete
    /promptrestart
        Prompts the user for restart if necessary
    /forcerestart
        Always restart the computer after installation
    /uninstall
        Uninstalls the product
    /log "&lt;LogFile&gt;"
        Create a log

OK
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\plecs_blockset.4_0_3\prod\update.pl</FullName>
    <Length>12436</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-01-23T15:08:53.6594481-06:00</CreationTime>
    <CreationTimeUtc>2017-01-23T21:08:53.6594481Z</CreationTimeUtc>
    <LastWriteTime>2017-01-25T09:35:27.5666919-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-01-25T15:35:27.5666919Z</LastWriteTimeUtc>
    <LastAccessTime>2017-01-23T15:08:53.6594481-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-01-23T21:08:53.6594481Z</LastAccessTimeUtc>
    <Text># PLECS Blockset Installer
# Package Created November 2013
# Packaged by Charlie Hendricks
# Updated 2014-12-05 by David Crow
# Update for 4.0.3 on 2016-11-28 by Grayson Gratop
# Verification/Completion of 4.0.3 update on 2017-01-03 by John Stinson

=pod

Begin-Doc
Modified: $Date$
Name: PLECS Installer
Type: script
Description: PLECS is a MATLAB module.
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'plecs_blockset.4_0_3',
        package_revision =&gt; '20170104T1316',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

use File::Basename;
use Getopt::Long;
use Win32::TieRegistry;
use File::Temp qw(tempfile);
use File::Copy;
use POSIX qw(strftime);

########################################################################
# BEGIN Configuration

# The MSI's were extracted from the downloaded(?) EXE's.
# I decided to extract the MSI's because the EXE's provided no extra
#   functionality and provided only a confusing way to pass MSI properties
#   to msiexec (in particular, it expected the set of properties to be enclosed
#   in double quotes---which assumes that the values themselves don't need
#   to be quoted, which isn't a valid assumption).
my $installer_x64 = 'plecs-blockset-4-0-3_win64.msi';


# This package attempts to install both the 32- and 64-bit versions
#   (if possible). We arbitrarily decide to install the package to
#   '%ProgramFiles%\plecs' (arch-specific).
# This is the traditional install location. (Previous packages just copied
#   the files---no manageable install.)
my $install_dir = 'plecs';


# END Configuration
########################################################################


my $srcfiles= get_pkg_sourcefiles();

sub usage {
    print qq(
usage: $0 [--help] [--uninstall]
);
}
GetOptions(
    'help' =&gt; sub { usage(); exit(0); },

    'uninstall' =&gt; sub { exit( ! uninstall() ); },
);

# Begin-Doc
################################
# Name: prerequisite_check_x64
# Description: Check to see if a version of PLECS is already installed.
#   Both 32- and 64-bit versions are checked for.
# Returns: true if PLECS is installed, false otherwise
# LastUpdated: 2013-11-15
# LastUpdatedBy: Charlie Hendricks
################################
# End-Doc
sub prerequisite_check {
    my $passed = 1;

    my $plecsEXEx64 = build_path(get_arch_programfiles(OSARCH_x64),
                                 $install_dir, 'plecs.exe');
    if ( -e $plecsEXEx64 ) {
        output("\nERROR Previous version of PLECS found.\n\nCheck Locations:\n\t${plecsEXEx64}\n\nPlease remove old versions and run again.\n");
        $passed = 0;
    }

    return $passed;
}

# Begin-Doc
################################
# Name: install_x64()
# Description: Install the 32- and 64-bit versions of PLECS
# Returns: true/false on success/failure (pass-through)
# LastUpdated: 2014-01-02
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub install_x64 {
    return install($installer_x64,'x64',
                   build_path(get_arch_programfiles(OSARCH_x64),$install_dir));
}

# Begin-Doc
################################
# Name: install()
# Description: Install the specified MSI.
# Returns: true/false on success/failure (pass-through)
# LastUpdated: 2014-01-02
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub install {
    my $installer = shift;
    my $marker = shift; # appended to log file name
    my $install_dir = shift;

    my $logfile = basename(get_default_app_log());
    $logfile =~ s/\.txt$/_${marker}.txt/i;

    # By default, the (extracted) MSI installs to the 'Personal' shell folder.
    my @msi_props = (
        sprintf('INSTALLDIR="%s"',$install_dir),
        );

    output("   Installing ${marker}: ");
    my $success = 
        install_msi(
            msi =&gt; build_path($srcfiles,$installer),
            additional_msi_properties =&gt; join(' ',@msi_props),
            logfile_indirection =&gt; 1,
            logfile_name =&gt; $logfile,
        );
    output(($success?'OK':'FAILED')."\n");
	
    $success &amp;&amp;= configure_matlab_pathdef($install_dir);

    return $success;
}

sub postinstall {
	#Configure license
	#Code adapted from Altera Quartus 12.0, previous methods for licensing PLECS conflict with how FlexLM handles things now.
	#Only changes made were to license server address and port, and changing "altera" to "plecs".
		ShellNotify_WM_SETTINGSCHANGE();
    output("Adding PLECS License Variable...\n");

    my $lm_reg = checkReg('LM_LICENSE_FILE');

     if (!defined($lm_reg) || ($lm_reg !~ m/\b1717\@plecs\.lic\.mst\.edu\b/i))
    {
        output("Adding 1717\@plecs.lic.mst.edu to LM_LICENSE_FILE\n");

        my @paths = split(/;/,$lm_reg || '');
        push(@paths,'1717@plecs.lic.mst.edu');

        my @command = (
            'SETX.EXE',
            'LM_LICENSE_FILE',
            '"'.join(';',@paths).'"',
            (is_XP()?'-M':'/M'),
        );
        if(run_command(join(' ',@command)))
        {
            output("Success!\n");
        }
        else
        {
            output("Failed.\n");
			return 0;
        }
    }
	else {
		output("License already configured.\n");
	}
	return 1;
}

# Begin-Doc
################################
# Name: configure_matlab_pathdef()
# Description: Update MATLAB's path search to include PLECS.
#   The PLECS installer only updates the MATLAB path for the user who ran
#   the install. It needs to be updated for every user.
# Returns: true/false on success/failure
# LastUpdated: 2014-01-14
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub configure_matlab_pathdef {
    my $install_dir = shift;

    my $success = 1;
    my $count = 0;

    my $pgm = dirname($install_dir); # appropriate ProgramFiles
    if (opendir(my $MATLABDIR, build_path($pgm,'MATLAB'))) {
        foreach my $ver (readdir($MATLABDIR)) {
            next if ($ver =~ /^\.?\.$/);

            my $pathdef = build_path($pgm,'MATLAB',$ver,'toolbox','local',
                                     'pathdef.m');

            if (-f $pathdef) {
                my ($PATHDEF,$TEMP_PATHDEF,$temp_pathdef);
                if (!open($PATHDEF,'&lt;',$pathdef)) {
                    output("Error opening '${pathdef}': $!\n");
                    $success = 0;
                    next;
                }
                ($TEMP_PATHDEF,$temp_pathdef) =
                    tempfile('pathdef_plecs_XXXXXXXX',DIR=&gt;$ENV{TEMP});

                my $found_plecs = 0;
                my $found_plecs_demo = 0;

                while ( &lt;$PATHDEF&gt; )
                {
                    if ($_ =~ "plecs" &amp;&amp; !($_ =~ "demos")) {
                        $found_plecs = 1;
                    }
                    if ($_ =~ "plecs" &amp;&amp; $_ =~ "demos") {
                        $found_plecs_demo = 1;
                    }
    
                    if ($_ =~ "%%% END ENTRIES %%%") {
                        # Inject the plecs dirs at the end of the list.
                        if (!$found_plecs) {
                            print $TEMP_PATHDEF "'${install_dir};', ...\n";
                        }
        
                        if (!$found_plecs_demo) {
                            print $TEMP_PATHDEF "'${install_dir}\\demos;', ...\n";
                        }
                    }
                    print $TEMP_PATHDEF $_;
                }

                close $PATHDEF;
                close $TEMP_PATHDEF;

                output("Updated pathdef.m (${temp_pathdef}):\n".
                       get_file_contents($temp_pathdef),
                       LOG_ONLY);
                my $backup_pathdef = 
                    build_path(dirname($pathdef),
                               'pathdef.m.'.strftime('%Y%m%dT%H%M%S',localtime));
                output("Backing up '${pathdef}' to '${backup_pathdef}'\n",
                       LOG_ONLY);
                if (! move($pathdef,$backup_pathdef)) {
                    output("Cannot backup pathdef.m to '${backup_pathdef}': $!\n");
                    $success = 0;
                } elsif (! move($temp_pathdef,$pathdef)) {
                    output("Cannot promote updated pathdef.m to '${pathdef}': $!\n");
                    $success = 0;
                } elsif (! run_command('icacls.exe "'.$pathdef.'" /inheritance:e')) {
                    # The file needs to inherit permissions from the parent.
                    # By default, it doesn't.
                    output("Cannot set permissions on '${pathdef}': $!\n");
                    $success = 0;
                } else {
                    output("   Updated MATLAB pathdef.m for version ${ver} (${pathdef})\n");
                    $count++;
                }
            } else {
                output("No pathdef.m found for MATLAB ${ver}!\n",
                       LOG_ONLY);
            }
        }
    } else {
        output("Error opening MATLAB directory '${pgm}\\MATLAB': $!\n",
               LOG_ONLY);
    }

    return $success;
}

sub checkReg {
  my $env_var = shift;

  return $Registry-&gt;{"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment\\\\".$env_var};
}

do_install( 
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [ qw(clc desktop traveling virtual-desktop virtual-clc)],
    exit_on_failure =&gt; 1,
    prerequisite_sub =&gt; \&amp;prerequisite_check,
    install_sub =&gt; \&amp;install_x64,
	postinstall_sub =&gt; \&amp;postinstall,
);
IM_Exit(EXIT_SUCCESS);


########################################################################

# Begin-Doc
################################
# Name: uninstall()
# Description: 
# Returns: 
# Requires: 
# LastUpdated: 
# LastUpdatedBy: 
################################
# End-Doc
sub uninstall {
    output("Uninstalling PLECS Blockset...\n");

    my $success = 1;
    my $count = 0;

    foreach my $appkey (IsAppInstalled('DisplayName' =&gt; qr/^PLECS Blockset/ )) {
        my $k = $Registry-&gt;{$appkey};
        my $dn = $k-&gt;{DisplayName};
        my $dv = $k-&gt;{DisplayVersion};
        my $app_id = basename($appkey);

        output("  ${dn} ${dv} (${app_id}): ");

        my $log = get_default_app_log();
        $log =~ s/(\.[^\.]+)$/_${app_id}_uninstall$1/;

        my $outcome = 
            install_msi( app_id =&gt; $app_id,
                         msi_action_flag =&gt; 'x',
                         logfile =&gt; $log );
        output(($outcome?'OK':'FAILED')."\n");

        $count++;
        $success &amp;&amp;= $outcome;
    }

    delete_product_registry_key(get_package_id());

    output("   No installed versions of PLECS Blockset found!\n")
        if ($count == 0);

    return $success;
}


### subroutine documentation block ###
# Begin-Doc
################################
# Name: 
# Description: 
# Returns: 
# Requires: 
# LastUpdated: 
# LastUpdatedBy: 
################################
# End-Doc

__END__

The EXE appears to be an unintelligent wrapper for the MSI.
Extract the MSI and use it for installation.

plecs-blockset-3-4-6_win64.exe /?

Installation options
    /extract "&lt;Directory&gt;"
        Extracts all installation packages to the specified directory
    /msicl "[PROPERTY=PropertyValue] ..."
        Properties to set for installation
    /lang &lt;LCID&gt;
        Locale ID of transform to apply to installation
    /quiet
        Quiet mode, no user interaction
    /passive
        Unattended mode - progress bar only
    /norestart
        Do not restart after the installation is complete
    /promptrestart
        Prompts the user for restart if necessary
    /forcerestart
        Always restart the computer after installation
    /uninstall
        Uninstalls the product
    /log "&lt;LogFile&gt;"
        Create a log

OK
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\plecs_blockset.4_0_3\prod.old\update.pl</FullName>
    <Length>11685</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-14T14:36:04.1322753-06:00</CreationTime>
    <CreationTimeUtc>2017-11-14T20:36:04.1322753Z</CreationTimeUtc>
    <LastWriteTime>2017-01-19T13:14:08.5242373-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-01-19T19:14:08.5242373Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-14T14:36:04.1322753-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-14T20:36:04.1322753Z</LastAccessTimeUtc>
    <Text># PLECS Blockset Installer
# Package Created November 2013
# Packaged by Charlie Hendricks
# Updated 2014-12-05 by David Crow
# Update for 4.0.3 on 2016-11-28 by Grayson Gratop
# Verification/Completion of 4.0.3 update on 2017-01-03 by John Stinson

=pod

Begin-Doc
Modified: $Date$
Name: PLECS Installer
Type: script
Description: PLECS is a MATLAB module.
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'plecs_blockset.4_0_3',
        package_revision =&gt; '20170104T1316',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

use File::Basename;
use Getopt::Long;
use Win32::TieRegistry;
use File::Temp qw(tempfile);
use File::Copy;
use POSIX qw(strftime);

########################################################################
# BEGIN Configuration

# The MSI's were extracted from the downloaded(?) EXE's.
# I decided to extract the MSI's because the EXE's provided no extra
#   functionality and provided only a confusing way to pass MSI properties
#   to msiexec (in particular, it expected the set of properties to be enclosed
#   in double quotes---which assumes that the values themselves don't need
#   to be quoted, which isn't a valid assumption).
my $installer_x64 = 'plecs-blockset-4-0-3_win64.msi';


# This package attempts to install both the 32- and 64-bit versions
#   (if possible). We arbitrarily decide to install the package to
#   '%ProgramFiles%\plecs' (arch-specific).
# This is the traditional install location. (Previous packages just copied
#   the files---no manageable install.)
my $install_dir = 'plecs';


# FLEXlm licensing
my $license_file_data = q(
SERVER plecs.lic.mst.edu ANY 1717
USE_SERVER
);
my $license_dir = "C:\\flexlm";

# END Configuration
########################################################################


my $srcfiles= get_pkg_sourcefiles();

sub usage {
    print qq(
usage: $0 [--help] [--uninstall]
);
}
GetOptions(
    'help' =&gt; sub { usage(); exit(0); },

    'uninstall' =&gt; sub { exit( ! uninstall() ); },
);

# Begin-Doc
################################
# Name: prerequisite_check_x64
# Description: Check to see if a version of PLECS is already installed.
#   Both 32- and 64-bit versions are checked for.
# Returns: true if PLECS is installed, false otherwise
# LastUpdated: 2013-11-15
# LastUpdatedBy: Charlie Hendricks
################################
# End-Doc
sub prerequisite_check_x64
{
    my $passed = 1;

    my $plecsEXEx64 = build_path(get_arch_programfiles(OSARCH_x64),
                                 $install_dir, 'plecs.exe');
    if ( -e $plecsEXEx64 ) {
        output("\nERROR Previous version of PLECS found.\n\nCheck Locations:\n\t${plecsEXEx64}\n\nPlease remove old versions and run again.\n");
        $passed = 0;
    }

    return $passed;
}

# Begin-Doc
################################
# Name: install_x64()
# Description: Install the 32- and 64-bit versions of PLECS
# Returns: true/false on success/failure (pass-through)
# LastUpdated: 2014-01-02
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub install_x64 {
    return install($installer_x64,'x64',
                   build_path(get_arch_programfiles(OSARCH_x64),$install_dir));
}

# Begin-Doc
################################
# Name: install()
# Description: Install the specified MSI.
# Returns: true/false on success/failure (pass-through)
# LastUpdated: 2014-01-02
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub install {
    my $installer = shift;
    my $marker = shift; # appended to log file name
    my $install_dir = shift;

    my $logfile = basename(get_default_app_log());
    $logfile =~ s/\.txt$/_${marker}.txt/i;

    # By default, the (extracted) MSI installs to the 'Personal' shell folder.
    my @msi_props = (
        sprintf('INSTALLDIR="%s"',$install_dir),
        );

    output("   Installing ${marker}: ");
    my $success = 
        install_msi(
            msi =&gt; build_path($srcfiles,$installer),
            additional_msi_properties =&gt; join(' ',@msi_props),
            logfile_indirection =&gt; 1,
            logfile_name =&gt; $logfile,
        );
    output(($success?'OK':'FAILED')."\n");

	unless(-e $license_dir)
    {
	  output("Creating installdir");
      mkdir $license_dir;
    }
    
    my $license_file = build_path($license_dir,'license.dat');
    if (open(my $LIC,'&gt;',$license_file)) {
        print $LIC $license_file_data;
        close($LIC);
    } else {
        output("Error opening license file '${license_file}': $!\n");
        $success=0;
    }
	
    $success &amp;&amp;= configure_matlab_pathdef($install_dir);

    return $success;
}


# Begin-Doc
################################
# Name: configure_matlab_pathdef()
# Description: Update MATLAB's path search to include PLECS.
#   The PLECS installer only updates the MATLAB path for the user who ran
#   the install. It needs to be updated for every user.
# Returns: true/false on success/failure
# LastUpdated: 2014-01-14
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub configure_matlab_pathdef {
    my $install_dir = shift;

    my $success = 1;
    my $count = 0;

    my $pgm = dirname($install_dir); # appropriate ProgramFiles
    if (opendir(my $MATLABDIR, build_path($pgm,'MATLAB'))) {
        foreach my $ver (readdir($MATLABDIR)) {
            next if ($ver =~ /^\.?\.$/);

            my $pathdef = build_path($pgm,'MATLAB',$ver,'toolbox','local',
                                     'pathdef.m');

            if (-f $pathdef) {
                my ($PATHDEF,$TEMP_PATHDEF,$temp_pathdef);
                if (!open($PATHDEF,'&lt;',$pathdef)) {
                    output("Error opening '${pathdef}': $!\n");
                    $success = 0;
                    next;
                }
                ($TEMP_PATHDEF,$temp_pathdef) =
                    tempfile('pathdef_plecs_XXXXXXXX',DIR=&gt;$ENV{TEMP});

                my $found_plecs = 0;
                my $found_plecs_demo = 0;

                while ( &lt;$PATHDEF&gt; )
                {
                    if ($_ =~ "plecs" &amp;&amp; !($_ =~ "demos")) {
                        $found_plecs = 1;
                    }
                    if ($_ =~ "plecs" &amp;&amp; $_ =~ "demos") {
                        $found_plecs_demo = 1;
                    }
    
                    if ($_ =~ "%%% END ENTRIES %%%") {
                        # Inject the plecs dirs at the end of the list.
                        if (!$found_plecs) {
                            print $TEMP_PATHDEF "'${install_dir};', ...\n";
                        }
        
                        if (!$found_plecs_demo) {
                            print $TEMP_PATHDEF "'${install_dir}\\demos;', ...\n";
                        }
                    }
                    print $TEMP_PATHDEF $_;
                }

                close $PATHDEF;
                close $TEMP_PATHDEF;

                output("Updated pathdef.m (${temp_pathdef}):\n".
                       get_file_contents($temp_pathdef),
                       LOG_ONLY);
                my $backup_pathdef = 
                    build_path(dirname($pathdef),
                               'pathdef.m.'.strftime('%Y%m%dT%H%M%S',localtime));
                output("Backing up '${pathdef}' to '${backup_pathdef}'\n",
                       LOG_ONLY);
                if (! move($pathdef,$backup_pathdef)) {
                    output("Cannot backup pathdef.m to '${backup_pathdef}': $!\n");
                    $success = 0;
                } elsif (! move($temp_pathdef,$pathdef)) {
                    output("Cannot promote updated pathdef.m to '${pathdef}': $!\n");
                    $success = 0;
                } elsif (! run_command('icacls.exe "'.$pathdef.'" /inheritance:e')) {
                    # The file needs to inherit permissions from the parent.
                    # By default, it doesn't.
                    output("Cannot set permissions on '${pathdef}': $!\n");
                    $success = 0;
                } else {
                    output("   Updated MATLAB pathdef.m for version ${ver} (${pathdef})\n");
                    $count++;
                }
            } else {
                output("No pathdef.m found for MATLAB ${ver}!\n",
                       LOG_ONLY);
            }
        }
    } else {
        output("Error opening MATLAB directory '${pgm}\\MATLAB': $!\n",
               LOG_ONLY);
    }

    return $success;
}

do_install( 
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [ qw(clc desktop traveling virtual-desktop virtual-clc)],
    exit_on_failure =&gt; 1,
    prerequisite_sub_x64 =&gt; \&amp;prerequisite_check_x64,
    install_sub_x64 =&gt; \&amp;install_x64,
);
IM_Exit(EXIT_SUCCESS);


########################################################################

# Begin-Doc
################################
# Name: uninstall()
# Description: 
# Returns: 
# Requires: 
# LastUpdated: 
# LastUpdatedBy: 
################################
# End-Doc
sub uninstall {
    output("Uninstalling PLECS Blockset...\n");

    my $success = 1;
    my $count = 0;

    foreach my $appkey (IsAppInstalled('DisplayName' =&gt; qr/^PLECS Blockset/ )) {
        my $k = $Registry-&gt;{$appkey};
        my $dn = $k-&gt;{DisplayName};
        my $dv = $k-&gt;{DisplayVersion};
        my $app_id = basename($appkey);

        output("  ${dn} ${dv} (${app_id}): ");

        my $log = get_default_app_log();
        $log =~ s/(\.[^\.]+)$/_${app_id}_uninstall$1/;

        my $outcome = 
            install_msi( app_id =&gt; $app_id,
                         msi_action_flag =&gt; 'x',
                         logfile =&gt; $log );
        output(($outcome?'OK':'FAILED')."\n");

        $count++;
        $success &amp;&amp;= $outcome;
    }

    delete_product_registry_key(get_package_id());

    output("   No installed versions of PLECS Blockset found!\n")
        if ($count == 0);

    return $success;
}


### subroutine documentation block ###
# Begin-Doc
################################
# Name: 
# Description: 
# Returns: 
# Requires: 
# LastUpdated: 
# LastUpdatedBy: 
################################
# End-Doc

__END__

The EXE appears to be an unintelligent wrapper for the MSI.
Extract the MSI and use it for installation.

plecs-blockset-3-4-6_win64.exe /?

Installation options
    /extract "&lt;Directory&gt;"
        Extracts all installation packages to the specified directory
    /msicl "[PROPERTY=PropertyValue] ..."
        Properties to set for installation
    /lang &lt;LCID&gt;
        Locale ID of transform to apply to installation
    /quiet
        Quiet mode, no user interaction
    /passive
        Unattended mode - progress bar only
    /norestart
        Do not restart after the installation is complete
    /promptrestart
        Prompts the user for restart if necessary
    /forcerestart
        Always restart the computer after installation
    /uninstall
        Uninstalls the product
    /log "&lt;LogFile&gt;"
        Create a log

OK
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\plecs_blockset.4_1_3\prod\update.pl</FullName>
    <Length>6728</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-01-12T15:36:04.036348-06:00</CreationTime>
    <CreationTimeUtc>2018-01-12T21:36:04.036348Z</CreationTimeUtc>
    <LastWriteTime>2018-02-28T10:05:12.0508378-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-02-28T16:05:12.0508378Z</LastWriteTimeUtc>
    <LastAccessTime>2018-01-12T15:36:04.2745968-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-01-12T21:36:04.2745968Z</LastAccessTimeUtc>
    <Text># PLECS Blockset 4.1.3
# Package Created Winter 2016
# Last Updated 2017-1-5 by Alex Schrimpf

=pod

Begin-Doc
Modified: 
Name: 
Type:
Description: 
Language: Perl
LastUpdatedBy:
Version:
Doc-Package-Info
Doc-SVN-Repository:
RCSId:
End-Doc

=cut

use strict;
use warnings;
our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'plecs_blockset.4_1_3',
        package_revision =&gt; '',
    );
}

use lib ( '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 'C:\temp' );

use InstallMonkey::Shared;
use File::Basename;
use Getopt::Long;
use Win32::TieRegistry;
use File::Temp qw(tempfile);
use File::Copy;
use POSIX qw(strftime);

my $install_dir = "$ENV{PROGRAMFILES}\\plecs";

# Begin-Doc
################################
# Name: configure_matlab_pathdef()
# Description: Update MATLAB's path search to include PLECS.
#   The PLECS installer only updates the MATLAB path for the user who ran
#   the install. It needs to be updated for every user.
# Returns: true/false on success/failure
# LastUpdated: 2014-01-14
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub configure_matlab_pathdef {
    my $install_dir = shift;

    my $success = 1;
    my $count = 0;

    my $pgm = dirname($install_dir); # appropriate ProgramFiles
    if (opendir(my $MATLABDIR, build_path($pgm,'MATLAB'))) {
        foreach my $ver (readdir($MATLABDIR)) {
            next if ($ver =~ /^\.?\.$/);

            my $pathdef = build_path($pgm,'MATLAB',$ver,'toolbox','local',
                                     'pathdef.m');

            if (-f $pathdef) {
                my ($PATHDEF,$TEMP_PATHDEF,$temp_pathdef);
                if (!open($PATHDEF,'&lt;',$pathdef)) {
                    output("Error opening '${pathdef}': $!\n");
                    $success = 0;
                    next;
                }
                ($TEMP_PATHDEF,$temp_pathdef) =
                    tempfile('pathdef_plecs_XXXXXXXX',DIR=&gt;$ENV{TEMP});

                my $found_plecs = 0;
                my $found_plecs_demo = 0;

                while ( &lt;$PATHDEF&gt; )
                {
                    if ($_ =~ "plecs" &amp;&amp; !($_ =~ "demos")) {
                        $found_plecs = 1;
                    }
                    if ($_ =~ "plecs" &amp;&amp; $_ =~ "demos") {
                        $found_plecs_demo = 1;
                    }
    
                    if ($_ =~ "%%% END ENTRIES %%%") {
                        # Inject the plecs dirs at the end of the list.
                        if (!$found_plecs) {
                            print $TEMP_PATHDEF "'${install_dir};', ...\n";
                        }
        
                        if (!$found_plecs_demo) {
                            print $TEMP_PATHDEF "'${install_dir}\\demos;', ...\n";
                        }
                    }
                    print $TEMP_PATHDEF $_;
                }

                close $PATHDEF;
                close $TEMP_PATHDEF;

                output("Updated pathdef.m (${temp_pathdef}):\n".
                       get_file_contents($temp_pathdef),
                       LOG_ONLY);
                my $backup_pathdef = 
                    build_path(dirname($pathdef),
                               'pathdef.m.'.strftime('%Y%m%dT%H%M%S',localtime));
                output("Backing up '${pathdef}' to '${backup_pathdef}'\n",
                       LOG_ONLY);
                if (! move($pathdef,$backup_pathdef)) {
                    output("Cannot backup pathdef.m to '${backup_pathdef}': $!\n");
                    $success = 0;
                } elsif (! move($temp_pathdef,$pathdef)) {
                    output("Cannot promote updated pathdef.m to '${pathdef}': $!\n");
                    $success = 0;
                } elsif (! run_command('icacls.exe "'.$pathdef.'" /inheritance:e')) {
                    # The file needs to inherit permissions from the parent.
                    # By default, it doesn't.
                    output("Cannot set permissions on '${pathdef}': $!\n");
                    $success = 0;
                } else {
                    output("   Updated MATLAB pathdef.m for version ${ver} (${pathdef})\n");
                    $count++;
                }
            } else {
                output("No pathdef.m found for MATLAB ${ver}!\n",
                       LOG_ONLY);
            }
        }
    } else {
        output("Error opening MATLAB directory '${pgm}\\MATLAB': $!\n",
               LOG_ONLY);
    }

    return $success;
}

use IM_helper(
   \%INSTALLMONKEY_OPTIONS,
    v4.04,
    (
        "INSTALL" =&gt; 
        [
            sub {
                IM_helper::run_command(
                    description=&gt;'PLECS Installer',
                    command=&gt;"\"$IM_helper::source_files\\plecs-blockset-4-1-3_win64.msi\" INSTALLDIR=\"$install_dir\" /quiet"
                );
            },
            sub {
                IM_helper::push_to_system_var(
                    name=&gt;"LM_LICENSE_FILE",
                    value=&gt;"1717\@plecs.lic.mst.edu"
                )
            },
            sub {
                IM_helper::flush_msg(msg=&gt;"Setting MATLAB Paths",type=&gt;'running');
                return (configure_matlab_pathdef($install_dir) &amp;&amp; IM_helper::flush_msg(msg=&gt;"Set MATLAB Paths",type=&gt;'success'));
            },
            sub {
                IM_helper::cp_file(
                    from=&gt; "$IM_helper::source_files\\PLECS Blockset 4.1.3 Setup (64 bit).lnk",
                    to_dir=&gt; "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs"
                )
            }
        ],
        "UNINSTALL" =&gt;
        [
            sub {
                IM_helper::uninstall_using_programs_and_features(
                    display_name=&gt;'PLECS Blockset 4.1.3 (64 bit)'
                );
            },
            sub{
                delete_product_registry_key($INSTALLMONKEY_OPTIONS{package_id});
            },
        ]
    )
);

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt;
      [ 'clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    no_install_check =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    no_product_key =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    install_sub =&gt; $IM_helper::exec_call_stack_override || sub{IM_helper::exec_call_stacks(ids=&gt;["INSTALL"])}
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\plecs_blockset.4_1_3\prod.old\update.pl</FullName>
    <Length>12488</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-14T14:35:23.0599829-06:00</CreationTime>
    <CreationTimeUtc>2017-11-14T20:35:23.0599829Z</CreationTimeUtc>
    <LastWriteTime>2017-11-14T15:26:03.565675-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-11-14T21:26:03.565675Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-14T14:35:23.0599829-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-14T20:35:23.0599829Z</LastAccessTimeUtc>
    <Text># PLECS Blockset Installer
# Package Created November 2013
# Packaged by Charlie Hendricks
# Updated 2014-12-05 by David Crow
# Update for 4.0.3 on 2016-11-28 by Grayson Gratop
# Verification/Completion of 4.0.3 update on 2017-01-03 by John Stinson
# Update for 4.1.3 on 2017-11-14 by Grayson Gratop

=pod

Begin-Doc
Modified: $Date$
Name: PLECS Installer
Type: script
Description: PLECS is a MATLAB module.
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'plecs_blockset.4_1_3',
        package_revision =&gt; '20171114T1508',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

use File::Basename;
use Getopt::Long;
use Win32::TieRegistry;
use File::Temp qw(tempfile);
use File::Copy;
use POSIX qw(strftime);

########################################################################
# BEGIN Configuration

# The MSI's were extracted from the downloaded(?) EXE's.
# I decided to extract the MSI's because the EXE's provided no extra
#   functionality and provided only a confusing way to pass MSI properties
#   to msiexec (in particular, it expected the set of properties to be enclosed
#   in double quotes---which assumes that the values themselves don't need
#   to be quoted, which isn't a valid assumption).
my $installer_x64 = 'plecs-blockset-4-1-3_win64.msi';


# This package attempts to install both the 32- and 64-bit versions
#   (if possible). We arbitrarily decide to install the package to
#   '%ProgramFiles%\plecs' (arch-specific).
# This is the traditional install location. (Previous packages just copied
#   the files---no manageable install.)
my $install_dir = 'plecs';


# END Configuration
########################################################################


my $srcfiles= get_pkg_sourcefiles();

sub usage {
    print qq(
usage: $0 [--help] [--uninstall]
);
}
GetOptions(
    'help' =&gt; sub { usage(); exit(0); },

    'uninstall' =&gt; sub { exit( ! uninstall() ); },
);

# Begin-Doc
################################
# Name: prerequisite_check_x64
# Description: Check to see if a version of PLECS is already installed.
#   Both 32- and 64-bit versions are checked for.
# Returns: true if PLECS is installed, false otherwise
# LastUpdated: 2013-11-15
# LastUpdatedBy: Charlie Hendricks
################################
# End-Doc
sub prerequisite_check {
    my $passed = 1;

    my $plecsEXEx64 = build_path(get_arch_programfiles(OSARCH_x64),
                                 $install_dir, 'plecs.exe');
    if ( -e $plecsEXEx64 ) {
        output("\nERROR Previous version of PLECS found.\n\nCheck Locations:\n\t${plecsEXEx64}\n\nPlease remove old versions and run again.\n");
        $passed = 0;
    }

    return $passed;
}

# Begin-Doc
################################
# Name: install_x64()
# Description: Install the 32- and 64-bit versions of PLECS
# Returns: true/false on success/failure (pass-through)
# LastUpdated: 2014-01-02
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub install_x64 {
    return install($installer_x64,'x64',
                   build_path(get_arch_programfiles(OSARCH_x64),$install_dir));
}

# Begin-Doc
################################
# Name: install()
# Description: Install the specified MSI.
# Returns: true/false on success/failure (pass-through)
# LastUpdated: 2014-01-02
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub install {
    my $installer = shift;
    my $marker = shift; # appended to log file name
    my $install_dir = shift;

    my $logfile = basename(get_default_app_log());
    $logfile =~ s/\.txt$/_${marker}.txt/i;

    # By default, the (extracted) MSI installs to the 'Personal' shell folder.
    my @msi_props = (
        sprintf('INSTALLDIR="%s"',$install_dir),
        );

    output("   Installing ${marker}: ");
    my $success = 
        install_msi(
            msi =&gt; build_path($srcfiles,$installer),
            additional_msi_properties =&gt; join(' ',@msi_props),
            logfile_indirection =&gt; 1,
            logfile_name =&gt; $logfile,
        );
    output(($success?'OK':'FAILED')."\n");
	
    $success &amp;&amp;= configure_matlab_pathdef($install_dir);

    return $success;
}

sub postinstall {
	#Configure license
	#Code adapted from Altera Quartus 12.0, previous methods for licensing PLECS conflict with how FlexLM handles things now.
	#Only changes made were to license server address and port, and changing "altera" to "plecs".
		ShellNotify_WM_SETTINGSCHANGE();
    output("Adding PLECS License Variable...\n");

    my $lm_reg = checkReg('LM_LICENSE_FILE');

     if (!defined($lm_reg) || ($lm_reg !~ m/\b1717\@plecs\.lic\.mst\.edu\b/i))
    {
        output("Adding 1717\@plecs.lic.mst.edu to LM_LICENSE_FILE\n");

        my @paths = split(/;/,$lm_reg || '');
        push(@paths,'1717@plecs.lic.mst.edu');

        my @command = (
            'SETX.EXE',
            'LM_LICENSE_FILE',
            '"'.join(';',@paths).'"',
            (is_XP()?'-M':'/M'),
        );
        if(run_command(join(' ',@command)))
        {
            output("Success!\n");
        }
        else
        {
            output("Failed.\n");
			return 0;
        }
    }
	else {
		output("License already configured.\n");
	}
	return 1;
}

# Begin-Doc
################################
# Name: configure_matlab_pathdef()
# Description: Update MATLAB's path search to include PLECS.
#   The PLECS installer only updates the MATLAB path for the user who ran
#   the install. It needs to be updated for every user.
# Returns: true/false on success/failure
# LastUpdated: 2014-01-14
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub configure_matlab_pathdef {
    my $install_dir = shift;

    my $success = 1;
    my $count = 0;

    my $pgm = dirname($install_dir); # appropriate ProgramFiles
    if (opendir(my $MATLABDIR, build_path($pgm,'MATLAB'))) {
        foreach my $ver (readdir($MATLABDIR)) {
            next if ($ver =~ /^\.?\.$/);

            my $pathdef = build_path($pgm,'MATLAB',$ver,'toolbox','local',
                                     'pathdef.m');

            if (-f $pathdef) {
                my ($PATHDEF,$TEMP_PATHDEF,$temp_pathdef);
                if (!open($PATHDEF,'&lt;',$pathdef)) {
                    output("Error opening '${pathdef}': $!\n");
                    $success = 0;
                    next;
                }
                ($TEMP_PATHDEF,$temp_pathdef) =
                    tempfile('pathdef_plecs_XXXXXXXX',DIR=&gt;$ENV{TEMP});

                my $found_plecs = 0;
                my $found_plecs_demo = 0;

                while ( &lt;$PATHDEF&gt; )
                {
                    if ($_ =~ "plecs" &amp;&amp; !($_ =~ "demos")) {
                        $found_plecs = 1;
                    }
                    if ($_ =~ "plecs" &amp;&amp; $_ =~ "demos") {
                        $found_plecs_demo = 1;
                    }
    
                    if ($_ =~ "%%% END ENTRIES %%%") {
                        # Inject the plecs dirs at the end of the list.
                        if (!$found_plecs) {
                            print $TEMP_PATHDEF "'${install_dir};', ...\n";
                        }
        
                        if (!$found_plecs_demo) {
                            print $TEMP_PATHDEF "'${install_dir}\\demos;', ...\n";
                        }
                    }
                    print $TEMP_PATHDEF $_;
                }

                close $PATHDEF;
                close $TEMP_PATHDEF;

                output("Updated pathdef.m (${temp_pathdef}):\n".
                       get_file_contents($temp_pathdef),
                       LOG_ONLY);
                my $backup_pathdef = 
                    build_path(dirname($pathdef),
                               'pathdef.m.'.strftime('%Y%m%dT%H%M%S',localtime));
                output("Backing up '${pathdef}' to '${backup_pathdef}'\n",
                       LOG_ONLY);
                if (! move($pathdef,$backup_pathdef)) {
                    output("Cannot backup pathdef.m to '${backup_pathdef}': $!\n");
                    $success = 0;
                } elsif (! move($temp_pathdef,$pathdef)) {
                    output("Cannot promote updated pathdef.m to '${pathdef}': $!\n");
                    $success = 0;
                } elsif (! run_command('icacls.exe "'.$pathdef.'" /inheritance:e')) {
                    # The file needs to inherit permissions from the parent.
                    # By default, it doesn't.
                    output("Cannot set permissions on '${pathdef}': $!\n");
                    $success = 0;
                } else {
                    output("   Updated MATLAB pathdef.m for version ${ver} (${pathdef})\n");
                    $count++;
                }
            } else {
                output("No pathdef.m found for MATLAB ${ver}!\n",
                       LOG_ONLY);
            }
        }
    } else {
        output("Error opening MATLAB directory '${pgm}\\MATLAB': $!\n",
               LOG_ONLY);
    }

    return $success;
}

sub checkReg {
  my $env_var = shift;

  return $Registry-&gt;{"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment\\\\".$env_var};
}

do_install( 
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [ qw(clc desktop traveling virtual-desktop virtual-clc)],
    exit_on_failure =&gt; 1,
    prerequisite_sub =&gt; \&amp;prerequisite_check,
    install_sub =&gt; \&amp;install_x64,
	postinstall_sub =&gt; \&amp;postinstall,
);
IM_Exit(EXIT_SUCCESS);


########################################################################

# Begin-Doc
################################
# Name: uninstall()
# Description: 
# Returns: 
# Requires: 
# LastUpdated: 
# LastUpdatedBy: 
################################
# End-Doc
sub uninstall {
    output("Uninstalling PLECS Blockset...\n");

    my $success = 1;
    my $count = 0;

    foreach my $appkey (IsAppInstalled('DisplayName' =&gt; qr/^PLECS Blockset/ )) {
        my $k = $Registry-&gt;{$appkey};
        my $dn = $k-&gt;{DisplayName};
        my $dv = $k-&gt;{DisplayVersion};
        my $app_id = basename($appkey);

        output("  ${dn} ${dv} (${app_id}): ");

        my $log = get_default_app_log();
        $log =~ s/(\.[^\.]+)$/_${app_id}_uninstall$1/;

        my $outcome = 
            install_msi( app_id =&gt; $app_id,
                         msi_action_flag =&gt; 'x',
                         logfile =&gt; $log );
        output(($outcome?'OK':'FAILED')."\n");

        $count++;
        $success &amp;&amp;= $outcome;
    }

    delete_product_registry_key(get_package_id());

    output("   No installed versions of PLECS Blockset found!\n")
        if ($count == 0);

    return $success;
}


### subroutine documentation block ###
# Begin-Doc
################################
# Name: 
# Description: 
# Returns: 
# Requires: 
# LastUpdated: 
# LastUpdatedBy: 
################################
# End-Doc

__END__

The EXE appears to be an unintelligent wrapper for the MSI.
Extract the MSI and use it for installation.

plecs-blockset-3-4-6_win64.exe /?

Installation options
    /extract "&lt;Directory&gt;"
        Extracts all installation packages to the specified directory
    /msicl "[PROPERTY=PropertyValue] ..."
        Properties to set for installation
    /lang &lt;LCID&gt;
        Locale ID of transform to apply to installation
    /quiet
        Quiet mode, no user interaction
    /passive
        Unattended mode - progress bar only
    /norestart
        Do not restart after the installation is complete
    /promptrestart
        Prompts the user for restart if necessary
    /forcerestart
        Always restart the computer after installation
    /uninstall
        Uninstalls the product
    /log "&lt;LogFile&gt;"
        Create a log

OK
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\polymath.2017-18\prod\update.pl</FullName>
    <Length>3594</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-07-17T08:59:00.7817753-05:00</CreationTime>
    <CreationTimeUtc>2017-07-17T13:59:00.7817753Z</CreationTimeUtc>
    <LastWriteTime>2017-07-18T09:18:21.5987946-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-07-18T14:18:21.5987946Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-17T08:59:00.7817753-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-17T13:59:00.7817753Z</LastAccessTimeUtc>
    <Text># Package Created 2015-07-13
# Package created by Ryan Andrews, converted from previous version
# Last Updated 2017-7-17 by Sergey Gruzdev

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS =
    (
        package_id =&gt; 'polymath.2017-2018',
        package_revision =&gt; '20170717T0844',
    );
}


use lib
(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);


use InstallMonkey::Shared;
use Getopt::Long;
GetOptions(
    'uninstall' =&gt; sub { exit(! uninstall()); },
);
sub uninstall {
    my $srcfiles = get_pkg_sourcefiles();
    
    output("Uninstalling Polymath EDU Site 2016-2017: ");
    my $Success = install_msi(
        msi =&gt; "$srcfiles\\msi\\Polymath EDU Site License 2017-18.msi",
        msi_action_flag =&gt; 'x',
    );
    
    output($Success ? "Success!\n" : "FAILED: $!\n");
    
    if ($Success) { delete_product_registry_key('polymath.2016-2017'); }
    
    return $Success;
}

sub install
{
    my $srcfiles = get_pkg_sourcefiles();
    
    output("Installing Polymath EDU Site 2016-2017: ");
    my $Success = install_msi(
        msi =&gt; "$srcfiles\\msi\\Polymath EDU Site License 2017-18.msi",
        'IgnoreExitCodes' =&gt; [ 3010, 194 ],
    );
    
    output($Success ? "Success!\n" : "FAILED: $!\n");
    
    return $Success;
}

sub postinstall
{
    my $allusersdesktop = get_allusers_desktop();
    my $srcfiles = get_pkg_sourcefiles();


    # So, even though in the ticket it doesn't explicitly ask us to install the Excel plugin, judging by the fact that they're throwing a lot of documentation at us as to
    # how to do it, I'm guessing they want it configured for them. Unfortunately, their docs are for how to do it via the GUI, which we can't readily use.
    my $excelAddinPath = get_arch_programfiles(OSARCH_x86)."\\Polymath Software\\Polymath EDU Site 2017-18\\ODE_Solver.xla";
    my $excelAddinFolderPath = get_arch_programfiles(OSARCH_x86).'\Microsoft Office\Office15\XLSTART';
    unless(-d $excelAddinFolderPath)
    {
        $excelAddinFolderPath = get_arch_programfiles(OSARCH_x86).'\Microsoft Office\Office14\XLSTART';
    }
    unless(-d $excelAddinFolderPath)
    {
        $excelAddinFolderPath = get_arch_programfiles(OSARCH_x86).'\Microsoft Office\Office16\XLSTART';
    }
    output("Installing Excel addin\n");
    if(!run_command("COPY \"$excelAddinPath\" \"$excelAddinFolderPath\"")) {
        output("Failed to install the Excel addon.\n");
        return 0;
    } else {
      output("Installed.\n");
    }

    my $delcmd = "DEL /Q \"$allusersdesktop\\Polymath EDU Site 6.2.lnk\"";
    output "\nDeleting desktop icon with command: $delcmd";
    if(!run_command($delcmd))
    {
        output("\nPolymath icon removal unsuccessful.\n\n");
        return 0;
    }
    else
    {
      output "\nDesktop icon removed\n\n";
    }
    return 1;
}


do_install
( 
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [ 'desktop', 'clc', 'traveling', 'virtual-desktop', 'virtual-clc' ],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);


IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\polymath.2018-19\prod\update.pl</FullName>
    <Length>3572</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-07-20T14:20:55.2932916-05:00</CreationTime>
    <CreationTimeUtc>2018-07-20T19:20:55.2932916Z</CreationTimeUtc>
    <LastWriteTime>2018-07-23T10:07:56.3137558-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-23T15:07:56.3137558Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-17T08:59:00-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-17T13:59:00Z</LastAccessTimeUtc>
    <Text># Package Created 2018-07-20
# Package created by Alexander Matthes, converted from previous version
# Last Updated 

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS =
    (
        package_id =&gt; 'polymath.2018-2019',
        package_revision =&gt; '20180720T1622',
    );
}


use lib
(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);


use InstallMonkey::Shared;
use Getopt::Long;
GetOptions(
    'uninstall' =&gt; sub { exit(! uninstall()); },
);
sub uninstall {
    my $srcfiles = get_pkg_sourcefiles();
    
    output("Uninstalling Polymath EDU Site 2018-2019: ");
    my $Success = install_msi(
        msi =&gt; "$srcfiles\\msi\\Polymath EDU Site 6.2 2018-19.msi",
        msi_action_flag =&gt; 'x',
    );
    
    output($Success ? "Success!\n" : "FAILED: $!\n");
    
    if ($Success) { delete_product_registry_key('polymath.2018-2019'); }
    
    return $Success;
}

sub install
{
    my $srcfiles = get_pkg_sourcefiles();
    
    output("Installing Polymath EDU Site 2018-2019: ");
    my $Success = install_msi(
        msi =&gt; "$srcfiles\\msi\\Polymath EDU Site 6.2 2018-19.msi",
        'IgnoreExitCodes' =&gt; [ 3010, 194 ],
    );
    
    output($Success ? "Success!\n" : "FAILED: $!\n");
    
    return $Success;
}

sub postinstall
{
    my $allusersdesktop = get_allusers_desktop();
    my $srcfiles = get_pkg_sourcefiles();


    # So, even though in the ticket it doesn't explicitly ask us to install the Excel plugin, judging by the fact that they're throwing a lot of documentation at us as to
    # how to do it, I'm guessing they want it configured for them. Unfortunately, their docs are for how to do it via the GUI, which we can't readily use.
    my $excelAddinPath = get_arch_programfiles(OSARCH_x86)."\\Polymath Software\\Polymath EDU Site 2018-19\\ODE_Solver.xla";
    my $excelAddinFolderPath = get_arch_programfiles(OSARCH_x86).'\Microsoft Office\Office15\XLSTART';
    unless(-d $excelAddinFolderPath)
    {
        $excelAddinFolderPath = get_arch_programfiles(OSARCH_x86).'\Microsoft Office\Office14\XLSTART';
    }
    unless(-d $excelAddinFolderPath)
    {
        $excelAddinFolderPath = get_arch_programfiles(OSARCH_x86).'\Microsoft Office\Office16\XLSTART';
    }
    output("Installing Excel addin\n");
    if(!run_command("COPY \"$excelAddinPath\" \"$excelAddinFolderPath\"")) {
        output("Failed to install the Excel addon.\n");
        return 0;
    } else {
      output("Installed.\n");
    }

    my $delcmd = "DEL /Q \"$allusersdesktop\\Polymath EDU 6.2 Site 2018-19.lnk\"";
    output "\nDeleting desktop icon with command: $delcmd";
    if(!run_command($delcmd))
    {
        output("\nPolymath icon removal unsuccessful.\n\n");
        return 0;
    }
    else
    {
      output "\nDesktop icon removed\n\n";
    }
    return 1;
}


do_install
( 
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [ 'desktop', 'clc', 'traveling', 'virtual-desktop', 'virtual-clc' ],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);


IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\powerdms_author.2\dev\update.pl</FullName>
    <Length>2257</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-09-29T16:28:09.6992121-05:00</CreationTime>
    <CreationTimeUtc>2016-09-29T21:28:09.6992121Z</CreationTimeUtc>
    <LastWriteTime>2016-10-06T09:33:11.0184079-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-10-06T14:33:11.0184079Z</LastWriteTimeUtc>
    <LastAccessTime>2016-09-29T16:28:09.6992121-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-09-29T21:28:09.6992121Z</LastAccessTimeUtc>
    <Text># PowerDMS Author for All Users
# Package Created September 2016	
# Packaged by Chris Schaaf
# Last Updated ...

use strict;
use warnings;
use Getopt::long;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'PowerDMS_Author.2',
        package_revision =&gt; '20160929T1615',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

#my $programfiles = "C:\\Program Files\\PowerDMS Author";
#my $shortcuts = "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\PowerDMS, Inc";
#my $startup = "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\PowerDMS Author.lnk";
my $srcfiles=get_pkg_sourcefiles();
my $cert = "$srcfiles\\powerdms.cer";

sub usage {
    print qq(
usage: $0 [--help] [--uninstall]

);
}
GetOptions(
    'help' =&gt; sub { usage(); exit(0); },
    'uninstall' =&gt; sub { exit(!uninstall()); },
);

sub pre_install {
	output("Installing certificate: ");
	if(!run_command("certutil -addstore \"TrustedPublisher\" \"$cert\"")) {
		output("Failed ($cert)\n INSTALL MAY HANG / REQUIRE INPUT\n");
	}
	output("OK\n");
	return 1;
}

sub install {
	output("\nRunning Installer: ");
	#Run extracted msi
	if(!run_command("\"$srcfiles\\PowerDMS Author.msi\" /qn")) {
		output("ERROR\n");
		return 0;
	}
	output("OK\n");
	return 1;
}

sub uninstall {
	output("Uninstalling program: ");
	if(!run_command("")) {
		output("FAILED TO IMPLEMENT\n");
		return 0;
	}
	output("OK\nDeleting Certificate: ");
	if(!run_command("certutil -delstore \"TrustedPublisher\" \"$cert\"")) {
		output("failed ($cert)\n INSTALL MAY HANG / REQUIRE INPUT\n");
	}
	output("OK\n");
	delete_product_registry_key(get_package_name().".".get_version());
	return 1;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86, OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
	need_reboot =&gt; 1,
    install_sub =&gt; \&amp;install,
	preinstall_sub =&gt; \&amp;pre_install,
);

IM_Exit(EXIT_SUCCESS);


</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\powerdms_author.2\dev2\update.pl</FullName>
    <Length>1840</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-09-30T13:22:02.0112357-05:00</CreationTime>
    <CreationTimeUtc>2016-09-30T18:22:02.0112357Z</CreationTimeUtc>
    <LastWriteTime>2016-09-30T12:02:48.3346206-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-09-30T17:02:48.3346206Z</LastWriteTimeUtc>
    <LastAccessTime>2016-09-30T13:22:02.0112357-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-09-30T18:22:02.0112357Z</LastAccessTimeUtc>
    <Text># PowerDMS Author for All Users
# Package Created September 2016	
# Packaged by Chris Schaaf
# Last Updated ...

use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'PowerDMS_Author.2',
        package_revision =&gt; '20160929T1615',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

sub install {
	my $srcfiles=get_pkg_sourcefiles();
	output("\n Copying installation files: ");
	#Copy over main installation files
	if(!run_command("xcopy \"$srcfiles\\PowerDMS Author\" \"C:\\Program Files\\PowerDMS Author\" /Y/E/F/I")) {
		output("ERROR");
		return 0;
	}
	output("OK\nCopying shortcuts: ");
	#Place shortcuts
	if(!run_command("xcopy \"$srcfiles\\PowerDMS, Inc\" \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\PowerDMS, Inc\" /Y/E/F/I")) {
		output("ERROR");
		return 0;
	}
	output("OK\nCopying registry changes: ");
	#add modified registry values
	if(!run_command("regedit /s \"$srcfiles\allkeys.reg\"")) {
		output("ERROR");
		return 0;
	}
	output("OK\nSetting to run on startup: ");
	#Set application to run on startup
	if(!run_command("copy /Y \"$srcfiles\\PowerDMS, Inc\\PowerDMS Author\\PowerDMS Author.lnk\" \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\PowerDMS Author.lnk\"")) {
		output("ERROR");
		return 0;
	}
	output("OK\n");
	return 1;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86, OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
	need_reboot =&gt; 1,
    install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);


</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\powerdms_author.2\prod\update.pl</FullName>
    <Length>2809</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-09-30T14:46:41.7185205-05:00</CreationTime>
    <CreationTimeUtc>2016-09-30T19:46:41.7185205Z</CreationTimeUtc>
    <LastWriteTime>2016-09-30T14:44:09.7247976-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-09-30T19:44:09.7247976Z</LastWriteTimeUtc>
    <LastAccessTime>2016-09-30T14:46:41.7185205-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-09-30T19:46:41.7185205Z</LastAccessTimeUtc>
    <Text># PowerDMS Author for All Users
# Package Created September 2016	
# Packaged by Chris Schaaf
# Last Updated ...

use strict;
use warnings;
use Getopt::long;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'PowerDMS_Author.2',
        package_revision =&gt; '20160929T1615',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

my $programfiles = "C:\\Program Files\\PowerDMS Author";
my $shortcuts = "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\PowerDMS, Inc";
my $startup = "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\PowerDMS Author.lnk";

sub usage {
    print qq(
usage: $0 [--help] [--uninstall]

);
}
GetOptions(
    'help' =&gt; sub { usage(); exit(0); },
    'uninstall' =&gt; sub { exit(!uninstall()); },
);

sub install {
	my $srcfiles=get_pkg_sourcefiles();
	output("\n Copying installation files: ");
	#Copy over main installation files
	if(!run_command("xcopy \"$srcfiles\\PowerDMS Author\" \"$programfiles\" /Y/E/F/I")) {
		output("ERROR");
		return 0;
	}
	output("OK\nCopying shortcuts: ");
	#Place shortcuts
	if(!run_command("xcopy \"$srcfiles\\PowerDMS, Inc\" \"$shortcuts\" /Y/E/F/I")) {
		output("ERROR");
		return 0;
	}
	#output("OK\nCopying registry changes: ");
	#add modified registry values
	#if(!run_command("regedit /s \"$srcfiles\allkeys.reg\"")) {
	#	output("ERROR");
	#	return 0;
	#}
	output("OK\nSetting to run on startup: ");
	#Set application to run on startup
	if(!run_command("copy /Y \"$srcfiles\\PowerDMS, Inc\\PowerDMS Author\\PowerDMS Author.lnk\" \"$startup\"")) {
		output("ERROR");
		return 0;
	}
	output("OK\n");
	return 1;
}

sub uninstall {
	output("Uninstalling program...   ");
	if(!run_command("taskkill /f /im PowerDMSAuthor.exe /T")) {
		output("Failed to stop service or service not running!\n");
	}
	if(!run_command("rd /s /q \"$programfiles\" /S")) {
		output("Failed to remove program directory!\n");
		return 0;
	}
	if(!run_command("rd /s /q \"$shortcuts\" /S")) {
		output("Failed to remove program directory!\n");
		return 0;
	}
	if(!run_command("del \"$startup\"")) {
		output("Failed to remove startup shortcut!\n");
		return 0;
	}
	output("Success!\n");
	delete_product_registry_key(get_package_name().".".get_version());
	return 1;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86, OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
	need_reboot =&gt; 1,
    install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);


</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\prevent_edge_default_associations.1\prod\update.pl</FullName>
    <Length>2300</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-02-22T12:46:05.8210235-06:00</CreationTime>
    <CreationTimeUtc>2017-02-22T18:46:05.8210235Z</CreationTimeUtc>
    <LastWriteTime>2017-02-27T12:29:28.8024744-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-02-27T18:29:28.8024744Z</LastWriteTimeUtc>
    <LastAccessTime>2017-02-27T12:29:28.8024744-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-02-27T18:29:28.8024744Z</LastAccessTimeUtc>
    <Text># Prevent Edge from being the Default PDF viewer and Browser in Windows 10
# Package Created February, 2017
# Packaged by Ryan Andrews
# Last Updated ...
# Every time our version of Windows 10 recieves a significant update, this
# - script will need to be updated. See http://www.winhelponline.com/blog/edge-hijack-pdf-htm-associations/

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;
use Win32::TieRegistry;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
      package_id =&gt; 'prevent_edge_default_browser.1',
      package_revision =&gt; '20170222T1250',
  );
}

# Add InstallMonkey Library to the path
use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use Getopt::Long;
use InstallMonkey::Shared;

sub install {
    my $windows_packages = $Registry-&gt;{"HKEY_CURRENT_USER\\SOFTWARE\\Classes\\Local Settings\\Software\\Microsoft\\Windows"}-&gt;{"CurrentVersion"}-&gt;{"AppModel"}-&gt;{"Repository\\"};
	#print($windows_packages-&gt;MemberNames);
	#my $microsoftEdgekey = undef;

	foreach my $subKey ($windows_packages -&gt; MemberNames) {
	print($subKey . "\n");
	#	if ($subKey =~ /Microsoft\.MicrosoftEdge_.*/) {
	#		$microsoftEdgekey = $subKey;
	#		last;
	#	}
	}
	#if (defined($microsoftEdgekey)) {
	#	my $edge_file_assocs = $windows_packages -&gt; {$microsoftEdgekey . "\\MicrosoftEdge\\Capabilities\\FileAssociations\\"};
	#	my $pdf_prgm_id = $edge_file_assocs -&gt; {"\\.pdf"};
	#	print($pdf_prgm_id);
	#}
	print($windows_packages-&gt;{"Repository"});
	return 1;
}

do_install( 
  no_source_files           =&gt; "1",
  allowed_versions =&gt; [OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  #preinstall_sub =&gt; \&amp;preInstall,
  install_sub =&gt; \&amp;install,
  #postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>clean_printer_config.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\printer.3\prod\clean_printer_config.pl</FullName>
    <Length>1098</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-03-25T15:27:12.0966993-05:00</CreationTime>
    <CreationTimeUtc>2016-03-25T20:27:12.0966993Z</CreationTimeUtc>
    <LastWriteTime>2016-03-16T13:30:42.1510832-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-03-16T18:30:42.1510832Z</LastWriteTimeUtc>
    <LastAccessTime>2016-03-25T15:27:12.0966993-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-03-25T20:27:12.0966993Z</LastAccessTimeUtc>
    <Text>#!perl

use strict;
use warnings;

use Data::Dumper;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'printer_setup.1',
    );
}
use lib('\\\\minerfiles.mst.edu\dfs\software\loginscripts\im');
use InstallMonkey::Shared;
use InstallMonkey::Printer;

# Delete all printers.
# Ensure that none are listed.
# Delete all drivers.
# Ensure that none are listed.
# Delete all ports.
# Ensure that none are listed.

my @not_deleted;

InstallMonkey::Printer::DeleteAllPrinters();
@not_deleted = GetPrinters();
if (@not_deleted != 0) {
    print("Not all printers deleted.\n");
    exit(1);
}
InstallMonkey::Printer::DeleteAllUnusedPrinterDrivers();
@not_deleted = GetPrinterDrivers();
if (@not_deleted != 0) {
    print("Not all drivers removed.\n");
    exit(1);
}
InstallMonkey::Printer::DeleteAllIPPPorts();
@not_deleted = GetIPPPorts();
if (@not_deleted != 0) {
    print("Not all IPP ports removed.\n");
    exit(1);
}


#InstallMonkey::Printer::ConvertLPRPorts();


print("Printer configuration cleaned.\n");
</Text>
  </Script>
  <Script>
    <Name>create_generic.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\printer.3\prod\create_generic.pl</FullName>
    <Length>2719</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-03-25T15:27:12.2059021-05:00</CreationTime>
    <CreationTimeUtc>2016-03-25T20:27:12.2059021Z</CreationTimeUtc>
    <LastWriteTime>2016-03-16T13:30:42.197885-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-03-16T18:30:42.197885Z</LastWriteTimeUtc>
    <LastAccessTime>2016-03-25T15:27:12.2059021-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-03-25T20:27:12.2059021Z</LastAccessTimeUtc>
    <Text>#!perl

# This script should be used to create a generic printer for the sake of
#   configuring its device-specific settings and exporting them so that
#   those settings can later be imported when the production package runs.

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'im_printer.2',
        suppress_header =&gt; 1,
    );
}
use lib('\\\\minerfiles.mst.edu\dfs\software\loginscripts\im');
use InstallMonkey::Shared;
use InstallMonkey::Printer;

use JSON;
use Data::Dumper;

my $generic_name = 0;
my $use_printer_data = 1;

use Getopt::Long;
Getopt::Long::Configure(qw(pass_through));
sub usage {
    print qq(
usage: $0 [--help] [--generic] [--no-printer-data] &lt;printer_settings.json&gt;

--generic
  Don't use the name of the printer from the metadata.
  Use the generic name instead. (This is primarily for development, to
    configure device-specific settings and export them.)

--no-printer-data
  Don't import any printer data.


Create a printer based on the printer description metadata in the specified
file.

Expectation of metadata:
{
    "printer-name"            : "useful printer name",
    "driver-inf"              : "relative_path_to_inf",
    "driver-model"            : "driver model",
    "campus-lpr-queue"        : "LPR_queue_name",
    "printer-device-settings" : "relative_path_to_printer-data_file"
}

'printer-device-settings' is optional.

);

}
GetOptions(
    'help' =&gt; sub { usage(); exit(0); },

    'generic' =&gt; \$generic_name,
    'printer-data!' =&gt; \$use_printer_data,
);

my $metadata_file = shift;

die("Cannot find metadata file: '${metadata_file}'")
    if (! -f $metadata_file);
my $printer_info = get_file_contents($metadata_file);
$printer_info =~ s/^\s*\/\/.*$//mg; # strip comments
my $printer_data;
eval {
    $printer_data = decode_json($printer_info);
};
if ($@) {
    die("Error decoding JSON from ('${metadat_file}'): $@\n");
}

my %args = %$printer_data;
if ($generic_name) {
    $args{'printer-name'} = $InstallMonkey::Printer::utility_printer_name;
}
if (! $use_printer_data ) {
    delete $args{'printer-device-settings'};
}

# Change the INF path relative to the 'data' directory.
if (! -f $args{'driver-inf'}) {
    my $path = build_path('data',$args{'driver-inf'});
    if (-f $path) {
        $args{'driver-inf'} = $path;
    }
}
if (! -f $args{'driver-inf'}) {
    die("Cannot find driver-inf referred to in metadata file '".
        $args{'driver-inf'}."'\n");
}

print(Dumper(\%args));

my $printer = CreatePrinter(%args);

print(Dumper($printer));
exit( ! defined($printer) ); # 0 if it was created successfully
</Text>
  </Script>
  <Script>
    <Name>export_printer_data.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\printer.3\prod\export_printer_data.pl</FullName>
    <Length>1283</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-03-25T15:27:12.2527033-05:00</CreationTime>
    <CreationTimeUtc>2016-03-25T20:27:12.2527033Z</CreationTimeUtc>
    <LastWriteTime>2016-03-16T13:30:42.2446868-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-03-16T18:30:42.2446868Z</LastWriteTimeUtc>
    <LastAccessTime>2016-03-25T15:27:12.2527033-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-03-25T20:27:12.2527033Z</LastAccessTimeUtc>
    <Text>#!perl

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'im_printer.1',
    );
}
use lib('\\\\minerfiles.mst.edu\dfs\software\loginscripts\im');
use InstallMonkey::Shared;
use InstallMonkey::Printer;


use Getopt::Long;

my $printer_name;
my $output_file;

Getopt::Long::Configure(qw(pass_through));
sub usage {
    print qq(
usage: $0 [--help] {--printer &lt;printer_name&gt;|--generic} &lt;output_file&gt;

Export the Printer Data for the specified printer.

--generic
  Use the IT default (internal) generic name for printers created by the
    InstallMonkey::Printer library.

);

}
GetOptions(
    'help' =&gt; sub { usage(); exit(0); },

    'printer=s' =&gt; \$printer_name,
    'generic'   =&gt; sub { $printer_name = $InstallMonkey::Printer::utility_printer_name; },
);
$output_file = shift;

if (!$printer_name) {
    print('No printer name specified');
    usage();
    exit(87);
}
if (!$output_file) {
    print('No output file was specified');
    usage();
    exit(87);
}

print("Saving settings for '${printer_name}' to '${output_file}'\n");
exit(
! SavePrinterSettings(
      'printer-name' =&gt; $printer_name,
      'settings' =&gt; 'PrinterData',
      'output-file' =&gt; $output_file,
    ));
</Text>
  </Script>
  <Script>
    <Name>install_INSTANCE_template.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\printer.3\prod\install_INSTANCE_template.pl</FullName>
    <Length>634</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-03-25T15:27:12.2995045-05:00</CreationTime>
    <CreationTimeUtc>2016-03-25T20:27:12.2995045Z</CreationTimeUtc>
    <LastWriteTime>2016-03-16T13:30:42.2914886-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-03-16T18:30:42.2914886Z</LastWriteTimeUtc>
    <LastAccessTime>2016-03-25T15:27:12.2995045-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-03-25T20:27:12.2995045Z</LastAccessTimeUtc>
    <Text>#!perl

use File::Basename;
use File::Spec;

#
# This is a template for invoking the common installer
#   (install_printer.pl), specifying the specific printer metadata
#   file, and passing through any other arguments given to it on the
#   command-line.
#

my $command =
    join(' ',
         'perl.exe',
         '"'.File::Spec-&gt;canonpath(File::Spec-&gt;catdir(dirname($0),
                                                      'install_printer.pl')).'"',
         '&lt;PRINTER_JSON_FILE&gt;',
         (@ARGV&gt;0?'"'.join('" "',@ARGV).'"':()),
    );

my $rc = system($command);
$rc &gt;&gt;= 8;
exit($rc); # pass-through
</Text>
  </Script>
  <Script>
    <Name>install_printer.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\printer.3\prod\install_printer.pl</FullName>
    <Length>3356</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-03-25T15:29:41.9697421-05:00</CreationTime>
    <CreationTimeUtc>2016-03-25T20:29:41.9697421Z</CreationTimeUtc>
    <LastWriteTime>2017-08-09T14:22:20.6732406-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-08-09T19:22:20.6732406Z</LastWriteTimeUtc>
    <LastAccessTime>2016-03-25T15:29:41.9697421-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-03-25T20:29:41.9697421Z</LastAccessTimeUtc>
    <Text>#!perl

# This file should be the same for all printer install packages.
# Because the script cannot be shared among the packages without also sharing
#   all the sourcefiles data, it should be copied to each package directory,
#   though it shouldn't need to be modified.

$|=1;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'printer_setup.1',
    );
}
use lib('\\\\minerfiles.mst.edu\dfs\software\loginscripts\im');
use InstallMonkey::Shared;
use InstallMonkey::Printer;

my $debug = 0;
my $override_name = '';

use File::Basename;

use Getopt::Long;
sub usage {
    print qq(
usage: $0 [--help] [--debug] &lt;printer_info.json&gt; [--name &lt;printer_name&gt;]

Install the printer described in the specified JSON file.

--name
  If a name is specified, use it. Otherwise, use the name given in the
    metadata file.
  If you specify this option, do not attempt to install more than one
    printer at a time (the script will try to use the same name for
    each of them).

The JSON data corresponds to an object whose fields match parameters to
  InstallMonkey::Printer::CreatePrinter().

);

}
Getopt::Long::Configure(qw(pass_through));
GetOptions(
    'help' =&gt; sub { usage(); exit(0); },

    'debug' =&gt; \$debug,

    'name=s' =&gt; \$override_name,
);
if (!@ARGV) {
    output("No printer description (JSON) file specified.\n");
    usage();
    exit(87);
}
my @printer_info = @ARGV;


sub configure_printer {
    # Files referenced by the JSON data are relative to the 'data' directory.
    #run_command("psexec -accepteula -u MST-USERS\\desktop1 -p \"ano|ano1\" robocopy /s \\\\minerfiles\\dfs\\software\\itwindist\\appdeploy\\printers C:\\SourceFiles\\printer_setup.1\\stuff");

    my $data_path = "C:\\SourceFiles\\printer_setup.1\\drivers";
    output("  chdir() to '${data_path}'\n", LOG_ONLY);
    push_dir($data_path);

    my @addl_args;
    if ($override_name) {
    push(@addl_args,'override',{'printer-name' =&gt; $override_name});
    }
	my $old_debug,$old_level;
    if ($debug) {
        ($old_debug,$old_level) = (
            $InstallMonkey::Shared::__debug,
            $InstallMonkey::Shared::__debug_level,
            );
        $InstallMonkey::Shared::__debug = 1;
        $InstallMonkey::Shared::__debug_level = 9;
    }
    foreach my $printer_info (@printer_info) {
        output("   Configuring printer for '${printer_info}': ");
        my $printer = CreatePrinterFromJSON($printer_info,@addl_args);
        if (!$printer) {
            output("FAILED!\n");
            return 0;
        }
    }
    if ($debug) {
        (
            $InstallMonkey::Shared::__debug,
            $InstallMonkey::Shared::__debug_level,
        ) = (
            $old_debug,
            $old_level
        );
    }

    output("OK\n");
    return 1;
}

do_install( 
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [ qw(clc desktop traveling virtual-clc virtual-desktop) ],
    exit_on_failure =&gt; 1,
    no_install_check =&gt; 1, # We use the same package ID for all printers.
    no_source_files =&gt; 0, # Local copies of the files is not really useful.
    install_sub =&gt; \&amp;configure_printer,
);
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>install_printer.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\printer.3\test-printer\install_printer.pl</FullName>
    <Length>3360</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-03-16T16:20:48.9994242-05:00</CreationTime>
    <CreationTimeUtc>2016-03-16T21:20:48.9994242Z</CreationTimeUtc>
    <LastWriteTime>2016-03-25T15:28:27.1034225-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-03-25T20:28:27.1034225Z</LastWriteTimeUtc>
    <LastAccessTime>2016-03-16T16:20:48.9994242-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-03-16T21:20:48.9994242Z</LastAccessTimeUtc>
    <Text>#!perl

# This file should be the same for all printer install packages.
# Because the script cannot be shared among the packages without also sharing
#   all the sourcefiles data, it should be copied to each package directory,
#   though it shouldn't need to be modified.

$|=1;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'printer_setup.1',
    );
}
use lib('\\\\minerfiles.mst.edu\dfs\software\loginscripts\im');
use InstallMonkey::Shared;
use InstallMonkey::Printer;

my $debug = 0;
my $override_name = '';

use File::Basename;

use Getopt::Long;
sub usage {
    print qq(
usage: $0 [--help] [--debug] &lt;printer_info.json&gt; [--name &lt;printer_name&gt;]

Install the printer described in the specified JSON file.

--name
  If a name is specified, use it. Otherwise, use the name given in the
    metadata file.
  If you specify this option, do not attempt to install more than one
    printer at a time (the script will try to use the same name for
    each of them).

The JSON data corresponds to an object whose fields match parameters to
  InstallMonkey::Printer::CreatePrinter().

);

}
Getopt::Long::Configure(qw(pass_through));
GetOptions(
    'help' =&gt; sub { usage(); exit(0); },

    'debug' =&gt; \$debug,

    'name=s' =&gt; \$override_name,
);
if (!@ARGV) {
    output("No printer description (JSON) file specified.\n");
    usage();
    exit(87);
}
my @printer_info = @ARGV;


sub configure_printer {
    # Files referenced by the JSON data are relative to the 'data' directory.
    run_command("psexec -accepteula -u MST-USERS\\desktop1 -p \"ano|ano1\" robocopy /s \\\\minerfiles\\dfs\\software\\itwindist\\appdeploy\\printers C:\\SourceFiles\\printer_setup.1\\stuff");

    my $data_path = "C:\\SourceFiles\\printer_setup.1\\drivers";
    output("  chdir() to '${data_path}'\n", LOG_ONLY);
    push_dir($data_path);

    my @addl_args;
    if ($override_name) {
    push(@addl_args,'override',{'printer-name' =&gt; $override_name});
    }

    my $old_debug,$old_level;
    if ($debug) {
        ($old_debug,$old_level) = (
            $InstallMonkey::Shared::__debug,
            $InstallMonkey::Shared::__debug_level,
            );
        $InstallMonkey::Shared::__debug = 1;
        $InstallMonkey::Shared::__debug_level = 9;
    }
    foreach my $printer_info (@printer_info) {
        output("   Configuring printer for '${printer_info}': ");
        my $printer = CreatePrinterFromJSON($printer_info,@addl_args);
        if (!$printer) {
            output("FAILED!\n");
            return 0;
        }
    }
    if ($debug) {
        (
            $InstallMonkey::Shared::__debug,
            $InstallMonkey::Shared::__debug_level,
        ) = (
            $old_debug,
            $old_level
        );
    }

    output("OK\n");
    return 1;
}

do_install( 
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [ qw(clc desktop traveling virtual-clc virtual-desktop) ],
    exit_on_failure =&gt; 1,
    no_install_check =&gt; 1, # We use the same package ID for all printers.
    no_source_files =&gt; 0, # Local copies of the files is not really useful.
    install_sub =&gt; \&amp;configure_printer,
);
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\project_pro.2016\prod\update.pl</FullName>
    <Length>2577</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-12-07T14:36:04.5316183-06:00</CreationTime>
    <CreationTimeUtc>2017-12-07T20:36:04.5316183Z</CreationTimeUtc>
    <LastWriteTime>2017-12-07T14:40:14.5141386-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-12-07T20:40:14.5141386Z</LastWriteTimeUtc>
    <LastAccessTime>2017-12-07T14:36:04.5316183-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-12-07T20:36:04.5316183Z</LastAccessTimeUtc>
    <Text># Microsoft Project Standard 2010
# Package Created June 2011
# Packaged by Joshua Hertlein
# Last Updated ...

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;
use Win32::Registry;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'project_pro.2016',
        package_revision =&gt; '20170712T1439',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;
my $srcfiles= get_pkg_sourcefiles();

GetOptions(
    '--uninstall' =&gt; sub { exit(!uninstall()); },
);

sub prerequisite
{
    if (!is_installed('office.2016x86')) {
        print "\nThis product requires office 2016 x86 to be installed.\n";
        return 0;
    }

    return 1;
}
sub preinstall
{
    #So Arena 15 installs an annoying old version of access database 2010, In order for project 2016 to work I have to uninstall it in this script.
    if(is_installed('arena.15')){
        install_msi(app_id =&gt;"{90140000-00D1-0409-1000-0000000FF1CE}",msi_action_flag =&gt;'x');
    }
    else
    {
        output("Arena 15 wasnt installed, guess ill do nothing then.");
        
    }

    return 1;
}
sub install
{
    print "\nInstalling MS Project Professional 2016: ";
    push_dir($srcfiles);

    my $msp = build_path($srcfiles,'mst_customization_x86.msp');
    my $cfg_file = build_path($srcfiles,'prjpro.ww', 'config.xml');
    my $cmd_string = "setup.exe /config \"$cfg_file\"";
    if (!run_command($cmd_string,'IgnoreExitCodes' =&gt; [ 194 ]))
    {
        output("FAILED: $!\n");
        return 0;
    }
    output("Success!\n");

    pop_dir();
    return 1;
}

sub postinstall
{
    do "$srcfiles\\activate.pl";
    return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_VISTA_SP0,  OSVER_VISTA_SP1,  OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    #prerequisite_sub =&gt; \&amp;prerequisite,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\project_std.2016\prod\update.pl</FullName>
    <Length>2573</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-02-16T14:25:12.7821586-06:00</CreationTime>
    <CreationTimeUtc>2016-02-16T20:25:12.7821586Z</CreationTimeUtc>
    <LastWriteTime>2017-12-07T11:26:26.8242806-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-12-07T17:26:26.8242806Z</LastWriteTimeUtc>
    <LastAccessTime>2016-02-16T14:25:12.7821586-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-02-16T20:25:12.7821586Z</LastAccessTimeUtc>
    <Text># Microsoft Project Standard 2010
# Package Created June 2011
# Packaged by Joshua Hertlein
# Last Updated ...

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;
use Win32::Registry;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'project_std.2016',
        package_revision =&gt; '20160216T1429',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;
my $srcfiles= get_pkg_sourcefiles();

GetOptions(
    '--uninstall' =&gt; sub { exit(!uninstall()); },
);

sub prerequisite
{
    if (!is_installed('office.2016x86')) {
        print "\nThis product requires office 2016 x86 to be installed.\n";
        return 0;
    }

    return 1;
}
sub preinstall
{
    #So Arena 15 installs an annoying old version of access database 2010, In order for project 2016 to work I have to uninstall it in this script.
    if(is_installed('arena.15')){
        install_msi(app_id =&gt;"{90140000-00D1-0409-1000-0000000FF1CE}",msi_action_flag =&gt;'x');
    }
    else
    {
        output("Arena 15 wasnt installed, guess ill do nothing then.");
        
    }

    return 1;
}
sub install
{
    print "\nInstalling MS Project Standard 2016: ";
    push_dir($srcfiles);

    my $msp = build_path($srcfiles,'mst_customization_x86.msp');
    my $cfg_file = build_path($srcfiles,'prjstd.ww', 'config.xml');
    my $cmd_string = "setup.exe /config \"$cfg_file\"";
    if (!run_command($cmd_string,'IgnoreExitCodes' =&gt; [ 194 ]))
    {
        output("FAILED: $!\n");
        return 0;
    }
    output("Success!\n");

    pop_dir();
    return 1;
}

sub postinstall
{
    do "$srcfiles\\activate.pl";
    return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_VISTA_SP0,  OSVER_VISTA_SP1,  OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    #prerequisite_sub =&gt; \&amp;prerequisite,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\psychopy.1_83_04\prod\update.pl</FullName>
    <Length>1334</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-07-28T15:39:36.6188418-05:00</CreationTime>
    <CreationTimeUtc>2016-07-28T20:39:36.6188418Z</CreationTimeUtc>
    <LastWriteTime>2016-07-28T15:44:44.5199892-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-07-28T20:44:44.5199892Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-28T15:39:36.6188418-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-28T20:39:36.6188418Z</LastAccessTimeUtc>
    <Text># Psycho Py
# Daniel T. Holtzclaw


=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;
use Win32::Registry;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'psychopy.1_83_04',
        package_revision =&gt; '20160216T1429',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;
my $srcfiles= get_pkg_sourcefiles();

sub install
{
  output("PsychoPy 1.83.04: ");
  if (!run_command("$srcfiles\\standalone_psychopy_1_83_04.exe /S"))
  {
    output("Failed! $!\n\n");
    return 0;
  }
  output("Success!\n\n");
  return 1;
}


do_install(
    allowed_versions =&gt; [OSVER_VISTA_SP0,  OSVER_VISTA_SP1,  OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\psychopy.1_85__1\prod\update.pl</FullName>
    <Length>1351</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-05T15:05:04.4643416-05:00</CreationTime>
    <CreationTimeUtc>2017-06-05T20:05:04.4643416Z</CreationTimeUtc>
    <LastWriteTime>2017-06-05T15:07:29.8747379-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-05T20:07:29.8747379Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-28T15:39:36-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-28T20:39:36Z</LastAccessTimeUtc>
    <Text># Psycho Py
# Daniel T. Holtzclaw


=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;
use Win32::Registry;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'psychopy.1_85_1',
        package_revision =&gt; '20160605T157',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;
my $srcfiles= get_pkg_sourcefiles();

sub install
{
  output("PsychoPy 1.85.1: ");
  if (!run_command("$srcfiles\\StandalonePsychoPy-1.85.1-win32.exe /S"))
  {
    output("Failed! $!\n\n");
    return 0;
  }
  output("Success!\n\n");
  return 1;
}


do_install(
    allowed_versions =&gt; [OSVER_VISTA_SP0,  OSVER_VISTA_SP1,  OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\putty.0_70\dev\update.pl</FullName>
    <Length>4292</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-11T08:47:24.7792469-05:00</CreationTime>
    <CreationTimeUtc>2018-06-11T13:47:24.7792469Z</CreationTimeUtc>
    <LastWriteTime>2015-03-12T12:12:44.4686647-05:00</LastWriteTime>
    <LastWriteTimeUtc>2015-03-12T17:12:44.4686647Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-11T08:47:24.7792469-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-11T13:47:24.7792469Z</LastAccessTimeUtc>
    <Text># Package Created February 2009
# Packaged by Logan Black (lbbhw2@mst.edu)
# Last Updated 2014-05-20 by Dillon Lustick

=pod

Begin-Doc
Modified: $Date: 2010-06-22 09:46:21 -0500 (Tue, 22 Jun 2010) $
Name: PuTTY Installer
Type: script
Description: installs PuTTY (vendor-supplied installer) and creates a login
    script to configure default sessions
Language: Perl
LastUpdatedBy: $Author: thartman $
Version: $Revision: 361 $
Doc-SVN-Repository: $URL: https://svn.mst.edu/project/itwindist/trunk/win7/appdist/putty.0_60/prod/update.pl $
RCSId: $Id: update.pl 361 2010-06-22 14:46:21Z thartman $
End-Doc

=cut

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'putty.0_63',
	package_revision =&gt; '20140520T0800',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use File::Spec;
use File::Copy;
use File::Path;
use Cwd qw(abs_path);
use Win32::TieRegistry;
use Getopt::Long;

my $srcfiles = get_pkg_sourcefiles();
my $installer = 'puttyinst.exe';


GetOptions(
    # This option is intended for updating an existing PuTTY 0.60 install. 
    'configure' =&gt; sub { InstallMonkey::Shared::copy_source_files('data');
                         exit(!configure_sessions()); },
	'uninstall' =&gt; sub { exit(! uninstall()); },
    );


sub install {
    # Uses innosetup; use /verysilent to keep setup quiet
    output("   Running vendor installer: ");
    if (!run_command(join(' ',
                          Win32::GetShortPathName(
                              File::Spec-&gt;catfile($srcfiles,
                                                  $installer)),
                          '/verysilent'),
                     'Description' =&gt; 'invoking PuTTY installer')) {
        output("FAILED\n");
        return 0;
    }
    output("OK\n");
    return 1;
}


sub postinstall {
    return configure_sessions();
}


do_install( 
    allowed_versions =&gt; [ OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_XP_32 ],
    allowed_os_architectures =&gt; [OSARCH_x86, OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                     'virtual-clc', 'virtual-desktop'],
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    );
IM_Exit(EXIT_SUCCESS);

sub uninstall{
	
	my $AutoIt = abs_path($0);
	$AutoIt =~ s/update.pl/autoUninst.exe/;
    output("Uninstalling PuTTY version 0.63: ");
	
	my $output = run_command("$AutoIt");
    if ($output) {
		delete_product_registry_key(get_package_id());
	}
	output (($output ? "OK" : "Failed")."\n");
}

sub configure_sessions {
    output("   Creating login script for default sessions: ");
    my $scriptdir = File::Spec-&gt;catdir(get_allusers_scripts(),
                                       'standard',
                                       'putty-sessions');
    if (! -d $scriptdir &amp;&amp; !mkpath($scriptdir)) {
        output("Error creating login script directory '${scriptdir}': $!\n");
        return 0;
    }
    my @files = (
        'puttysettings.pl', # This one needs to be first in the list. See &amp;&amp;&amp;
        'default.reg',
        'cs213-01.reg',
        );
    foreach my $file (@files) {
        my $source = File::Spec-&gt;catfile($srcfiles,$file);
        if (!copy($source,$scriptdir)) {
            print("Error copying '${source}' to '${scriptdir}': $!\n");
            return 0;
        }
    }
    my $action = File::Spec-&gt;catfile($scriptdir,$files[0]); # &amp;&amp;&amp;

    if (!create_activesetup_action(
             'Identifier' =&gt; get_package_id(),
             'ComponentID' =&gt; 'User_Presets',
             'Description' =&gt; 'Create PuTTY sessions and defaults.',
             'Version' =&gt; '2010,6,22,1',
             'StubPath' =&gt; Win32::GetShortPathName($action),
        )) {
        output("     Error: cannot create Active Setup action to configure PuTTY sessions.\n");
        return 0;
    }
    output("OK\n");

    # Invoke it for the current user.
    run_command('cmd /c "'.$action.'"',
                'Description' =&gt;
                  'configuring PuTTY sessions for the current user');

    return 1;
}
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\putty.0_70\prod\update.pl</FullName>
    <Length>4515</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-11T08:40:41.3829325-05:00</CreationTime>
    <CreationTimeUtc>2018-06-11T13:40:41.3829325Z</CreationTimeUtc>
    <LastWriteTime>2018-06-11T12:15:41.0002178-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-11T17:15:41.0002178Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-11T08:40:41.3829325-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-11T13:40:41.3829325Z</LastAccessTimeUtc>
    <Text># Package Created February 2009
# Packaged by Logan Black (lbbhw2@mst.edu)
# Last 2018-05-15 by Dzu Pham
# Last updated 2018-06-11 by Gavin Altermatt

=pod

Begin-Doc
Modified: $Date: 2010-06-22 09:46:21 -0500 (Tue, 22 Jun 2010) $
Name: PuTTY Installer
Type: script
Description: installs PuTTY (vendor-supplied installer) and creates a login
    script to configure default sessions
Language: Perl
LastUpdatedBy: $Author: thartman $
Version: $Revision: 361 $
Doc-SVN-Repository: $URL: https://svn.mst.edu/project/itwindist/trunk/win7/appdist/putty.0_60/prod/update.pl $
RCSId: $Id: update.pl 361 2010-06-22 14:46:21Z thartman $
End-Doc

=cut

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'putty.0_70',
	package_revision =&gt; '20180611T0929',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use File::Spec;
use File::Copy;
use File::Path;
use Cwd qw(abs_path);
use Win32::TieRegistry;
use Getopt::Long;

my $srcfiles = get_pkg_sourcefiles();
my $installer = 'putty-64bit-0.70-installer.msi';


GetOptions(
    # This option is intended for updating an existing PuTTY 0.60 install.
    'configure' =&gt; sub { InstallMonkey::Shared::copy_source_files('data');
                         exit(!configure_sessions()); },
	'uninstall' =&gt; sub { exit(! uninstall()); },
);


sub install {
    # Uses innosetup; use /verysilent to keep setup quiet
    output("   Running vendor installer: ");
my $logfilesdir = get_applogs_dir();
if(!run_command("msiexec.exe /qn /i \"$srcfiles\\$installer\" /l* \"$logfilesdir\\putty.7_0.txt\""))
{



    #if (!run_command(join(' ',
                        #  Win32::GetShortPathName(
                              #File::Spec-&gt;catfile($srcfiles,
                              #                    $installer)),
                        #  '/verysilent'),
                    # 'Description' =&gt; 'invoking PuTTY installer')) {
        output("FAILED\n");
        return 0;
    }
    output("OK\n");
    return 1;
}


sub postinstall {
    return configure_sessions();
}


do_install(
    allowed_versions =&gt; [ OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_XP_32,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x86, OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                     'virtual-clc', 'virtual-desktop'],
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    );
IM_Exit(EXIT_SUCCESS);

sub uninstall{

	my $AutoIt = abs_path($0);
	$AutoIt =~ s/update.pl/autoUninst.exe/;
    output("Uninstalling PuTTY version 0.70: ");

	my $output = run_command("$AutoIt");

    if ($output) {
		delete_product_registry_key(get_package_id());
	}
	output (($output ? "OK" : "Failed")."\n");
}

sub configure_sessions {
    output("   Creating login script for default sessions: ");
    my $scriptdir = File::Spec-&gt;catdir(get_allusers_scripts(),
                                       'standard',
                                       'putty-sessions');
    if (! -d $scriptdir &amp;&amp; !mkpath($scriptdir)) {
        output("Error creating login script directory '${scriptdir}': $!\n");
        return 0;
    }
    my @files = (
        'puttysettings.pl', # This one needs to be first in the list. See &amp;&amp;&amp;
        'default.reg',
        'cs213-01.reg',
        );
    foreach my $file (@files) {
        my $source = File::Spec-&gt;catfile($srcfiles,$file);
        if (!copy($source,$scriptdir)) {
            print("Error copying '${source}' to '${scriptdir}': $!\n");
            return 0;
        }
    }
    my $action = File::Spec-&gt;catfile($scriptdir,$files[0]); # &amp;&amp;&amp;

    if (!create_activesetup_action(
             'Identifier' =&gt; get_package_id(),
             'ComponentID' =&gt; 'User_Presets',
             'Description' =&gt; 'Create PuTTY sessions and defaults.',
             'Version' =&gt; '2010,6,22,1',
             'StubPath' =&gt; 'perl ' . Win32::GetShortPathName($action),
        )) {
        output("     Error: cannot create Active Setup action to configure PuTTY sessions.\n");
        return 0;
    }
    output("OK\n");

    # Invoke it for the current user.
    run_command('cmd /c "'.$action.'"',
                'Description' =&gt;
                  'configuring PuTTY sessions for the current user');

    return 1;
}
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\pycharm.2016_1_2\prod\update.pl</FullName>
    <Length>2754</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-07-20T15:35:38.4690072-05:00</CreationTime>
    <CreationTimeUtc>2016-07-20T20:35:38.4690072Z</CreationTimeUtc>
    <LastWriteTime>2017-06-19T15:40:42.0917425-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-19T20:40:42.0917425Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-20T15:35:38.5158081-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-20T20:35:38.5158081Z</LastAccessTimeUtc>
    <Text># PyCharm 2016.1.2
# Package Created July 2016
# Packaged by Ronith (based on Billy Rhoades' 2015 package)
# Last Updated by Mark Raymond Jr. on 9/1/16.

use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'pycharm.2016_1_2',
        package_revision =&gt; '20161027T1243',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $exename = "setup.exe";
my $startmenu = get_allusers_start_menu();

sub preinstall
{
	output("Checking if Python is installed\n");

	if(!is_installed("python.3_5_1"))
  {
		output("Error please install python first\n");
		return 0;
	}
	output("Program found! \n");
	return 1;
}

sub install
{
    output( "Running installer: " );

    if( !run_command( "\"$srcfiles\\$exename\" /S" ) )
    {
        output( "Failed\n" );
        return 0;
    }
    else
    {
        output( "Done\n" );
        return 1;
    }
}

sub postinstall {
    # PyCharm requires a license on first start from every user, along with
    # clicking through a EULA and other nonsense. We're coping a script to
    # run via ActiveSetup at the start of every user's log on.

    my $programDataDir = $ENV{"PROGRAMDATA"}."\\standard\\PyCharm2016.1";
    mkdir_im($programDataDir);


    if(!run_command("COPY $srcfiles\\active_setup\\activesetup.pl \"$programDataDir\""))
    {
        output("Error copying key to %PROGRAMDATA%\n");
        return 0;
    }

	  if(!run_command("COPY \"$srcfiles\\PyCharm.lnk\" \"$startmenu\""))
    {
        output("Error creating shortcut\n");
    }

    create_activesetup_action(
        'Identifier' =&gt; $INSTALLMONKEY_OPTIONS{'package_id'}.'_setup',
        'ComponentID' =&gt; $INSTALLMONKEY_OPTIONS{'package_id'},
        'Description' =&gt; 'Accept EULA and add serial',
        'Version' =&gt; '1.0',
        'StubPath' =&gt; "$programDataDir\\activesetup.pl");

    run_command("netsh advfirewall firewall add rule name=\"PyCharm\" dir=out action=allow profile=domain program=\"C:\\Program Files (x86)\\JetBrains\\PyCharm 2016.1.2\\bin\\pycharm.exe\"");
    return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x86, OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
	#preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\pycharm.2017_1_1\dev\update.pl</FullName>
    <Length>3490</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-07-21T09:46:59.5459846-05:00</CreationTime>
    <CreationTimeUtc>2017-07-21T14:46:59.5459846Z</CreationTimeUtc>
    <LastWriteTime>2017-07-25T15:36:39.2589021-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-07-25T20:36:39.2589021Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-21T09:46:59.5928545-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-21T14:46:59.5928545Z</LastAccessTimeUtc>
    <Text># Package Name: PyCharm 2017
# Package Created: July 19, 2017
# Packaged by: Jason S. Holm
# Last Updated: 201707241411

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'pycharm.2017_1_1',
        package_revision =&gt; '20170724T1411',
    );
}

# Add InstallMonkey Library to the path.
my $umrinst = $ENV{'WINDIR'}.'\\SYSTEM32\\UMRINST';
use lib (
    '\\\\minerfiles.mst.edu\\dfs\\software\\loginscripts\\im',
    '$umrinst',
    'C:\\temp',
);

use InstallMonkey::Shared;
use Getopt::Long;

my $srcfiles  = get_pkg_sourcefiles();
my $exename   = "pycharm-professional-2017.1.1.exe";
my $startmenu = get_allusers_start_menu();

sub install
{
    output( "Running installer: " );

    if( !run_command( "\"$srcfiles\\$exename\" /S" ) )
    {
     output( "Failed!\n" );
    }
    else
    {
     output( "Success!\n" );
    }
}

sub postinstall {
    # PyCharm requires a license on first start from every user, along with
    # clicking through a EULA and other nonsense. We're coping a script to
    # run via ActiveSetup at the start of every user's log on.
    # License expires 24 December 2014
		
	# This version notes pycharm50, is this still correct?

    my $programDataDir = $ENV{"PROGRAMDATA"}."\\standard\\pycharm50";
    
	output("I think ProgramData is located here: $programDataDir");
		
	mkdir_im($programDataDir);

	
	
	# Changing all 'copy' commands to 'xcopy' (known return error codes exist for xcopy)
	# Placing all directory locations in quotes as part of the variable string might include spaces.
	# "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\JetBrains\JetBrains PyCharm 2017.1.1.lnk"
	
	# Attempting to locate the 'key'...I do not think this is used anymore...
	
    if(!run_command("xcopy \"$srcfiles\\active_setup\\pycharm50.key\" \"$programDataDir\"")) {
        output("Error copying key to %PROGRAMDATA%\n");
        return 0;
    }

    if(!run_command("xcopy \"$srcfiles\\active_setup\\activesetup.pl\" \"$programDataDir\"")) {
        output("Error copying script to %PROGRAMDATA%\n");
        return 0;
    }
    if(!run_command("xcopy \"$srcfiles\\JetBrains PyCharm 2017.1.1.lnk\" \"$startmenu\"")) {
        output("Error creating shortcut\n");
    }

    create_activesetup_action(
        'Identifier'  =&gt; $INSTALLMONKEY_OPTIONS{'package_id'}.'_setup',
        'ComponentID' =&gt; $INSTALLMONKEY_OPTIONS{'package_id'},
        'Description' =&gt; 'Accept EULA and add serial',
        'Version'     =&gt; '1.0',
        'StubPath'    =&gt; "$programDataDir\\activesetup.pl");
	
	# Updated file name and location: C:\Program Files\JetBrains\PyCharm 2017.1.1\bin\pycharm64.exe
    run_command("netsh advfirewall firewall add rule name=\"PyCharm\" dir=out action=allow profile=domain program=\"C:\\Program Files\\JetBrains\\PyCharm 2017.1.1\\bin\\pycharm64.exe\"");
    return 1;
}

do_install(
    allowed_versions         =&gt; ['OSVER_WIN7_SP0', 'OSVER_WIN7_SP1', 'OSVER_WIN10_SP0'],
    allowed_os_architectures =&gt; ['OSARCH_x64', 'x64'],
    allowed_regs             =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure          =&gt; 1,
    install_sub              =&gt; \&amp;install,
    postinstall_sub          =&gt; \&amp;postinstall,
    need_reboot              =&gt; 1,
);

# ALL installers need to have an explicit exit code.
IM_Exit('EXIT_SUCCESS');
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\pycharm.2017_1_1\prod\update.pl</FullName>
    <Length>5448</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-07-26T09:47:20.4399867-05:00</CreationTime>
    <CreationTimeUtc>2017-07-26T14:47:20.4399867Z</CreationTimeUtc>
    <LastWriteTime>2017-07-26T13:13:31.993384-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-07-26T18:13:31.993384Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-26T09:47:20.4399867-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-26T14:47:20.4399867Z</LastAccessTimeUtc>
    <Text># PyCharm 2017.1.1
# Package Created 2017-07-26
# Packaged by Alex Schrimpf
# Updated 2017-07-26 by Alex Schrimpf

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'pycharm.2017_1_1',
        package_revision =&gt; '20170719T1433',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;
use Getopt::Long;
use File::Copy;
use File::Path qw(make_path remove_tree);
use File::Basename;

my $src = get_pkg_sourcefiles();

########################################################
# CONFIG
########################################################

my $INSTALLER = "$src\\setup.exe";

my %SHORTCUTS = (
  "x64" =&gt; "$src\\PyCharm x64.lnk",
  "x86" =&gt; "$src\\PyCharm.lnk"
);

#Where to store key
#Expected to be in %HOMEPATH% Dir
my $USER_CONFIG = '\\.PyCharm2017.1\\config';
my $KEY_LOC = $USER_CONFIG.'\\pycharm.key';

#key file binary dump
#EX: $ xxd -b -i example.key
my @KEY = (0xff, 0xff, 0x55, 0x00, 0x52, 0x00, 0x4c, 0x00, 0x3a, 0x00, 0x68, 0x00,
  0x74, 0x00, 0x74, 0x00, 0x70, 0x00, 0x3a, 0x00, 0x2f, 0x00, 0x2f, 0x00,
  0x70, 0x00, 0x79, 0x00, 0x63, 0x00, 0x68, 0x00, 0x61, 0x00, 0x72, 0x00,
  0x6d, 0x00, 0x2e, 0x00, 0x6c, 0x00, 0x69, 0x00, 0x63, 0x00, 0x2e, 0x00,
  0x6d, 0x00, 0x73, 0x00, 0x74, 0x00, 0x2e, 0x00, 0x65, 0x00, 0x64, 0x00,
  0x75, 0x00, 0x3a, 0x00, 0x38, 0x00, 0x30, 0x00, 0x38, 0x00, 0x30, 0x00
);

########################################################

sub create_login_script
{
    my $script_dir = build_path(get_allusers_scripts(),'standard',get_package_id());
    
    my $script_file = build_path($script_dir,get_package_id().'_userlogin.pl');
   
    my $script_wrapper = build_path($script_dir,get_package_id().'_userlogin.cmd');

    if (-d $script_dir) {
      remove_tree($script_dir) or
      output(":: ERROR | REMOVING EXISTING LOGIN SCRIPT DIRECTORY '${script_dir}': $! |\n",
        LOG_ONLY);
    }
    
    make_path($script_dir);

    if (open(my $script,'&gt;',$script_file)) {
      print $script q|
  use strict;
  use File::Path qw (make_path remove_tree);
  
  my $home = $ENV{"HOMEPATH"};
  my $user_config = $home.'|.$USER_CONFIG.q|';
  my $key = $home.'|.$KEY_LOC.q|';

  print(": BUILDING DIRECTORY \| \"$user_config\" \|\n");
  if(!make_path($user_config)){
    print(":: FAILED\n\n");
  }
  print(": DONE\n\n");

  #key file binary dump
  #EX: $ xxd -b -i example.key

  my @key = (|.join(", ",@KEY).q|);

 print(": WRITING KEY FILE \| \"$key\" \|\n");
 if(open(KEY_FILE, "&gt;", $key)){
  foreach (@key){
   print KEY_FILE map { chr } $_;
  }
  close(KEY_FILE);
  print(": DONE\n\n");
  exit(0);
 }
 else{
  print(":: FAILED\n\n");
  exit(1);
 }
|;
      close($script);
      output(join("\n",get_package_id(),' Login Script:',('-' x 60),
        get_file_contents($script_file),('-' x 60),''), LOG_ONLY);
    } else {
      output(":: ERROR | COULD NOT OPEN LOGIN SCRIPT FILE '${script_file}': $! | \n");
      return 0;
    }

    if (open(my $script,'&gt;',$script_wrapper)) {
      my $log_dir = build_path('%APPDATA%','MST','Logs');
      print $script q|
C:
IF NOT EXIST |.$log_dir.q| mkdir "|.$log_dir.q|"
perl "%~dp0|.basename($script_file).q|" &gt; "|.
            build_path($log_dir,get_package_id().'-loginscript.txt').q|" 2&gt;&amp;1
|;

      close($script);
      output(join("\n",get_package_id(),' Login Script:',('-' x 60),
        get_file_contents($script_wrapper),('-' x 60),''), LOG_ONLY);
    } else {
      output(":: ERROR | COULD NOT OPEN LOGIN SCRIPT WRAPPER FILE '${script_wrapper}': $! |\n");
      return 0;
    }

    return $script_wrapper;
}

sub install
{
  output(": INSTALLING ".get_package_id()."\n");
  if(!run_command("\"$INSTALLER\" /S /NCRC"))
  {
    output ":: FAILED\n\n";
	  return 0;
  }
  output ": DONE\n\n";
  return 1;
}

sub postinstall
{
  foreach my $scut (keys %SHORTCUTS){
    output(": COPYING SHORTCUT \"$scut\" TO START MENU\n");
    if(!copy($SHORTCUTS{$scut},"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs")){
      output(":: FAILED\n\n");
      return 0;
    }
    output(": DONE\n\n");
  }
  output(": BUILDING LOGIN SCRIPT\n");
  my $script_wrapper = cmd_quote(create_login_script());
  output(": DONE\n\n");

  #this part can be disabled when not testing as system account won't ever run program
  if(!(`whoami` eq "nt authority\\system\n")){
    output(": RUNNING LOGIN SCRIPT FOR CURRENT USER\n");
    if(!run_command($script_wrapper)){
      output(":: FAILED\n\n");
      return 0;
    }
    output(": DONE\n\n");   
  }else{
    output(": DETECTED RUNNING AS SYSTEM\n")
  }

  create_activesetup_action(
	  'Identifier' =&gt; $INSTALLMONKEY_OPTIONS{'package_id'}.'_setup',
	  'ComponentID' =&gt; $INSTALLMONKEY_OPTIONS{'package_id'},
	  'Description' =&gt; 'add license server',
	  'Version' =&gt; '1.0',
	  'StubPath' =&gt; $script_wrapper);

  return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x64,OSARCH_x86],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\pycharm.2018_1_2\dev\update.pl</FullName>
    <Length>3477</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-22T11:42:58.452609-05:00</CreationTime>
    <CreationTimeUtc>2018-05-22T16:42:58.452609Z</CreationTimeUtc>
    <LastWriteTime>2018-05-22T12:30:50.706774-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-22T17:30:50.706774Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-22T11:42:58.452609-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-22T16:42:58.452609Z</LastAccessTimeUtc>
    <Text># Package Name: PyCharm 2017
# Package Created: July 19, 2017
# Packaged by: Jason S. Holm
# Last Updated: 201707241411

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'pycharm.2018_1_2',
        package_revision =&gt; '20180522T1147',
    );
}

# Add InstallMonkey Library to the path.
my $umrinst = $ENV{'WINDIR'}.'\\SYSTEM32\\UMRINST';
use lib (
    '\\\\minerfiles.mst.edu\\dfs\\software\\loginscripts\\im',
    '$umrinst',
    'C:\\temp',
);

use InstallMonkey::Shared;
use Getopt::Long;

my $srcfiles  = get_pkg_sourcefiles();
my $exename   = "pycharm-professional-2018.1.2.exe";
my $startmenu = get_allusers_start_menu();

sub install
{
    output( "Running installer: " );

    if( !run_command( "\"$srcfiles\\$exename\" /S" ) )
    {
     output( "Failed!\n" );
    }
    else
    {
     output( "Success!\n" );
    }
}

sub postinstall {
    # PyCharm requires a license on first start from every user, along with
    # clicking through a EULA and other nonsense. We're coping a script to
    # run via ActiveSetup at the start of every user's log on.
    # License expires 24 December 2014

	# This version notes pycharm50, is this still correct?

    my $programDataDir = $ENV{"PROGRAMDATA"}."\\standard\\pycharm50";

	output("I think ProgramData is located here: $programDataDir");

	mkdir_im($programDataDir);



	# Changing all 'copy' commands to 'xcopy' (known return error codes exist for xcopy)
	# Placing all directory locations in quotes as part of the variable string might include spaces.
	# "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\JetBrains\JetBrains PyCharm 2017.1.1.lnk"

	# Attempting to locate the 'key'...I do not think this is used anymore...

    if(!run_command("xcopy \"$srcfiles\\active_setup\\pycharm50.key\" \"$programDataDir\"")) {
        output("Error copying key to %PROGRAMDATA%\n");
        return 0;
    }

    if(!run_command("xcopy \"$srcfiles\\active_setup\\activesetup.pl\" \"$programDataDir\"")) {
        output("Error copying script to %PROGRAMDATA%\n");
        return 0;
    }
    if(!run_command("xcopy \"$srcfiles\\JetBrains PyCharm 2018.1.2.lnk\" \"$startmenu\"")) {
        output("Error creating shortcut\n");
    }

    create_activesetup_action(
        'Identifier'  =&gt; $INSTALLMONKEY_OPTIONS{'package_id'}.'_setup',
        'ComponentID' =&gt; $INSTALLMONKEY_OPTIONS{'package_id'},
        'Description' =&gt; 'Accept EULA and add serial',
        'Version'     =&gt; '1.0',
        'StubPath'    =&gt; "$programDataDir\\activesetup.pl");

	# Updated file name and location: C:\Program Files\JetBrains\PyCharm 2017.1.1\bin\pycharm64.exe
    run_command("netsh advfirewall firewall add rule name=\"PyCharm\" dir=out action=allow profile=domain program=\"C:\\Program Files\\JetBrains\\PyCharm 2018.1.2\\bin\\pycharm64.exe\"");
    return 1;
}

do_install(
    allowed_versions         =&gt; ['OSVER_WIN7_SP0', 'OSVER_WIN7_SP1', 'OSVER_WIN10_SP0'],
    allowed_os_architectures =&gt; ['OSARCH_x64', 'x64'],
    allowed_regs             =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure          =&gt; 1,
    install_sub              =&gt; \&amp;install,
    postinstall_sub          =&gt; \&amp;postinstall,
    need_reboot              =&gt; 1,
);

# ALL installers need to have an explicit exit code.
IM_Exit('EXIT_SUCCESS');
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\pycharm.2018_1_2\prod\update.pl</FullName>
    <Length>5455</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-22T11:42:56.988307-05:00</CreationTime>
    <CreationTimeUtc>2018-05-22T16:42:56.988307Z</CreationTimeUtc>
    <LastWriteTime>2018-06-07T13:38:53.6706295-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-07T18:38:53.6706295Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-22T11:42:56.988307-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-22T16:42:56.988307Z</LastAccessTimeUtc>
    <Text># PyCharm 2017.1.1
# Package Created 2017-07-26
# Packaged by Alex Schrimpf
# Updated 2018-06-07 by Kade Wessels

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'pycharm.2018_1_2',
        package_revision =&gt; '20180607T1328',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;
use Getopt::Long;
use File::Copy;
use File::Path qw(make_path remove_tree);
use File::Basename;

my $src = get_pkg_sourcefiles();

########################################################
# CONFIG
########################################################

my $INSTALLER = "$src\\pycharm-professional-2018.1.2.exe";

my %SHORTCUTS = (
  "x64" =&gt; "$src\\PyCharm x64.lnk",
  "x86" =&gt; "$src\\PyCharm.lnk"
);

#Where to store key
#Expected to be in %HOMEPATH% Dir
my $USER_CONFIG = '\\.PyCharm2018.1\\config';
my $KEY_LOC = $USER_CONFIG.'\\pycharm.key';

#key file binary dump
#EX: $ xxd -b -i example.key
my @KEY = (0xff, 0xff, 0x55, 0x00, 0x52, 0x00, 0x4c, 0x00, 0x3a, 0x00, 0x68, 0x00,
  0x74, 0x00, 0x74, 0x00, 0x70, 0x00, 0x3a, 0x00, 0x2f, 0x00, 0x2f, 0x00,
  0x70, 0x00, 0x79, 0x00, 0x63, 0x00, 0x68, 0x00, 0x61, 0x00, 0x72, 0x00,
  0x6d, 0x00, 0x2e, 0x00, 0x6c, 0x00, 0x69, 0x00, 0x63, 0x00, 0x2e, 0x00,
  0x6d, 0x00, 0x73, 0x00, 0x74, 0x00, 0x2e, 0x00, 0x65, 0x00, 0x64, 0x00,
  0x75, 0x00, 0x3a, 0x00, 0x38, 0x00, 0x30, 0x00, 0x38, 0x00, 0x30, 0x00
);

########################################################

sub create_login_script
{
    my $script_dir = build_path(get_allusers_scripts(),'standard',get_package_id());

    my $script_file = build_path($script_dir,get_package_id().'_userlogin.pl');

    my $script_wrapper = build_path($script_dir,get_package_id().'_userlogin.cmd');

    if (-d $script_dir) {
      remove_tree($script_dir) or
      output(":: ERROR | REMOVING EXISTING LOGIN SCRIPT DIRECTORY '${script_dir}': $! |\n",
        LOG_ONLY);
    }

    make_path($script_dir);

    if (open(my $script,'&gt;',$script_file)) {
      print $script q|
  use strict;
  use File::Path qw (make_path remove_tree);

  my $home = $ENV{"HOMEPATH"};
  my $user_config = $home.'|.$USER_CONFIG.q|';
  my $key = $home.'|.$KEY_LOC.q|';

  print(": BUILDING DIRECTORY \| \"$user_config\" \|\n");
  if(!make_path($user_config)){
    print(":: FAILED\n\n");
  }
  print(": DONE\n\n");

  #key file binary dump
  #EX: $ xxd -b -i example.key

  my @key = (|.join(", ",@KEY).q|);

 print(": WRITING KEY FILE \| \"$key\" \|\n");
 if(open(KEY_FILE, "&gt;", $key)){
  foreach (@key){
   print KEY_FILE map { chr } $_;
  }
  close(KEY_FILE);
  print(": DONE\n\n");
  exit(0);
 }
 else{
  print(":: FAILED\n\n");
  exit(1);
 }
|;
      close($script);
      output(join("\n",get_package_id(),' Login Script:',('-' x 60),
        get_file_contents($script_file),('-' x 60),''), LOG_ONLY);
    } else {
      output(":: ERROR | COULD NOT OPEN LOGIN SCRIPT FILE '${script_file}': $! | \n");
      return 0;
    }

    if (open(my $script,'&gt;',$script_wrapper)) {
      my $log_dir = build_path('%APPDATA%','MST','Logs');
      print $script q|
C:
IF NOT EXIST |.$log_dir.q| mkdir "|.$log_dir.q|"
perl "%~dp0|.basename($script_file).q|" &gt; "|.
            build_path($log_dir,get_package_id().'-loginscript.txt').q|" 2&gt;&amp;1
|;

      close($script);
      output(join("\n",get_package_id(),' Login Script:',('-' x 60),
        get_file_contents($script_wrapper),('-' x 60),''), LOG_ONLY);
    } else {
      output(":: ERROR | COULD NOT OPEN LOGIN SCRIPT WRAPPER FILE '${script_wrapper}': $! |\n");
      return 0;
    }

    return $script_wrapper;
}

sub install
{
  output(": INSTALLING ".get_package_id()."\n");
  if(!run_command("\"$INSTALLER\" /S /NCRC"))
  {
    output ":: FAILED\n\n";
	  return 0;
  }
  output ": DONE\n\n";
  return 1;
}

sub postinstall
{
  foreach my $scut (keys %SHORTCUTS){
    output(": COPYING SHORTCUT \"$scut\" TO START MENU\n");
    if(!copy($SHORTCUTS{$scut},"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs")){
      output(":: FAILED\n\n");
      return 0;
    }
    output(": DONE\n\n");
  }
  output(": BUILDING LOGIN SCRIPT\n");
  my $script_wrapper = cmd_quote(create_login_script());
  output(": DONE\n\n");

  #this part can be disabled when not testing as system account won't ever run program
  if(!(`whoami` eq "nt authority\\system\n")){
    output(": RUNNING LOGIN SCRIPT FOR CURRENT USER\n");
    if(!run_command($script_wrapper)){
      output(":: FAILED\n\n");
      return 0;
    }
    output(": DONE\n\n");
  }else{
    output(": DETECTED RUNNING AS SYSTEM\n")
  }

  create_activesetup_action(
	  'Identifier' =&gt; $INSTALLMONKEY_OPTIONS{'package_id'}.'_setup',
	  'ComponentID' =&gt; $INSTALLMONKEY_OPTIONS{'package_id'},
	  'Description' =&gt; 'add license server',
	  'Version' =&gt; '1.0',
	  'StubPath' =&gt; $script_wrapper);

  return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x64,OSARCH_x86],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\python.2_7_14\prod\update.pl</FullName>
    <Length>4647</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-29T12:45:43.4924471-06:00</CreationTime>
    <CreationTimeUtc>2017-11-29T18:45:43.4924471Z</CreationTimeUtc>
    <LastWriteTime>2017-12-04T13:10:33.0666395-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-12-04T19:10:33.0666395Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-29T12:45:43.4924471-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-29T18:45:43.4924471Z</LastAccessTimeUtc>
    <Text># Python, modules, and add-ins for Computer Science
# Package Created Jan 2013
# Packaged by Ray Morgan (based on Charlie Hendricks' 2011 package)
# Updated August 17, 2015 by Ryan Andrews
# Updated December 7, 2015 by Grayson Gratop
# Last Updated for 2.7.14 on November 29, 2017 by Grayson Gratop

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN {
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'python.2_7_14',
    package_revision =&gt; '20171129T1253',
  );
}


use lib(
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);


use InstallMonkey::Shared;


my $sourcefilesdir  = get_pkg_sourcefiles();
my $location        = "%SystemDrive%\\Python27\\Lib\\site-packages";
my $install_modules = 1;

use Getopt::Long;

GetOptions(
  'modules-only' =&gt; sub { exit(!postinstall()); }, # This won't work because it doesn't copy sourcefiles...
  'modules!' =&gt; \$install_modules,
);

sub preinstall {
  return 1;
}

sub install {
   #######################################################################
  #Install Python                                                       #
  #######################################################################

  output("\n");
  output("Installing Python 2.7.14...");

  my $file = "$sourcefilesdir\\python-2.7.14.msi";
  my $switches = "ALLUSERS=1 ADDLOCAL=ALL /norestart";

  if (!run_command("msiexec.exe /qn /i \"$file\" $switches",'IgnoreExitCode'=&gt;[194])) {
    output("\n");
    output("Error installing Python 2.7.14 - please check the log(s)");
    output("\n");

    return 0;
  }

  output("done!");
  output("\n");

  #######################################################################
  #Modify the PATH                                                      #
  #######################################################################
  output("Adding Python to the path...");
  add_environment_variable("Path", "C:\\Python27");
  add_environment_variable("Path", "C:\\Python27\\Scripts");

  #######################################################################
  #Add firewall rules so that the user isn't bothered with unnecessary  #
  # firewall dialogs when running Python for the first time             #
  #######################################################################

  if (!run_command("netsh advfirewall firewall add rule \"allow python\" dir=in
                    action=allow program=\"c:\\python27\\python.exe\"
                    enable=yes profile=domain"))
  {
    output("\n");
    output("Error adding firewall rule - please check the log(s)");
    output("\n");
  }

  if (!run_command("netsh advfirewall firewall add rule \"allow python\" dir=in
                    action=allow program=\"c:\\python27\\python.exe\"
                    enable=yes profile=public"))
  {
    output("\n");
    output("Error adding firewall rule - please check the log(s)");
    output("\n");
  }

  return 1;
}

sub postinstall {
  # allow python 2 to be launched by using `python2`
  run_command("copy /y C:\\Python27\\python.exe C:\\Python27\\python2.exe");

  if ( !$install_modules ){
    return 1;
  }
  
  #output("   Adding to Path: ");
  output((add_environment_variable("Path","C:\\Python27")?"OK":"FAILED")."\n");
  output((add_environment_variable("Path","C:\\Python27\\Scripts")?"OK":"FAILED")."\n");
  
  output("Installation successful!\n");
  output("Installing Python Modules:\n");
  my $success = 1;
  my $py_base_path = build_path("C:","Python27", "python.exe");
  my $pip_base_path = build_path("C:","Python27","Scripts","pip.exe");
  
  output("Modules: \n");
  my $run_info = {};
  $success &amp;&amp;= run_command("\"$pip_base_path\" install -r $sourcefilesdir\\requirements.txt", 'ReturnCommandInfo'=&gt;$run_info) or warn $!;
  output($$run_info{'Output'}); # Outputs the command's output. This is what you see in the log under standard output.
  return $success;

  return 1;
}

do_install(
  allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, ],
  allowed_os_architectures =&gt; [ OSARCH_x64 ],
  allowed_regs =&gt; [ 'desktop', 'clc', 'traveling', 'virtual-desktop',
            'virtual-clc' ],

  exit_on_failure =&gt; 1,

  install_sub =&gt; \&amp;install,
  preinstall_sub =&gt; \&amp;preinstall,
  postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update_nomods.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\python.2_7_14\prod\update_nomods.pl</FullName>
    <Length>4011</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-29T12:45:43.5554999-06:00</CreationTime>
    <CreationTimeUtc>2017-11-29T18:45:43.5554999Z</CreationTimeUtc>
    <LastWriteTime>2017-12-04T13:10:44.931453-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-12-04T19:10:44.931453Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-29T12:45:43.5554999-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-29T18:45:43.5554999Z</LastAccessTimeUtc>
    <Text># Python, modules, and add-ins for Computer Science
# Package Created Jan 2013
# Packaged by Ray Morgan (based on Charlie Hendricks' 2011 package)
# Updated August 17, 2015 by Ryan Andrews
# Updated December 7, 2015 by Grayson Gratop
# Last Updated for 2.7.14 on November 29, 2017 by Grayson Gratop

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN {
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'python.2_7_14_modless',
    package_revision =&gt; '20171129T1253',
  );
}


use lib(
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);


use InstallMonkey::Shared;


my $sourcefilesdir  = get_pkg_sourcefiles();
my $location        = "%SystemDrive%\\Python27\\Lib\\site-packages";
my $install_modules = 0;

use Getopt::Long;

GetOptions(
  'modules-only' =&gt; sub { exit(!postinstall()); }, # This won't work because it doesn't copy sourcefiles...
  'modules!' =&gt; \$install_modules,
  'nomods' =&gt; sub { eval{output("Setting install_modules to zero.."); $install_modules = 0;}},
);

sub preinstall {
  return 1;
}

sub install {
  #######################################################################
  #Install Python                                                       #
  #######################################################################

  output("\n");
  output("Installing Python 2.7.14...");

  my $file = "$sourcefilesdir\\python-2.7.14.msi";
  my $switches = "ALLUSERS=1 ADDLOCAL=ALL /norestart";

  if (!run_command("msiexec.exe /qn /i \"$file\" $switches",'IgnoreExitCode'=&gt;[194])) {
    output("\n");
    output("Error installing Python 2.7.14 - please check the log(s)");
    output("\n");

    return 0;
  }

  output("done!");
  output("\n");

  #######################################################################
  #Modify the PATH                                                      #
  #######################################################################
  output("Adding Python to the path...");
  add_environment_variable("Path", "C:\\Python27");
  add_environment_variable("Path", "C:\\Python27\\Scripts");

  #######################################################################
  #Add firewall rules so that the user isn't bothered with unnecessary  #
  # firewall dialogs when running Python for the first time             #
  #######################################################################

  if (!run_command("netsh advfirewall firewall add rule \"allow python\" dir=in
                    action=allow program=\"c:\\python27\\python.exe\"
                    enable=yes profile=domain"))
  {
    output("\n");
    output("Error adding firewall rule - please check the log(s)");
    output("\n");
  }

  if (!run_command("netsh advfirewall firewall add rule \"allow python\" dir=in
                    action=allow program=\"c:\\python27\\python.exe\"
                    enable=yes profile=public"))
  {
    output("\n");
    output("Error adding firewall rule - please check the log(s)");
    output("\n");
  }

  run_command("copy /y C:\\Python27\\python.exe C:\\Python27\\python2.exe");

  return 1;
}

sub postinstall {
  # allow python 2 to be launched by using `python2`
  run_command("copy /y C:\\Python27\\python.exe C:\\Python27\\python2.exe");
  
  return 1;
}

do_install(
  allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [ OSARCH_x64 ],
  allowed_regs =&gt; [ 'desktop', 'clc', 'traveling', 'virtual-desktop',
            'virtual-clc' ],

  exit_on_failure =&gt; 1,

  install_sub =&gt; \&amp;install,
  preinstall_sub =&gt; \&amp;preinstall,
  #postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update _modules.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\python.3_5_2\prod\update _modules.pl</FullName>
    <Length>2076</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-12-23T15:58:11.0411156-06:00</CreationTime>
    <CreationTimeUtc>2016-12-23T21:58:11.0411156Z</CreationTimeUtc>
    <LastWriteTime>2017-01-04T15:37:06.9014622-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-01-04T21:37:06.9014622Z</LastWriteTimeUtc>
    <LastAccessTime>2016-12-23T15:58:11.0411156-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-12-23T21:58:11.0411156Z</LastAccessTimeUtc>
    <Text># Python
# Package Created 2016-11-16
# Packaged by Dzu Pham
# Last Updated 
# With version 3.5, Python started using a new Windows installer and the MSI
# is no longer available. Luckily, command line options for the installer 
# replicate all of the funcitonality of the traditional MSI install.

=pod

Begin-Doc
Modified: $Date$
Name: $Name$
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'Python.3_5_2',
        package_revision =&gt; '20161116T0800',
    );
}


use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);


use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();
sub install {
    if(!run_command("\"$srcfiles\\Python.exe\" /quiet InstallAllUsers=1"))
    {
        output("Installation failed!\n");
        return 0;
    }
    
    output("   Adding to Path: ");
    output((add_environment_variable("Path","$ENV{'ProgramFiles'}\\Python35")?"OK":"FAILED")."\n");
    
    output("Installation successful!");
    return 1;
}
sub postinstall {
    output("Installing Python Modules:");
    output("Oslash 0.51:");
    my $success = 0;
    my $command = build_path("C:","\"Program Files\"","Python35", "python.exe");
    $command .= " -m pip install oslash==0.5.1";
    #output($command);
    my $success = run_command($command);
    output(($success)?"OK\n":"FAILED\n");
    return $success;

}
do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\python.3_5_2\prod\update.pl</FullName>
    <Length>1660</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-11-16T11:13:24.8170974-06:00</CreationTime>
    <CreationTimeUtc>2016-11-16T17:13:24.8170974Z</CreationTimeUtc>
    <LastWriteTime>2016-11-28T11:22:24.3492287-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-11-28T17:22:24.3492287Z</LastWriteTimeUtc>
    <LastAccessTime>2016-11-16T11:13:24.8170974-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-11-16T17:13:24.8170974Z</LastAccessTimeUtc>
    <Text># Python
# Package Created 2016-11-16
# Packaged by Dzu Pham
# Last Updated 
# With version 3.5, Python started using a new Windows installer and the MSI
# is no longer available. Luckily, command line options for the installer 
# replicate all of the funcitonality of the traditional MSI install.

=pod

Begin-Doc
Modified: $Date$
Name: $Name$
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'Python.3_5_2',
        package_revision =&gt; '20161116T0800',
    );
}


use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);


use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

sub install {
    if(!run_command("\"$srcfiles\\Python.exe\" /quiet InstallAllUsers=1"))
    {
        output("Installation failed!\n");
        return 0;
    }
    
    output("   Adding to Path: ");
    output((add_environment_variable("Path","$ENV{'ProgramFiles'}\\Python35")?"OK":"FAILED")."\n");
    
    output("Installation successful!");
    return 1;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>modules.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\python.3_6_1\prod\modules.pl</FullName>
    <Length>3113</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-07-18T15:20:48.0512967-05:00</CreationTime>
    <CreationTimeUtc>2017-07-18T20:20:48.0512967Z</CreationTimeUtc>
    <LastWriteTime>2017-08-09T10:37:55.5877671-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-08-09T15:37:55.5877671Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-18T15:20:48.0512967-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-18T20:20:48.0512967Z</LastAccessTimeUtc>
    <Text># Python
# Package Created 2017-05-26
# Packaged by Benjamin Kruger
# Last Updated 
# With version 3.5, Python started using a new Windows installer and the MSI
# is no longer available. Luckily, command line options for the installer 
# replicate all of the funcitonality of the traditional MSI install.

=pod

Begin-Doc
Modified: $Date$
Name: $Name$
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'Python.3_6_1_modules',
        package_revision =&gt; '20170526T1353',
    );
}


use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);


use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();
sub install {
    if(!run_command("\"$srcfiles\\python-3.6.1-amd64\" /quiet InstallAllUsers=1"))
    {
        output("Installation failed!\n");
        return 0;
    }

    
    #output("   Adding to Path: ");
    output((add_environment_variable("Path","$ENV{'ProgramFiles'}\\Python35")?"OK":"FAILED")."\n");
    
    output("Installation successful!");
    output("Installing Python Modules:");
    my $success = 0;
    my $py_base_path = build_path("C:","\"Program\ Files\"","Python36", "python.exe");
    my $pip_base_path = build_path("C:","\"Program\ Files\"","Python36","Scripts","pip.exe");
    output("Anaconda 4.3.1: ");
    $success = run_command($srcfiles."\\Anaconda3-4.3.1-Windows-x86_64.exe /InstallationType=[AllUsers] /S");
    output(($success)?"OK\n":"FAILED\n");
    output("Oslash 0.51:");
    my $command = $py_base_path." -m pip install oslash";
    output($command);
    my $success = run_command($command);
    output(($success)?"OK\n":"FAILED\n");
    output("Installing Cython:");
    $command = $py_base_path." -m pip install cython==0.25.2";
    $success = run_command($command);
    output(($success)?"OK\n":"FAILED\n");
    #Installing Matplotlib
    output("Installing Matplotlib:");
    $command = $py_base_path." -m pip install matplotlib==2.0.1";
    $success = run_command($command);
    output(($success)?"OK\n":"FAILED\n");
    #Install Numpy
    output("Installing Numpy:");
    $command = $py_base_path." -m pip install numpy==1.12.1";
    $success = run_command($command);
    output(($success)?"OK\n":"FAILED\n");
    #install pyopengl
    output("Installing PyOpenGL:");
    $command = $py_base_path." -m pip install pyopengl";
    $success = run_command($command);
    output(($success)?"OK\n":"FAILED\n");

    return 1;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update _modules.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\python.3_6_1\prod\update _modules.pl</FullName>
    <Length>3113</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-07-31T16:07:58.2529625-05:00</CreationTime>
    <CreationTimeUtc>2017-07-31T21:07:58.2529625Z</CreationTimeUtc>
    <LastWriteTime>2017-07-31T16:07:58.2685895-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-07-31T21:07:58.2685895Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-31T16:07:58.2529625-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-31T21:07:58.2529625Z</LastAccessTimeUtc>
    <Text># Python
# Package Created 2017-05-26
# Packaged by Benjamin Kruger
# Last Updated 
# With version 3.5, Python started using a new Windows installer and the MSI
# is no longer available. Luckily, command line options for the installer 
# replicate all of the funcitonality of the traditional MSI install.

=pod

Begin-Doc
Modified: $Date$
Name: $Name$
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'Python.3_6_1_modules',
        package_revision =&gt; '20170526T1353',
    );
}


use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);


use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();
sub install {
    if(!run_command("\"$srcfiles\\python-3.6.1-amd64\" /quiet InstallAllUsers=1"))
    {
        output("Installation failed!\n");
        return 0;
    }

    
    #output("   Adding to Path: ");
    output((add_environment_variable("Path","$ENV{'ProgramFiles'}\\Python36")?"OK":"FAILED")."\n");
    
    output("Installation successful!");
    output("Installing Python Modules:");
    my $success = 0;
    my $py_base_path = build_path("C:","\"Program\ Files\"","Python36", "python.exe");
    my $pip_base_path = build_path("C:","\"Program\ Files\"","Python36","Scripts","pip.exe");
    output("Anaconda 4.2.0: ");
    $success = run_command($srcfiles."\\Anaconda3-4.2.0-Windows-x86_64.exe /InstallationType=[AllUsers] /S");
    output(($success)?"OK\n":"FAILED\n");
    output("Oslash 0.51:");
    my $command = $py_base_path." -m pip install oslash";
    output($command);
    my $success = run_command($command);
    output(($success)?"OK\n":"FAILED\n");
    output("Installing Cython:");
    $command = $py_base_path." -m pip install cython==0.25.2";
    $success = run_command($command);
    output(($success)?"OK\n":"FAILED\n");
    #Installing Matplotlib
    output("Installing Matplotlib:");
    $command = $py_base_path." -m pip install matplotlib==2.0.1";
    $success = run_command($command);
    output(($success)?"OK\n":"FAILED\n");
    #Install Numpy
    output("Installing Numpy:");
    $command = $py_base_path." -m pip install numpy==1.12.1";
    $success = run_command($command);
    output(($success)?"OK\n":"FAILED\n");
    #install pyopengl
    output("Installing PyOpenGL:");
    $command = $py_base_path." -m pip install pyopengl";
    $success = run_command($command);
    output(($success)?"OK\n":"FAILED\n");

    return 1;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\python.3_6_1\prod\update.pl</FullName>
    <Length>1669</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-07-18T15:20:48.0669255-05:00</CreationTime>
    <CreationTimeUtc>2017-07-18T20:20:48.0669255Z</CreationTimeUtc>
    <LastWriteTime>2017-07-20T15:38:05.6294569-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-07-20T20:38:05.6294569Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-18T15:20:48.0669255-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-18T20:20:48.0669255Z</LastAccessTimeUtc>
    <Text># Python
# Package Created 2016-11-16
# Packaged by Dzu Pham
# Last Updated 
# With version 3.5, Python started using a new Windows installer and the MSI
# is no longer available. Luckily, command line options for the installer 
# replicate all of the funcitonality of the traditional MSI install.

=pod

Begin-Doc
Modified: $Date$
Name: $Name$
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'Python.3_6_1',
        package_revision =&gt; '05262017T1038',
    );
}


use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);


use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

sub install {
    if(!run_command("\"$srcfiles\\python-3.6.1-amd64\" /quiet InstallAllUsers=1"))
    {
        output("Installation failed!\n");
        return 0;
    }
    
    output("   Adding to Path: ");
    #output((add_environment_variable("Path","$ENV{'ProgramFiles'}\\Python35")?"OK":"FAILED")."\n");
    
    output("Installation successful!");
    return 1;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>modules.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\python.3_6_3\prod\modules.pl</FullName>
    <Length>2695</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-16T15:25:50.7363585-06:00</CreationTime>
    <CreationTimeUtc>2017-11-16T21:25:50.7363585Z</CreationTimeUtc>
    <LastWriteTime>2017-12-04T12:44:05.1073437-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-12-04T18:44:05.1073437Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-16T15:25:50.7363585-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-16T21:25:50.7363585Z</LastAccessTimeUtc>
    <Text># Python
# Package Created 2017-05-26
# Packaged by Benjamin Kruger
# Last Updated on 2017-11-29 by Austin Wall
# With version 3.5, Python started using a new Windows installer and the MSI
# is no longer available. Luckily, command line options for the installer 
# replicate all of the funcitonality of the traditional MSI install.

=pod

Begin-Doc
Modified: $Date$
Name: $Name$
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN {
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'Python.3_6_3_modules',
    package_revision =&gt; '20171129T1705',
  );
}


use lib(
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);


use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

sub install {
  output("Installing Python 3.6.3:\n");
  if (!run_command("\"$srcfiles\\python-3.6.3-amd64\" /quiet InstallAllUsers=1")) {
    output("Installation failed!\n");
    return 0;
  }

  # allow python 3 to be specified by using the command `python3`
  run_command("copy /y \"C:\\Program Files\\Python36\\python.exe\" \"C:\\Program Files\\Python36\\python3.exe\"");
  
  #output("   Adding to Path: ");
  output((add_environment_variable("Path","$ENV{'ProgramFiles'}\\Python36")?"OK":"FAILED")."\n");
  output((add_environment_variable("Path","$ENV{'ProgramFiles'}\\Python36\\Scripts")?"OK":"FAILED")."\n");
  
  output("Installation successful!\n");
  output("Installing Python Modules:\n");
  my $success = 1;
  my $py_base_path = build_path("C:","Program Files","Python36", "python.exe");
  my $pip_base_path = build_path("C:","Program Files","Python36","Scripts","pip.exe");
  
  output("Anaconda 4.2.0: \n");
  $success &amp;&amp;= run_command($srcfiles."\\Anaconda3-5.0.1-Windows-x86_64.exe /InstallationType=[AllUsers] /S") or warn $!;
  output("Other Modules: \n");
  my $run_info = {};
  $success &amp;&amp;= run_command("\"$pip_base_path\" install -r $srcfiles\\requirements.txt", 'ReturnCommandInfo'=&gt;$run_info) or warn $!;
  output($$run_info{'Output'}); # Outputs the command's output. This is what you see in the log under standard output.
  return $success;
}

do_install( 
  allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update _modules.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\python.3_6_3\prod\update _modules.pl</FullName>
    <Length>2229</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-16T15:25:50.7766234-06:00</CreationTime>
    <CreationTimeUtc>2017-11-16T21:25:50.7766234Z</CreationTimeUtc>
    <LastWriteTime>2017-11-27T13:54:46.3010709-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-11-27T19:54:46.3010709Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-16T15:25:50.7766234-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-16T21:25:50.7766234Z</LastAccessTimeUtc>
    <Text># Python
# Package Created 2017-05-26
# Packaged by Benjamin Kruger
# Last Updated 2017-11-16 for 3.6.3 by Grayson Gratop
# With version 3.5, Python started using a new Windows installer and the MSI
# is no longer available. Luckily, command line options for the installer 
# replicate all of the funcitonality of the traditional MSI install.

=pod

Begin-Doc
Modified: $Date$
Name: $Name$
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'Python.3_6_3_modules',
        package_revision =&gt; '20171116T1528',
    );
}


use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);


use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();
sub install {
    if(!run_command("\"$srcfiles\\python-3.6.3-amd64\" /quiet InstallAllUsers=1"))
    {
        output("Installation failed!\n");
        return 0;
    }

    
    #output("   Adding to Path: ");
    output((add_environment_variable("Path","$ENV{'ProgramFiles'}\\Python36")?"OK":"FAILED")."\n");
    
    output("Installation successful!");
    output("Installing Python Modules:");
    my $success = 1;
    my $py_base_path = build_path("C:","\"Program\ Files\"","Python36", "python.exe");
    my $pip_base_path = build_path("C:","\"Program\ Files\"","Python36","Scripts","pip.exe");
    
    output("Anaconda 4.2.0: ");
    $success &amp;&amp;= run_command($srcfiles."\\Anaconda3-5.0.1-Windows-x86_64.exe /InstallationType=[AllUsers] /S");

    
    $success &amp;&amp;= run_command("$pip_base_path install -r $srcfiles\\requirements.txt");


    return $success;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\python.3_6_3\prod\update.pl</FullName>
    <Length>1941</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-16T15:25:50.7937802-06:00</CreationTime>
    <CreationTimeUtc>2017-11-16T21:25:50.7937802Z</CreationTimeUtc>
    <LastWriteTime>2017-12-04T12:43:23.7507438-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-12-04T18:43:23.7507438Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-16T15:25:50.7937802-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-16T21:25:50.7937802Z</LastAccessTimeUtc>
    <Text># Python
# Package Created 2016-11-16
# Packaged by Dzu Pham
# Last Updated 2017-11-16 for 3.6.3 by Grayson Gratop
# With version 3.5, Python started using a new Windows installer and the MSI
# is no longer available. Luckily, command line options for the installer 
# replicate all of the funcitonality of the traditional MSI install.

=pod

Begin-Doc
Modified: $Date$
Name: $Name$
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN {
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'Python.3_6_3',
    package_revision =&gt; '20171117T1527',
  );
}


use lib(
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);


use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

sub install {
  if (!run_command("\"$srcfiles\\python-3.6.3-amd64\" /quiet InstallAllUsers=1")) {
    output("Installation failed!\n");
    return 0;
  }
  
  output("   Adding to Path: ");
  output((add_environment_variable("Path","$ENV{'ProgramFiles'}\\Python36")?"OK":"FAILED")."\n");
  output((add_environment_variable("Path","$ENV{'ProgramFiles'}\\Python36\\Scripts")?"OK":"FAILED")."\n");
  
  # allow python 3 to be specified by using the command `python3`
  run_command("copy /y \"C:\\Program Files\\Python36\\python.exe\" \"C:\\Program Files\\Python36\\python3.exe\"");

  output("Installation successful!");
  return 1;
}

do_install( 
  allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>modules.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\python.3_6_5\prod\modules.pl</FullName>
    <Length>2698</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-18T08:52:42.2220332-05:00</CreationTime>
    <CreationTimeUtc>2018-06-18T13:52:42.2220332Z</CreationTimeUtc>
    <LastWriteTime>2018-06-19T10:29:58.6297084-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-19T15:29:58.6297084Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-18T08:52:42.2220332-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-18T13:52:42.2220332Z</LastAccessTimeUtc>
    <Text># Python
# Package Created 2017-05-26
# Packaged by Benjamin Kruger
# Last Updated 2018-06-18 for 3.6.5 by Cameron Loren
# With version 3.5, Python started using a new Windows installer and the MSI
# is no longer available. Luckily, command line options for the installer
# replicate all of the funcitonality of the traditional MSI install.

=pod

Begin-Doc
Modified: $Date$
Name: $Name$
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN {
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'Python.3_6_5_modules',
    package_revision =&gt; '20180618T0853',
  );
}


use lib(
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);


use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

sub install {
  output("Installing Python 3.6.5:\n");
  if (!run_command("\"$srcfiles\\python-3.6.5-amd64.exe\" /quiet InstallAllUsers=1")) {
    output("Installation failed!\n");
    return 0;
  }

  # allow python 3 to be specified by using the command `python3`
  run_command("copy /y \"C:\\Program Files\\Python36\\python.exe\" \"C:\\Program Files\\Python36\\python3.exe\"");

  #output("   Adding to Path: ");
  output((add_environment_variable("Path","$ENV{'ProgramFiles'}\\Python36")?"OK":"FAILED")."\n");
  output((add_environment_variable("Path","$ENV{'ProgramFiles'}\\Python36\\Scripts")?"OK":"FAILED")."\n");

  output("Installation successful!\n");
  output("Installing Python Modules:\n");
  my $success = 1;
  my $py_base_path = build_path("C:","Program Files","Python36", "python.exe");
  my $pip_base_path = build_path("C:","Program Files","Python36","Scripts","pip.exe");

  output("Anaconda 5.1.0: \n");
  $success &amp;&amp;= run_command($srcfiles."\\Anaconda3-5.1.0-Windows-x86_64.exe /InstallationType=[AllUsers] /S") or warn $!;
  output("Other Modules: \n");
  my $run_info = {};
  $success &amp;&amp;= run_command("\"$pip_base_path\" install -r $srcfiles\\requirements.txt", 'ReturnCommandInfo'=&gt;$run_info) or warn $!;
  output($$run_info{'Output'}); # Outputs the command's output. This is what you see in the log under standard output.
  return $success;
}

do_install(
  allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\python.3_6_5\prod\update.pl</FullName>
    <Length>1936</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-18T08:52:42.2064751-05:00</CreationTime>
    <CreationTimeUtc>2018-06-18T13:52:42.2064751Z</CreationTimeUtc>
    <LastWriteTime>2018-06-19T08:06:58.4307185-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-19T13:06:58.4307185Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-18T08:52:42.2064751-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-18T13:52:42.2064751Z</LastAccessTimeUtc>
    <Text># Python
# Package Created 2016-11-16
# Packaged by Dzu Pham
# Last Updated 2018-06-18 for 3.6.5 by Cameron Loren
# With version 3.5, Python started using a new Windows installer and the MSI
# is no longer available. Luckily, command line options for the installer
# replicate all of the funcitonality of the traditional MSI install.

=pod

Begin-Doc
Modified: $Date$
Name: $Name$
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN {
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'Python.3_6_5',
    package_revision =&gt; '20180618T0853',
  );
}


use lib(
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);


use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

sub install {
  if (!run_command("\"$srcfiles\\python-3.6.5-amd64.exe\" /quiet InstallAllUsers=1")) {
    output("Installation failed!\n");
    return 0;
  }

  output("   Adding to Path: ");
  output((add_environment_variable("Path","$ENV{'ProgramFiles'}\\Python36")?"OK":"FAILED")."\n");
  output((add_environment_variable("Path","$ENV{'ProgramFiles'}\\Python36\\Scripts")?"OK":"FAILED")."\n");

  # allow python 3 to be specified by using the command `python3`
  run_command("copy /y \"C:\\Program Files\\Python36\\python.exe\" \"C:\\Program Files\\Python36\\python3.exe\"");

  output("Installation successful!");
  return 1;
}

do_install(
  allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update _modules.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\python_modules.3_6_1\prod\update _modules.pl</FullName>
    <Length>2793</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-07-13T16:51:19.1447429-05:00</CreationTime>
    <CreationTimeUtc>2017-07-13T21:51:19.1447429Z</CreationTimeUtc>
    <LastWriteTime>2017-07-13T15:54:22.5423021-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-07-13T20:54:22.5423021Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-13T16:51:19.1447429-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-13T21:51:19.1447429Z</LastAccessTimeUtc>
    <Text># Python
# Package Created 2017-05-26
# Packaged by Benjamin Kruger
# Last Updated 
# With version 3.5, Python started using a new Windows installer and the MSI
# is no longer available. Luckily, command line options for the installer 
# replicate all of the funcitonality of the traditional MSI install.

=pod

Begin-Doc
Modified: $Date$
Name: $Name$
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'Python.3_6_1_modules',
        package_revision =&gt; '20170526T1353',
    );
}


use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);


use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();
sub install {
    output((add_environment_variable("Path","$ENV{'ProgramFiles'}\\Python36")?"OK":"FAILED")."\n");
    output("Installing Python Modules:");
    output("Oslash 0.51:");
    my $success = 0;
    my $py_base_path = build_path("C:","\"Program Files\"","Python36", "python.exe");
    my $command = $py_base_path." -m pip install oslash==0.5.1";
    output($command);
    my $success = run_command($command);
    output(($success)?"OK\n":"FAILED\n");
    output("Anaconda 4.2.0: ");
    $success = run_command($srcfiles."\\Anaconda3-4.2.0-Windows-x86_64.exe /InstallationType=[AllUsers] /S");
    output(($success)?"OK\n":"FAILED\n");
    #Install Cython
    output("Installing Cython:");
    $command = $py_base_path." -m pip install cython==0.25.2";
    $success = run_command($command);
    output(($success)?"OK\n":"FAILED\n");
    #Installing Matplotlib
    output("Installing Matplotlib:");
    $command = $py_base_path." -m pip install matplotlib==2.0.1";
    $success = run_command($command);
    output(($success)?"OK\n":"FAILED\n");
    #Install Numpy
    output("Installing Numpy:");
    $command = $py_base_path." -m pip install numpy==1.12.1";
    $success = run_command($command);
    output(($success)?"OK\n":"FAILED\n");
    #install pyopengl
    output("Installing PyOpenGL:");
    $command = $py_base_path." -m pip install pyopengl";
    $success = run_command($command);
    output(($success)?"OK\n":"FAILED\n");

    return 1;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\qcachegrind.0_7_4\prod\update.pl</FullName>
    <Length>1803</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-07-14T13:19:13.8230069-05:00</CreationTime>
    <CreationTimeUtc>2016-07-14T18:19:13.8230069Z</CreationTimeUtc>
    <LastWriteTime>2016-07-14T13:15:05.8214871-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-07-14T18:15:05.8214871Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-14T13:19:13.8230069-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-14T18:19:13.8230069Z</LastAccessTimeUtc>
    <Text>#QCacheGrind Callgrind graphical interface
#Package created July 2016
#Packaged by Benjamin Krueger
#Last Updated 2016-01-16

use File::Basename;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'qcachegrind.0_7_4',
        package_revision =&gt; '7420160714T934',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;

use Getopt::Long;
GetOptions('uninstall'=&gt; sub{exit(!uninstall());});
sub install {
    my $exename = get_pkg_sourcefiles().'\\qcachegrind074-x86\\qcachegrind.exe';
    my $smlnk = get_allusers_start_menu().'\\Programs\\Qcachegrind.lnk';
    my $iconfile = get_pkg_sourcefiles.'\\icon.ico';
    create_shortcut(
        'target' =&gt;$exename,
        'link' =&gt; $smlnk,
        'description' =&gt; 'Launches qcachegrind',
        'icon' =&gt; $iconfile,0,
    );
}
sub uninstall {
    my $sourcedir = get_pkg_sourcefiles();
    my $shortcut = get_allusers_start_menu().'\\Programs\\Qcachegrind.lnk';

    if(!run_command("rmdir /s /q \"${sourcedir}\""))
    {
        output("Source directory deletion failed");
        return 0;
    }
    if(!run_command("DEL -Force  \"${shortcut}\""))
    {
        output("Shortcut deletion failed");
        return 0;
    }
    delete_product_registry_key(get_package_name().".".get_version());
    return 1;
}
do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1], #How would I go about finding where a package may be compatible
    allowed_os_architectures =&gt; [ OSARCH_x64, OSARCH_x86 ],
    allowed_regs =&gt; [ 'clc', 'desktop', 'traveling',
                      'virtual-clc', 'virtual-desktop' ],

    install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\qgis.2_14_3\prod\update.pl</FullName>
    <Length>1801</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-06-21T16:25:30.729546-05:00</CreationTime>
    <CreationTimeUtc>2016-06-21T21:25:30.729546Z</CreationTimeUtc>
    <LastWriteTime>2016-06-22T13:05:04.9180007-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-06-22T18:05:04.9180007Z</LastWriteTimeUtc>
    <LastAccessTime>2016-06-21T16:25:30.7607466-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-06-21T21:25:30.7607466Z</LastAccessTimeUtc>
    <Text># QGIS 2.14.3
# Packaged by Ronith (based on Dillon Lustick's 2015 Package)
# Packged on 2016-06-21

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'qgis.2_14_3',
        package_revision =&gt; '20160622T1230',

    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;


sub install
{
    my $srcfiles = get_pkg_sourcefiles();
    my $log_dir = get_applogs_dir();
    
    output("Installing QGIS 2.14.3: ");
    if(!run_command("$srcfiles\\QGIS-OSGeo4W-2.14.3-2-Setup-x86_64.exe /S")) {
        return 0;
    }
    output("Done!\n");
    
    return 1;
}

sub postinstall {
    my $pub_desk = $ENV{'PUBLIC'}.'\Desktop';
    my @public_files = ("OSGeo4W Shell",
                        "GRASS GIS 7.0.4");
    output("Deleting desktop icons: ");
    for my $file (@public_files) {
        run_command("del /q \"$pub_desk\\$file.lnk\"");
    }
    run_command("rmdir /q /s \"$pub_desk\\qgis essen\"");
    return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update530.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\qt.5_1_1\dev\update530.pl</FullName>
    <Length>6340</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-07-27T11:13:51.4895536-05:00</CreationTime>
    <CreationTimeUtc>2018-07-27T16:13:51.4895536Z</CreationTimeUtc>
    <LastWriteTime>2015-04-16T14:20:51.7814184-05:00</LastWriteTime>
    <LastWriteTimeUtc>2015-04-16T19:20:51.7814184Z</LastWriteTimeUtc>
    <LastAccessTime>2018-07-27T11:13:51.4895536-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-07-27T16:13:51.4895536Z</LastAccessTimeUtc>
    <Text># Qt for visual studio 2013
# Package Created June 2013
# Packaged by Billy Rhoades
# Updated 2014-06-06 by Dillon Lustick

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use Win32;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'qt.5_3_0',
        package_revision =&gt; '20140522T0920',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Archive::Extract;
use Win32::TieRegistry;
use Getopt::Long;

######
GetOptions(
    'uninstall' =&gt; sub { exit(!uninstall()); },
) || die "Usage: $!";
######



sub uninstall
{
	my $srcfiles = get_pkg_sourcefiles();
	
	my $qt_hklm_uninstall = "$srcfiles\\qt_hklm_uninstall.reg";
	my $vs_hklm_uninstall = "$srcfiles\\vs_hklm_uninstall.reg";
	my $vs_hkcu_uninstall = "$srcfiles\\vs_hkcu_uninstall.reg";
	
	my $StartMenu = cmd_quote(build_path('C:', 'ProgramData', 'Microsoft', 'Windows', 'Start Menu', 'Qt 5.3.0'));
	
	my @RemoveQtFolder = (
		   'rmdir', '/q', '/s', 'c:\Qt',
		);
		
	my $FolderRemoved = run_command(join(' ',@RemoveQtFolder));
	
	if ($FolderRemoved)
	{
		output("Removing start menu shortcuts: ");
		( run_command("rmdir /q /s $StartMenu") ? output("Success!\n\n") : output("Failed: $!\n\n") );
		
		output("Removing Qt hklm: ");
		( run_command( "regedit.exe /s $qt_hklm_uninstall" ) ? output("Success!\n") : output("Failed: $!\n") );
		
		output("Removing Qt hkcu: ");
		( run_command( "regedit.exe /s $vs_hkcu_uninstall" ) ? output("Success!\n") : output("Failed: $!\n") );
		
		output("Removing VS hklm: ");
		( run_command( "regedit.exe /s $vs_hklm_uninstall" ) ? output("Success!\n") : output("Failed: $!\n") );
		
		output("Removing registry key.\n");
		delete_product_registry_key('qt.5_3_0');
		output("Qt Removed successfully!");
		return 1;
	}
	else
	{
		output("Issue removing Qt: $!");
		return 0;
	}
	
	#output("Removing leftover folder in Program Files (x86)\n");
	#run_command("rmdir /q /s \"\%programfiles(x86)\%\\WebEx\\\"");
}


#Called by ActiveSetup on each user profile creation assoc. qt w/ vs
my $srcfiles = get_pkg_sourcefiles();
my $local_reg = $ENV{'SYSTEMDRIVE'}."\\ProgramData\\mst\\standard\\QT\\vs_hkcu.reg";
my $qt_hklm = "$srcfiles\\qt_hklm.reg";
my $vs_hklm = "$srcfiles\\vs_hklm.reg";
my $vs_hkcu = "$srcfiles\\vs_hkcu.reg";

sub prereq
{
  if( is_installed( "visual_studio.2013" ) )
  {
    output( "Visual Studio 2013 is installed\n" );
    return 1;
  }
  else
  {
    output( "Visual Studio 2013 isn't installed, please install it before proceeding.\n" );
    return 0;
  }
}

sub install
{
  select STDOUT;

  #due to the installers dropping all silent flags, the contents are now just extracted to where they need to go
  #program is in dev data
  my $qtarch = Archive::Extract-&gt;new( archive =&gt; "$srcfiles\\Qt.zip" );

  output( "Extracting Qt 5.3.0: " );

  $|=1;

  if( !$qtarch-&gt;extract( to =&gt; "C:\\" ) )
  {
    output( "FAILED!\n" );
    return 0;
  }

  output( "Done\n" );


  # /S works with this plugin but causes it to hang 90% of the times it is run, so manually create registry entries instead
  # Program is in dev data
  output( "Extracting Qt Visual Studio Add-In 1.2.3: " );
  my $qtaddarch = Archive::Extract-&gt;new( archive =&gt; "$srcfiles\\VSaddin.zip" ); #see Digia in Program Files (x86)

  $|=1;

  if( !$qtaddarch-&gt;extract( to =&gt; $ENV{'ProgramFiles(x86)'} ) )
  {
    output( "FAILED!\n" );
    return 0;
  }

  output( "Done\n" );


  #adds qt and addin to uninstall and adds file associations.
  output( "Adding appropriate registry entries: " );
  if( !run_command( "regedit.exe /s $qt_hklm" ) || !run_command( "regedit.exe /s $vs_hklm" ) )
  {
    output( "FAILED!\n" );
    return 0;
  }

  output( "Done\n" );

  return 1;
}

sub postinstall
{
  #vcredist used by the addin + one included with qt
  # output( "Executing included Visual C++ Redistributables: " );
  my $vcredist = $ENV{'SYSTEMDRIVE'}."\\Qt\\Qt5.3.0\\vcredist";
  if( !run_command( $vcredist."\\vcredist_sp1_x86.exe /norestart /q" ) #vc++ 2010 sp1
      || !run_command( $vcredist."\\vcredist_sp1_x64.exe /norestart /q" )
      #|| !run_command( "$sourcefilesdir\\vcredist_x86.exe /norestart /q" ) ) #vc++ 2010
      )
  {
    output( "FAILED!\n" );
    return 0;
  }

  output( "Done\n" );

  # This is per user so needs to be done with create_active_setup
  # Top command prompts "is this a file or directory" so enter f
  output( "Performing Visual Studio 2013's Qt setup: " );
  if( !run_command( "echo f | XCOPY \"$vs_hkcu\" \"$local_reg\" /Y /Q /I" )
      || !create_activesetup_action(
       'Identifier' =&gt; $INSTALLMONKEY_OPTIONS{'package_id'}.'_setup',
       'ComponentID' =&gt; $INSTALLMONKEY_OPTIONS{'package_id'},
       'Description' =&gt; 'Registers qt in the vs-addin in visual studio. Has to be done per user.',
       'Description' =&gt; 'Adds file associations for QT per user',
       'Version' =&gt; '1,0',
       'StubPath' =&gt; "regedit.exe /s ".$local_reg ) )
  {
    output( "FAILED!\n" );
    return 0;
  }
  output( "Done\n" );

  # Also need to delete old active setup or it will complain about missing plugins
  $Registry-&gt;Delimiter("/");
  delete $Registry-&gt;{"LMachine/Software/Microsoft/Active Setup/Installed Components/qt.5_0_2.vs2010_setup/"};

  output( "Adding shortcuts to start menu: " );
  if( !run_command( "XCOPY \"$srcfiles\\Start Menu\" \"".$ENV{'ALLUSERSPROFILE'}."\\Microsoft\\Windows\\Start Menu\" /E /Y /I /Q" ) )
  {
    output( "FAILED!\n" );
    return 0;
  }

  output( "Installation complete!\n" );
  return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    prerequisite_sub =&gt; \&amp;prereq,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\qt.5_1_1\prod\update.pl</FullName>
    <Length>4475</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-07-27T12:04:14.2488433-05:00</CreationTime>
    <CreationTimeUtc>2018-07-27T17:04:14.2488433Z</CreationTimeUtc>
    <LastWriteTime>2018-08-02T13:41:01.4366611-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-08-02T18:41:01.4366611Z</LastWriteTimeUtc>
    <LastAccessTime>2018-07-27T13:23:56.17324-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-07-27T18:23:56.17324Z</LastAccessTimeUtc>
    <Text># Qt for visual studio 2013
# Package Created June 2013
# Packaged by Billy Rhoades
# Updated 2017-07-27 by Kade Wessels

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use Win32;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'qt.5_1_1',
        package_revision =&gt; '20180727T1411',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Archive::Extract;
use Win32::TieRegistry;


#Called by ActiveSetup on each user profile creation assoc. qt w/ vs
my $src = get_pkg_sourcefiles();
my $local_reg = $ENV{'SYSTEMDRIVE'}."\\ProgramData\\mst\\standard\\QT\\vs_hkcu.reg";
my $qt_hklm = "$src\\qt_hklm.reg";
my $vs_hklm = "$src\\vs_hklm.reg";
my $vs_hkcu = "$src\\vs_hkcu.reg";

sub prereq
{
  if( is_installed( "visual_studio.2017" ) )
  {
    output( "Visual Studio 2017 is installed\n" );
    return 1;
  }
  else
  {
    output( "Visual Studio 2017 isn't installed, please install it before proceeding.\n" );
    return 0;
  }
}

sub install
{
  select STDOUT;

  #due to the installers dropping all silent flags, the contents are now just extracted to where they need to go
  my $zip = "C:\\Program Files\\7-zip\\7z.exe";

  output( "Extracting Qt 5.1.1: " );
  # Extract right to the C drive
  if(!run_command("\"$zip\" x \"$src\"\\Qt5.1.1.zip -aoa -oC:"))
  {
    output( "FAILED!\n" );
    return 0;
  }
  output( "Done\n" );


  # /S works with this plugin but causes it to hang 90% of the times it is run, so manually create registry entries instead
  # Extract straight into program files
  output( "Extracting Qt Visual Studio Add-In 1.2.3: " );
  if(!run_command("\"$zip\" x \"$src\"\\VSaddin.zip -aoa -o\"C:\\Program Files (x86)\""))
  {
    output( "FAILED!\n" );
    return 0;
  }

  output( "Done\n" );


  #adds qt and addin to uninstall and adds file associations.
  output( "Adding appropriate registry entries: " );
  if( !run_command( "regedit.exe /s $qt_hklm" ) || !run_command( "regedit.exe /s $vs_hklm" ) )
  {
    output( "FAILED!\n" );
    return 0;
  }

  output( "Done\n" );

  return 1;
}

sub postinstall
{
  #vcredist used by the addin + one included with qt
  # output( "Executing included Visual C++ Redistributables: " )
  my $vcredist = build_path("C:", "Qt", "Qt5.1.1", "vcredist", "vcredist_sp1_x86.exe");
  if( !run_command( $vcredist . " /norestart /q" )) {
    output( "Failed: $!. \n" );
    return 0;
  }

  output( "Done\n" );

  # This is per user so needs to be done with create_active_setup
  # Top command prompts "is this a file or directory" so enter f
  output( "Performing Visual Studio 2017's Qt setup: " );
  if( !run_command( "echo f | XCOPY \"$vs_hkcu\" \"$local_reg\" /Y /Q /I" )
      || !create_activesetup_action(
       'Identifier' =&gt; $INSTALLMONKEY_OPTIONS{'package_id'}.'_setup',
       'ComponentID' =&gt; $INSTALLMONKEY_OPTIONS{'package_id'},
       'Description' =&gt; 'Registers qt in the vs-addin in visual studio. Has to be done per user.',
       'Description' =&gt; 'Adds file associations for QT per user',
       'Version' =&gt; '1,0',
       'StubPath' =&gt; "regedit.exe /s ".$local_reg ) )
  {
    output( "FAILED!\n" );
    return 0;
  }
  output( "Done\n" );

  # Also need to delete old active setup or it will complain about missing plugins
  $Registry-&gt;Delimiter("/");
  delete $Registry-&gt;{"LMachine/Software/Microsoft/Active Setup/Installed Components/qt.5_0_2.vs2010_setup/"};

  output( "Adding shortcuts to start menu: " );
  if( !run_command( "XCOPY \"$src\\Start Menu\" \"".$ENV{'ALLUSERSPROFILE'}."\\Microsoft\\Windows\\Start Menu\" /E /Y /I /Q" ) )
  {
    output( "FAILED!\n" );
    return 0;
  }

  output( "Installation complete!\n" );
  return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    prerequisite_sub =&gt; \&amp;prereq,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\Qt.5_7_0\prod\update.pl</FullName>
    <Length>4691</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-08-15T10:17:57.4160626-05:00</CreationTime>
    <CreationTimeUtc>2016-08-15T15:17:57.4160626Z</CreationTimeUtc>
    <LastWriteTime>2016-08-18T13:42:53.9260763-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-08-18T18:42:53.9260763Z</LastWriteTimeUtc>
    <LastAccessTime>2016-08-15T10:17:57.4160626-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-08-15T15:17:57.4160626Z</LastAccessTimeUtc>
    <Text># Qt for visual studio 2013
# Package Created June 2013
# Packaged by Billy Rhoades
# Updated 2014-06-06 by Dillon Lustick

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use Win32;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'qt.5_3_0',
        package_revision =&gt; '20140522T0920',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Archive::Extract;
use Win32::TieRegistry;


#Called by ActiveSetup on each user profile creation assoc. qt w/ vs
my $srcfiles = get_pkg_sourcefiles();
my $local_reg = $ENV{'SYSTEMDRIVE'}."\\ProgramData\\mst\\standard\\QT\\vs_hkcu.reg";
my $qt_hklm = "$srcfiles\\qt_hklm.reg";
my $vs_hklm = "$srcfiles\\vs_hklm.reg";
my $vs_hkcu = "$srcfiles\\vs_hkcu.reg";

sub prereq
{
  if( is_installed( "visual_studio.2015u2" ) || is_installed( "visual_studio.2015u3" ) )
  {
    output( "Visual Studio 2015 is installed\n" );
    return 1;
  }
  else
  {
    output( "Visual Studio 2015 isn't installed, please install it before proceeding.\n" );
    return 0;
  }
}

sub install
{
  select STDOUT;

  #due to the installers dropping all silent flags, the contents are now just extracted to where they need to go
  #program is in dev data
  my $qtarch = Archive::Extract-&gt;new( archive =&gt; "$srcfiles\\Qt.zip" );

  output( "Extracting Qt 5.7.0: " );

  $|=1;

  if( !$qtarch-&gt;extract( to =&gt; "C:\\Qt\\" ) )
  {
    output( "FAILED!\n" );
    return 0;
  }

  output( "Done\n" );


  # /S works with this plugin but causes it to hang 90% of the times it is run, so manually create registry entries instead
  # Program is in dev data
  output( "Extracting Qt Visual Studio Add-In 1.2.3: " );
  my $qtaddarch = Archive::Extract-&gt;new( archive =&gt; "$srcfiles\\VSaddin.zip" ); #see Digia in Program Files (x86)

  $|=1;

  if( !$qtaddarch-&gt;extract( to =&gt; $ENV{'ProgramFiles(x86)'} ) )
  {
    output( "FAILED!\n" );
    return 0;
  }

  output( "Done\n" );


  #adds qt and addin to uninstall and adds file associations.
  output( "Adding appropriate registry entries: " );
  if( !run_command( "regedit.exe /s $qt_hklm" ) || !run_command( "regedit.exe /s $vs_hklm" ) )
  {
    output( "FAILED!\n" );
    return 0;
  }

  output( "Done\n" );

  return 1;
}

sub postinstall
{
  #vcredist used by the addin + one included with qt
  # output( "Executing included Visual C++ Redistributables: " )
  my $vcredist = build_path("\%SYSTEMDRIVE\%", "Qt", "Qt5.7.0", "vcredist", "vcredist_msvc2013_x86.exe");#"\%SYSTEMDRIVE\%\\Qt\\Qt5.7.0\\vcredist";
  if( !run_command( $vcredist . " /norestart /q" )) {
    output( "Failed: $!. \n" );
    return 0;
  }

  output( "Done\n" );

  # This is per user so needs to be done with create_active_setup
  # Top command prompts "is this a file or directory" so enter f
  output( "Performing Visual Studio 2015's Qt setup: " );
  if( !run_command( "echo f | XCOPY \"$vs_hkcu\" \"$local_reg\" /Y /Q /I" )
      || !create_activesetup_action(
       'Identifier' =&gt; $INSTALLMONKEY_OPTIONS{'package_id'}.'_setup',
       'ComponentID' =&gt; $INSTALLMONKEY_OPTIONS{'package_id'},
       'Description' =&gt; 'Registers qt in the vs-addin in visual studio. Has to be done per user.',
       'Description' =&gt; 'Adds file associations for QT per user',
       'Version' =&gt; '1,0',
       'StubPath' =&gt; "regedit.exe /s ".$local_reg ) )
  {
    output( "FAILED!\n" );
    return 0;
  }
  output( "Done\n" );

  # Also need to delete old active setup or it will complain about missing plugins
  $Registry-&gt;Delimiter("/");
  delete $Registry-&gt;{"LMachine/Software/Microsoft/Active Setup/Installed Components/qt.5_0_2.vs2010_setup/"};

  output( "Adding shortcuts to start menu: " );
  if( !run_command( "XCOPY \"$srcfiles\\Start Menu\" \"".$ENV{'ALLUSERSPROFILE'}."\\Microsoft\\Windows\\Start Menu\" /E /Y /I /Q" ) )
  {
    output( "FAILED!\n" );
    return 0;
  }

  output( "Installation complete!\n" );
  return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    prerequisite_sub =&gt; \&amp;prereq,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\qt.5_9_0\prod\update.pl</FullName>
    <Length>4563</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-07-18T11:51:43.4388868-05:00</CreationTime>
    <CreationTimeUtc>2017-07-18T16:51:43.4388868Z</CreationTimeUtc>
    <LastWriteTime>2017-08-04T13:16:33.1518957-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-08-04T18:16:33.1518957Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-18T11:51:43.4388868-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-18T16:51:43.4388868Z</LastAccessTimeUtc>
    <Text># Qt for visual studio 2013
# Package Created June 2013
# Packaged by Billy Rhoades
# Updated 2017-07-10 by Sergey Gruzdev

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use Win32;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'qt.5_9_0',
        package_revision =&gt; '20170710T0836',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Archive::Extract;
use Win32::TieRegistry;


#Called by ActiveSetup on each user profile creation assoc. qt w/ vs
my $src = get_pkg_sourcefiles();
my $local_reg = $ENV{'SYSTEMDRIVE'}."\\ProgramData\\mst\\standard\\QT\\vs_hkcu.reg";
my $qt_hklm = "$src\\qt_hklm.reg";
my $vs_hklm = "$src\\vs_hklm.reg";
my $vs_hkcu = "$src\\vs_hkcu.reg";

sub prereq
{
  if( is_installed( "visual_studio.2015u2" ) || is_installed( "visual_studio.2015u3" ) || is_installed( "visual_studio.2015u3" ) )
  {
    output( "Visual Studio 2015 is installed\n" );
    return 1;
  }
  else
  {
    output( "Visual Studio 2015 isn't installed, please install it before proceeding.\n" );
    return 0;
  }
}

sub install
{
  select STDOUT;

  #due to the installers dropping all silent flags, the contents are now just extracted to where they need to go
  my $zip = "C:\\Program Files\\7-zip\\7z.exe";

  output( "Extracting Qt 5.9.0: " );
  # Extract right to the C drive
  if(!run_command("\"$zip\" x \"$src\"\\Qt.zip -aoa -oC:"))
  {
    output( "FAILED!\n" );
    return 0;
  }
  output( "Done\n" );


  # /S works with this plugin but causes it to hang 90% of the times it is run, so manually create registry entries instead
  # Extract straight into program files
  output( "Extracting Qt Visual Studio Add-In 1.2.3: " );
  if(!run_command("\"$zip\" x \"$src\"\\VSaddin.zip -aoa -o\"C:\\Program Files (x86)\""))
  {
    output( "FAILED!\n" );
    return 0;
  }

  output( "Done\n" );


  #adds qt and addin to uninstall and adds file associations.
  output( "Adding appropriate registry entries: " );
  if( !run_command( "regedit.exe /s $qt_hklm" ) || !run_command( "regedit.exe /s $vs_hklm" ) )
  {
    output( "FAILED!\n" );
    return 0;
  }

  output( "Done\n" );

  return 1;
}

sub postinstall
{
  #vcredist used by the addin + one included with qt
  # output( "Executing included Visual C++ Redistributables: " )
  my $vcredist = build_path("C:", "Qt", "Qt5.9.0", "vcredist", "vcredist_msvc2015_x86.exe");
  if( !run_command( $vcredist . " /norestart /q" )) {
    output( "Failed: $!. \n" );
    return 0;
  }

  output( "Done\n" );

  # This is per user so needs to be done with create_active_setup
  # Top command prompts "is this a file or directory" so enter f
  output( "Performing Visual Studio 2015's Qt setup: " );
  if( !run_command( "echo f | XCOPY \"$vs_hkcu\" \"$local_reg\" /Y /Q /I" )
      || !create_activesetup_action(
       'Identifier' =&gt; $INSTALLMONKEY_OPTIONS{'package_id'}.'_setup',
       'ComponentID' =&gt; $INSTALLMONKEY_OPTIONS{'package_id'},
       'Description' =&gt; 'Registers qt in the vs-addin in visual studio. Has to be done per user.',
       'Description' =&gt; 'Adds file associations for QT per user',
       'Version' =&gt; '1,0',
       'StubPath' =&gt; "regedit.exe /s ".$local_reg ) )
  {
    output( "FAILED!\n" );
    return 0;
  }
  output( "Done\n" );

  # Also need to delete old active setup or it will complain about missing plugins
  $Registry-&gt;Delimiter("/");
  delete $Registry-&gt;{"LMachine/Software/Microsoft/Active Setup/Installed Components/qt.5_0_2.vs2010_setup/"};

  output( "Adding shortcuts to start menu: " );
  if( !run_command( "XCOPY \"$src\\Start Menu\" \"".$ENV{'ALLUSERSPROFILE'}."\\Microsoft\\Windows\\Start Menu\" /E /Y /I /Q" ) )
  {
    output( "FAILED!\n" );
    return 0;
  }

  output( "Installation complete!\n" );
  return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    prerequisite_sub =&gt; \&amp;prereq,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update_old.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\qt.5_9_0\prod\update_old.pl</FullName>
    <Length>1375</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-07-18T11:51:43.4701568-05:00</CreationTime>
    <CreationTimeUtc>2017-07-18T16:51:43.4701568Z</CreationTimeUtc>
    <LastWriteTime>2017-06-28T08:06:03.6189858-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-28T13:06:03.6189858Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-18T11:51:43.4701568-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-18T16:51:43.4701568Z</LastAccessTimeUtc>
    <Text># QT 5.9.0
# Package created by Sergey Gruzdev
# Package created 6/22/2017
# Package last edited 6/22/2017 by Sergey Gruzdev

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'qt.5_9_0',
		package_revision =&gt; '20170622T1546',
	);
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $src = get_pkg_sourcefiles();

sub install
{
  print "Running QT installer...\n";
  # Run the installation script
  my $success = run_command("\"$src\\qt-opensource-windows-x86-5.9.0.exe\" --verysilent");
  #sleep(9500);
  if(!$success)
  {
    print "Error while installing QT: failed!\n";
	return 0;
  }
  print "Installation complete!\n";
  return 1;
}

do_install
(
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x86, OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\qtcreator.4_6_0\dev\update.pl</FullName>
    <Length>1916</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-07-30T10:16:38.5271554-05:00</CreationTime>
    <CreationTimeUtc>2018-07-30T15:16:38.5271554Z</CreationTimeUtc>
    <LastWriteTime>2018-07-30T10:37:03.2798325-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-30T15:37:03.2798325Z</LastWriteTimeUtc>
    <LastAccessTime>2018-07-30T10:16:38.5271554-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-07-30T15:16:38.5271554Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Package Created July 2018
# Packaged by Robert Smith
# Updated 2018-07-30 by Robert Smith

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use Win32;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'qtcreator.4_6_0',
        package_revision =&gt; '20180730T1017',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Archive::Extract;
use Win32::TieRegistry;


my $src = get_pkg_sourcefiles();

sub install
{
  select STDOUT;

  #due to the installers dropping all silent flags, the contents are now just extracted to where they need to go
  my $zip = "C:\\Program Files\\7-zip\\7z.exe";

  output( "Extracting Qt Creator 4.6.0: " );
  # Extracts Qt.zip to C:\, creator will be in C:\Qt\qtcreator-4.6.0
  if(!run_command("\"$zip\" x \"$src\"\\Qt.zip -aoa -oC:"))
  {
    output( "FAILED!\n" );
    return 0;
  }
  output( "Done\n" );

  return 1;
}

sub postinstall
{
  output( "Adding shortcuts to start menu: " );
  if( !run_command( "XCOPY \"$src\\Start Menu\" \"".$ENV{'ALLUSERSPROFILE'}."\\Microsoft\\Windows\\Start Menu\" /E /Y /I /Q" ) )
  {
    output( "FAILED!\n" );
    return 0;
  }

  output( "Installation complete!\n" );
  return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\qtcreator.4_6_0\prod\update.pl</FullName>
    <Length>1916</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-07-30T10:40:59.0989806-05:00</CreationTime>
    <CreationTimeUtc>2018-07-30T15:40:59.0989806Z</CreationTimeUtc>
    <LastWriteTime>2018-07-30T10:37:03.2798325-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-30T15:37:03.2798325Z</LastWriteTimeUtc>
    <LastAccessTime>2018-07-30T10:40:59.0989806-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-07-30T15:40:59.0989806Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Package Created July 2018
# Packaged by Robert Smith
# Updated 2018-07-30 by Robert Smith

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use Win32;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'qtcreator.4_6_0',
        package_revision =&gt; '20180730T1017',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Archive::Extract;
use Win32::TieRegistry;


my $src = get_pkg_sourcefiles();

sub install
{
  select STDOUT;

  #due to the installers dropping all silent flags, the contents are now just extracted to where they need to go
  my $zip = "C:\\Program Files\\7-zip\\7z.exe";

  output( "Extracting Qt Creator 4.6.0: " );
  # Extracts Qt.zip to C:\, creator will be in C:\Qt\qtcreator-4.6.0
  if(!run_command("\"$zip\" x \"$src\"\\Qt.zip -aoa -oC:"))
  {
    output( "FAILED!\n" );
    return 0;
  }
  output( "Done\n" );

  return 1;
}

sub postinstall
{
  output( "Adding shortcuts to start menu: " );
  if( !run_command( "XCOPY \"$src\\Start Menu\" \"".$ENV{'ALLUSERSPROFILE'}."\\Microsoft\\Windows\\Start Menu\" /E /Y /I /Q" ) )
  {
    output( "FAILED!\n" );
    return 0;
  }

  output( "Installation complete!\n" );
  return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\QtSpim.9_1_19\prod\update.pl</FullName>
    <Length>1566</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-07-27T11:03:15.4264731-05:00</CreationTime>
    <CreationTimeUtc>2018-07-27T16:03:15.4264731Z</CreationTimeUtc>
    <LastWriteTime>2018-07-31T14:03:26.2950582-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-31T19:03:26.2950582Z</LastWriteTimeUtc>
    <LastAccessTime>2018-07-27T11:03:15.4264731-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-07-27T16:03:15.4264731Z</LastAccessTimeUtc>
    <Text># QtSpim 9.1.19
# Package Created April 2012
# Packaged by Jason Iverson
# Last Updated 7/27/2018 Gavin Altermatt

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'QtSpim.9_1_19',
        package_revision =&gt; '20180727T1106',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;




  my $sourcefilesdir = get_pkg_sourcefiles();
#added install to try to get it to install properly
sub install {
    #my $sourcefilesdir = get_pkg_sourcefiles();
    output( "Installing QtSpim: " );
    my $Success = install_msi(
        msi =&gt; "$sourcefilesdir\\QtSpim_9.1.19_Windows.msi",
    );
    output($Success ? "Success!\n" : "FAILED: $!\n");

    return $Success;
}
#end of new install
sub postinstall
{
    my $shortcut = get_allusers_desktop().'\QtSpim.lnk';
    output("\nRemoving desktop shortcuts...\n");
    run_command("DEL /F /Q \"${shortcut}\"");

    return 1;
}

do_install(
    msi_name =&gt; "QtSpim_9.1.19_Windows.msi",
    allowed_versions =&gt; [ OSVER_XP_32, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs =&gt; [ 'clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    additional_msi_properties =&gt; "ALLUSERS=\"1\" REBOOT=\"ReallySuppress\"",
    postinstall_sub =&gt; \&amp;postinstall,
    exit_on_failure =&gt; 1,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\r.3_2_2\dev\update.pl</FullName>
    <Length>1205</Length>
    <Extension>.pl</Extension>
    <CreationTime>2015-11-11T14:52:15.2104436-06:00</CreationTime>
    <CreationTimeUtc>2015-11-11T20:52:15.2104436Z</CreationTimeUtc>
    <LastWriteTime>2015-11-16T14:38:37.5413283-06:00</LastWriteTime>
    <LastWriteTimeUtc>2015-11-16T20:38:37.5413283Z</LastWriteTimeUtc>
    <LastAccessTime>2015-11-11T14:52:15.2104436-06:00</LastAccessTime>
    <LastAccessTimeUtc>2015-11-11T20:52:15.2104436Z</LastAccessTimeUtc>
    <Text># R 3.2.2
# Package Created November 11, 2015
# Packaged by Dzu Pham

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'r.3_2_2',
        package_revision =&gt; '20151111T1111',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles= get_pkg_sourcefiles();

sub install
{
  output("\nInstalling R 3.2.2: ");

  my $inf = '$srcfiles\\install_settings.inf';
  output((run_command("$srcfiles\\R-3.2.2-win.exe /loadinf=$inf /verysilent")?"OK":"FAILED").."\n");

  return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,

    install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\r.3_2_2\prod\update.pl</FullName>
    <Length>1359</Length>
    <Extension>.pl</Extension>
    <CreationTime>2015-11-11T14:52:21.7314108-06:00</CreationTime>
    <CreationTimeUtc>2015-11-11T20:52:21.7314108Z</CreationTimeUtc>
    <LastWriteTime>2015-11-20T14:14:01.2799273-06:00</LastWriteTime>
    <LastWriteTimeUtc>2015-11-20T20:14:01.2799273Z</LastWriteTimeUtc>
    <LastAccessTime>2015-11-16T14:47:45.5989807-06:00</LastAccessTime>
    <LastAccessTimeUtc>2015-11-16T20:47:45.5989807Z</LastAccessTimeUtc>
    <Text># R 3.2.2
# Package Created November 11, 2015
# Packaged by Dzu Pham

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'r.3_2_2',
        package_revision =&gt; '20151111T1111',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles= get_pkg_sourcefiles();
my $desktop=$ENV{"public"}."\\desktop";

sub install
{
  output("\nInstalling R 3.2.2: ");

  my $inf = '$srcfiles\\install_settings.inf';
  output((run_command("$srcfiles\\R-3.2.2-win.exe /loadinf=$inf /verysilent")?"OK":"FAILED").."\n");

  run_command("del /q \"$desktop\\R i386 3.2.2.ink\"");
  run_command("del /q \"$desktop\\R x64 3.2.2.ink\"");
  return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,

    install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\r.3_3_0\prod\update.pl</FullName>
    <Length>1403</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-06-20T10:30:15.5269793-05:00</CreationTime>
    <CreationTimeUtc>2016-06-20T15:30:15.5269793Z</CreationTimeUtc>
    <LastWriteTime>2016-06-22T13:15:07.1519819-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-06-22T18:15:07.1519819Z</LastWriteTimeUtc>
    <LastAccessTime>2016-06-20T10:30:15.5269793-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-06-20T15:30:15.5269793Z</LastAccessTimeUtc>
    <Text># R 3.3.0
# Package Created June 20, 2016
# Packaged by Austin Wall
# Last Updated June 21, 2016 by Austin Wall
=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'r.3_3_0',
        package_revision =&gt; '20160621T1649',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
my $srcfiles= get_pkg_sourcefiles();
my $desktop = $ENV{"public"}."\\desktop";

sub install
{
  output("\nInstalling R 3.3.0: ");

  
  my $inf = '$srcfiles\\install_settings.inf';
  output((run_command("$srcfiles\\R-3.3.0-win.exe /loadinf=$inf /verysilent")?"OK":"FAILED").."\n");
  run_command("del /q \"$desktop\\R i386 3.3.0.lnk\"");
  run_command("del /q \"$desktop\\R x64 3.3.0.lnk\"");

  return 1;
}
do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,

    install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\r.3_3_2\prod\update.pl</FullName>
    <Length>1377</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-12-06T10:16:33.3431519-06:00</CreationTime>
    <CreationTimeUtc>2016-12-06T16:16:33.3431519Z</CreationTimeUtc>
    <LastWriteTime>2016-12-06T10:16:33.5459558-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-12-06T16:16:33.5459558Z</LastWriteTimeUtc>
    <LastAccessTime>2016-12-06T10:16:33.3743525-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-12-06T16:16:33.3743525Z</LastAccessTimeUtc>
    <Text># R 3.3.2
# Package Created Dec 6, 2016
# Packaged by Ronith Muttur

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'r.3_3_2',
        package_revision =&gt; '20161206T1011',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
my $srcfiles= get_pkg_sourcefiles();
my $desktop = $ENV{"public"}."\\desktop";

sub install
{
  output("\nInstalling R 3.3.2: ");

  
  my $inf = '$srcfiles\\install_settings.inf';
  output((run_command("$srcfiles\\R-3.3.2-win.exe /loadinf=$inf /verysilent")?"OK":"FAILED").."\n");
  run_command("del /q \"$desktop\\R i386 3.3.2.lnk\"");
  run_command("del /q \"$desktop\\R x64 3.3.2.lnk\"");

  return 1;
}
do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,

    install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\r.3_4_2\prod\update.pl</FullName>
    <Length>1378</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-09T10:52:28.2854098-06:00</CreationTime>
    <CreationTimeUtc>2017-11-09T16:52:28.2854098Z</CreationTimeUtc>
    <LastWriteTime>2017-11-09T11:04:55.0544003-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-11-09T17:04:55.0544003Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-09T10:52:28.2854098-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-09T16:52:28.2854098Z</LastAccessTimeUtc>
    <Text># R 3.4.2
# Package Created Nov 9, 2017
# Packaged by Benjamin Krueger
=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'r.3_4_2',
        package_revision =&gt; '20171109T1058',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
my $srcfiles= get_pkg_sourcefiles();
my $desktop = $ENV{"public"}."\\desktop";

sub install
{
  output("\nInstalling R 3.4.2: ");

  
  my $inf = '$srcfiles\\install_settings.inf';
  output((run_command("$srcfiles\\R-3.4.2-win.exe /loadinf=$inf /verysilent")?"OK":"FAILED").."\n");
  run_command("del /q \"$desktop\\R i386 3.4.2.lnk\"");
  run_command("del /q \"$desktop\\R x64 3.4.2.lnk\"");

  return 1;
}
do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,

    install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\racket.6_11\prod\update.pl</FullName>
    <Length>2353</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-10T16:06:32.0986361-06:00</CreationTime>
    <CreationTimeUtc>2017-11-10T22:06:32.0986361Z</CreationTimeUtc>
    <LastWriteTime>2018-01-24T10:37:15.519751-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-24T16:37:15.519751Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-10T16:06:32.2355625-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-10T22:06:32.2355625Z</LastAccessTimeUtc>
    <Text># Racket 6.11
# Package Created Fall 2017
# Packaged by Alex Schrimpf
# Last Updated Fall 2017 by Alex Schrimpf


=pod

Begin-Doc
Modified: 
Name: 
Type:
Description: 
Language: Perl
LastUpdatedBy:
Version:
Doc-Package-Info
Doc-SVN-Repository:
RCSId:
End-Doc

=cut

use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'racket.6_11',
        package_revision =&gt; '',
    );
}

use lib ( '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 'C:\temp' );

use InstallMonkey::Shared;

use IM_helper(
    \%INSTALLMONKEY_OPTIONS,
    v4.04,
    (
        "EXTRACT" =&gt; [
            sub{
                IM_helper::extract_files(
                    from=&gt;["$IM_helper::source_files\\program_files.zip"],
                    to=&gt;'C:\Program Files'
                );
            }
        ],
        "COPY_SHORTCUTS" =&gt; [
            sub {
                IM_helper::run_command(
                    description=&gt;"Copying shortcuts",
                    command=&gt;"xcopy /Y /I \"$IM_helper::source_files\\icons\\Racket\" \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Racket\""
                );
            }            
        ],
        "UNINSTALL" =&gt; [
            sub {
                IM_helper::rm_dir(
                    dir=&gt;"C:\\Program Files\\Racket"
                );
            },        
            sub {
                IM_helper::rm_dir(
                    dir=&gt;"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Racket"
                );
            },
            sub {
                delete_product_registry_key(get_package_id());
            },
        ]
    )
);

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt;
      [ 'clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    no_install_check =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    no_product_key =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    install_sub =&gt; $IM_helper::exec_call_stack_override || sub{IM_helper::exec_call_stacks(ids=&gt;["EXTRACT","COPY_SHORTCUTS"])}
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\racket.6_4\prod\update.pl</FullName>
    <Length>866</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-07-15T16:14:24.3607954-05:00</CreationTime>
    <CreationTimeUtc>2016-07-15T21:14:24.3607954Z</CreationTimeUtc>
    <LastWriteTime>2016-07-18T08:57:02.7832601-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-07-18T13:57:02.7832601Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-18T13:54:45.7207353-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-18T18:54:45.7207353Z</LastAccessTimeUtc>
    <Text>
BEGIN{
    %INSTALLMONKEY_OPTIONS =(
        package_id =&gt; "racket.6_4",
        package_revision =&gt; "6.420160714T1434"
    )
}

use lib(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;


sub install {
    if(!run_command(get_pkg_sourcefiles."\\install.exe"))
    {
        return 0;
    }
    return 1;
}


sub postinstall
{
    KillProcess("racket-6.4-x86_64-win32.exe");
    return 1;   
}
do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1,OSVER_WIN8_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64,OSARCH_x86],
    allowed_regs =&gt; ['desktop','virtual-desktop','traveling','clc','virtual-clc'],
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\racket.6_7\prod\update.pl</FullName>
    <Length>863</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-12-28T10:40:38.9183313-06:00</CreationTime>
    <CreationTimeUtc>2016-12-28T16:40:38.9183313Z</CreationTimeUtc>
    <LastWriteTime>2016-12-28T10:44:09.1337213-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-12-28T16:44:09.1337213Z</LastWriteTimeUtc>
    <LastAccessTime>2016-12-28T10:40:38.9183313-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-12-28T16:40:38.9183313Z</LastAccessTimeUtc>
    <Text>
BEGIN{
    %INSTALLMONKEY_OPTIONS =(
        package_id =&gt; "racket.6_7",
        package_revision =&gt; "20161228T1044"
    )
}

use lib(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;


sub install {
    if(!run_command(get_pkg_sourcefiles."\\install.exe"))
    {
        return 0;
    }
    return 1;
}


sub postinstall
{
    KillProcess("racket-6.4-x86_64-win32.exe");
    return 1;   
}
do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1,OSVER_WIN8_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64,OSARCH_x86],
    allowed_regs =&gt; ['desktop','virtual-desktop','traveling','clc','virtual-clc'],
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\remote_server_admin_tools.1_1\prod\update.pl</FullName>
    <Length>2293</Length>
    <Extension>.pl</Extension>
    <CreationTime>2015-10-07T18:01:44.9194616-05:00</CreationTime>
    <CreationTimeUtc>2015-10-07T23:01:44.9194616Z</CreationTimeUtc>
    <LastWriteTime>2015-10-08T15:21:00.6493925-05:00</LastWriteTime>
    <LastWriteTimeUtc>2015-10-08T20:21:00.6493925Z</LastWriteTimeUtc>
    <LastAccessTime>2015-10-07T18:01:44.9194616-05:00</LastAccessTime>
    <LastAccessTimeUtc>2015-10-07T23:01:44.9194616Z</LastAccessTimeUtc>
    <Text># Package created 2015-10-07
# Packaged by Dillon Lustick

=begin
Begin-Doc
Modified: Oct 07, 2015
Name: Remote Server Admin Tools
Type: script
Description: Installs the Remote Server Admin Tools on Win10
Language: Perl
LastUpdatedBy: t-dwlfk2
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc
=cut

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'remote_server_admin_tools.win10',
        package_revision =&gt; '20151007T1300',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

sub install {
    # Server admin tools have an installer in windows 10
    # instead of using DISM
    output("Installing RSAT x64: ");
    if( !run_command("wusa.exe \"$srcfiles\\WindowsTH-KB2693643-x64.msu\" /quiet /norestart",
                     'IgnoreExitCodes' =&gt; [ 3010 ] ) ) { # Reboot required
        return 0;
    }
    output("OK\n");
    
    return 1;
}



sub postinstall {
    my $startmenu = get_allusers_start_menu();
    output("Creating Start Menu Shortcuts...\n");
    # dsa.msc doesn't exist until next reboot and causes the script to fail
    # if you use create_shortcut() from IM.
    if(!run_command("xcopy /Q/Y/E \"$srcfiles\\Active Directory Users and Computers.lnk ".
                    "\"$startmenu\\Programs\\IT Admin Tools\\\"")) {
        output("Failed to copy shortcut.\n");
    }

    output("Setting Folder Permissions...\n");
    if(!run_command('icacls "'.$allusersstartmenu.'\\Programs\\IT Admin Tools" /inheritance:r /remove Users',
            'Description' =&gt; 'Setting Permissions'))
    {
        output("Failed to set permissions.\n");
    }
    
    return 1;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                     'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);


</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\revit.2018\prod\update.pl</FullName>
    <Length>3027</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-15T10:49:31.1065164-05:00</CreationTime>
    <CreationTimeUtc>2017-06-15T15:49:31.1065164Z</CreationTimeUtc>
    <LastWriteTime>2018-05-04T09:53:45.9814812-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-04T14:53:45.9814812Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-15T10:49:31.1065164-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-15T15:49:31.1065164Z</LastAccessTimeUtc>
    <Text># Package Created June 15, 2017
# Packaged by Austin Wall
# Last Updated 

use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'revit.2018',
        package_revision =&gt; '20170615T1050',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Win32::TieRegistry;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

sub preinstall{
    output("Clearing reboot flag...\n");
    $Registry-&gt;Delimiter("/");
    # The setup will restart the machine first if this key exists
    delete $Registry-&gt;{"LMachine/Software/Microsoft/Windows/CurrentVersion/WindowsUpdate/Auto Update/RebootRequired/"};
}

sub install{
    # This is run from appdeploy to avoid copying over 6GB of files per install.
    # The setup is generated with "Create Deployment" in the original install file.
    # More info available on wiki.
    my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\revit2018\\Img";
    my $command = "$appdeploy\\Setup.exe /W /qb /I $appdeploy\\revit.2018.ini /language en-us";

    output("Installing Autodesk Revit...\n");
    run_command($command, 'IgnoreReturnCode'=&gt;1);

    # The run_command spawns a separate process and returns immediately so this loop waits until setup.exe finishes running.
    my $index = 0;
    while($index &lt; 3600) # 3600*5sec = 5 hours
    {
        $_ = `tasklist`;
        if(/setup\.exe/gi){
            $index++;
            sleep(5);
        }
        else{
            output("Setup finished!\n");
            return 1;
        }
    }

    output("Timed out...\n");

    return 0;
}

sub postinstall
{
    my $cwd = cwd();

    print("Copying License...\n");
    my $dest = get_arch_programfiles(OSARCH_x64).'\\Autodesk\\Revit 2018\\';
    run_command("copy \"$cwd\\LICPATH.LIC\" \"$dest\" /Y");
    run_command("setx ADSKFLEX_LICENSE_FILE \"C:\\Program Files\\Autodesk\\Revit 2018\\LICPATH.LIC\" \/m");

    output("Deleting desktop icons...\n");
    my $desk = get_allusers_desktop();
    run_command("DEL /Q \"$desk\\Revit 2018.lnk\"");
    run_command("DEL /Q \"$desk\\Dynamo 0.9.1.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk Desktop App.lnk\"");
    run_command("DEL /Q \"$desk\\Worksharing Monitor for Autodesk Revit 2018.lnk\"");
    return 1;
}

do_install(
    no_source_files  =&gt; "1",
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
#    prerequisite_sub =&gt; \&amp;prerequisite,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\revit.2019\prod\update.pl</FullName>
    <Length>3236</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-07T09:49:43.1327908-05:00</CreationTime>
    <CreationTimeUtc>2018-06-07T14:49:43.1327908Z</CreationTimeUtc>
    <LastWriteTime>2018-06-20T11:39:03.3407383-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-20T16:39:03.3407383Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-07T09:49:43.1327908-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-07T14:49:43.1327908Z</LastAccessTimeUtc>
    <Text># Package Created June 15, 2017
# Packaged by Austin Wall
# Last Updated by Gavin Altermatt

use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'revit.2019',
        package_revision =&gt; '20180607T1314',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Win32::TieRegistry;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

sub preinstall{
    output("Clearing reboot flag...\n");
    $Registry-&gt;Delimiter("/");
    # The setup will restart the machine first if this key exists
    delete $Registry-&gt;{"LMachine/Software/Microsoft/Windows/CurrentVersion/WindowsUpdate/Auto Update/RebootRequired/"};
}

sub install{
    # This is run from appdeploy to avoid copying over 6GB of files per install.
    # The setup is generated with "Create Deployment" in the original install file.
    # More info available on wiki.
    my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\revit2019\\Img";
    my $command = "$appdeploy\\Setup.exe /W /qb /I $appdeploy\\revit.2019.ini /language en-us";

    output("Installing Autodesk Revit...\n");
    run_command($command, 'IgnoreReturnCode'=&gt;1);

    # The run_command spawns a separate process and returns immediately so this loop waits until setup.exe finishes running.
    my $index = 0;
    while($index &lt; 3600) # 3600*5sec = 5 hours
    {
        $_ = `tasklist`;
        if(/setup\.exe/gi){
            $index++;
            sleep(5);
        }
        else{
            output("Setup finished!\n");
            return 1;
        }
    }

    output("Timed out...\n");

    return 0;
}

sub postinstall
{
    my $cwd = cwd();

    print("Copying License...\n");
    my $dest = get_arch_programfiles(OSARCH_x64).'\\Autodesk\\Revit 2019\\';
    run_command("copy \"$cwd\\LICPATH.LIC\" \"$dest\" /Y");
    run_command("setx ADSKFLEX_LICENSE_FILE \"C:\\Program Files\\Autodesk\\Revit 2019\\LICPATH.LIC\" \/m");

    output("Deleting desktop icons...\n");
    my $desk = get_allusers_desktop();
    run_command("DEL /Q \"$desk\\Revit 2019.lnk\"");
    run_command("DEL /Q \"$desk\\Dynamo 0.9.1.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk Desktop App.lnk\"");
    run_command("DEL /Q \"$desk\\Worksharing Monitor for Autodesk Revit 2019.lnk\"");
    #if( !run_command("start /wait \"\" del /Q \"$desk\\Autodesk ReCap Photo.lnk\" " ))
  #  {
    #  output( "Failed to delete Autodesk ReCap Photo.lnk\n" );
  #  }


    return 1;
}

do_install(
    no_source_files  =&gt; "1",
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
#    prerequisite_sub =&gt; \&amp;prerequisite,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\ricardo_wave_vectis.2016_2\prod\update.pl</FullName>
    <Length>1580</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-06T10:06:55.3978283-06:00</CreationTime>
    <CreationTimeUtc>2017-11-06T16:06:55.3978283Z</CreationTimeUtc>
    <LastWriteTime>2017-11-14T10:35:23.1208735-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-11-14T16:35:23.1208735Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-06T10:06:55.3978283-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-06T16:06:55.3978283Z</LastAccessTimeUtc>
    <Text># Maple 2017
# Package created by Ryan Andrews
# Package created 11/6/2017
# Package last edited ...

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'ricardo_wave_vectis.2016_2',
		package_revision =&gt; '20171106T1008',
	);
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

my $src = get_pkg_sourcefiles();
our $install = "$src\\RS_2016.2_windows_installer.exe --mode unattended ";

sub install {
	output("Installing Ricardo Wave Vectis 2016.2: ");
  # Run install command
  if(!run_command($install)) {
    output("Failed: $!\n");
		return 0;
  }
  output("Done!\n");
  return 1;
}

sub postinstall
{
	output("Adding license registry key...");

  if(!run_command("setx RICARDO_LICENSE_FILE \"1714\@ricardo.lic.mst.edu\" /M"))
  {
      output("FAILED!\n");
      return 0;
  }
  return 1;
}

do_install
(
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'virtual-clc', 'desktop', 'virtual-desktop', 'traveling'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\robotstructural_2018.x64\prod\update.pl</FullName>
    <Length>3047</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-15T14:38:10.4503636-05:00</CreationTime>
    <CreationTimeUtc>2017-06-15T19:38:10.4503636Z</CreationTimeUtc>
    <LastWriteTime>2017-06-15T14:40:04.3510743-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-15T19:40:04.3510743Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-15T14:38:10.4503636-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-15T19:38:10.4503636Z</LastAccessTimeUtc>
    <Text># Package Created June 15, 2017
# Packaged by Austin Wall
# Last Updated 

use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'robotstructural_2018.x64',
        package_revision =&gt; '20170615T1438',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Win32::TieRegistry;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

sub preinstall{
    output("Clearing reboot flag...\n");
    $Registry-&gt;Delimiter("/");
    # The setup will restart the machine first if this key exists
    delete $Registry-&gt;{"LMachine/Software/Microsoft/Windows/CurrentVersion/WindowsUpdate/Auto Update/RebootRequired/"};
}

sub install{
    # This is run from appdeploy to avoid copying over 6GB of files per install.
    # The setup is generated with "Create Deployment" in the original install file.
    # More info available on wiki.
    my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\robot_structural2018\\Img";
    my $command = "$appdeploy\\Setup.exe /W /qb /I $appdeploy\\robot_structural2018.ini /language en-us";

    output("Installing Autodesk Robot Structural...\n");
    run_command($command, 'IgnoreReturnCode'=&gt;1);

    # The run_command spawns a separate process and returns immediately so this loop waits until setup.exe finishes running.
    my $index = 0;
    while($index &lt; 3600) # 3600*5sec = 5 hours
    {
        $_ = `tasklist`;
        if(/setup\.exe/gi){
            if(($index%12)==0) {output((300 - ($index/12))."minutes left\n");}
            $index++;
            sleep(5);
        }
        else{
            output("Setup finished!\n");
            return 1;
        }
    }

    output("Timed out...\n");

    return 0;
}

sub postinstall
{
    my $cwd = cwd();

    print("Copying License...\n");
    my $dest = get_arch_programfiles(OSARCH_x64).'\\Autodesk\\';
    run_command("copy \"$cwd\\LICPATH.LIC\" \"$dest\" /Y");
    run_command("setx ADSKFLEX_LICENSE_FILE \"C:\\Program Files\\Autodesk\\LICPATH.LIC\" \/m");

    output("Deleting desktop icons...\n");
    my $desk = get_allusers_desktop();
    run_command("DEL /Q \"$desk\\Autodesk Robot Structural Analysis Professional 2018.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk Desktop App.lnk\"");

    return 1;
}

do_install(
    no_source_files  =&gt; "1",
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
#    prerequisite_sub =&gt; \&amp;prerequisite,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\robotstructural_2019.x64\prod\update.pl</FullName>
    <Length>3066</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-07T08:40:06.8544865-05:00</CreationTime>
    <CreationTimeUtc>2018-06-07T13:40:06.8544865Z</CreationTimeUtc>
    <LastWriteTime>2018-06-18T15:57:27.8745235-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-18T20:57:27.8745235Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-07T08:40:06.8544865-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-07T13:40:06.8544865Z</LastAccessTimeUtc>
    <Text># Package Created June 15, 2017
# Packaged by Austin Wall
# Last Updated by Gavin Altermatt

use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'robotstructural_2019.x64',
        package_revision =&gt; '20180607T0841',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Win32::TieRegistry;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

sub preinstall{
    output("Clearing reboot flag...\n");
    $Registry-&gt;Delimiter("/");
    # The setup will restart the machine first if this key exists
    delete $Registry-&gt;{"LMachine/Software/Microsoft/Windows/CurrentVersion/WindowsUpdate/Auto Update/RebootRequired/"};
}

sub install{
    # This is run from appdeploy to avoid copying over 6GB of files per install.
    # The setup is generated with "Create Deployment" in the original install file.
    # More info available on wiki.
    my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\robot_structural2019\\Img";
    my $command = "$appdeploy\\Setup.exe /W /qb /I $appdeploy\\robot_structural.2019.ini /language en-us";

    output("Installing Autodesk Robot Structural...\n");
    run_command($command, 'IgnoreReturnCode'=&gt;1);

    # The run_command spawns a separate process and returns immediately so this loop waits until setup.exe finishes running.
    my $index = 0;
    while($index &lt; 3600) # 3600*5sec = 5 hours
    {
        $_ = `tasklist`;
        if(/setup\.exe/gi){
            if(($index%12)==0) {output((300 - ($index/12))."minutes left\n");}
            $index++;
            sleep(5);
        }
        else{
            output("Setup finished!\n");
            return 1;
        }
    }

    output("Timed out...\n");

    return 0;
}

sub postinstall
{
    my $cwd = cwd();

    print("Copying License...\n");
    my $dest = get_arch_programfiles(OSARCH_x64).'\\Autodesk\\';
    run_command("copy \"$cwd\\LICPATH.LIC\" \"$dest\" /Y");
    run_command("setx ADSKFLEX_LICENSE_FILE \"C:\\Program Files\\Autodesk\\LICPATH.LIC\" \/m");

    output("Deleting desktop icons...\n");
    my $desk = get_allusers_desktop();
    run_command("DEL /Q \"$desk\\Autodesk Robot Structural Analysis Professional 2019.lnk\"");
    run_command("DEL /Q \"$desk\\Autodesk Desktop App.lnk\"");

    return 1;
}

do_install(
    no_source_files  =&gt; "1",
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
#    prerequisite_sub =&gt; \&amp;prerequisite,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\Rocscience_2017\prod\update.pl</FullName>
    <Length>4947</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-17T19:10:28.1889269-06:00</CreationTime>
    <CreationTimeUtc>2017-11-18T01:10:28.1889269Z</CreationTimeUtc>
    <LastWriteTime>2018-01-25T08:17:36.1811571-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-25T14:17:36.1811571Z</LastWriteTimeUtc>
    <LastAccessTime>2018-01-14T13:48:35.6556317-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-01-14T19:48:35.6556317Z</LastAccessTimeUtc>
    <Text># Rocscience 2017
# Package Created Fall 2017
# Packaged by Alex Schrimpf
# Last Updated Winter 2017 by Alex Schrimpf

=pod

Begin-Doc
Modified: 
Name: 
Type:
Description: 
Language: Perl
LastUpdatedBy:
Version:
Doc-Package-Info
Doc-SVN-Repository:
RCSId:
End-Doc

=cut

use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'Rocscience.2017',
        package_revision =&gt; '',
    );
}

use lib ( '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 'C:\temp' );

use InstallMonkey::Shared;

my $umr_scripts_dir = "C:\\Windows\\System32\\UMRInst\\scripts\\".get_package_id();

use IM_helper(
    \%INSTALLMONKEY_OPTIONS,
    v4.04,
    (
        "INSTALL" =&gt; [
        	# Begin-Doc
			################################
			# Description: Mimic the behavior of the ClientConfiguration_Utility.exe
			#   Usually we do this kind of thing afterward, but the install guide
			#   says to do this step first.
			# Returns: true/false on success/failure
			# LastUpdated: 2013-06-10
			# LastUpdatedBy: Todd Hartman
			################################
			# End-Doc
        	sub {
        		return (
	        		IM_helper::create_reg_key(
	        			root=&gt;'HKEY_LOCAL_MACHINE/',
	        			key=&gt;'SOFTWARE/Wow6432Node/Rocscience/',
	        		)
	        		&amp;&amp;
	        		IM_helper::set_reg_key_values(
	        			key=&gt;'HKEY_LOCAL_MACHINE/SOFTWARE/Wow6432Node/Rocscience/',
	        			values=&gt;['License'=&gt;['\\\\rocscience.lic.mst.edu\rocscience-lic\rocscience.lf','REG_SZ']]
	        		)
        		);

        	},
            sub {            	
                IM_helper::run_command(
                    description =&gt; 'Main Installer',
                    command =&gt; "\"$IM_helper::source_files\\rss1059o20s.exe\" /s /a /f1\"$IM_helper::source_files\\setup.iss\""
                );           
            },
            sub {
            	IM_helper::cp_file(
            		from=&gt;"$IM_helper::source_files\\Rocscience_auto_web.reg",
            		to_dir=&gt;$umr_scripts_dir,
                    succ_cb =&gt; sub{
                        IM_helper::create_activesetup(
                            command =&gt; "REG IMPORT \"$umr_scripts_dir\\Rocscience_auto_web.reg\"",
                            description =&gt; "Sets registry keys to automatically check web for registration"
                        );
                    }
            	);
            },
            sub {
                IM_helper::transform_ini(
                    old_file=&gt;"$IM_helper::source_files\\hasplm.ini",
                    new_file=&gt;"C:\\Program Files (x86)\\Common Files\\Aladdin Shared\\HASP\\hasplm.ini",
                    data=&gt;[
                        {
                            section=&gt;"SERVER",
                            key=&gt;"name",
                            new_value=&gt; $ENV{COMPUTERNAME}
                        },
                        {
                            section=&gt;"REMOTE",
                            key=&gt;"serveraddr",
                            new_value=&gt; "rocscience.lic.mst.edu"
                        }
                    ]
                );
            }
        ],
        "UNINSTALL" =&gt; [
            sub{
                IM_helper::get_uninstall_strings(
                    display_name=&gt; "Rocscience Software Suite",
                    succ_cb =&gt; sub{
                        my $x64_uninst_str = @{{@_}-&gt;{x64}}[0];
                        if(defined $x64_uninst_str){
                            return IM_helper::run_command(
                                description=&gt;"Rocscience Uninstaller x64",
                                command=&gt;$x64_uninst_str." -s -f1\"$IM_helper::source_files\\uninstall.iss\"",
                                succ_cb=&gt; sub{
                                    sleep(60*3); #Have to do this because uninstaller /wait command doesn't work
                                    return 1;
                                }
                            );                            
                        }
                        return 0;
                    }
                );
            },
            sub {
                delete_product_registry_key(get_package_id());
            },
        ]
    )
);

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt;
      [ 'clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    no_install_check =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    no_product_key =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    install_sub =&gt; $IM_helper::exec_call_stack_override || sub{IM_helper::exec_call_stacks(ids=&gt;["INSTALL"])}
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\rust.1_25_0\prod\update.pl</FullName>
    <Length>1615</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-07-02T13:01:16.6714025-05:00</CreationTime>
    <CreationTimeUtc>2018-07-02T18:01:16.6714025Z</CreationTimeUtc>
    <LastWriteTime>2018-07-02T13:14:29.8244575-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-02T18:14:29.8244575Z</LastWriteTimeUtc>
    <LastAccessTime>2018-07-02T13:01:16.7026429-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-07-02T18:01:16.7026429Z</LastAccessTimeUtc>
    <Text># Rust 1.25.0
# Package Created May 11th, 2018
# Packaged by Kade Wessels
# Last updated by Kade Wessels

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'rust.1_25_0',
        package_revision =&gt; '20180511T1611',
    );
}

# Add InstallMonkey Library to the path
use lib (
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);
use InstallMonkey::Shared;
use File::Basename;
use File::Path;
use File::Copy;

my $sourcefilesdir = get_pkg_sourcefiles();
my $applogs=get_applogs_dir();
my $programfiles = get_arch_programfiles(OSARCH_x64);


sub install
{

 	output("Installing Rust 1.25.0 (x64)\n");
    if(!run_command("start /wait $sourcefilesdir\\rust-1.25.0-x86_64-pc-windows-msvc.msi /quiet"))
    {
        output("Rust 1.25.0 (x64) installation did not complete!\n");
        return 0;
    }
    else{
        output("Rust 1.25.0 (x64) installation was successful!\n");
    }
    return 1;
}
	
do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                     'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
	  need_reboot =&gt; 0,
    install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\r_studio.0_99_489\dev\update.pl</FullName>
    <Length>1666</Length>
    <Extension>.pl</Extension>
    <CreationTime>2015-11-11T14:20:48.8412764-06:00</CreationTime>
    <CreationTimeUtc>2015-11-11T20:20:48.8412764Z</CreationTimeUtc>
    <LastWriteTime>2015-11-11T16:11:05.423328-06:00</LastWriteTime>
    <LastWriteTimeUtc>2015-11-11T22:11:05.423328Z</LastWriteTimeUtc>
    <LastAccessTime>2015-11-11T14:20:48.8412764-06:00</LastAccessTime>
    <LastAccessTimeUtc>2015-11-11T20:20:48.8412764Z</LastAccessTimeUtc>
    <Text># RStudio 0.99.473
# Package Created Aug 2015
# Packaged by Dzu Pham
# Last Updated ...

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'r_studio.0_99_489',
        package_revision =&gt; '20151111T1111',
    );
}


use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();

sub preinstall
{
  # Make sure you check on the WTG which version of R is installed
  # It installs R frist inside the R Studio WTG
  output("Checking if R is installed: ");
  if(!is_installed("r.3_2_2"))
  {
    output("Error Plesae Install R Software\n");
    return 0;
  }
  output("Program Found!\n");
  return 1;
}

sub install
{

  output("Installing RStudio 0.99.489: ");
  if(!run_command("\"$sourcefilesdir\\RStudio-0.99.489.exe\" /S"))
  {
    output("FAILED!!\n");
    return 0;
  }
  output("Success");
  return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\r_studio.0_99_489\prod\update.pl</FullName>
    <Length>1666</Length>
    <Extension>.pl</Extension>
    <CreationTime>2015-11-16T14:50:29.1691747-06:00</CreationTime>
    <CreationTimeUtc>2015-11-16T20:50:29.1691747Z</CreationTimeUtc>
    <LastWriteTime>2015-11-11T16:11:05.423328-06:00</LastWriteTime>
    <LastWriteTimeUtc>2015-11-11T22:11:05.423328Z</LastWriteTimeUtc>
    <LastAccessTime>2015-11-16T14:50:29.1691747-06:00</LastAccessTime>
    <LastAccessTimeUtc>2015-11-16T20:50:29.1691747Z</LastAccessTimeUtc>
    <Text># RStudio 0.99.473
# Package Created Aug 2015
# Packaged by Dzu Pham
# Last Updated ...

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'r_studio.0_99_489',
        package_revision =&gt; '20151111T1111',
    );
}


use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();

sub preinstall
{
  # Make sure you check on the WTG which version of R is installed
  # It installs R frist inside the R Studio WTG
  output("Checking if R is installed: ");
  if(!is_installed("r.3_2_2"))
  {
    output("Error Plesae Install R Software\n");
    return 0;
  }
  output("Program Found!\n");
  return 1;
}

sub install
{

  output("Installing RStudio 0.99.489: ");
  if(!run_command("\"$sourcefilesdir\\RStudio-0.99.489.exe\" /S"))
  {
    output("FAILED!!\n");
    return 0;
  }
  output("Success");
  return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\r_studio.0_99_902\prod\update.pl</FullName>
    <Length>2151</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-06-22T14:53:09.1909854-05:00</CreationTime>
    <CreationTimeUtc>2016-06-22T19:53:09.1909854Z</CreationTimeUtc>
    <LastWriteTime>2016-10-05T11:35:17.011343-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-10-05T16:35:17.011343Z</LastWriteTimeUtc>
    <LastAccessTime>2016-06-22T14:53:09.2845872-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-06-22T19:53:09.2845872Z</LastAccessTimeUtc>
    <Text># RStudio 0.99.902
# Package Created June 2016
# Packaged by Ronith (based on Dzu Pham's 2015 package)
# Last Updated by Dzu 

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description: it now supports installing R 3.3.0 (Note: this update was so it can run on software 2)
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'r_studio.0_99_902',
        package_revision =&gt; '20160622T1500',
    );
}


use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
my $desktop = $ENV{"public"}."\\desktop";

sub preinstall
{
  # This can now be standalone, it checks if R is installed or not.
  # Try to keep the 2 most current versions 
  output("Checking if R is installed: ");
  if(!is_installed("r.3_3_0") || !is_installed("r.3_3_2"))
  {
    output("R needs to be installed for R Studios to work\n");
    output("Installing R 3.3.0: ");

    my $inf = '$sourcefilesdir\\install_settings.inf';
    output((run_command("$sourcefilesdir\\R.3_3_0\\R-3.3.0-win.exe /loadinf=$inf /verysilent")?"OK":"FAILED").."\n");

    run_command("del /q \"$desktop\\R i386 3.3.0.ink\"");
    run_command("del /q \"$desktop\\R x64 3.3.0.ink\"");
  }
  else {
    output("OK\n");
  }
  return 1;
}

sub install
{

  output("Installing RStudio 0.99.902: ");
  if(!run_command("\"$sourcefilesdir\\RStudio-0.99.902.exe\" /S"))
  {
    output("FAILED!!\n");
    return 0;
  }
  output("Success");
  return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\r_studio.1_0_44\prod\update.pl</FullName>
    <Length>2455</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-12-05T09:42:41.3162062-06:00</CreationTime>
    <CreationTimeUtc>2016-12-05T15:42:41.3162062Z</CreationTimeUtc>
    <LastWriteTime>2016-12-05T14:38:05.3006455-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-12-05T20:38:05.3006455Z</LastWriteTimeUtc>
    <LastAccessTime>2016-12-05T09:42:41.3162062-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-12-05T15:42:41.3162062Z</LastAccessTimeUtc>
    <Text># RStudio 1.0.44
# Package Created June 2016
# Packaged by Ronith (based on Dzu Pham's 2015 package)
# Last Updated by Chris Schaaf

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description: it now supports installing R 3.3.0 (Note: this update was so it can run on software 2)
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'r_studio.1_0_44',
        package_revision =&gt; '20161205T1000',
    );
}


use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
my $desk = get_allusers_desktop();
my $desk2 = "C:\\Users\\All Users\\Desktop";

sub preinstall {
  # This can now be standalone, it checks if R is installed or not.
  # Try to keep the 2 most current versions 
  output("deskvar points to: $desk\n");
  output("Checking if R is installed: ");
 #I suck at logic, so let's write it out
 #	3.3.0	3.3.2	Install
 #		0		0		1
 #		0		1		0
 #		1		0		0
 #		1		1		X
  if(!(is_installed("r.3_3_0") || is_installed("r.3_3_2"))) {
    output("R needs to be installed for R Studios to work\n");
    output("Installing R 3.3.2: ");

    my $inf = '$sourcefilesdir\\install_settings.inf';
    output((run_command("$sourcefilesdir\\R.3_3_2\\R-3.3.2-win.exe /loadinf=$inf /verysilent")?"OK":"FAILED").."\n");

    run_command("del /f/q \"$desk\\R i386 3.3.2.ink\"");
    run_command("del /f/q \"$desk\\R x64 3.3.2.ink\"");
	run_command("del /f/q \"$desk2\\R i386 3.3.2.ink\"");
    run_command("del /f/q \"$desk2\\R x64 3.3.2.ink\"");
  }
  else {
    output("OK\n");
  }
  return 1;
}

sub install {

  output("Installing RStudio 1.0.44: ");
  if(!run_command("\"$sourcefilesdir\\RStudio-1.0.44.exe\" /S")) {
    output("FAILED!!\n");
    return 0;
  }
  output("Success");
  return 1;
}

do_install (
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\r_studio.1_1_383\update.pl</FullName>
    <Length>2490</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-09T11:46:10.3291188-06:00</CreationTime>
    <CreationTimeUtc>2017-11-09T17:46:10.3291188Z</CreationTimeUtc>
    <LastWriteTime>2017-11-09T11:46:10.3291188-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-11-09T17:46:10.3291188Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-09T11:46:10.3291188-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-09T17:46:10.3291188Z</LastAccessTimeUtc>
    <Text># RStudio 1.0.44
# Package Created June 2016
# Packaged by Ronith (based on Dzu Pham's 2015 package)
# Last Updated by Benjamin Krueger

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description: it now supports installing R 3.3.0 (Note: this update was so it can run on software 2)
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'r_studio.1_1_383',
        package_revision =&gt; '20171109T1020',
    );
}


use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
my $desk = get_allusers_desktop();
my $desk2 = "C:\\Users\\All Users\\Desktop";

sub preinstall {
  # This can now be standalone, it checks if R is installed or not.
  # Try to keep the 2 most current versions 
  output("deskvar points to: $desk\n");
  output("Checking if R is installed: ");
 #I suck at logic, so let's write it out
 #	3.3.0	3.3.2	Install
 #		0		0		1
 #		0		1		0
 #		1		0		0
 #		1		1		X
  if(!(is_installed("r.3_3_0") || is_installed("r.3_3_2") || is_installed("r.3_4_2"))) {
    output("R needs to be installed for R Studios to work\n");
    output("Installing R 3.3.2: ");

    my $inf = '$sourcefilesdir\\install_settings.inf';
    output((run_command("$sourcefilesdir\\R.3_3_2\\R-3.4.2-win.exe /loadinf=$inf /verysilent")?"OK":"FAILED").."\n");

    run_command("del /f/q \"$desk\\R i386 3.3.2.ink\"");
    run_command("del /f/q \"$desk\\R x64 3.3.2.ink\"");
	  run_command("del /f/q \"$desk2\\R i386 3.3.2.ink\"");
    run_command("del /f/q \"$desk2\\R x64 3.3.2.ink\"");
  }
  else {
    output("OK\n");
  }
  return 1;
}

sub install {

  output("Installing RStudio 1.0.44: ");
  if(!run_command("\"$sourcefilesdir\\RStudio-1.1.383.exe\" /S")) {
    output("FAILED!!\n");
    return 0;
  }
  output("Success");
  return 1;
}

do_install (
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\r_studio.1_1_383\prod\update.pl</FullName>
    <Length>2490</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-09T10:19:49.315838-06:00</CreationTime>
    <CreationTimeUtc>2017-11-09T16:19:49.315838Z</CreationTimeUtc>
    <LastWriteTime>2017-11-09T11:32:40.1468612-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-11-09T17:32:40.1468612Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-09T10:19:49.315838-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-09T16:19:49.315838Z</LastAccessTimeUtc>
    <Text># RStudio 1.0.44
# Package Created June 2016
# Packaged by Ronith (based on Dzu Pham's 2015 package)
# Last Updated by Benjamin Krueger

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description: it now supports installing R 3.3.0 (Note: this update was so it can run on software 2)
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'r_studio.1_1_383',
        package_revision =&gt; '20171109T1020',
    );
}


use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
my $desk = get_allusers_desktop();
my $desk2 = "C:\\Users\\All Users\\Desktop";

sub preinstall {
  # This can now be standalone, it checks if R is installed or not.
  # Try to keep the 2 most current versions 
  output("deskvar points to: $desk\n");
  output("Checking if R is installed: ");
 #I suck at logic, so let's write it out
 #	3.3.0	3.3.2	Install
 #		0		0		1
 #		0		1		0
 #		1		0		0
 #		1		1		X
  if(!(is_installed("r.3_3_0") || is_installed("r.3_3_2") || is_installed("r.3_4_2"))) {
    output("R needs to be installed for R Studios to work\n");
    output("Installing R 3.3.2: ");

    my $inf = '$sourcefilesdir\\install_settings.inf';
    output((run_command("$sourcefilesdir\\R.3_3_2\\R-3.3.2-win.exe /loadinf=$inf /verysilent")?"OK":"FAILED").."\n");

    run_command("del /f/q \"$desk\\R i386 3.3.2.ink\"");
    run_command("del /f/q \"$desk\\R x64 3.3.2.ink\"");
	  run_command("del /f/q \"$desk2\\R i386 3.3.2.ink\"");
    run_command("del /f/q \"$desk2\\R x64 3.3.2.ink\"");
  }
  else {
    output("OK\n");
  }
  return 1;
}

sub install {

  output("Installing RStudio 1.0.44: ");
  if(!run_command("\"$sourcefilesdir\\RStudio-1.1.383.exe\" /S")) {
    output("FAILED!!\n");
    return 0;
  }
  output("Success");
  return 1;
}

do_install (
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>activate_office.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\sap.bobj.analysis.2_3\prod\activate_office.pl</FullName>
    <Length>659</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-01-03T08:54:05.7978868-06:00</CreationTime>
    <CreationTimeUtc>2017-01-03T14:54:05.7978868Z</CreationTimeUtc>
    <LastWriteTime>2014-08-12T13:38:18.8546978-05:00</LastWriteTime>
    <LastWriteTimeUtc>2014-08-12T18:38:18.8546978Z</LastWriteTimeUtc>
    <LastAccessTime>2017-01-03T08:54:05.7978868-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-01-03T14:54:05.7978868Z</LastAccessTimeUtc>
    <Text># Activates Office products using kms activation

# Use nslookup to get kms host
my $text = `nslookup -type=srv _vlmcs._tcp 2&gt;&amp;1 | findstr "hostname"`;
$text =~ m/.*=\s*(\S+)/;
my $kms = $1;


# Office 2010
my $file = $ENV{'PROGRAMFILES(x86)'}."\\Microsoft Office\\Office14\\ospp.vbs";
if (-e $file) {
  print "\nActivating Office 2010...\n\n";
  system("cscript \"$file\" /sethst:$kms");
  system("cscript \"$file\" /act");
}


# Office 2013
$file = $ENV{'PROGRAMFILES(x86)'}."\\Microsoft Office\\Office15\\ospp.vbs";
if (-e $file) {
  print "\nActivating Office 2013...\n\n";
  system("cscript \"$file\" /sethst:$kms");
  system("cscript \"$file\" /act");
}</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\sap.bobj.analysis.2_3\prod\update.pl</FullName>
    <Length>1858</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-01-03T08:26:34.9947596-06:00</CreationTime>
    <CreationTimeUtc>2017-01-03T14:26:34.9947596Z</CreationTimeUtc>
    <LastWriteTime>2017-01-06T16:13:26.8200828-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-01-06T22:13:26.8200828Z</LastWriteTimeUtc>
    <LastAccessTime>2017-01-03T08:26:34.9947596-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-01-03T14:26:34.9947596Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Package Created 01/16/2014
# Packaged by Billy Rhoades
# Last Updated 2017-01-06 by Chris Schaaf

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'sap.bobj.analysis.2_3',
        package_revision =&gt; '20170106T1615',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $src = get_pkg_sourcefiles();
my $cwd = cwd();

sub preinstall {
	#Make sure office is activated
	do "$cwd\\activate_office.pl";
	output("Installing VS Tools for Office 2010: ");
	if(!run_command("$src\\vstor_redist.exe /q")) {
		output("FAILED\n");
		return 0;
	}
	output("Done\n");
	return 1;
}

sub install
{
	output( "Installing add-on: " );

	if( !run_command("$src\\WIN32\\AOFFICE23SP00_0.exe /Silent", 'IgnoreExitCodes'=&gt;[129])) {
		output( "FAILED\n");
		return 0;
	}

	output( "Done\n" );
	return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
	preinstall_sub =&gt; \&amp;preinstall,
	install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

### subroutine documentation block ###
# Begin-Doc
################################
# Name:
# Description:
# Returns:
# Requires:
# LastUpdated:
# LastUpdatedBy:
################################
# End-Doc
</Text>
  </Script>
  <Script>
    <Name>activate_office.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\sap.bobj.analysis.2_5\prod\activate_office.pl</FullName>
    <Length>892</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-14T09:35:26.3576245-05:00</CreationTime>
    <CreationTimeUtc>2018-06-14T14:35:26.3576245Z</CreationTimeUtc>
    <LastWriteTime>2018-06-14T09:35:26.38887-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-14T14:35:26.38887Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-14T09:35:26.38887-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-14T14:35:26.38887Z</LastAccessTimeUtc>
    <Text># Activates Office products using kms activation

# Use nslookup to get kms host
my $text = `nslookup -type=srv _vlmcs._tcp 2&gt;&amp;1 | findstr "hostname"`;
$text =~ m/.*=\s*(\S+)/;
my $kms = $1;


# Office 2010
my $file = $ENV{'PROGRAMFILES(x86)'}."\\Microsoft Office\\Office14\\ospp.vbs";
if (-e $file) {
  print "\nActivating Office 2010...\n\n";
  system("cscript \"$file\" /sethst:$kms");
  system("cscript \"$file\" /act");
}


# Office 2013
$file = $ENV{'PROGRAMFILES(x86)'}."\\Microsoft Office\\Office15\\ospp.vbs";
if (-e $file) {
  print "\nActivating Office 2013...\n\n";
  system("cscript \"$file\" /sethst:$kms");
  system("cscript \"$file\" /act");
}


# Office 2016
$file = $ENV{'PROGRAMFILES(x86)'}."\\Microsoft Office\\Office16\\ospp.vbs";
if (-e $file) {
  print "\nActivating Office 2016...\n\n";
  system("cscript \"$file\" /sethst:$kms");
  system("cscript \"$file\" /act");
}</Text>
  </Script>
  <Script>
    <Name>update32.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\sap.bobj.analysis.2_5\prod\update32.pl</FullName>
    <Length>1885</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-14T09:53:49.6882876-05:00</CreationTime>
    <CreationTimeUtc>2018-06-14T14:53:49.6882876Z</CreationTimeUtc>
    <LastWriteTime>2018-07-17T15:02:34.214776-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-17T20:02:34.214776Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-14T09:53:49.7208929-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-14T14:53:49.7208929Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Package Created 01/16/2014
# Packaged by Billy Rhoades
# Last Updated 2018-07-17 by Kade Wessels

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN
{
    %INSTALLMONKEY_OPTIONS = 
	(
        package_id =&gt; 'sap.bobj.analysis.2_5',
        package_revision =&gt; '20180717T1334',
    );
}

use lib 
(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $src = get_pkg_sourcefiles();
my $cwd = cwd();

sub preinstall 
{
	#Make sure office is activated
	do "$cwd\\activate_office.pl";
	output("Installing VS Tools for Office 2016: ");
	if(!run_command("$src\\vstor_redist.exe /q")) 
	{
		output("FAILED\n");
		return 0;
	}
	output("Done\n");
	return 1;
}

sub install
{
	output( "Installing add-on: " );

	if ( !run_command("$src\\WIN32\\AOFFICE25SP04P_1-80002380.exe /Silent", 'IgnoreExitCodes'=&gt;[129])) 
	{
		output( "FAILED\n");
		return 0;
	}

	output( "Done\n" );
	return 1;
}

do_install
(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
	preinstall_sub =&gt; \&amp;preinstall,
	install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

### subroutine documentation block ###
# Begin-Doc
################################
# Name:
# Description:
# Returns:
# Requires:
# LastUpdated:
# LastUpdatedBy:
################################
# End-Doc
</Text>
  </Script>
  <Script>
    <Name>update64.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\sap.bobj.analysis.2_5\prod\update64.pl</FullName>
    <Length>1868</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-20T15:02:39.1770358-05:00</CreationTime>
    <CreationTimeUtc>2018-06-20T20:02:39.1770358Z</CreationTimeUtc>
    <LastWriteTime>2018-07-17T14:51:03.0970907-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-17T19:51:03.0970907Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-20T15:02:39.192657-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-20T20:02:39.192657Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Package Created 01/16/2014
# Packaged by Billy Rhoades
# Last Updated 2018-06-27 by Kade Wessels

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'sap.bobj.analysis.2_5',
        package_revision =&gt; '20180627T1153',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $src = get_pkg_sourcefiles();
my $cwd = cwd();

sub preinstall {
	#Make sure office is activated
	do "$cwd\\activate_office.pl";
	output("Installing VS Tools for Office 2016: ");
	if(!run_command("$src\\vstor_redist.exe /q")) {
		output("FAILED\n");
		return 0;
	}
	output("Done\n");
	return 1;
}

sub install
{
	output( "Installing add-on: " );

	if( !run_command("$src\\WIN64\\AOFFICE25SP04P_1-80002421.EXE /Silent", 'IgnoreExitCodes'=&gt;[129])) {
		output( "FAILED\n");
		return 0;
	}

	output( "Done\n" );
	return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
	preinstall_sub =&gt; \&amp;preinstall,
	install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

### subroutine documentation block ###
# Begin-Doc
################################
# Name:
# Description:
# Returns:
# Requires:
# LastUpdated:
# LastUpdatedBy:
################################
# End-Doc
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\sap.bobj.explorer.4_2\test\update.pl</FullName>
    <Length>1835</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-01-06T13:31:32.4858688-06:00</CreationTime>
    <CreationTimeUtc>2017-01-06T19:31:32.4858688Z</CreationTimeUtc>
    <LastWriteTime>2017-01-11T08:29:15.8708164-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-01-11T14:29:15.8708164Z</LastWriteTimeUtc>
    <LastAccessTime>2017-01-06T13:31:32.4858688-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-01-06T19:31:32.4858688Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Package Created 01/16/2014
# Packaged by Billy Rhoades
# Last Updated 2016-01-11 by Chris Schaaf

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'sap.bobj.explorer.4_2',
        package_revision =&gt; '20160111T0830',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $installdir = $ENV{'PROGRAMFILES(X86)'}.'\SAP BusinessObjects\Explorer_win';

sub preinstall {
	return 1;
}

sub install
{
	output("Installing SAP BusinessObjects Explorer: ");

	if( !run_command("start /wait \"\" $srcfiles\\setup.exe -r $srcfiles\\response.ini")) {
		output( "\nSAP failed to install!\n");
		return 0;
	}

	output( "Success!\n" );

	my $desk = get_allusers_desktop();
	run_command("DEL /Q \"$desk\\SAP BusinessObjects Explorer.lnk\"");
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
	preinstall_sub =&gt; \&amp;preinstall,
	install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

### subroutine documentation block ###
# Begin-Doc
################################
# Name:
# Description:
# Returns:
# Requires:
# LastUpdated:
# LastUpdatedBy:
################################
# End-Doc
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\sap.bobj_42\dev\update.pl</FullName>
    <Length>3363</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-01-10T11:23:12.7100232-06:00</CreationTime>
    <CreationTimeUtc>2017-01-10T17:23:12.7100232Z</CreationTimeUtc>
    <LastWriteTime>2015-03-02T14:03:52.8551106-06:00</LastWriteTime>
    <LastWriteTimeUtc>2015-03-02T20:03:52.8551106Z</LastWriteTimeUtc>
    <LastAccessTime>2017-01-10T11:23:12.7100232-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-01-10T17:23:12.7100232Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Package Created 01/15/2014
# Packaged by Dane Greer

# Update history at bottom

use strict;
use warnings;

use File::Basename;
use Data::Dumper;
use Config;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'sap.bobj_41',
        package_revision =&gt; '20150210T1500',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();

sub prereq
{
  if( !is_installed('sapgui.710') &amp;&amp; !is_installed('sapgui.7_20')
      &amp;&amp; !is_installed('sapgui.7_30') )
  {
      output("\n");
      output("SAP GUI 7.10-7.30 is required to install this package.");
      output("\n");

      return 0;
  }
  
 if( !is_installed('office.2007') &amp;&amp; !is_installed('office.2010x86') )
    {
        output("\n");
        output("Microsoft Office 2007 or Office 2010 (x86) is required!\n");
        output("Please uninstall the current version of Office and install ");
        output("a supported Office package.");
        output("\n");

        return 0;
    }
  
  return 1;
}

sub preinst
{
  my $sz = "$sourcefilesdir\\7z\\".( exists( $Config{'archname64'} ) ? "64" : "32" )."\\7z.exe";

  if( -e "C:\\SourceFiles\\sap.bobj_4.2" )
  {
    $sourcefilesdir = "C:\\SourceFiles\\sap.bobj_4.2";
    return 1;
  }
  
  output("Unpacking install files: \n");
  my @files = &lt;"$sourcefilesdir\\*.7z"&gt;;
  my $sofar = 0;
  my $totes = 0;
  
  #For display, since this takes a while, tabulate the sizes for a percentage readout
  for my $file (@files)
  {
    $totes += (-s $file);
  }
  for my $i (keys @files)
  {
    my $file = $files[$i];
    $file =~ s/\.7z//;
    
    output( "  ".basename($file)." (".sprintf( "%i", ( $sofar / $totes )*100 )."%): ");
    if( !run_command( "\"$sz\" x \"$file.7z\" -o\"$sourcefilesdir\" -y" ) )
    {
      output( "FAILED\n" );
      return 0;
    }
    else
    {
      $sofar += (-s "$file.7z");
      output( "done\n" );
    }
  }

  return 1;
}

#Main install sub
#Order is like so:
#  Client
#  Client Patch2
#  Dashboard/InstallFirst
#  Dashboard/setup.exe
#  Dashboard/patch2
#  Crystal Reports
sub install 
{
  output( "Installing: \n" );
  if(!run_command( "\"$sourcefilesdir\\SBOP41\\DATA_UNITS\\BusinessObjectsClient\\setup.exe\" -r \"$sourcefilesdir\\SBOP41\\DATA_UNITS\\BusinessObjectsClient\\response.ini\" "))
  {
	output("\n Install Failed");
	return 0;
  }
 return 1;
}

sub postinst
{

  if(!run_command("del \"C:\\Users\\Public\\Desktop\\Dashboards.lnk\" /Q"))
  {
    output("\nDesktop Icon not deleted!\n");
  }

 return 1;
}

do_install( 
  allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1],
  allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
  allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
  exit_on_failure =&gt; 1,
  prerequisite_sub =&gt; \&amp;prereq,
  preinstall_sub =&gt; \&amp;preinst,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postinst,
);

IM_Exit(EXIT_SUCCESS);

############################################
# Update History
############################################
# Billy Rhoades - 1/15/14
#   Initial script creation.
# </Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\sap.bobj_42\prod\update.pl</FullName>
    <Length>3839</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-01-10T11:23:56.6875508-06:00</CreationTime>
    <CreationTimeUtc>2017-01-10T17:23:56.6875508Z</CreationTimeUtc>
    <LastWriteTime>2017-07-27T15:16:06.8148915-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-07-27T20:16:06.8148915Z</LastWriteTimeUtc>
    <LastAccessTime>2017-01-10T11:23:56.6875508-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-01-10T17:23:56.6875508Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template


# Update history at bottom

use strict;
use warnings;

use File::Basename;
use Data::Dumper;
use Config;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'sap.bobj_42',
        package_revision =&gt; '20160105T1043',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;
######
GetOptions(
    'uninstall' =&gt; sub { exit(!uninstall()); },
) || die "Usage: $!";


sub uninstall {
    output("///////////////////////////\n");
    output("To uninstall this program, please open Control Panel, then go to uninstall a program, and find SAP BusinessObjects BI platform 4.1 Client Tools SP4.\n");
    output("///////////////////////////\n");
}

my $sourcefilesdir = get_pkg_sourcefiles();

sub prereq
{
  if(!is_installed('sapgui.710') &amp;&amp; !is_installed('sapgui.7_20') &amp;&amp; !is_installed('sapgui.7_30') &amp;&amp; !is_installed('sapgui.7_40'))
  {
      output("\n");
      output("SAP GUI 7.10-7.40 is required to install this package.");
      output("\n");

      return 0;
  }
  
  #Microsoft Office is now included in the base image, so no need to check for it here.
 #if( !is_installed('office.2007') &amp;&amp; !is_installed('office.2010x86') &amp;&amp; !is_installed('office.2013x86_SP1') &amp;&amp; !is_installed('office.2013x86') )
 #   {
 #       output("\n");
 #       output("Microsoft Office 2007, Office 2010 (x86), or Office 2013 (x86) is required!\n");
 #       output("Please uninstall the current version of Office and install ");
 #       output("a supported Office package.");
 #       output("\n");
#
#        return 0;
#    }
  
  return 1;
}

sub preinst
{
  my $sz = "$sourcefilesdir\\7z\\".( exists( $Config{'archname64'} ) ? "64" : "32" )."\\7z.exe";

  if( -e "C:\\SourceFiles\\sap.bobj_42\\SBOP_BI_PLAT_4.2_SP3_CLNT_WIN_" )
  {
    $sourcefilesdir = "C:\\SourceFiles\\sap.bobj_42";
    return 1;
  }
  
  output("Unpacking install files: \n");
  my @files = &lt;"$sourcefilesdir\\*.7z"&gt;;
  my $sofar = 0;
  my $totes = 0;
  
  #For display, since this takes a while, tabulate the sizes for a percentage readout
  for my $file (@files)
  {
    $totes += (-s $file);
  }
  for my $i (keys @files)
  {
    my $file = $files[$i];
    $file =~ s/\.7z//;
    
    output( "  ".basename($file)." (".sprintf( "%i", ( $sofar / $totes )*100 )."%): ");
    if( !run_command( "\"$sz\" x \"$file.7z\" -o\"$sourcefilesdir\" -y" ) )
    {
      output( "FAILED\n" );
      return 0;
    }
    else
    {
      $sofar += (-s "$file.7z");
      output( "done\n" );
    }
  }

  return 1;
}

#Main install sub
#Order is like so:
#  Client
#  Client Patch2
#  Dashboard/InstallFirst
#  Dashboard/setup.exe
#  Dashboard/patch2
#  Crystal Reports
sub install 
{
  output( "Installing: \n" );
  if(!run_command( "\"$sourcefilesdir\\SBOP_BI_PLAT_4.2_SP3_CLNT_WIN_\\DATA_UNITS\\BusinessObjectsClient\\setup.exe\" -r \"$sourcefilesdir\\SBOP_BI_PLAT_4.2_SP3_CLNT_WIN_\\DATA_UNITS\\BusinessObjectsClient\\response.ini\" ProductKey=D530V-T6J7S30-H4U76DV-PA200CM-MC"))
  {
	output("\n Install Failed");
	return 0;
  }
 return 1;
}


do_install( 
  allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1],
  allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
  allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
  exit_on_failure =&gt; 1,
  #prerequisite_sub =&gt; \&amp;prereq,
  preinstall_sub =&gt; \&amp;preinst,
  install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);

############################################
# Update History
############################################
# Billy Rhoades - 1/15/14
#   Initial script creation.
# </Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\sap.dashboards.4_1\prod\update.pl</FullName>
    <Length>1431</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-07-28T09:43:26.7310111-05:00</CreationTime>
    <CreationTimeUtc>2017-07-28T14:43:26.7310111Z</CreationTimeUtc>
    <LastWriteTime>2015-02-04T14:21:50.2536768-06:00</LastWriteTime>
    <LastWriteTimeUtc>2015-02-04T20:21:50.2536768Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-28T09:43:26.7310111-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-28T14:43:26.7310111Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Package Created 2015-27-01
# Packaged by Dillon Lustick
# Last Updated 2015-27-01

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'sap.dashboards.4_1',
        package_revision =&gt; '20152701T1007',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();

sub install
{
  output( "Installing SAP Dashboards: " );

  if( !run_command( "start /wait \"\" $srcfiles\\setup.exe -r $srcfiles\\response.ini" ) )
  {
    output( "\nSAP failed to install!\n");
    return 0;
  }

  output( "Success!\n" );
  
  my $desk = get_allusers_desktop();
  run_command("DEL /Q \"$desk\\SAP BusinessObjects Dashboards.lnk\"");
  
  return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    # need_reboot =&gt; 0,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\sap.dashboards.4_2\prod\update.pl</FullName>
    <Length>1918</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-01-06T08:48:07.4414532-06:00</CreationTime>
    <CreationTimeUtc>2017-01-06T14:48:07.4414532Z</CreationTimeUtc>
    <LastWriteTime>2017-08-07T11:06:21.4044236-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-08-07T16:06:21.4044236Z</LastWriteTimeUtc>
    <LastAccessTime>2017-01-06T08:48:07.4414532-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-01-06T14:48:07.4414532Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Package Created 2015-27-01
# Packaged by Dillon Lustick
# Last Updated 2017-01-06 by Chris Schaaf

#Requires Flash Player 11 or greater

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'sap.dashboards.4_2',
        package_revision =&gt; '20170106T0900',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $installdir = "C:\\Program Files (x86)\\Sap BusinessObjects\\Xcelsius 4.0";#$ENV{'PROGRAMFILES(X86)'}.'\SAP BusinessObjects\Xcelsius 4.0';
print $installdir."\n";


sub install {
	output("Installing SAP Dashboards: ");

	if( !run_command("start /wait \"\" $srcfiles\\setup.exe -r $srcfiles\\response.ini")) {
		output( "\nSAP failed to install!\n");
		return 0;
	}

	output( "Success!\n" );

	my $desk = get_allusers_desktop();
	run_command("DEL /Q \"$desk\\SAP BusinessObjects Dashboards.lnk\"");

	return 1;
}

sub postinstall {
	#Installer doesn't consistently give a failure code when it fails, so double check
	output("Verifying install success: ");
	if(-d $installdir){
		output("OK\n");
		return 1;
	}
	else {
		output("Install failed.\n");
		return 0;
	}
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
	postinstall_sub =&gt; \&amp;postinstall,
    # need_reboot =&gt; 0,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\sap.design.studio.1_6\prod\update.pl</FullName>
    <Length>1414</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-01-06T10:04:02.7738536-06:00</CreationTime>
    <CreationTimeUtc>2017-01-06T16:04:02.7738536Z</CreationTimeUtc>
    <LastWriteTime>2017-01-06T10:20:38.2041768-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-01-06T16:20:38.2041768Z</LastWriteTimeUtc>
    <LastAccessTime>2017-01-06T10:04:02.7738536-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-01-06T16:04:02.7738536Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Package Created 2015-26-01
# Packaged by Dillon Lustick
# Last Updated 2017-01-06 by Chris Schaaf

#Old version required Java 6/7. This version no longer seems to need that.

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'sap.design.studio.1_6',
        package_revision =&gt; '20170106T1007',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();


sub install
{
  output( "Installing SAP Design Studio: " );

  if( !run_command( "start /wait \"\" $srcfiles\\DS_CLIENT04_0-70001266.exe /silent" ) )
  {
    output( "\nSAP failed to install!\n");
    return 0;
  }

  output( "Success!\n" );
  return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    # need_reboot =&gt; 0,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\sap.lumira.discovery.2_0\prod\update.pl</FullName>
    <Length>4054</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-25T15:37:37.0110302-05:00</CreationTime>
    <CreationTimeUtc>2018-06-25T20:37:37.0110302Z</CreationTimeUtc>
    <LastWriteTime>2018-06-25T16:28:02.1338265-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-25T21:28:02.1338265Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-25T15:37:37.0110302-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-25T20:37:37.0110302Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Package Created 2018-06-25
# Packaged by Robert Smith
# Last Updated 2018-06-25
# Updated by Robert Smith

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;
use File::Spec;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'sap.lumira.discovery.2_0',
        package_revision =&gt; '20180625T1538',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $CDrive = $ENV{'SYSTEMDRIVE'};

sub preinstall
{
  #Add a happy little reg key.
  output("Adding Reg Key:");
  if(!run_command("REG ADD \"HKEY_LOCAL_MACHINE\\SOFTWARE\\SAP BusinessObjects\\Suite XI 4.0\\Installer\" /v \"pa\" /t REG_SZ /d \"Path\" /f"))
  {
    output("Failed to add Registry key.\n");
  }
  output("OK\n");
}

sub install
{
  # Disable firewall for install and AutoIt
  output("Disabling firewalls for install: ");
  #if(!run_command("net stop MpsSvc"))
  if(!run_command("netsh advfirewall set allprofiles state off"))
  {
    output("\nERROR - Could not turn off firewall\n");
  }
  output("OK\n");


########################################################################
#                           SAP INSTALLATION                           #
########################################################################

  output( "Installing SAP Lumira: " );

  if( !run_command( "$srcfiles\\DATA_UNITS\\SBOP_LUMIRA_DISCOVERY_20_SP03P\\SBOPLumiraDiscoverySetup.exe -s -r $srcfiles\\DATA_UNITS\\SBOP_LUMIRA_DISCOVERY_20_SP03P\\response.ini" ) )
  {
    output( "\nSAP Lumira failed to install!\n");
    return 0;
  }
  output( "Success!\n" );

########################################################################
#                          PRODUCT KEY ENTRY                           #
########################################################################

# the product key is now added in-line, in the response.ini (see above section)

  return 1;
}

sub postinstall
{
  ######################################################################
  #                      Removing Desktop Icons                        #
  ######################################################################

  output("Removing desktop icons...\n");
  my $deskicon = get_allusers_desktop().'\\Lumira Discovery.lnk';
  if(!run_command("del /q \"$deskicon\""))
  {
    output("Icon removal failed!\n");
  }
  output("Desktop icon removed!\n");


  # Turn firewall back on!
  output("Enabling firewalls: ");
  #if(!run_command("net start MpsSvc"))
  if(!run_command("netsh advfirewall set allprofiles state on"))
  {
    output("\nERROR - Could not turn on firewall\n");
  }
  output("OK\n");

  ######################################################################
  #                      Adding Firewall Rules                         #
  ######################################################################

  output("Adding firewall rules: ");
  if(!run_command("netsh advfirewall firewall add rule \"allow SAP Predictive Analysis\" dir=in
        action=allow program=\"$ENV{'PROGRAMFILES'}\\SAP BusinessObjects Lumira\\Desktop\\SBOPLumiraDiscovery.exe\"
        enable=yes profile=domain"))
  {
    output("\nError adding firewall rule\n");
  }

  output("Added.\n");

  output( "Done!\nSAP Lumira is finished installing." );

  return 1;
}


do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    preinstall_sub =&gt; \&amp;preinstall,
    need_reboot =&gt; 1,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>updateForOS.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\sap.predictive.analytics.3_3\dev\updateForOS.pl</FullName>
    <Length>7025</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-21T09:49:44.72652-05:00</CreationTime>
    <CreationTimeUtc>2018-06-21T14:49:44.72652Z</CreationTimeUtc>
    <LastWriteTime>2018-06-28T14:19:20.6534791-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-28T19:19:20.6534791Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-21T09:49:44.72652-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-21T14:49:44.72652Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Package Created 2018-06-15
# Packaged by Robert Smith, based on Kyle Knudsen's 2.5 package
# Last Updated 2018-06-25
# Updated by Robert Smith

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;
use File::Spec;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'sap.predictive.analytics-foros.3_3_2',
        package_revision =&gt; '20180625T1619',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $CDrive = $ENV{'SYSTEMDRIVE'};

sub preinstall
{
  #Add a happy little reg key.
  output("Adding Reg Key:");
  if(!run_command("REG ADD \"HKEY_LOCAL_MACHINE\\SOFTWARE\\SAP BusinessObjects\\Suite XI 4.0\\Installer\" /v \"pa\" /t REG_SZ /d \"Path\" /f"))
  {
    output("Failed to add Registry key. Exiting.\n");
  }
  output("OK\n");
}

sub install
{
  # Disable firewall for install and AutoIt
  output("Disabling firewalls for install: ");
  #if(!run_command("net stop MpsSvc"))
  if(!run_command("netsh advfirewall set allprofiles state off"))
  {
    output("\nERROR - Could not turn off firewall\n");
  }
  output("OK\n");


########################################################################
#                           SAP INSTALLATION                           #
########################################################################

  output( "Installing SAP Predictive Analytics: " );

  if( !run_command( "$srcfiles\\PADESKTOP3003P_2-70001855\\setup.exe -r $srcfiles\\response.ini userkeycode=DG20X-M0PTV38-WK6T2EV-PAYT279-X7" ) )
  {
    output( "\nSAP failed to install!\n");
    return 0;
  }
  output( "Success!\n" );

########################################################################
#                          PRODUCT KEY ENTRY                           #
########################################################################

# the product key is now added in-line, after using the response.ini (see above section)

=pod
  output( "Configuring Product Key: " );
  #\"$ENV{'PROGRAMFILES'}\\SAP Predictive Analytics\\Desktop\\Expert\\Desktop\\SAPPredictiveAnalysis.exe\"
  if(!run_command("\"$srcfiles\\EnterProductKey.exe\""))
  {
    output( "\nProduct Key Entry Failed!\n");
    return 0;
  }
  output( "Success!\n" );
=cut

  return 1;
}

sub postinstall
{
  ######################################################################
  #                      Removing Desktop Icons                        #
  ######################################################################

  output("Removing desktop icons...\n");
  my $deskicon = get_allusers_desktop().'\\SAP Predictive Analytics.lnk';
  if(!run_command("del /q \"$deskicon\""))
  {
    output("Icon removal failed!\n");
  }
  output("Desktop icon removed!\n");
  $deskicon = get_allusers_desktop().'\\SAP Predictive Analytics Control Panel.lnk';
  if(!run_command("del /q \"$deskicon\""))
  {
    output("Icon removal failed!\n");
  }
  output("Desktop icon removed!\n");


  # Turn firewall back on!
  output("Enabling firewalls: ");
  #if(!run_command("net start MpsSvc"))
  if(!run_command("netsh advfirewall set allprofiles state on"))
  {
    output("\nERROR - Could not turn on firewall\n");
  }
  output("OK\n");

  ######################################################################
  #                      Adding Firewall Rules                         #
  ######################################################################

  output("Adding firewall rules: ");
  if(!run_command("netsh advfirewall firewall add rule \"allow SAP Predictive Analysis\" dir=in
        action=allow program=\"$ENV{'PROGRAMFILES'}\\SAP Predictive Analytics\\Desktop\\Expert\\Desktop\\SAPPredictiveAnalysis.exe\"
        enable=yes profile=domain"))
  {
    output("\nError adding firewall rule\n");
  }
  if(!run_command("netsh advfirewall firewall add rule \"allow SAP Sybase IQ Network Server\" dir=in
        action=allow program=\"$ENV{'PROGRAMFILES'}\\SAP Predictive Analytics\\Desktop\\Expert\\Desktop\\IQ\\bin64\\iqsrv16.exe\"
        enable=yes profile=domain"))
  {
    output("\nError adding firewall rule\n");
  }
  output("Added.\n");


  ######################################################################
  #                           Configuring R                            #
  ######################################################################

  #install R packages
  output( "Installing R packages: " );
  if( !run_command( "XCOPY /Y /S /I \"$srcfiles\\temp\" \"$CDrive\\temp\"" ) )
  {
    output( "ERROR copying R package file.\n" );
    return 0;
  }
  if( !run_command( "\"$CDrive\\Program Files\\R\\R-3.4.2\\bin\\R.exe\" CMD BATCH $CDrive\\temp\\packages.R" ) )
  {
    output( "ERROR installing R packages.\n" );
    return 0;
  }

  output( "done\n" );

  # package creation: after a manual setup, grab the .xml from C:\Users\Public\sappa\Config
  # this .xml tells the program that R is installed.
  # copy it to that directory for the scripted install
  output( "Adding R .xml configuration file: " );
  if( !run_command( "XCOPY /Y /S /I \"$srcfiles\\Users\" \"$CDrive\\Users\" " ) )
  {
    output( "ERROR configuring R.\n" );
    return 0;
  }
  output( "\nDone! SAP PA 3.3.2 is finished installing." );


=pod
  ######################################################################
  #                         First-time Launch                          #
  ######################################################################

  # First-time launch necessary so Expert Analytics doesn't hang for the user
  # Below code obsolete. WTG will insetad launch updateOSLaunch.pl, which uses an AutoIt script.
  
  output( "First-time running Expert Analytics.\n" );
  if( !run_command( "start \"SAP Expert Analytics\" \"C:\\Program Files\\SAP Predictive Analytics\\Desktop\\Expert\\Desktop\\SAPPredictiveAnalysis.exe\"" ) )
  {
    output( "ERROR. Couldn't run!\n" );
  }
  output( "Expert Analytics is starting up: " );
  sleep 90;
  output( "Done.\nKilling SAP process(es).\n\n" );
  KillProcess(qw(KJWizardJni.exe SAPPredictiveAnalysis.exe SAPLumira.exe));
  sleep 20;
  KillProcess(qw(KJWizardJni.exe SAPPredictiveAnalysis.exe SAPLumira.exe));
  sleep 20;
  output( "\nDone! SAP PA 3.3.2 has finished its first-time launch." );
=cut
  
  return 1;
}


do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    preinstall_sub =&gt; \&amp;preinstall,
    need_reboot =&gt; 1,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>updateForOSLaunch.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\sap.predictive.analytics.3_3\dev\updateForOSLaunch.pl</FullName>
    <Length>1993</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-26T12:27:42.3854645-05:00</CreationTime>
    <CreationTimeUtc>2018-06-26T17:27:42.3854645Z</CreationTimeUtc>
    <LastWriteTime>2018-06-28T14:17:12.8468684-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-28T19:17:12.8468684Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-26T12:27:42.3854645-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-26T17:27:42.3854645Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Package Created 2018-06-15
# Packaged by Robert Smith, based on Kyle Knudsen's 2.5 package
# Last Updated 2018-06-26
# Updated by Robert Smith

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;
use File::Spec;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'sap.predictive.analytics-foroslaunch.3_3_2',
        package_revision =&gt; '20180626T1228',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $CDrive = $ENV{'SYSTEMDRIVE'};

sub install
{
  output( "First-time running Expert Analytics: " );
  #if( !run_command( "start \"SAP Expert Analytics\" \"$CDrive\\Program Files\\SAP Predictive Analytics\\Desktop\\Automated\\EXE\\Clients\\KJWizardJNI\\KJWizardJni.exe\"" ) )
  if(!run_command("\"$srcfiles\\launchExpertAnalytics.exe\""))
  {
    output( "ERROR. Couldn't run!\n" );
	return 0;
  }
  
  sleep 20;
  output( "Done.\n" );

  return 1;
}

sub postinstall
{
  output( "Killing SAP process(es).\n\n" );
  KillProcess(qw(KJWizardJni.exe SAPLumira.exe SAPPredictiveAnalysis.exe));
  sleep 20;
  KillProcess(qw(KJWizardJni.exe SAPLumira.exe SAPPredictiveAnalysis.exe));
  sleep 20;
  output( "\nDone! SAP PA 3.3.2 has finished its first-time launch." );

  return 1;
}


do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    need_reboot =&gt; 1,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update_test.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\sap.predictive.analytics.3_3\dev\update_test.pl</FullName>
    <Length>8750</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-07-24T14:12:40.3121245-05:00</CreationTime>
    <CreationTimeUtc>2018-07-24T19:12:40.3121245Z</CreationTimeUtc>
    <LastWriteTime>2018-07-24T15:13:45.0114675-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-24T20:13:45.0114675Z</LastWriteTimeUtc>
    <LastAccessTime>2018-07-24T14:12:40.3121245-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-07-24T19:12:40.3121245Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Package Created 2018-06-15
# Packaged by Robert Smith, based on Kyle Knudsen's 2.5 package
# Last Updated 2018-06-25
# Updated by Robert Smith

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;
use File::Spec;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'sap.predictive.analytics.3_3_2',
        package_revision =&gt; '20180625T1619',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use File::Basename;
use File::Path;
use File::Copy;
use Win32::TieRegistry( Delimiter=&gt;"/");

my $srcfiles = get_pkg_sourcefiles();
my $CDrive = $ENV{'SYSTEMDRIVE'};
my $user_config_script = get_pkg_sourcefiles()."\\login.pl";

sub preinstall
{
  #Add a happy little reg key.
  output("Adding Reg Key:");
  if(!run_command("REG ADD \"HKEY_LOCAL_MACHINE\\SOFTWARE\\SAP BusinessObjects\\Suite XI 4.0\\Installer\" /v \"pa\" /t REG_SZ /d \"Path\" /f"))
  {
    output("Failed to add Registry key. Exiting.\n");
  }
  output("OK\n");
}

sub install
{

  ########################################################################
  #                              LOGIN SCRIPT                            #
  ########################################################################

  if (verify_registry_data('HKEY_CURRENT_USER\SOFTWARE\Microsoft\Active Setup\Installed Components\sap.predictive.analytics.3_3_2'))
  {
    print("Key does exist.\n");
    delete $Registry-&gt;{'HKEY_CURRENT_USER/SOFTWARE/Microsoft/Active Setup/Installed Components/sap.predictive.analytics.3_3_2/'}
      or die("Could not delete registry key\n");
  }

  # Create the login script.
  output("   Creating login script for SAPPA: ");
  if (!create_configure_script($user_config_script))
  {
    output("FAILED\n");
    return 0; # Don't bother trying anything else in this sub.
  }
  else
  {
    output("OK\n");
  }

  # Create activesetup action for login script
  my $short_cfg_path = Win32::GetShortPathName($user_config_script);
  output("   Creating activesetup action for login script: ");
  output($short_cfg_path."\n");
  if (! create_activesetup_action(
            'ComponentID' =&gt; get_package_id(),
            'Identifier' =&gt; get_package_id(),
            'Version' =&gt; get_package_revision(),
            'StubPath' =&gt; 'C:\Perl64\bin\perl.exe ' . $short_cfg_path,
      ))
  {
    output("FAILED ACTIVESETUP ACTION\n");
    return 0;
  }
  output("ACTIVESETUP ACTION COMPLETE\n");

  ########################################################################

  # Disable firewall for install and AutoIt
  output("Disabling firewalls for install: ");
  #if(!run_command("net stop MpsSvc"))
  if(!run_command("netsh advfirewall set allprofiles state off"))
  {
    output("\nERROR - Could not turn off firewall\n");
  }
  output("OK\n");


########################################################################
#                           SAP INSTALLATION                           #
########################################################################

  output( "Installing SAP Predictive Analytics: " );

  if( !run_command( "$srcfiles\\PADESKTOP3003P_2-70001855\\setup.exe -r $srcfiles\\response.ini userkeycode=DG20X-M0PTV38-WK6T2EV-PAYT279-X7" ) )
  {
    output( "\nSAP failed to install!\n");
    return 0;
  }
  output( "Success!\n" );

########################################################################
#                          PRODUCT KEY ENTRY                           #
########################################################################

# the product key is now added in-line, after using the response.ini (see above section)

=pod
  output( "Configuring Product Key: " );
  #\"$ENV{'PROGRAMFILES'}\\SAP Predictive Analytics\\Desktop\\Expert\\Desktop\\SAPPredictiveAnalysis.exe\"
  if(!run_command("\"$srcfiles\\EnterProductKey.exe\""))
  {
    output( "\nProduct Key Entry Failed!\n");
    return 0;
  }
  output( "Success!\n" );
=cut

  return 1;
}

sub postinstall
{
  ######################################################################
  #                      Removing Desktop Icons                        #
  ######################################################################

  output("Removing desktop icons...\n");
  my $deskicon = get_allusers_desktop().'\\SAP Predictive Analytics.lnk';
  if(!run_command("del /q \"$deskicon\""))
  {
    output("Icon removal failed!\n");
  }
  output("Desktop icon removed!\n");
  $deskicon = get_allusers_desktop().'\\SAP Predictive Analytics Control Panel.lnk';
  if(!run_command("del /q \"$deskicon\""))
  {
    output("Icon removal failed!\n");
  }
  output("Desktop icon removed!\n");


  # Turn firewall back on!
  output("Enabling firewalls: ");
  #if(!run_command("net start MpsSvc"))
  if(!run_command("netsh advfirewall set allprofiles state on"))
  {
    output("\nERROR - Could not turn on firewall\n");
  }
  output("OK\n");

  ######################################################################
  #                      Adding Firewall Rules                         #
  ######################################################################

  output("Adding firewall rules: ");
  if(!run_command("netsh advfirewall firewall add rule \"allow SAP Predictive Analysis\" dir=in
        action=allow program=\"$ENV{'PROGRAMFILES'}\\SAP Predictive Analytics\\Desktop\\Expert\\Desktop\\SAPPredictiveAnalysis.exe\"
        enable=yes profile=domain"))
  {
    output("\nError adding firewall rule\n");
  }
  if(!run_command("netsh advfirewall firewall add rule \"allow SAP Sybase IQ Network Server\" dir=in
        action=allow program=\"$ENV{'PROGRAMFILES'}\\SAP Predictive Analytics\\Desktop\\Expert\\Desktop\\IQ\\bin64\\iqsrv16.exe\"
        enable=yes profile=domain"))
  {
    output("\nError adding firewall rule\n");
  }
  output("Added.\n");


  ######################################################################
  #                           Configuring R                            #
  ######################################################################

  #install R packages
  output( "Installing R packages: " );
  if( !run_command( "XCOPY /Y /S /I \"$srcfiles\\temp\" \"$CDrive\\temp\"" ) )
  {
    output( "ERROR copying R package file.\n" );
    return 0;
  }
  if( !run_command( "\"$CDrive\\Program Files\\R\\R-3.4.2\\bin\\R.exe\" CMD BATCH $CDrive\\temp\\packages.R" ) )
  {
    output( "ERROR installing R packages.\n" );
    return 0;
  }

  output( "done\n" );

  # package creation: after a manual setup, grab the .xml from C:\Users\Public\sappa\Config
  # this .xml tells the program that R is installed.
  # copy it to that directory for the scripted install
  output( "Adding R .xml configuration file: " );
  if( !run_command( "XCOPY /Y /S /I \"$srcfiles\\Users\" \"$CDrive\\Users\" " ) )
  {
    output( "ERROR configuring R.\n" );
    return 0;
  }
  output( "Done!\nSAP PA 3.3.2 is finished installing." );

  return 1;
}

#Function to create the login script
sub create_configure_script
{

    my $filename = shift;
    my $dir = dirname($filename);
    if (! -d $dir) {
        if (!mkpath($dir))
        {
            output("Error creating script directory '${dir}': $!\n",LOG_ONLY);
            return 0;
        }
    }

    if (open(my $SCRIPT,'&gt;',$user_config_script))
    {
        print $SCRIPT q[
use strict;
use warnings;

my $login = getlogin || getpwuid($&lt;);

if(-e "C:\\\\Users\\\\$login\\\\.sappa\\\\preferences\\\\general.persistent")
{
  print("SAP BI Platform is already configured.\n");
}
else
{
  print("Configuring SAP BI Platform\n");
  system("XCOPY /Y /S /I \\"$srcfiles\\\\CurrentUser\\" \\"$CDrive\\\\Users\\\\$login\\"") == 0
    or die("SAP BI Platform configuration did not complete!\\n");

  print("Waiting 15 seconds to ensure installation completes...\\n");
  sleep(15);

  print("SAP BI Platform configuration was successful!\\n");

}
        ];
        close($SCRIPT);
    }
    else
    {
        output("Error opening script file '${filename}' for writing: $!\n", LOG_ONLY);
        return 0;
    }
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    preinstall_sub =&gt; \&amp;preinstall,
    need_reboot =&gt; 1,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\sap.predictive.analytics.3_3\prod\update.pl</FullName>
    <Length>8699</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-15T08:44:27.8508777-05:00</CreationTime>
    <CreationTimeUtc>2018-06-15T13:44:27.8508777Z</CreationTimeUtc>
    <LastWriteTime>2018-07-26T13:56:04.0137376-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-26T18:56:04.0137376Z</LastWriteTimeUtc>
    <LastAccessTime>2018-07-26T12:41:07.9809542-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-07-26T17:41:07.9809542Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Package Created 2018-06-15
# Packaged by Robert Smith, based on Kyle Knudsen's 2.5 package
# Last Updated 2018-07-26
# Updated by Robert Smith

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;
use File::Spec;
use File::Basename;
use File::Path;
use File::Copy;
use Win32::TieRegistry( Delimiter=&gt;"/");

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'sap.predictive.analytics.3_3_2',
        package_revision =&gt; '20180726T1356',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;


my $srcfiles = get_pkg_sourcefiles();
my $CDrive = $ENV{'SYSTEMDRIVE'};
my $user_config_script = get_pkg_sourcefiles()."\\login.pl";

sub preinstall
{
  #Add a happy little reg key.
  output("Adding Reg Key:");
  if(!run_command("REG ADD \"HKEY_LOCAL_MACHINE\\SOFTWARE\\SAP BusinessObjects\\Suite XI 4.0\\Installer\" /v \"pa\" /t REG_SZ /d \"Path\" /f"))
  {
    output("Failed to add Registry key. Exiting.\n");
  }
  output("OK\n");
}

sub install
{

  ########################################################################
  #                              LOGIN SCRIPT                            #
  ########################################################################

  if (verify_registry_data('HKEY_CURRENT_USER\SOFTWARE\Microsoft\Active Setup\Installed Components\sap.predictive.analytics.3_3_2'))
  {
    print("Key does exist.\n");
    delete $Registry-&gt;{'HKEY_CURRENT_USER/SOFTWARE/Microsoft/Active Setup/Installed Components/sap.predictive.analytics.3_3_2/'}
      or die("Could not delete registry key\n");
  }

  # Create the login script.
  output("   Creating login script for SAPPA: ");
  if (!create_configure_script($user_config_script))
  {
    output("FAILED\n");
    return 0; # Don't bother trying anything else in this sub.
  }
  else
  {
    output("OK\n");
  }

  # Create activesetup action for login script
  my $short_cfg_path = Win32::GetShortPathName($user_config_script);
  output("   Creating activesetup action for login script: ");
  output($short_cfg_path."\n");
  if (! create_activesetup_action(
            'ComponentID' =&gt; get_package_id(),
            'Identifier' =&gt; get_package_id(),
            'Version' =&gt; get_package_revision(),
            'StubPath' =&gt; 'C:\Perl64\bin\perl.exe ' . $short_cfg_path,
      ))
  {
    output("FAILED ACTIVESETUP ACTION\n");
    return 0;
  }
  output("ACTIVESETUP ACTION COMPLETE\n");

  ########################################################################

  # Disable firewall for install and AutoIt
  output("Disabling firewalls for install: ");
  #if(!run_command("net stop MpsSvc"))
  if(!run_command("netsh advfirewall set allprofiles state off"))
  {
    output("\nERROR - Could not turn off firewall\n");
  }
  output("OK\n");


########################################################################
#                           SAP INSTALLATION                           #
########################################################################

  output( "Installing SAP Predictive Analytics: " );

  if( !run_command( "$srcfiles\\PADESKTOP3003P_2-70001855\\setup.exe -r $srcfiles\\response.ini userkeycode=DG20X-M0PTV38-WK6T2EV-PAYT279-X7" ) )
  {
    output( "\nSAP failed to install!\n");
    return 0;
  }
  output( "Success!\n" );

########################################################################
#                          PRODUCT KEY ENTRY                           #
########################################################################

# the product key is now added in-line, after using the response.ini (see above section)

=pod
  output( "Configuring Product Key: " );
  #\"$ENV{'PROGRAMFILES'}\\SAP Predictive Analytics\\Desktop\\Expert\\Desktop\\SAPPredictiveAnalysis.exe\"
  if(!run_command("\"$srcfiles\\EnterProductKey.exe\""))
  {
    output( "\nProduct Key Entry Failed!\n");
    return 0;
  }
  output( "Success!\n" );
=cut

  return 1;
}

sub postinstall
{
  ######################################################################
  #                      Removing Desktop Icons                        #
  ######################################################################

  output("Removing desktop icons...\n");
  my $deskicon = get_allusers_desktop().'\\SAP Predictive Analytics.lnk';
  if(!run_command("del /q \"$deskicon\""))
  {
    output("Icon removal failed!\n");
  }
  output("Desktop icon removed!\n");
  $deskicon = get_allusers_desktop().'\\SAP Predictive Analytics Control Panel.lnk';
  if(!run_command("del /q \"$deskicon\""))
  {
    output("Icon removal failed!\n");
  }
  output("Desktop icon removed!\n");


  # Turn firewall back on!
  output("Enabling firewalls: ");
  #if(!run_command("net start MpsSvc"))
  if(!run_command("netsh advfirewall set allprofiles state on"))
  {
    output("\nERROR - Could not turn on firewall\n");
  }
  output("OK\n");

  ######################################################################
  #                      Adding Firewall Rules                         #
  ######################################################################

  output("Adding firewall rules: ");
  if(!run_command("netsh advfirewall firewall add rule \"allow SAP Predictive Analysis\" dir=in
        action=allow program=\"$ENV{'PROGRAMFILES'}\\SAP Predictive Analytics\\Desktop\\Expert\\Desktop\\SAPPredictiveAnalysis.exe\"
        enable=yes profile=domain"))
  {
    output("\nError adding firewall rule\n");
  }
  if(!run_command("netsh advfirewall firewall add rule \"allow SAP Sybase IQ Network Server\" dir=in
        action=allow program=\"$ENV{'PROGRAMFILES'}\\SAP Predictive Analytics\\Desktop\\Expert\\Desktop\\IQ\\bin64\\iqsrv16.exe\"
        enable=yes profile=domain"))
  {
    output("\nError adding firewall rule\n");
  }
  output("Added.\n");


  ######################################################################
  #                           Configuring R                            #
  ######################################################################

  #install R packages
  output( "Installing R packages: " );
  if( !run_command( "XCOPY /Y /S /I \"$srcfiles\\temp\" \"$CDrive\\temp\"" ) )
  {
    output( "ERROR copying R package file.\n" );
    return 0;
  }
  if( !run_command( "\"$CDrive\\Program Files\\R\\R-3.4.2\\bin\\R.exe\" CMD BATCH $CDrive\\temp\\packages.R" ) )
  {
    output( "ERROR installing R packages.\n" );
    return 0;
  }

  output( "done\n" );

  # package creation: after a manual setup, grab the .xml from C:\Users\Public\sappa\Config
  # this .xml tells the program that R is installed.
  # copy it to that directory for the scripted install
  output( "Adding R .xml configuration file: " );
  if( !run_command( "XCOPY /Y /S /I \"$srcfiles\\Users\" \"$CDrive\\Users\" " ) )
  {
    output( "ERROR configuring R.\n" );
    return 0;
  }
  output( "Done!\nSAP PA 3.3.2 is finished installing." );

  return 1;
}

#Function to create the login script
sub create_configure_script
{

    my $filename = shift;
    my $dir = dirname($filename);
    if (! -d $dir) {
        if (!mkpath($dir))
        {
            output("Error creating script directory '${dir}': $!\n",LOG_ONLY);
            return 0;
        }
    }

    if (open(my $SCRIPT,'&gt;',$user_config_script))
    {
        print $SCRIPT q[
use strict;
use warnings;

my $login = getlogin || getpwuid($&lt;);
my $srcfiles = "C:\\\\SourceFiles\\\\sap.predictive.analytics.3_3_2";
my $CDrive = $ENV{'SYSTEMDRIVE'};

print("Configuring SAP BI Platform\n");
system("XCOPY /Y /S /I \\"$srcfiles\\\\CurrentUser\\" \\"$CDrive\\\\Users\\\\$login\\"") == 0
  or die("SAP BI Platform configuration did not complete!\\n");

print("Waiting 15 seconds to ensure installation completes...\\n");
sleep(15);

print("SAP BI Platform configuration was successful!\\n");

        ];
        close($SCRIPT);
    }
    else
    {
        output("Error opening script file '${filename}' for writing: $!\n", LOG_ONLY);
        return 0;
    }
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    preinstall_sub =&gt; \&amp;preinstall,
    need_reboot =&gt; 1,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update_old.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\sap.predictive.analytics.3_3\prod\update_old.pl</FullName>
    <Length>5986</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-15T08:44:27.8508777-05:00</CreationTime>
    <CreationTimeUtc>2018-06-15T13:44:27.8508777Z</CreationTimeUtc>
    <LastWriteTime>2018-06-28T14:24:27.9819619-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-28T19:24:27.9819619Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-15T08:44:27.8508777-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-15T13:44:27.8508777Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Package Created 2018-06-15
# Packaged by Robert Smith, based on Kyle Knudsen's 2.5 package
# Last Updated 2018-06-25
# Updated by Robert Smith

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;
use File::Spec;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'sap.predictive.analytics.3_3_2',
        package_revision =&gt; '20180625T1619',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $CDrive = $ENV{'SYSTEMDRIVE'};

sub preinstall
{
  #Add a happy little reg key.
  output("Adding Reg Key:");
  if(!run_command("REG ADD \"HKEY_LOCAL_MACHINE\\SOFTWARE\\SAP BusinessObjects\\Suite XI 4.0\\Installer\" /v \"pa\" /t REG_SZ /d \"Path\" /f"))
  {
    output("Failed to add Registry key. Exiting.\n");
  }
  output("OK\n");
}

sub install
{
  # Disable firewall for install and AutoIt
  output("Disabling firewalls for install: ");
  #if(!run_command("net stop MpsSvc"))
  if(!run_command("netsh advfirewall set allprofiles state off"))
  {
    output("\nERROR - Could not turn off firewall\n");
  }
  output("OK\n");


########################################################################
#                           SAP INSTALLATION                           #
########################################################################

  output( "Installing SAP Predictive Analytics: " );

  if( !run_command( "$srcfiles\\PADESKTOP3003P_2-70001855\\setup.exe -r $srcfiles\\response.ini userkeycode=DG20X-M0PTV38-WK6T2EV-PAYT279-X7" ) )
  {
    output( "\nSAP failed to install!\n");
    return 0;
  }
  output( "Success!\n" );

########################################################################
#                          PRODUCT KEY ENTRY                           #
########################################################################

# the product key is now added in-line, after using the response.ini (see above section)

=pod
  output( "Configuring Product Key: " );
  #\"$ENV{'PROGRAMFILES'}\\SAP Predictive Analytics\\Desktop\\Expert\\Desktop\\SAPPredictiveAnalysis.exe\"
  if(!run_command("\"$srcfiles\\EnterProductKey.exe\""))
  {
    output( "\nProduct Key Entry Failed!\n");
    return 0;
  }
  output( "Success!\n" );
=cut

  return 1;
}

sub postinstall
{
  ######################################################################
  #                      Removing Desktop Icons                        #
  ######################################################################

  output("Removing desktop icons...\n");
  my $deskicon = get_allusers_desktop().'\\SAP Predictive Analytics.lnk';
  if(!run_command("del /q \"$deskicon\""))
  {
    output("Icon removal failed!\n");
  }
  output("Desktop icon removed!\n");
  $deskicon = get_allusers_desktop().'\\SAP Predictive Analytics Control Panel.lnk';
  if(!run_command("del /q \"$deskicon\""))
  {
    output("Icon removal failed!\n");
  }
  output("Desktop icon removed!\n");


  # Turn firewall back on!
  output("Enabling firewalls: ");
  #if(!run_command("net start MpsSvc"))
  if(!run_command("netsh advfirewall set allprofiles state on"))
  {
    output("\nERROR - Could not turn on firewall\n");
  }
  output("OK\n");

  ######################################################################
  #                      Adding Firewall Rules                         #
  ######################################################################

  output("Adding firewall rules: ");
  if(!run_command("netsh advfirewall firewall add rule \"allow SAP Predictive Analysis\" dir=in
        action=allow program=\"$ENV{'PROGRAMFILES'}\\SAP Predictive Analytics\\Desktop\\Expert\\Desktop\\SAPPredictiveAnalysis.exe\"
        enable=yes profile=domain"))
  {
    output("\nError adding firewall rule\n");
  }
  if(!run_command("netsh advfirewall firewall add rule \"allow SAP Sybase IQ Network Server\" dir=in
        action=allow program=\"$ENV{'PROGRAMFILES'}\\SAP Predictive Analytics\\Desktop\\Expert\\Desktop\\IQ\\bin64\\iqsrv16.exe\"
        enable=yes profile=domain"))
  {
    output("\nError adding firewall rule\n");
  }
  output("Added.\n");


  ######################################################################
  #                           Configuring R                            #
  ######################################################################

  #install R packages
  output( "Installing R packages: " );
  if( !run_command( "XCOPY /Y /S /I \"$srcfiles\\temp\" \"$CDrive\\temp\"" ) )
  {
    output( "ERROR copying R package file.\n" );
    return 0;
  }
  if( !run_command( "\"$CDrive\\Program Files\\R\\R-3.4.2\\bin\\R.exe\" CMD BATCH $CDrive\\temp\\packages.R" ) )
  {
    output( "ERROR installing R packages.\n" );
    return 0;
  }

  output( "done\n" );

  # package creation: after a manual setup, grab the .xml from C:\Users\Public\sappa\Config
  # this .xml tells the program that R is installed.
  # copy it to that directory for the scripted install
  output( "Adding R .xml configuration file: " );
  if( !run_command( "XCOPY /Y /S /I \"$srcfiles\\Users\" \"$CDrive\\Users\" " ) )
  {
    output( "ERROR configuring R.\n" );
    return 0;
  }
  output( "Done!\nSAP PA 3.3.2 is finished installing." );

  return 1;
}


do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    preinstall_sub =&gt; \&amp;preinstall,
    need_reboot =&gt; 1,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\sapgui.7_40\dev\update.pl</FullName>
    <Length>11033</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-02-10T13:38:11.6100002-06:00</CreationTime>
    <CreationTimeUtc>2016-02-10T19:38:11.6100002Z</CreationTimeUtc>
    <LastWriteTime>2016-03-25T13:20:01.8318565-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-03-25T18:20:01.8318565Z</LastWriteTimeUtc>
    <LastAccessTime>2016-02-10T13:38:11.6100002-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-02-10T19:38:11.6100002Z</LastAccessTimeUtc>
    <Text># SapGUI 7.40
# Package Created Feb 10, 2016
# Packaged by Dzu Phan
# Last Updated

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'sapgui.7_40',
        package_revision =&gt; '20150210T1111',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

use Win32::TieRegistry;
use File::Basename;
use File::Temp qw(tempfile);
use Getopt::Long;
use File::Copy;

my $srcfiles = get_pkg_sourcefiles();

########################################################################
# BEGIN Configuration

my $install_log_dir = build_path(get_arch_programfiles(OSARCH_x86),
                                 'SAP','SAPSetup','LOGs');

my $default_sap_install_log = build_path($install_log_dir,'NwSapSetup.log');
my $bw_sap_install_log =
    build_path($install_log_dir,'bw350gui730_3-20010239.log');

my $target_jre_currver = '1.7';
my $target_jre_ver = '1.7.0_671';

my $JRE_rloc = 'HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\JavaSoft\Java Runtime Environment';
my $JRE_FV_rloc = build_path($JRE_rloc,'Java7FamilyVersion');
my $JRE_CV_rloc = build_path($JRE_rloc,'CurrentVersion');

my $JRE_temp_ver_data = {
    'JavaHome' =&gt; build_path($srcfiles,'jre7'),
};

# Used to validate that the application is actually installed.
my @installed_exes = (
    build_path(get_arch_programfiles(OSARCH_x86),
               'SAP','FrontEnd','SAPgui','saplgpad.exe'),
    build_path(get_arch_programfiles(OSARCH_x86),
               'SAP','Business Explorer','BI','BExAnalyzer.exe'),
);

# END Configuration
########################################################################

# Used to save the changes made by hijack_jre()
my %revert;
my @delete;

GetOptions(
    'code=s' =&gt; sub { exit(eval($_[1])); }, # bazooka debugging
);


sub preinstall {
    if(!is_installed('jre.7u72'))
    {
        output("\n");
        output("Java 7u72 is required to install this package.");
        output("\n");

        return 0;
    }

    return 1;
}


#/////////////////////////////////////////////////////////////////////////////////////#
sub install
{
    push_dir($srcfiles);
    my $success = 1;
    my @command;

    my @install_prog = (
        "SAPGUI",
        "SapBI",
        "NWBC50",
        "AXL",
        "KW",
        "SAPWUS"
        );
        # "JNet", is the one that needs Java 7u4 or higher

    print "Installing SAPGUI 7.40: \n";
    for (my $i=0; $i &lt; scalar(@install_prog); $i++) {
      @command = (
          'start','/wait',
          "$srcfiles\\GUI\\WINDOWS\\WIN32\\Setup\\NwSapSetup.exe",
          '/Silent',
          "/Product=$install_prog[$i]",
          );
      print "Product $i: ";

      if ($success) {
          $success &amp;&amp;= run_command(join(' ',@command));
          output(($success?'OK':'FAILURE: ' . $!)."\n");
      }
    }

    if ($success) {
        print "Installing SAPGUI 7.40 Patches \n";
        print "Patch 4:";
        $success &amp;&amp;= run_command("start /wait $srcfiles\\BEx740_patch4.exe /Silent");
        output(($success?'OK':'FAILURE: ' . $!)."\n");

        print "Patch 7:";
        $success &amp;&amp;= run_command("start /wait $srcfiles\\gui740_patch7.exe /Silent");
        output(($success?'OK':'FAILURE: ' . $!)."\n");
    }
    pop_dir();

    return $success ;
}


sub post_install
{
    my $success = 1;
    my @command;
    my $saplogon = '\\\\minerfiles.mst.edu\\dfs\\Software\\appserv\\SAP_GUI\\saplogon.ini';

    # Installing a few Add-ons, These weren't in the same dir as the main prog
    # Note: There are mulitple @commands because they have different DIR paths
    @command = (
        'start','/wait',
        "$srcfiles\\BI_PreCalServer\\Setup\\NwSapSetup.exe",
        '/Silent',
        '/Product=BiPcs',
        );
    print "Installing BI_PreCalServer: ";

    if ($success) {
        $success &amp;&amp;= run_command(join(' ',@command));
        output(($success?'OK':'FAILURE: ' . $!)."\n");
    }

    @command = (
        'start','/wait',
        "$srcfiles\\SAPCONSOLE\\NT_X64\\Setup\\NwSapSetup.exe",
        '/Silent',
        '/Product=SAPConsolex64',
        );
    print "Installing SAP Console: ";

    if ($success) {
        $success &amp;&amp;= run_command(join(' ',@command));
        output(($success?'OK':'FAILURE: ' . $!)."\n");
    }

    @command = (
        'start','/wait',
        "$srcfiles\\SAPPdfPrint\\NT_X64\\Setup\\NwSapSetup.exe",
        '/Silent',
        '/Product=PdfPrint64',
        );
    print "Installing SAP Pdf Print: ";

    if ($success) {
        $success &amp;&amp;= run_command(join(' ',@command));
        output(($success?'OK':'FAILURE: ' . $!)."\n");
    }

    @command = (
        'start','/wait',
        "$srcfiles\\SAPSPrint\\NT_X64\\Setup\\NwSapSetup.exe",
        '/Silent',
        '/Product=SPrint64',
        );
    print "Installing SAP S Print: ";

    if ($success) {
        $success &amp;&amp;= run_command(join(' ',@command));
        output(($success?'OK':'FAILURE: ' . $!)."\n");
    }

    if ($success) {
        print "Adding Environment Variable: ";
        $success &amp;&amp;= add_environment_variable('SAPLOGON_INI_FILE',$saplogon);
        output(($success?'OK':'FAILED')."\n");
    }

    return $success;
}


sub validate {
    my $success = 1;

    # Make sure the exe's are there.
    output("Validating install: ");
    foreach my $sap_exe (@installed_exes) {
        if (! -f $sap_exe) {
            output("  [MISSING_EXE] '${sap_exe}'\n");
            $success = 0;
        }
    }
    output(($success?'OK':'FAILED')."\n");

    return $success;
}

do_install(
    allowed_versions =&gt; [
        OSVER_XP_32,
        OSVER_VISTA_SP0, OSVER_VISTA_SP1,
        OSVER_WIN7_SP0, OSVER_WIN7_SP1,
        OSVER_WIN81_SP0,
    ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; [qw(clc desktop traveling virtual-clc virtual-desktop)],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    #preinstall_sub =&gt; \&amp;preinstall,
    postinstall_sub =&gt; \&amp;post_install,
    validate_sub =&gt; \&amp;validate,
);
IM_Exit(EXIT_SUCCESS);


# Begin-Doc
################################
# Name: configure_icons()
# Description: Traditionally, there has been a Start Menu shortcut to start
#   the GUI logon. This version doesn't seem to create it (anywhere I thought
#   to look). Create one that looks like the old way.
# Returns: True/false on success/failure (pass-through)
# Requires: File::Copy
# LastUpdated: 2014-09-16
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub configure_icons {
    my $source = build_path($srcfiles,'SAP Logon.lnk');
    my $target = build_path(get_allusers_start_menu(),'Programs',
                            'SAP Front End','SAP Logon.lnk');

    if (! copy($source,$target)) {
        output("Error copying shortcut from desktop to Start Menu: $!".
               "\n  ${source}\n  ${target}\n");
        cleanup();
        return 0;
    }

    return 1;
}


# Begin-Doc
################################
# Name: copy_logs()
# Description: Copy all the SAP install logs to AppLogs with the package ID
#   as a prefix.
# Requires: File::Copy
# LastUpdated: 2014-09-17
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub copy_logs {
    my $prefix = get_default_app_log();
    $prefix =~ s/\.txt$/_/i;

    if (opendir(my $LOGS,$install_log_dir)) {
        foreach my $entry (readdir($LOGS)) {
            next if ($entry =~ /\.log$/i);
            my $source = build_path($install_log_dir,$entry);
            next if (! -f $source);

            # copy it
            my $target = $prefix.basename($entry).'.txt';
            my $outcome = copy($source,$target);
            output("  ${entry}: ".($outcome?'OK':('FAILURE: '.$!))."\n");
        }
    } else {
        output("Error opening install log dir '${install_log_dir}': $!\n");
    }
}

# Begin-Doc
################################
# Name: discern_success_from_log()
# Description: The vendor-supplied installer does not always return non-zero
#   when the application install fails. Hmm...
#   The log file usually contains something meaningful (when the machine is
#     clean of previous SAP GUI installs, anyway). Check the end of it for
#     a summative "Return-Code: " string.
# Returns: true/false if the end of the specified log file indincates
#   success/failure.
# LastUpdated: 2014-09-17
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub discern_success_from_log {
    my $sap_log_file = shift;

    output("Checking SAP log file '${sap_log_file}' for exit status...\n",
           LOG_ONLY);
    # The log files are the typical Windows-Unicode format.
    if (open(my $SAPLOG,'&lt;:encoding(UTF-16LE)',$sap_log_file)) {
        my @lines = &lt;$SAPLOG&gt;;
        close($SAPLOG);

        # Search for the line closest to the end of the file containing:
        #   'Return-code: &lt;number&gt;'
        for (my $i=@lines-1; $i&gt;=0; $i--) {
            if ($lines[$i] =~ /Return-Code:\s*(\d+)/i) {
                output("Found 'Return-Code' in log file (line ".($i+1)."):\n".
                       $lines[$i]."\n",LOG_ONLY);
                my $return_code = $1;
                print "\n" . $1 . "\n";
                return $return_code == 0;
            }
        }
        output("No 'Return-Code' line in log file '${sap_log_file}': ".
               "assuming failure\n", LOG_ONLY);
        return 0;
    } else {
        # Failure to open the file is interpreted as a failure.
        output("Error opening log file '${sap_log_file}': $!\n");
        return 0;
    }
}


__END__
&gt; install.exe /?

Command Line Switches for the SAP Smart Extractor:
  /Silent: Runs in silent mode

  /noDLG: Only the progress pages will be displayed

  /D="&lt;Filename&gt;.cab" or /Detach="&lt;Filename&gt;.cab": Detach the cabinet file into the specified file (silently)

  /X="&lt;Pathname&gt;" or /Extract="&lt;Pathname&gt;" Extract the contents of the cabinet file into the specified folder

  /CreateServer [/dest="&lt;Absolute path to a newly created folder&gt;"]

  /UpdateServer [/dest="&lt;Absolute path to an existing SAP Installation Server&gt;"]


  /H or /? or /Help: Show this Help window


============================================================

The installer wants a 32-bit version of the JRE installed.


szJre7Version = HKEY_LOCAL_MACHINE\SOFTWARE\JavaSoft\Java Runtime Environment\Java7FamilyVersion
strJre7Path = HKEY_LOCAL_MACHINE\SOFTWARE\JavaSoft\Java Runtime Environment&lt;szJre7Version&gt;\JavaHome
&lt;strJre7Path&gt;\bin\java.exe


I found a number of config files with semi-useful information in the extracted
files obtained by using the /X flag.
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\sapgui.7_40\prod\update.pl</FullName>
    <Length>10372</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-03-24T16:57:40.6017038-05:00</CreationTime>
    <CreationTimeUtc>2016-03-24T21:57:40.6017038Z</CreationTimeUtc>
    <LastWriteTime>2016-05-20T16:53:24.0469282-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-05-20T21:53:24.0469282Z</LastWriteTimeUtc>
    <LastAccessTime>2016-03-24T16:57:40.6017038-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-03-24T21:57:40.6017038Z</LastAccessTimeUtc>
    <Text># SapGUI 7.40
# Package Created Feb 10, 2016
# Packaged by Dzu Phan
# Last Updated 5/20/2016 by Austin Wall

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'sapgui.7_40',
        package_revision =&gt; '20160520T1652',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

use Win32::TieRegistry;
use File::Basename;
use File::Temp qw(tempfile);
use Getopt::Long;
use File::Copy;

my $srcfiles = get_pkg_sourcefiles();

########################################################################
# BEGIN Configuration

my $install_log_dir = build_path(get_arch_programfiles(OSARCH_x86),
                                 'SAP','SAPSetup','LOGs');

my $default_sap_install_log = build_path($install_log_dir,'NwSapSetup.log');
my $bw_sap_install_log =
    build_path($install_log_dir,'bw350gui730_3-20010239.log');

my $target_jre_currver = '1.7';
my $target_jre_ver = '1.7.0_671';

my $JRE_rloc = 'HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\JavaSoft\Java Runtime Environment';
my $JRE_FV_rloc = build_path($JRE_rloc,'Java7FamilyVersion');
my $JRE_CV_rloc = build_path($JRE_rloc,'CurrentVersion');

my $JRE_temp_ver_data = {
    'JavaHome' =&gt; build_path($srcfiles,'jre7'),
};

# Used to validate that the application is actually installed.
my @installed_exes = (
    build_path(get_arch_programfiles(OSARCH_x86),
               'SAP','FrontEnd','SAPgui','saplgpad.exe'),
    build_path(get_arch_programfiles(OSARCH_x86),
               'SAP','Business Explorer','BI','BExAnalyzer.exe'),
);

# END Configuration
########################################################################

# Used to save the changes made by hijack_jre()
my %revert;
my @delete;

GetOptions(
    'code=s' =&gt; sub { exit(eval($_[1])); }, # bazooka debugging
);


sub preinstall {
    if(!is_installed('jre.7u72'))
    {
        output("\n");
        output("Java 7u72 is required to install this package.");
        output("\n");

        return 0;
    }

    return 1;
}


#/////////////////////////////////////////////////////////////////////////////////////#
sub install
{
    push_dir($srcfiles);
    my $success = 1;
    my @command;

    my @install_prog = (
        "SAPGUI",
        "SapBI",
        "NWBC50",
        "AXL",
        "KW",
        "SAPWUS"
        );
        # "JNet", is the one that needs Java 7u4 or higher

    print "Installing SAPGUI 7.40: \n";
    for (my $i=0; $i &lt; scalar(@install_prog); $i++) {
      @command = (
          'start','/wait',
          "$srcfiles\\GUI\\WINDOWS\\WIN32\\Setup\\NwSapSetup.exe",
          '/Silent',
          "/Product=$install_prog[$i]",
          );

      if ($success) {
          print "Product $i - $install_prog[$i]: ";
          $success &amp;&amp;= run_command(join(' ',@command));
          output(($success?'OK':'FAILURE: ' . $!)."\n");
      }
    }

    if ($success) {
        print "\nInstalling SAPGUI 7.40 Patches \n";
        print "Patch 4:";
        $success &amp;&amp;= run_command("start /wait $srcfiles\\BEx740_patch4.exe /Silent");
        output(($success?'OK':'FAILURE: ' . $!)."\n");

        print "Patch 7:";
        $success &amp;&amp;= run_command("start /wait $srcfiles\\gui740_patch7.exe /Silent");
        output(($success?'OK':'FAILURE: ' . $!)."\n");
    }
    pop_dir();

    return $success ;
}


sub post_install
{
    my $success = 1;
    my @command;
    my $saplogon = '\\\\minerfiles.mst.edu\\dfs\\Software\\appserv\\SAP_GUI\\saplogon.ini';

    my @install_dir = (
        "BI_PreCalServer",
        "SAPCONSOLE\\NT_X64",
        "SAPPdfPrint\\NT_X64",
        "SAPSPrint\\NT_X64"
        );

    my @install_prog = (
        "BiPcs",
        "SAPConsolex64",
        "PdfPrint64",
        "SPrint64",
        );

    # Installing a few Add-ons
    # Note: The Add-ons have different DIR paths
    print "Installing SAPGUI Add-ons: \n";
    for (my $i=0; $i &lt; scalar(@install_prog); $i++) {
      @command = (
          'start','/wait',
          "$srcfiles\\$install_dir[$i]\\Setup\\NwSapSetup.exe",
          '/Silent',
          "/Product=$install_prog[$i]",
          );

      if ($success) {
          print "Installing $install_prog[$i]: ";
          $success &amp;&amp;= run_command(join(' ',@command));
          output(($success?'OK':'FAILURE: ' . $!)."\n");
      }
    }

    if ($success) {
        print "Adding Environment Variable: ";
        $success &amp;&amp;= add_environment_variable('SAPLOGON_INI_FILE',$saplogon);
        output(($success?'OK':'FAILED')."\n");
    }

    return $success;
}


sub validate {
    my $success = 1;

    # Make sure the exe's are there.
    output("Validating install: ");
    foreach my $sap_exe (@installed_exes) {
        if (! -f $sap_exe) {
            output("  [MISSING_EXE] '${sap_exe}'\n");
            $success = 0;
        }
    }
    output(($success?'OK':'FAILED')."\n");

    return $success;
}

do_install(
    allowed_versions =&gt; [
        OSVER_XP_32,
        OSVER_VISTA_SP0, OSVER_VISTA_SP1,
        OSVER_WIN7_SP0, OSVER_WIN7_SP1,
        OSVER_WIN81_SP0,
    ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; [qw(clc desktop traveling virtual-clc virtual-desktop)],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    #preinstall_sub =&gt; \&amp;preinstall,
    postinstall_sub =&gt; \&amp;post_install,
    validate_sub =&gt; \&amp;validate,
);
IM_Exit(EXIT_SUCCESS);


# Begin-Doc
################################
# Name: configure_icons()
# Description: Traditionally, there has been a Start Menu shortcut to start
#   the GUI logon. This version doesn't seem to create it (anywhere I thought
#   to look). Create one that looks like the old way.
# Returns: True/false on success/failure (pass-through)
# Requires: File::Copy
# LastUpdated: 2014-09-16
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub configure_icons {
    my $source = build_path($srcfiles,'SAP Logon.lnk');
    my $target = build_path(get_allusers_start_menu(),'Programs',
                            'SAP Front End','SAP Logon.lnk');

    if (! copy($source,$target)) {
        output("Error copying shortcut from desktop to Start Menu: $!".
               "\n  ${source}\n  ${target}\n");
        cleanup();
        return 0;
    }

    return 1;
}


# Begin-Doc
################################
# Name: copy_logs()
# Description: Copy all the SAP install logs to AppLogs with the package ID
#   as a prefix.
# Requires: File::Copy
# LastUpdated: 2014-09-17
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub copy_logs {
    my $prefix = get_default_app_log();
    $prefix =~ s/\.txt$/_/i;

    if (opendir(my $LOGS,$install_log_dir)) {
        foreach my $entry (readdir($LOGS)) {
            next if ($entry =~ /\.log$/i);
            my $source = build_path($install_log_dir,$entry);
            next if (! -f $source);

            # copy it
            my $target = $prefix.basename($entry).'.txt';
            my $outcome = copy($source,$target);
            output("  ${entry}: ".($outcome?'OK':('FAILURE: '.$!))."\n");
        }
    } else {
        output("Error opening install log dir '${install_log_dir}': $!\n");
    }
}

# Begin-Doc
################################
# Name: discern_success_from_log()
# Description: The vendor-supplied installer does not always return non-zero
#   when the application install fails. Hmm...
#   The log file usually contains something meaningful (when the machine is
#     clean of previous SAP GUI installs, anyway). Check the end of it for
#     a summative "Return-Code: " string.
# Returns: true/false if the end of the specified log file indincates
#   success/failure.
# LastUpdated: 2014-09-17
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub discern_success_from_log {
    my $sap_log_file = shift;

    output("Checking SAP log file '${sap_log_file}' for exit status...\n",
           LOG_ONLY);
    # The log files are the typical Windows-Unicode format.
    if (open(my $SAPLOG,'&lt;:encoding(UTF-16LE)',$sap_log_file)) {
        my @lines = &lt;$SAPLOG&gt;;
        close($SAPLOG);

        # Search for the line closest to the end of the file containing:
        #   'Return-code: &lt;number&gt;'
        for (my $i=@lines-1; $i&gt;=0; $i--) {
            if ($lines[$i] =~ /Return-Code:\s*(\d+)/i) {
                output("Found 'Return-Code' in log file (line ".($i+1)."):\n".
                       $lines[$i]."\n",LOG_ONLY);
                my $return_code = $1;
                print "\n" . $1 . "\n";
                return $return_code == 0;
            }
        }
        output("No 'Return-Code' line in log file '${sap_log_file}': ".
               "assuming failure\n", LOG_ONLY);
        return 0;
    } else {
        # Failure to open the file is interpreted as a failure.
        output("Error opening log file '${sap_log_file}': $!\n");
        return 0;
    }
}


__END__
&gt; install.exe /?

Command Line Switches for the SAP Smart Extractor:
  /Silent: Runs in silent mode

  /noDLG: Only the progress pages will be displayed

  /D="&lt;Filename&gt;.cab" or /Detach="&lt;Filename&gt;.cab": Detach the cabinet file into the specified file (silently)

  /X="&lt;Pathname&gt;" or /Extract="&lt;Pathname&gt;" Extract the contents of the cabinet file into the specified folder

  /CreateServer [/dest="&lt;Absolute path to a newly created folder&gt;"]

  /UpdateServer [/dest="&lt;Absolute path to an existing SAP Installation Server&gt;"]


  /H or /? or /Help: Show this Help window


============================================================

The installer wants a 32-bit version of the JRE installed.


szJre7Version = HKEY_LOCAL_MACHINE\SOFTWARE\JavaSoft\Java Runtime Environment\Java7FamilyVersion
strJre7Path = HKEY_LOCAL_MACHINE\SOFTWARE\JavaSoft\Java Runtime Environment&lt;szJre7Version&gt;\JavaHome
&lt;strJre7Path&gt;\bin\java.exe


I found a number of config files with semi-useful information in the extracted
files obtained by using the /X flag.
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\sapgui.7_5\prod\update.pl</FullName>
    <Length>2040</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-12-12T09:15:41.6847824-06:00</CreationTime>
    <CreationTimeUtc>2017-12-12T15:15:41.6847824Z</CreationTimeUtc>
    <LastWriteTime>2018-06-08T16:20:34.1131474-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-08T21:20:34.1131474Z</LastWriteTimeUtc>
    <LastAccessTime>2017-12-12T09:15:41.6847824-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-12-12T15:15:41.6847824Z</LastAccessTimeUtc>
    <Text># Package created 12/8/2017
# Package created by Sergey Gruzdev
# Last Updated 12/8/2017 by Sergey Gruzdev

=pod

Begin-Doc
Modified: $Date$
Name: $Name$
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'sapgui.7_5',
        package_revision =&gt; '20170812T1532',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $src = get_pkg_sourcefiles();
sub install
{
  print "Installing SAP Gui 7.5: ";
  if(!run_command("$src\\SAPGUI_750_0.EXE /Silent /noDLG", IgnoreExitCodes =&gt; [129]))
  {
    print "FAILED - Fatal!\n";
	return 0;
  }
  print "Success!\n";
  print "===RESTART REQUIRED!===\n";
  return 1;
}

sub postinstall
{
  my $saplogon = '\\\\minerfiles.mst.edu\\dfs\\Software\\appserv\\SAP_GUI\\saplogon.ini';
  # Set env var to point to saplogon.ini
  print "Adding Environment Variable: ";
  my $success = add_environment_variable('SAPLOGON_INI_FILE',$saplogon);
  output(($success?'OK':'FAILED')."\n");
  
  # Set hklm key: HKLM\SOFTWARE\WOW6432Node\SAP\SAPLogon\Options\Options = \\minerfiles.mst.edu\dfs\software\appserv\SAP_GUI\SAPUILandscape.xml
  # Delete hkcu key
  
  print "Deleting shortcuts...\n";
  run_command("del \"SAP Logon.lnk\"");
  run_command("del \"SAP Business Client 6.5.lnk\"");
  run_command("del \"SAP Business Client.lnk\"");
  print "Deletd shortcuts!\n";
}

do_install
(
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\sapgui.7_5_new\prod\update.pl</FullName>
    <Length>2784</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-11T11:16:11.6970007-05:00</CreationTime>
    <CreationTimeUtc>2018-06-11T16:16:11.6970007Z</CreationTimeUtc>
    <LastWriteTime>2018-07-02T10:47:12.9029368-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-02T15:47:12.9029368Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-11T11:16:11.6970007-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-11T16:16:11.6970007Z</LastAccessTimeUtc>
    <Text># Package created 6/11/2018
# Package created by Sergey Gruzdev
# Last Updated 6/11/2018 by Sergey Gruzdev

=pod

Begin-Doc
Modified: $Date$
Name: $Name$
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'sapgui.7_5',
        package_revision =&gt; '20180611T0924',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $src = get_pkg_sourcefiles();

sub preinstall
{
	print "Installing Visual Studio 2010 Tools for Office...\n";
	if(!run_command("$src\\vstor_redist.exe /norestart /q"))
	{
		print "FATAL: Prerequisite Visual Studio 2010 Tools for Office failed!\n";
		return 0;
	}
	print "Prerequisites installed successfully!\n";
	return 1;
}

sub install
{
  my @products = (
    "SAPGUI",
	"SapBI",
	"NWBC65",
	"KW",
	"SAPWUS");
	
  
  foreach my $prod (@products)
  {
	  print "Installing SAP $prod: ";
	  if(!run_command("$src\\GUI\\WINDOWS\\Win32\\Setup\\NwSapSetup.exe /silent /nodlg /Product=$prod", IgnoreExitCodes =&gt; [129]))
	  {
		print "FAILED - Fatal!\n";
		return 0;
	  }
	  print "Success!\n";
  }
  print "Installing SAP AXL: ";
  if(!run_command("$src\\xSapAXL.exe /silent /nodlg", IgnoreExitCodes =&gt; [129]))
  {
    print "FAILED - Fatal!\n";
	return 0;
  }
  print "Success!\n";
  print "===RESTART REQUIRED!===\n";
  return 1;
}

sub postinstall
{
  my $saplogon = '\\\\minerfiles.mst.edu\\dfs\\Software\\appserv\\SAP_GUI\\saplogon.ini';
  # Set env var to point to saplogon.ini
  print "Adding Environment Variable: ";
  my $success = run_command("setx SAPLOGON_INI_FILE $saplogon /M");#add_environment_variable('SAPLOGON_INI_FILE',$saplogon);
  output(($success?'OK':'FAILED')."\n");
  
  print "Deleting shortcuts...\n";
  run_command("del \"C:\\Users\\Public\\Desktop\\SAP Logon.lnk\"");
  run_command("del \"C:\\Users\\Public\\Desktop\\SAP Business Client 6.5.lnk\"");
  run_command("del \"C:\\Users\\Public\\Desktop\\SAP Business Client.lnk\"");
  print "Deleted shortcuts!\n";
  
  print "Installation Complete!\n=====RESTART REQUIRED=====\n";
}

do_install
(
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  preinstall_sub =&gt; \&amp;preinstall,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\sap_hana_studio.2_3_39\prod\update.pl</FullName>
    <Length>3649</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-07-10T11:52:49.0944504-05:00</CreationTime>
    <CreationTimeUtc>2018-07-10T16:52:49.0944504Z</CreationTimeUtc>
    <LastWriteTime>2018-07-10T08:59:59.7594695-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-10T13:59:59.7594695Z</LastWriteTimeUtc>
    <LastAccessTime>2018-07-10T11:52:49.0944504-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-07-10T16:52:49.0944504Z</LastAccessTimeUtc>
    <Text># SAP HANA Studio 2.3.6 - An Eclipse-based IDE used to develop artifacts in a HANA server
# Package generated with GenGen on 2017-Mar-10 15:15
# Packaged by Grayson Gratop
# Package updated by Sergey Gruzdev, July 2018
#		Package now installs SAP HANA 2.3.39

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
      package_id =&gt; 'sap_hana_studio.2_3_39',
      package_revision =&gt; '20180710T0825',
  );
}

# Add InstallMonkey Library to the path
use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use Getopt::Long;
use InstallMonkey::Shared;

GetOptions(
  'uninstall' =&gt; sub { exit(!uninstall()); },
);

my $srcfilesdir = get_pkg_sourcefiles();
my $allUsersDesktop = get_allusers_desktop();
my $allUsersStartmenu = get_allusers_start_menu();
my $startmenudir = "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs";




sub install {
  ####
  # since the studio installer doesn't like it when javaw.exe is a symlink, follow the symlink if we need to and rewrite the
  ####

  # see if C:\ProgramData\Oracle\Java\javapath\javaw.exe is a symlink
  my %commandInfo;
  run_command('dir C:\ProgramData\Oracle\Java\javapath\javaw.exe', ReturnCommandInfo =&gt; \%commandInfo);
  my ($symPath) = ($commandInfo{'Output'} =~ /\[(.*)\]/);

  if (!($symPath eq '')) {
    output("Setting Java path to $symPath\n");
    open(FILE, "$srcfilesdir\\studio\\response.ini");
    undef $/;
    my $config = &lt;FILE&gt;;
    close(FILE);

    $config =~ s/C:\\ProgramData\\Oracle\\Java\\javapath\\javaw.exe/$symPath/;

    open(FILE, '&gt;', "$srcfilesdir\\studio\\response.ini");
    print FILE $config;
    close(FILE);
  }


  ####
  # Perform the rest of the install
  ####

  #thanks, creator of python 2.7 package. second argument is whether or not it's okay if the command fails
  my @installCommands = (
    ["$srcfilesdir\\hdbinst.exe --p=\"C:\\Program Files\\sap\\hdbstudio\"", 0]
    #["$srcfilesdir\\studio\\hdbinst -a studio -b --configfile=$srcfilesdir\\studio\\response.ini", 0]
  );

  my $success = 0;
  my $allDone = 1;

  output("Installing SAP HANA Studio 2.3.39... \n");

  for (my $i = 0; $i &lt; scalar @installCommands; $i++) {
    output("\t" . $installCommands[$i][0] . ": ");
    $success = run_command($installCommands[$i][0]);
    output($success ? "Done!\n" : "FAILED: $!\n");
    $allDone &amp;&amp;= $installCommands[$i][1] || $success;
  }

  if ($allDone) {
    output("Looks like it was a success!\n");
  }
  else {
    output("Something went wrong!\n");
  }

  return $allDone;
}


sub postInstall {

  # This step is deprecated as of 7/6/2018 by request from Joshua Jones
  if (!run_command("$srcfilesdir\\HANA_studio_plugin_installer.bat", 'IgnoreExitCodes' =&gt; [3010])) {
      output("FAILED: $!\n");
  return 0;
  }
  return 1;
}


do_install(
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
  allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
  #postinstall_sub =&gt; \&amp;postInstall,

);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\sap_hana_studio.2_3_6\prod\update.pl</FullName>
    <Length>3534</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-03-10T15:16:03.8763966-06:00</CreationTime>
    <CreationTimeUtc>2017-03-10T21:16:03.8763966Z</CreationTimeUtc>
    <LastWriteTime>2018-07-11T13:26:31.1501366-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-11T18:26:31.1501366Z</LastWriteTimeUtc>
    <LastAccessTime>2017-03-10T15:16:03.8763966-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-03-10T21:16:03.8763966Z</LastAccessTimeUtc>
    <Text># SAP HANA Studio 2.3.6 - An Eclipse-based IDE used to develop artifacts in a HANA server
# Package generated with GenGen on 2017-Mar-10 15:15
# Packaged by Grayson Gratop

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
      package_id =&gt; 'sap_hana_studio.2_3_6',
      package_revision =&gt; '20170310T1515',
  );
}

# Add InstallMonkey Library to the path
use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use Getopt::Long;
use InstallMonkey::Shared;

GetOptions(
  'uninstall' =&gt; sub { exit(!uninstall()); },
);

my $srcfilesdir = get_pkg_sourcefiles();
my $allUsersDesktop = get_allusers_desktop();
my $allUsersStartmenu = get_allusers_start_menu();
my $startmenudir = "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs";




sub install {
  ####
  # since the studio installer doesn't like it when javaw.exe is a symlink, follow the symlink if we need to and rewrite the
  ####

  # see if C:\ProgramData\Oracle\Java\javapath\javaw.exe is a symlink
  my %commandInfo;
  run_command('dir C:\ProgramData\Oracle\Java\javapath\javaw.exe', ReturnCommandInfo =&gt; \%commandInfo);
  my ($symPath) = ($commandInfo{'Output'} =~ /\[(.*)\]/);

  if (!($symPath eq '')) {
    output("Setting Java path to $symPath\n");
    open(FILE, "$srcfilesdir\\studio\\response.ini");
    undef $/;
    my $config = &lt;FILE&gt;;
    close(FILE);

    $config =~ s/C:\\ProgramData\\Oracle\\Java\\javapath\\javaw.exe/$symPath/;

    open(FILE, '&gt;', "$srcfilesdir\\studio\\response.ini");
    print FILE $config;
    close(FILE);
  }


  ####
  # Perform the rest of the install
  ####

  #thanks, creator of python 2.7 package. second argument is whether or not it's okay if the command fails
  my @installCommands = (
    ["$srcfilesdir\\client\\hdbinst -a client -b", 0],
    ["$srcfilesdir\\studio\\hdbinst -a studio -b --configfile=$srcfilesdir\\studio\\response.ini", 0]
  );

  my $success = 0;
  my $allDone = 1;

  output("Installing SAP HANA Studio 2.3.6... \n");

  for (my $i = 0; $i &lt; scalar @installCommands; $i++) {
    output("\t" . $installCommands[$i][0] . ": ");
    $success = run_command($installCommands[$i][0]);
    output($success ? "Done!\n" : "FAILED: $!\n");
    $allDone &amp;&amp;= $installCommands[$i][1] || $success;
  }

  if ($allDone) {
    output("Looks like it was a success!\n");
  }
  else {
    output("Something went wrong!\n");
  }

  return $allDone;
}


sub postInstall {

  # This step is deprecated as of 7/6/2018 by request from Joshua Jones
  if (!run_command("$srcfilesdir\\HANA_studio_plugin_installer.bat", 'IgnoreExitCodes' =&gt; [3010])) {
      output("FAILED: $!\n");
  return 0;
  }
  return 1;
}


do_install(
  allowed_versions =&gt; [OSVER_WIN10_SP0,OSVER_WIN10_SP1],
  allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
  #postinstall_sub =&gt; \&amp;postInstall,

);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\sassafrasKSC.7_4_0_0\prod\update.pl</FullName>
    <Length>2114</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-05-18T09:33:06.2886523-05:00</CreationTime>
    <CreationTimeUtc>2017-05-18T14:33:06.2886523Z</CreationTimeUtc>
    <LastWriteTime>2017-05-18T10:58:36.7125124-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-05-18T15:58:36.7125124Z</LastWriteTimeUtc>
    <LastAccessTime>2017-05-18T09:33:42.465748-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-05-18T14:33:42.465748Z</LastAccessTimeUtc>
    <Text># Sassafras Key Server Client 7.4.0.0
# Package Created May 2013
# Packaged by Charlie Hendricks
# Last Updated by Chris Schaaf - 2017-05-18

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'SassafrasKSC.7_4_0_0',
        package_revision =&gt; '20170518T0935',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $src = get_pkg_sourcefiles();

sub install 
{
  #http://www.sassafras.com/hrl/7.4/k2clientconfigW.html
  #'b' flag sets reboot after install option, 7.4 now auto-reboots after install.
  #taking care of this w/ "need_reboot" instead
  if(!run_command("start /WAIT \"\" \"$src\\k2clientconfig\" -s 3 -b no \"$src\\K2Client7400mst.exe\""))
  {
    output("Could not configure installer!\n");
    return 0;
  }
  else{
    output("Sassafras Keyserver Client Installer was configured...\n");
  }
  #This new method still requires you to run the installer after configuring it
  if(!run_command("start /WAIT \"\" \"$src\\K2Client7400mst.exe\""))
  {
    output("Could not install Sassafras KSC!\n");
    return 0;
  }
  else{
    output("Sassafras Keyserver Client was installed\n");
  }
  
  return 1;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
	need_reboot =&gt; 1,
   install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>20151030T152938_rename_mapping.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\sccm_2012_drivers\20151030T152938_rename_mapping.pl</FullName>
    <Length>5684</Length>
    <Extension>.pl</Extension>
    <CreationTime>2015-10-30T15:29:37.5151545-05:00</CreationTime>
    <CreationTimeUtc>2015-10-30T20:29:37.5151545Z</CreationTimeUtc>
    <LastWriteTime>2015-10-30T15:29:37.5151545-05:00</LastWriteTime>
    <LastWriteTimeUtc>2015-10-30T20:29:37.5151545Z</LastWriteTimeUtc>
    <LastAccessTime>2015-10-30T15:29:37.5151545-05:00</LastAccessTime>
    <LastAccessTimeUtc>2015-10-30T20:29:37.5151545Z</LastAccessTimeUtc>
    <Text>$VAR1 = {
          'Surface Pro 3\\Accessory\\SurfaceCoverAudio\\pro3_SurfaceCoverAudio.inf' =&gt; 'Surface Pro 3\\Accessory\\SurfaceCoverAudio\\SurfaceCoverAudio.inf',
          'Surface Pro 3\\Accessory\\SurfaceTouchCoverFwUpdate\\pro3_SurfaceTouchCoverFwUpdate.inf' =&gt; 'Surface Pro 3\\Accessory\\SurfaceTouchCoverFwUpdate\\SurfaceTouchCoverFwUpdate.inf',
          'Surface Pro 3\\System\\I2C\\pro3_iaLPSS_GPIO.inf' =&gt; 'Surface Pro 3\\System\\I2C\\iaLPSS_GPIO.inf',
          'Surface Pro 3\\Accessory\\SurfaceCoverTelemetry\\pro3_SurfaceCoverTelemetry.inf' =&gt; 'Surface Pro 3\\Accessory\\SurfaceCoverTelemetry\\SurfaceCoverTelemetry.inf',
          'Surface Pro 3\\Display\\Graphics\\pro3_64dp4256.inf' =&gt; 'Surface Pro 3\\Display\\Graphics\\64dp4256.inf',
          'Surface Pro 3\\System\\I2C\\pro3_iaLPSS_UART2.inf' =&gt; 'Surface Pro 3\\System\\I2C\\iaLPSS_UART2.inf',
          'Surface Pro 3\\Pen\\SurfacePen\\pro3_SurfacePen.inf' =&gt; 'Surface Pro 3\\Pen\\SurfacePen\\SurfacePen.inf',
          'Surface Pro 3\\Accessory\\SurfaceTypeCover\\pro3_SurfaceTypeCover.inf' =&gt; 'Surface Pro 3\\Accessory\\SurfaceTypeCover\\SurfaceTypeCover.inf',
          'Surface Pro 3\\System\\SurfaceIntegrationDriver\\pro3_SurfaceIntegrationDriver.inf' =&gt; 'Surface Pro 3\\System\\SurfaceIntegrationDriver\\SurfaceIntegrationDriver.inf',
          'Surface Pro 3\\System\\ManagementEngine\\pro3_heci.inf' =&gt; 'Surface Pro 3\\System\\ManagementEngine\\heci.inf',
          'Surface Pro 3\\Accessory\\SurfaceTypeCoverFwUpdate\\pro3_SurfaceTypeCoverFwUpdate.inf' =&gt; 'Surface Pro 3\\Accessory\\SurfaceTypeCoverFwUpdate\\SurfaceTypeCoverFwUpdate.inf',
          'Surface Pro 3\\System\\GPIO\\pro3_iaLPSS_I2C.inf' =&gt; 'Surface Pro 3\\System\\GPIO\\iaLPSS_I2C.inf',
          'Surface Pro 3\\Accessory\\SurfaceWirelessAdapter\\pro3_SurfaceWirelessAdapter.inf' =&gt; 'Surface Pro 3\\Accessory\\SurfaceWirelessAdapter\\SurfaceWirelessAdapter.inf',
          'Surface Pro 3\\System\\I2C\\pro3_iaLPSS_I2C.inf' =&gt; 'Surface Pro 3\\System\\I2C\\iaLPSS_I2C.inf',
          'Surface Pro 3\\Pen\\SurfacePenSettingsDriver\\pro3_SurfacePenDriver.inf' =&gt; 'Surface Pro 3\\Pen\\SurfacePenSettingsDriver\\SurfacePenDriver.inf',
          'Surface Pro 3\\System\\I2C\\pro3_iaLPSS_SPI.inf' =&gt; 'Surface Pro 3\\System\\I2C\\iaLPSS_SPI.inf',
          'Surface Pro 3\\Accessory\\SurfaceTypeCoverV3FwUpdate\\pro3_SurfaceTypeCoverV3FwUpdate.inf' =&gt; 'Surface Pro 3\\Accessory\\SurfaceTypeCoverV3FwUpdate\\SurfaceTypeCoverV3FwUpdate.inf',
          'Surface Pro 3\\Audio\\DockingStationAudioDevice\\pro3_msdokub.inf' =&gt; 'Surface Pro 3\\Audio\\DockingStationAudioDevice\\msdokub.inf',
          'Surface Pro 3\\Display\\SurfaceDisplayCalibration\\pro3_SurfaceDisplayCalibration.inf' =&gt; 'Surface Pro 3\\Display\\SurfaceDisplayCalibration\\SurfaceDisplayCalibration.inf',
          'Surface Pro 3\\System\\GPIO\\pro3_iaLPSS_SPI.inf' =&gt; 'Surface Pro 3\\System\\GPIO\\iaLPSS_SPI.inf',
          'Surface Pro 3\\Audio\\HdAudio\\pro3_HDXMSSP.inf' =&gt; 'Surface Pro 3\\Audio\\HdAudio\\HDXMSSP.inf',
          'Surface Pro 3\\System\\SurfacePciController\\pro3_SurfacePciController.inf' =&gt; 'Surface Pro 3\\System\\SurfacePciController\\SurfacePciController.inf',
          'Surface Pro 3\\System\\GPIO\\pro3_iaLPSS_GPIO.inf' =&gt; 'Surface Pro 3\\System\\GPIO\\iaLPSS_GPIO.inf',
          'Surface Pro 3\\System\\LowPinCount\\pro3_LxLpCore.inf' =&gt; 'Surface Pro 3\\System\\LowPinCount\\LxLpCore.inf',
          'Surface Pro 3\\Accessory\\SurfaceTouchCover2FwUpdate\\pro3_SurfaceTouchCover2FwUpdate.inf' =&gt; 'Surface Pro 3\\Accessory\\SurfaceTouchCover2FwUpdate\\SurfaceTouchCover2FwUpdate.inf',
          'Surface Pro 3\\System\\GPIO\\pro3_iaLPSS_UART2.inf' =&gt; 'Surface Pro 3\\System\\GPIO\\iaLPSS_UART2.inf',
          'Surface Pro 3\\Accessory\\SurfaceAccessoryDevice\\pro3_SurfaceAccessoryDevice.inf' =&gt; 'Surface Pro 3\\Accessory\\SurfaceAccessoryDevice\\SurfaceAccessoryDevice.inf',
          'Surface Pro 3\\Network\\WiFi\\pro3_mrvlpcie8897.inf' =&gt; 'Surface Pro 3\\Network\\WiFi\\mrvlpcie8897.inf',
          'Surface Pro 3\\Accessory\\SurfaceTypeCover2FwUpdate\\pro3_SurfaceTypeCover2FwUpdate.inf' =&gt; 'Surface Pro 3\\Accessory\\SurfaceTypeCover2FwUpdate\\SurfaceTypeCover2FwUpdate.inf',
          'Surface Pro 3\\Accessory\\SurfaceCoverClick\\pro3_SurfaceCoverClick.inf' =&gt; 'Surface Pro 3\\Accessory\\SurfaceCoverClick\\SurfaceCoverClick.inf',
          'Surface Pro 3\\Network\\SurfaceGigabitEthernetAdapter\\pro3_msu30x64w8.inf' =&gt; 'Surface Pro 3\\Network\\SurfaceGigabitEthernetAdapter\\msu30x64w8.inf',
          'Surface Pro 3\\Accessory\\SurfaceTouchCover\\pro3_SurfaceTouchCover.inf' =&gt; 'Surface Pro 3\\Accessory\\SurfaceTouchCover\\SurfaceTouchCover.inf',
          'Surface Pro 3\\Network\\SurfaceEthernetAdapter\\pro3_msu64w8.inf' =&gt; 'Surface Pro 3\\Network\\SurfaceEthernetAdapter\\msu64w8.inf',
          'Surface Pro 3\\Network\\Bluetooth\\pro3_mbtr8897w81x64.inf' =&gt; 'Surface Pro 3\\Network\\Bluetooth\\mbtr8897w81x64.inf',
          'Surface Pro 3\\Camera\\LifeCam\\pro3_TrueColor.inf' =&gt; 'Surface Pro 3\\Camera\\LifeCam\\TrueColor.inf',
          'Surface Pro 3\\System\\CardReader\\pro3_RtsUerXDisableMMC.inf' =&gt; 'Surface Pro 3\\System\\CardReader\\RtsUerXDisableMMC.inf',
          'Surface Pro 3\\System\\SMBus\\pro3_LxLpSMB.inf' =&gt; 'Surface Pro 3\\System\\SMBus\\LxLpSMB.inf',
          'Surface Pro 3\\Display\\DisplayAudio\\pro3_IntcDAud.inf' =&gt; 'Surface Pro 3\\Display\\DisplayAudio\\IntcDAud.inf',
          'Surface Pro 3\\System\\CapacitiveHomeButton\\pro3_SurfaceCapacitiveHomeButton.inf' =&gt; 'Surface Pro 3\\System\\CapacitiveHomeButton\\SurfaceCapacitiveHomeButton.inf'
        };
</Text>
  </Script>
  <Script>
    <Name>20151208T140642_rename_mapping.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\sccm_2012_drivers\20151208T140642_rename_mapping.pl</FullName>
    <Length>26444</Length>
    <Extension>.pl</Extension>
    <CreationTime>2015-12-08T14:06:43.5503992-06:00</CreationTime>
    <CreationTimeUtc>2015-12-08T20:06:43.5503992Z</CreationTimeUtc>
    <LastWriteTime>2015-12-08T14:06:43.5659996-06:00</LastWriteTime>
    <LastWriteTimeUtc>2015-12-08T20:06:43.5659996Z</LastWriteTimeUtc>
    <LastAccessTime>2015-12-08T14:06:43.5503992-06:00</LastAccessTime>
    <LastAccessTimeUtc>2015-12-08T20:06:43.5503992Z</LastAccessTimeUtc>
    <Text>$VAR1 = {
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Accessory\\SurfacePTPFilter\\pro4_SurfacePTPFilter.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Accessory\\SurfacePTPFilter\\SurfacePTPFilter.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\SignalProcessor\\pro4_ov5693.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\SignalProcessor\\ov5693.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\DPTF\\pro4_sunrisepoint-lpSDHost.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\DPTF\\sunrisepoint-lpSDHost.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Accessory\\SurfaceFingerprintSensor\\pro4_SurfaceFingerprintSensor.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Accessory\\SurfaceFingerprintSensor\\SurfaceFingerprintSensor.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Network\\SurfaceCoSAR\\pro4_SurfaceCoSAR.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Network\\SurfaceCoSAR\\SurfaceCoSAR.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\FrontSensor\\pro4_iacamera64.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\FrontSensor\\iacamera64.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\SurfaceTouchServicingML\\pro4_SurfaceTouchServicingML.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\SurfaceTouchServicingML\\SurfaceTouchServicingML.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\CSI2HostController\\pro4_ov5693.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\CSI2HostController\\ov5693.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\SPI\\pro4_iaLPSS2_I2C_SKL.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\SPI\\iaLPSS2_I2C_SKL.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\FrontIRSensor\\pro4_SkcController.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\FrontIRSensor\\SkcController.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Accessory\\SurfaceAccessoryFwUpdate\\pro4_SurfaceAccessoryFwUpdate.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Accessory\\SurfaceAccessoryFwUpdate\\SurfaceAccessoryFwUpdate.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\AVStream\\pro4_iaisp64.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\AVStream\\iaisp64.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\FrontIRSensor\\pro4_CSI2HostControllerDriver.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\FrontIRSensor\\CSI2HostControllerDriver.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\WindowsHello\\pro4_SurfaceCameraWindowsHello.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\WindowsHello\\SurfaceCameraWindowsHello.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Firmware\\UEFI\\pro4_SurfaceUEFI.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Firmware\\UEFI\\SurfaceUEFI.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\SurfaceHomeButton\\pro4_SurfaceButton.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\SurfaceHomeButton\\SurfaceButton.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\UART\\pro4_iaLPSS2_I2C_SKL.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\UART\\iaLPSS2_I2C_SKL.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Network\\WiFi\\pro4_mrvlpcie8897.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Network\\WiFi\\mrvlpcie8897.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\RearSensor\\pro4_ov5693.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\RearSensor\\ov5693.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\GPIO\\pro4_iaLPSS2_GPIO2_SKL.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\GPIO\\iaLPSS2_GPIO2_SKL.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Firmware\\EC\\pro4_SurfaceEC.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Firmware\\EC\\SurfaceEC.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Pen\\SurfacePenSettingsDriver\\pro4_SurfacePenDriver.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Pen\\SurfacePenSettingsDriver\\SurfacePenDriver.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\SignalProcessor\\pro4_iaisp64.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\SignalProcessor\\iaisp64.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\SignalProcessor\\pro4_SkcController.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\SignalProcessor\\SkcController.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\LPC\\pro4_sunrisepoint-lpSDHost.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\LPC\\sunrisepoint-lpSDHost.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Display\\SurfaceDisplay\\pro4_SurfaceDisplay.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Display\\SurfaceDisplay\\SurfaceDisplay.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\SkcController\\pro4_iaisp64.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\SkcController\\iaisp64.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\SignalProcessor\\pro4_ov7251.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\SignalProcessor\\ov7251.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\CSI2HostController\\pro4_ov7251.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\CSI2HostController\\ov7251.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Pen\\SurfacePenIntegration\\pro4_SurfacePenIntegration.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Pen\\SurfacePenIntegration\\SurfacePenIntegration.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\DPTF\\pro4_sunrisepoint-lpSystem.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\DPTF\\sunrisepoint-lpSystem.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\FrontIRSensor\\pro4_ov7251.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\FrontIRSensor\\ov7251.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\RearSensor\\pro4_iaisp64.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\RearSensor\\iaisp64.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\RearSensor\\pro4_CSI2HostControllerDriver.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\RearSensor\\CSI2HostControllerDriver.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Audio\\SmartSoundOED\\pro4_IntcOED.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Audio\\SmartSoundOED\\IntcOED.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Accessory\\SurfaceTypeCover\\pro4_SurfaceTypeCover.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Accessory\\SurfaceTypeCover\\SurfaceTypeCover.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\AVStream\\pro4_iacamera64.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\AVStream\\iacamera64.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\SignalProcessor\\pro4_iacamera64.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\SignalProcessor\\iacamera64.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\Skylake\\pro4_sunrisepoint-lpSDHost.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\Skylake\\sunrisepoint-lpSDHost.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\UART\\pro4_iaLPSS2_UART2_SKL.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\UART\\iaLPSS2_UART2_SKL.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\Skylake\\pro4_skylakeSystem.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\Skylake\\skylakeSystem.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\AVStream\\pro4_CSI2HostControllerDriver.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\AVStream\\CSI2HostControllerDriver.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\FrontIRSensor\\pro4_iaisp64.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\FrontIRSensor\\iaisp64.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\SkcController\\pro4_iacamera64.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\SkcController\\iacamera64.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\FrontSensor\\pro4_SkcController.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\FrontSensor\\SkcController.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\AVStream\\pro4_ov7251.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\AVStream\\ov7251.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Firmware\\SAM\\pro4_SurfaceSAM.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Firmware\\SAM\\SurfaceSAM.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\SignalProcessor\\pro4_ov8865.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\SignalProcessor\\ov8865.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\LPC\\pro4_commonSystem.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\LPC\\commonSystem.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Accessory\\SurfacePro4TypeCoverIntegration\\pro4_SurfacePro4TypeCoverIntegration.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Accessory\\SurfacePro4TypeCoverIntegration\\SurfacePro4TypeCoverIntegration.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\FrontSensor\\pro4_CSI2HostControllerDriver.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\FrontSensor\\CSI2HostControllerDriver.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Firmware\\Touch\\pro4_SurfaceTouch.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Firmware\\Touch\\SurfaceTouch.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\SurfaceStorageFwUpdate\\pro4_SurfaceStorageFwUpdate.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\SurfaceStorageFwUpdate\\SurfaceStorageFwUpdate.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\SPI\\pro4_iaLPSS2_UART2_SKL.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\SPI\\iaLPSS2_UART2_SKL.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\FrontSensor\\pro4_iaisp64.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\FrontSensor\\iaisp64.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Display\\SurfaceDigitizerIntegration\\pro4_SurfaceDigitizerIntegration.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Display\\SurfaceDigitizerIntegration\\SurfaceDigitizerIntegration.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\SurfaceIntegrationDriver\\pro4_SurfaceIntegrationDriver.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\SurfaceIntegrationDriver\\SurfaceIntegrationDriver.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Pen\\SurfacePenClickFilter\\pro4_SurfacePenClickFilter.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Pen\\SurfacePenClickFilter\\SurfacePenClickFilter.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Audio\\SmartSoundBus\\pro4_IntcAudioBus.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Audio\\SmartSoundBus\\IntcAudioBus.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Display\\Graphics\\pro4_64gh4326.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Display\\Graphics\\64gh4326.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Display\\DisplayAudio\\pro4_IntcDAud.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Display\\DisplayAudio\\IntcDAud.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\CSI2HostController\\pro4_ov8865.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\CSI2HostController\\ov8865.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\SkcController\\pro4_CSI2HostControllerDriver.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\SkcController\\CSI2HostControllerDriver.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\FrontIRSensor\\pro4_ov8865.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\FrontIRSensor\\ov8865.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\I2C\\pro4_iaLPSS2_GPIO2_SKL.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\I2C\\iaLPSS2_GPIO2_SKL.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\FrontSensor\\pro4_ov7251.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\FrontSensor\\ov7251.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\LPSDHost\\pro4_skylakeSystem.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\LPSDHost\\skylakeSystem.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\I2C\\pro4_iaLPSS2_SPI_SKL.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\I2C\\iaLPSS2_SPI_SKL.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Audio\\HDAudio\\pro4_HDXSSTM.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Audio\\HDAudio\\HDXSSTM.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\SkcController\\pro4_ov7251.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\SkcController\\ov7251.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\I2C\\pro4_iaLPSS2_UART2_SKL.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\I2C\\iaLPSS2_UART2_SKL.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\DPTF\\pro4_commonSystem.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\DPTF\\commonSystem.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Accessory\\SurfaceCoverClick\\pro4_SurfaceCoverClick.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Accessory\\SurfaceCoverClick\\SurfaceCoverClick.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\SkcController\\pro4_ov5693.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\SkcController\\ov5693.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\AVStream\\pro4_ov8865.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\AVStream\\ov8865.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\SurfacePowerMeter\\pro4_SurfacePowerMeter.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\SurfacePowerMeter\\SurfacePowerMeter.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\DPTF\\pro4_skylakeSystem.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\DPTF\\skylakeSystem.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\UART\\pro4_iaLPSS2_SPI_SKL.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\UART\\iaLPSS2_SPI_SKL.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Accessory\\SurfaceTypeCoverV3Integration\\pro4_SurfaceTypeCoverV3Integration.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Accessory\\SurfaceTypeCoverV3Integration\\SurfaceTypeCoverV3Integration.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\GPIO\\pro4_iaLPSS2_SPI_SKL.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\GPIO\\iaLPSS2_SPI_SKL.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Network\\WiFi\\pro4_mbtr8897w81x64.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Network\\WiFi\\mbtr8897w81x64.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\LPSDHost\\pro4_commonSystem.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\LPSDHost\\commonSystem.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Accessory\\Surface3TypeCoverIntegration\\pro4_Surface3TypeCoverIntegration.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Accessory\\Surface3TypeCoverIntegration\\Surface3TypeCoverIntegration.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\LPSDHost\\pro4_sunrisepoint-lpSDHost.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\LPSDHost\\sunrisepoint-lpSDHost.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\UART\\pro4_iaLPSS2_GPIO2_SKL.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\UART\\iaLPSS2_GPIO2_SKL.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Accessory\\SurfaceTypeCoverV3FwUpdate\\pro4_SurfaceTypeCoverV3FwUpdate.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Accessory\\SurfaceTypeCoverV3FwUpdate\\SurfaceTypeCoverV3FwUpdate.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\SignalProcessor\\pro4_CSI2HostControllerDriver.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\SignalProcessor\\CSI2HostControllerDriver.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\GPIO\\pro4_iaLPSS2_UART2_SKL.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\GPIO\\iaLPSS2_UART2_SKL.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\CSI2HostController\\pro4_iaisp64.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\CSI2HostController\\iaisp64.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\SPI\\pro4_iaLPSS2_GPIO2_SKL.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\SPI\\iaLPSS2_GPIO2_SKL.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Audio\\SurfaceDockAudioUSB\\pro4_msdokub.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Audio\\SurfaceDockAudioUSB\\msdokub.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\FrontSensor\\pro4_ov5693.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\FrontSensor\\ov5693.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\CSI2HostController\\pro4_SkcController.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\CSI2HostController\\SkcController.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\RearSensor\\pro4_ov7251.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\RearSensor\\ov7251.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\GPIO\\pro4_iaLPSS2_I2C_SKL.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\GPIO\\iaLPSS2_I2C_SKL.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\FrontSensor\\pro4_ov8865.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\FrontSensor\\ov8865.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\Battery\\pro4_SurfaceACPIBattery.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\Battery\\SurfaceACPIBattery.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\LPC\\pro4_skylakeSystem.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\LPC\\skylakeSystem.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\CSI2HostController\\pro4_CSI2HostControllerDriver.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\CSI2HostController\\CSI2HostControllerDriver.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\FrontIRSensor\\pro4_iacamera64.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\FrontIRSensor\\iacamera64.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\SkcController\\pro4_ov8865.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\SkcController\\ov8865.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\Skylake\\pro4_sunrisepoint-lpSystem.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\Skylake\\sunrisepoint-lpSystem.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\Skylake\\pro4_commonSystem.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\Skylake\\commonSystem.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\CSI2HostController\\pro4_iacamera64.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\CSI2HostController\\iacamera64.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\AVStream\\pro4_ov5693.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\AVStream\\ov5693.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\SurfaceSystemTelemetryDriver\\pro4_SurfaceSystemTelemetryDriver.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\SurfaceSystemTelemetryDriver\\SurfaceSystemTelemetryDriver.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\LPSDHost\\pro4_sunrisepoint-lpSystem.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\LPSDHost\\sunrisepoint-lpSystem.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\SPI\\pro4_iaLPSS2_SPI_SKL.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\SPI\\iaLPSS2_SPI_SKL.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\RearSensor\\pro4_SkcController.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\RearSensor\\SkcController.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Accessory\\SurfaceKeyboardBacklight\\pro4_SurfaceKeyboardBacklight.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Accessory\\SurfaceKeyboardBacklight\\SurfaceKeyboardBacklight.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Firmware\\ME\\pro4_SurfaceME.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Firmware\\ME\\SurfaceME.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\FrontIRSensor\\pro4_ov5693.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\FrontIRSensor\\ov5693.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\RearSensor\\pro4_iacamera64.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\RearSensor\\iacamera64.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\LPC\\pro4_sunrisepoint-lpSystem.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\LPC\\sunrisepoint-lpSystem.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Accessory\\SurfaceAccessoryDevice\\pro4_SurfaceAccessoryDevice.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Accessory\\SurfaceAccessoryDevice\\SurfaceAccessoryDevice.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Pen\\SurfacePen\\pro4_SurfacePen.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Pen\\SurfacePen\\SurfacePen.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\I2C\\pro4_iaLPSS2_I2C_SKL.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\I2C\\iaLPSS2_I2C_SKL.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Network\\Bluetooth\\pro4_mbtr8897w81x64.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Network\\Bluetooth\\mbtr8897w81x64.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Network\\Bluetooth\\pro4_mrvlpcie8897.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Network\\Bluetooth\\mrvlpcie8897.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Display\\SurfaceDisplayCalibration\\pro4_SurfaceDisplayCalibration.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Display\\SurfaceDisplayCalibration\\SurfaceDisplayCalibration.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\RearSensor\\pro4_ov8865.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\RearSensor\\ov8865.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\SkcController\\pro4_SkcController.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\SkcController\\SkcController.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Pen\\SurfacePenPairing\\pro4_SurfacePenPairing.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Pen\\SurfacePenPairing\\SurfacePenPairing.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\AVStream\\pro4_SkcController.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\Camera\\AVStream\\SkcController.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\PreciseTouch\\pro4_iaPreciseTouch.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\PreciseTouch\\iaPreciseTouch.inf',
          'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\ManagementEngine\\pro4_heci.inf' =&gt; 'Surface Pro 4\\SurfacePro4_Win10_151203_0\\Drivers\\System\\ManagementEngine\\heci.inf'
        };
</Text>
  </Script>
  <Script>
    <Name>rename_inf.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\sccm_2012_drivers\rename_inf.pl</FullName>
    <Length>5368</Length>
    <Extension>.pl</Extension>
    <CreationTime>2015-10-30T15:28:13.8814101-05:00</CreationTime>
    <CreationTimeUtc>2015-10-30T20:28:13.8814101Z</CreationTimeUtc>
    <LastWriteTime>2011-05-24T07:35:58.3282157-05:00</LastWriteTime>
    <LastWriteTimeUtc>2011-05-24T12:35:58.3282157Z</LastWriteTimeUtc>
    <LastAccessTime>2015-10-30T15:28:13.8814101-05:00</LastAccessTime>
    <LastAccessTimeUtc>2015-10-30T20:28:13.8814101Z</LastAccessTimeUtc>
    <Text>#!perl

=pod

Begin-Doc
Modified: $Date: 2011-05-13 11:12:26 -0500 (Fri, 13 May 2011) $
Name: rename_inf.pl
Type: script
Description: Config Manager requires a flat namespace for all .INF files
  in its driver database. In order to keep different drivers with the same
  .INF name, we need to rename each .INF in the driver directories.

  Our current convention is to append the hardware platform short name,
    like '-E6420'.
Language: Perl
LastUpdatedBy: $Author: thartman $
Version: $Revision: 688 $
Doc-Package-Info: 
Doc-SVN-Repository: $URL: https://svn.mst.edu/project/itwindist/trunk/win7/appdist/configmgr_drivers/rename_inf.pl $
RCSId: $Id: rename_inf.pl 688 2011-05-13 16:12:26Z thartman $
End-Doc

=cut

$|=1;

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'rename_inf.1',
        output_log =&gt; '.\rename_inf-log.txt',
    );
}
use lib ('\\\\minerfiles.mst.edu\dfs\software\loginscripts\im');
use InstallMonkey::Shared;

use File::Find;
use File::Basename;
use Getopt::Long;
use Data::Dumper;
use POSIX qw(strftime);


my $prefix = '';
my $suffix = '';
my @default_dirs = ( '.' );
my @dirs;
my $revert_file = '';
my $test_only = 0;
sub usage {
    print qq/
usage: $0 [-help] [-test]
          {-prefix &lt;new_name_prefix&gt;|-suffix &lt;new_name_suffix&gt;}
          [-revert &lt;revert_mapping&gt;]
          [&lt;dir1&gt; [&lt;dir2&gt; [...]]]

Rename all .INF files in the specified directory trees (or the
current directory, if no directories are specified) to use the
specified prefix, suffix, or both.

-test
  Do not actually rename anything, just print out the mapping.

-revert &lt;revert_mapping_file&gt;
  Undo the renaming by the hashref dumped to &lt;revert_mapping_file&gt;.

/;
}
Getopt::Long::Configure(qw(pass_through));
GetOptions(
    'help' =&gt; sub { usage(); exit(0); },
    'test' =&gt; \$test_only,

    'prefix=s' =&gt; \$prefix,
    'suffix=s' =&gt; \$suffix,

    'revert=s' =&gt; sub { exit(revert_files($_[1])); },
);
push(@dirs,@ARGV);
@dirs = @default_dirs if (!@dirs);

if (!$prefix &amp;&amp; !$suffix) {
    print("You must specify at least one of -prefix or -suffix.\n");
    usage();
    exit(0x57);
}

print("Renaming '*.INF' files to '${prefix}*${suffix}.*'\n\n");

my %mapping;
my %printed_dirs;
my $success = 1;
my $total = 0;
find(
    sub {
        return if (!($_ =~ /(\.(?:INF))$/i &amp;&amp; -f $_));

        my $ext = $1;
        my $new_name = build_path($File::Find::dir,
                                  $prefix.basename($_,$ext).$suffix.$ext);
        $mapping{$new_name} = build_path($File::Find::name);
        if ($test_only) {
            output("[TEST_ONLY] '".build_path($File::Find::name).
                   "' =&gt; '$new_name'\n");
        } else {
            my $dir = build_path($File::Find::dir);
            if (!exists($printed_dirs{$dir})) {
                $printed_dirs{$dir} = 1;
                output("${dir}\n");
            }
            output("  '$_' =&gt; '".basename($new_name)."': ");
            if (run_command("rename \"$_\" \"".basename($new_name)."\"")) {
                output("OK\n");
                $total++;
            } else {
                output("FAILED\n");
                $success = 0;
            }
        }
    },
    @dirs
    );

output("\n\nSUMMARY\n${total} files renamed.\n");
if (!$success) {
    output("Not all .INF files successfully renamed.\n");
}


if (!$test_only) {
    output("Mapping (for reverting the rename):\n".
           ('=' x 72)."\n".
           Dumper(\%mapping).
           ('=' x 72)."\n",
           LOG_ONLY);

    $revert_file = strftime('%Y%m%dT%H%M%S',localtime()).'_rename_mapping.pl';
    output("Saving filename mapping to '${revert_file}': ");
    if (open(my $MAPPING,'&gt;',$revert_file)) {
        print $MAPPING Dumper(\%mapping);
        close($MAPPING);
        print("OK\n");
    } else {
        print("FAILED\n  Error opening file: $!\n");
    }
}

exit(!$success);


########################################################################

sub revert_files {
    my $revert_file = shift;
    output("Reverting files ('${revert_file}'):\n");
    if (! -f $revert_file) {
        output("  Cannot access '${revert_file}'!\n");
        return 0;
    }
    my $mapping;
    my $mapping_code = get_file_contents($revert_file);
    $mapping_code =~ s/^[^=]*=//;
    output("Mapping:\n".
           ('=' x 72)."\n".
           $mapping_code."\n".
           ('=' x 72)."\n",LOG_ONLY);
    if (!eval('$mapping = '.$mapping_code.'; 1;')) {
        output("Error evaluating file mapping Perl code: $@\n");
        return 0;
    }
    my $success = 1;
    my $count = 0;
    for my $curr_name (keys(%$mapping)) {
        my $old_name = $mapping-&gt;{$curr_name};
        output("  '${curr_name}' =&gt; '".basename($old_name).'": ');
        if (run_command('rename "'.$curr_name.'" "'.
                        basename($old_name).'"')) {
            output("OK\n");
            $count++;
        } else {
            output("FAILED\n");
            $success = 0;
        }
    }

    output("\n\n${count} files reverted.\n");
    if (!$success) {
        output("Not all reversions were successful!\n");
    }
    return $success;
}
</Text>
  </Script>
  <Script>
    <Name>generate_unattend_templates_from_master.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\sccm_2012_unattend\generate_unattend_templates_from_master.pl</FullName>
    <Length>1540</Length>
    <Extension>.pl</Extension>
    <CreationTime>2015-10-09T11:48:06.037889-05:00</CreationTime>
    <CreationTimeUtc>2015-10-09T16:48:06.037889Z</CreationTimeUtc>
    <LastWriteTime>2015-10-09T12:08:32.073325-05:00</LastWriteTime>
    <LastWriteTimeUtc>2015-10-09T17:08:32.073325Z</LastWriteTimeUtc>
    <LastAccessTime>2015-10-09T11:48:06.037889-05:00</LastAccessTime>
    <LastAccessTimeUtc>2015-10-09T16:48:06.037889Z</LastAccessTimeUtc>
    <Text>



$cwd=$0;
@cwd=split(/\\/,$cwd,-1);
$#cwd=$#cwd-1;
$cwd=join("\\",@cwd);
if ($cwd eq "")
{
 $cwd=`cd`;
 chomp($cwd);
}




@displaymodes=("1920x1080","1600x1200","1680x1050","1600x900","1440x900","1400x1050","1366x768","1360x768","1280x1024","1280x800","1024x768","800x600","640x480");


for ($i=0;$i&lt;@displaymodes;$i++)
{
    @resval = split('x', $displaymodes[$i]);
    
    
    my $xres=@resval[0];
    my $yres=@resval[1];
    
    
    
    createfile($xres,$yres);    
}
    
    
    
    
    
    
    
    

sub createfile{
    my $xres=$_[0];
    my $yres=$_[1];
    
    $file="$cwd\\master.xml";
    open (MASTER, $file);
    open (NEWFILE, "&gt;$cwd\\prod\\unattend_10_$xres"."x$yres.xml");
    while ($line = &lt;MASTER&gt;)
    {
        if ($line =~ /&lt;SETDISPLAYSETTINGSHERE&gt;/)
        {
            $line =~ s/&lt;SETDISPLAYSETTINGSHERE&gt;/&lt;Display&gt;
                &lt;ColorDepth&gt;32&lt;\/ColorDepth&gt;
                &lt;HorizontalResolution&gt;$xres&lt;\/HorizontalResolution&gt;
                &lt;VerticalResolution&gt;$yres&lt;\/VerticalResolution&gt;
                &lt;RefreshRate&gt;60&lt;\/RefreshRate&gt;
            &lt;\/Display&gt;/mg;
            
        }
        
        print NEWFILE "$line";
    
    }

}


#
#
#&lt;Display&gt;
#                &lt;ColorDepth&gt;32&lt;/ColorDepth&gt;
#                &lt;HorizontalResolution&gt;1440&lt;/HorizontalResolution&gt;
#                &lt;VerticalResolution&gt;900&lt;/VerticalResolution&gt;
#                &lt;RefreshRate&gt;60&lt;/RefreshRate&gt;
#            &lt;/Display&gt;
#            
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\schlumberger.2017\Eclipse\update.pl</FullName>
    <Length>3235</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-12-01T16:49:04.1910735-06:00</CreationTime>
    <CreationTimeUtc>2017-12-01T22:49:04.1910735Z</CreationTimeUtc>
    <LastWriteTime>2018-01-24T15:36:42.5418161-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-24T21:36:42.5418161Z</LastWriteTimeUtc>
    <LastAccessTime>2017-12-13T14:08:30.4838462-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-12-13T20:08:30.4838462Z</LastAccessTimeUtc>
    <Text># Eclipse 2017.1 - wellbore information aggregate
# Package generated with GenGen on 2017-DEC-11 15:52
# Packaged by Kele Shi

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
      package_id =&gt; 'Eclipse.2017_1',
      package_revision =&gt; '20171211T1552',
  );
}

# Add InstallMonkey Library to the path
use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use Getopt::Long;
use InstallMonkey::Shared;

GetOptions(
  'uninstall' =&gt; sub { exit(!uninstall()); },
);

my $appdeploy_path = "\\\\minerfiles.mst.edu\\dfs\\software\\appdeploy\\schlumberger.2017\\Eclipse 2017.1";
my $allUsersDesktop = get_allusers_desktop();
my $allUsersStartmenu = get_allusers_start_menu();
my $startmenudir = "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs";

my $eclipseDir = "C:\\Program Files\\Schlumberger\\Eclipse 2017.2 (r234070)\\bin64";

sub install {
  #thanks, creator of python 2.7 package. second argument is whether or not it's okay if the command fails
  my @installCommands = (
    ["\"$appdeploy_path\\PC\\RuntimeEnvironment\\VC2012\\vcredist_x64.exe\" /S /v/qn", 0],
	["msiexec.exe /quiet /i \"$appdeploy_path\\PC\\ECLRUN\\SimulationRuntime_Installer.msi\"", 0],
    ["msiexec.exe /quiet /i \"$appdeploy_path\\PC\\ECLIPSE\\ECLIPSE_Installer.msi\"", 0],
    
  );

  my $success = 0;
  my $allDone = 1;

  output("Installing Eclipse 2017.1... \n");

  for (my $i = 0; $i &lt; scalar @installCommands; $i++) {
    output("\t" . $installCommands[$i][0] . ": ");
    if ($i == 2)
    {
      $success = run_command($installCommands[$i][0], 'IgnoreExitCodes'=&gt;[1]);
    }
    else
    {
      $success = run_command($installCommands[$i][0]);
    }
    output($success ? "Done!\n" : "FAILED: $!\n");
    $allDone &amp;&amp;= $installCommands[$i][1] || $success;
  }

  if ($allDone) {
    output("Looks like it was a success!\n");
  }
  else {
    output("Something went wrong!\n");
  }

  return $allDone;
}


sub postInstall {
    output("\nSetting License Environment Variable...\n");
    my $license_var = $ENV{'SLBSLS_LICENSE_FILE'};
    my $server = "1724\@schlumberger-hw.lic.mst.edu";
    if(!defined($license_var)) {
        run_command("setx /m SLBSLS_LICENSE_FILE \"$server\"");
    } elsif ($license_var !~ /$server/) {
        run_command("setx /m SLBSLS_LICENSE_FILE \"$server;\%SLBSLS_LICENSE_FILE\%\"");
    }

    return 1;
}


do_install(
  allowed_versions =&gt; [OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  no_source_files =&gt; 1,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postInstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\schlumberger.2017\Merak\update.pl</FullName>
    <Length>3358</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-12-06T13:50:59.4927458-06:00</CreationTime>
    <CreationTimeUtc>2017-12-06T19:50:59.4927458Z</CreationTimeUtc>
    <LastWriteTime>2018-02-02T11:20:52.884454-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-02-02T17:20:52.884454Z</LastWriteTimeUtc>
    <LastAccessTime>2017-12-13T15:09:33.7471402-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-12-13T21:09:33.7471402Z</LastAccessTimeUtc>
    <Text># Merak 2017.1 - wellbore information aggregate
# Package generated with GenGen on 2017-DEC-11 15:52
# Packaged by Kele Shi

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
      package_id =&gt; 'Merak.2017_1',
      package_revision =&gt; '20171211T1552',
  );
}

# Add InstallMonkey Library to the path
use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use Getopt::Long;
use InstallMonkey::Shared;

GetOptions(
  'uninstall' =&gt; sub { exit(!uninstall()); },
);

my $appdeploy_path = "\\\\minerfiles.mst.edu\\dfs\\software\\appdeploy\\schlumberger.2017\\Merak 2017.1";
my $allUsersDesktop = get_allusers_desktop();
my $allUsersStartmenu = get_allusers_start_menu();
my $startmenudir = "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs";

my $merakDir = "C:\\Program Files\\Schlumberger\\Merak 2017.2 (r234070)\\bin64";

sub install {
  #thanks, creator of python 2.7 package. second argument is whether or not it's okay if the command fails
  my @installCommands = (
    ["msiexec.exe /quiet /i \"$appdeploy_path\\Merak\\Install\\Merak 2017.1.msi\"", 0],
    ["msiexec.exe /quiet /i \"$appdeploy_path\\MerakService\\Install\\MerakService.msi\"", 0],
	["msiexec.exe /quiet /i \"$appdeploy_path\\Peep Model Visualizer\\Merak_Peep_Model_Visualizer.msi\"", 0],
	["msiexec.exe /quiet /i \"$appdeploy_path\\Merak_Fiscal_Model_Library.msi\"", 0],    
  );

 

  my $success = 0;
  my $allDone = 1;

  output("Installing Merak 2017.1... \n");

  for (my $i = 0; $i &lt; scalar @installCommands; $i++) {
    output("\t" . $installCommands[$i][0] . ": ");
    if ($i == 2)
    {
      $success = run_command($installCommands[$i][0], 'IgnoreExitCodes'=&gt;[1]);
    }
    else
    {
      $success = run_command($installCommands[$i][0]);
    }
    output($success ? "Done!\n" : "FAILED: $!\n");
    $allDone &amp;&amp;= $installCommands[$i][1] || $success;
  }

  if ($allDone) {
    output("Looks like it was a success!\n");
  }
  else {
    output("Something went wrong!\n");
  }

  return $allDone;
}


sub postInstall {
    output("\nSetting License Environment Variable...\n");
    my $license_var = $ENV{'SLBSLS_LICENSE_FILE'};
    my $server = "1724\@schlumberger-hw.lic.mst.edu;1724\@schlumberger-eth.lic.mst.edu";
    if(!defined($license_var)) {
        run_command("setx /m SLBSLS_LICENSE_FILE \"$server\"");
    } elsif ($license_var !~ /$server/) {
        run_command("setx /m SLBSLS_LICENSE_FILE \"$server;\%SLBSLS_LICENSE_FILE\%\"");
    }

    return 1;
}


do_install(
  allowed_versions =&gt; [OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  no_source_files =&gt; 1,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postInstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\schlumberger.2017\Ocean\update.pl</FullName>
    <Length>3443</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-12-07T16:19:37.4242529-06:00</CreationTime>
    <CreationTimeUtc>2017-12-07T22:19:37.4242529Z</CreationTimeUtc>
    <LastWriteTime>2018-01-04T13:55:59.9881667-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-04T19:55:59.9881667Z</LastWriteTimeUtc>
    <LastAccessTime>2017-12-07T16:19:37.4242529-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-12-07T22:19:37.4242529Z</LastAccessTimeUtc>
    <Text># Ocean 2017 - Plugins for Petrel and other software
# Package generated with GenGen on 2016-Apr-15 16:00
# Packaged by Chris Schaaf

#Must be installed AFTER Petrel, otherwise will fail

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
      package_id =&gt; 'ocean.2017',
      package_revision =&gt; '20171207T1600',
  );
}

# Add InstallMonkey Library to the path
use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use Getopt::Long;
use InstallMonkey::Shared;

GetOptions(
  'uninstall' =&gt; sub { exit(!uninstall()); },
);

my $appdeploy_path = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\schlumberger.2017\\ocean 2017";
my $allUsersDesktop = get_allusers_desktop();
my $allUsersStartmenu = get_allusers_start_menu();
my $startmenudir = "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs";
my $logs = "C:\\Windows\\System32\\UMRInst\\AppLogs";


sub install {
  #thanks, creator of python 2.7 package. second argument is whether or not it's okay if the command fails
  my @installCommands = (
    ["\"$appdeploy_path\\Ocean_for_Petrel_Installer_2017.exe\" /S /v/qn", 0],    
    
  );


  my $success = 0;
  my $allDone = 1;

  output("Installing Ocean 2017... \n");

  for (my $i = 0; $i &lt; scalar @installCommands; $i++) {
    output("\t" . $installCommands[$i][0] . ": ");
    $success = run_command($installCommands[$i][0]);
    output($success ? "Done!\n" : "FAILED: $!\n");
    $allDone &amp;&amp;= $installCommands[$i][1] || $success;

    if (!$allDone) {
      output("\nSomething went wrong!\n");

      return 0;
    }
  }

  output("\nLooks like it was a success!\n");

  return $allDone;
}


sub postInstall {
    output("\nSetting License Environment Variable...\n");
    my $license_var = $ENV{'SLBSLS_LICENSE_FILE'};
    my $server = "1724\@schlumberger-hw.lic.mst.edu";
    if(!defined($license_var)) {
        run_command("setx /m SLBSLS_LICENSE_FILE \"$server\"");
    } elsif ($license_var !~ /$server/) {
        run_command("setx /m SLBSLS_LICENSE_FILE \"$server;\%SLBSLS_LICENSE_FILE\%\"");
    }
	my $iconSuccess = 0;
	#Delete icons in every user's Desktop folder (excluding Default). Thanks, StackOverflow
	opendir(DIR, 'C:\\Users');
	my @users = grep { (!/^\.\.?$/) &amp;&amp; (-d "C:\\Users\\$_") &amp;&amp; ($_ ne 'Default') } readdir(DIR);
	closedir(DIR);

	foreach my $place (@users) {
		$iconSuccess += run_command("DEL /Q \"C:\\Users\\$place\\Desktop\\Ocean 2017 Help.lnk\"");
	}

	output($iconSuccess ? "$iconSuccess desktop icon(s) were removed.\n"
					  : "Did not remove any desktop icons.\n");
    return 1;
}


do_install(
  allowed_versions =&gt; [OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  no_source_files =&gt; 1,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postInstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update-components.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\schlumberger.2017\Petrel\update-components.pl</FullName>
    <Length>8286</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-01-25T11:04:24.3662048-06:00</CreationTime>
    <CreationTimeUtc>2018-01-25T17:04:24.3662048Z</CreationTimeUtc>
    <LastWriteTime>2018-01-25T11:04:24.3974428-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-25T17:04:24.3974428Z</LastWriteTimeUtc>
    <LastAccessTime>2018-01-25T11:04:24.3662048-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-01-25T17:04:24.3662048Z</LastAccessTimeUtc>
    <Text># Petrel 2017.1
# Package Created Dec 7, 2017
# Packaged by Chris Schaaf


=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;
use Getopt::Long;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'petrel.2017_1',
        package_revision =&gt; '20171207T1500',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $appdeploy_path = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\schlumberger.2017\\Petrel 2017";

GetOptions(
    'uninstall' =&gt; sub { exit ( !uninstall());},
);

sub uninstall
{
    output("Uninstalling Petrel 2017.1: ");

    my $success = run_command("msiexec.exe /qn /x \"$appdeploy_path\\Petrel\\Petrel 2017 (64-bit).msi\"");

    output(($success ? "OK\n" : "Failed\n"));

    if($success)
    {
        delete_product_registry_key(get_package_id());
    }
}


sub install
{
	my @disable_perm_cmds = (
		"REG ADD \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones\\3\" /V \"1806\" /T \"REG_DWORD\" /D \"00000000\" /F",
		"REG ADD \"HKLM\\SOFTWARE\\Policies\\Microsoft\\Internet Explorer\\Security\" /V \"DisableSecuritySettingsCheck\" /T \"REG_DWORD\" /D \"00000001\" /F",
		"REG ADD \"HKLM\\SOFTWARE\\Policies\\Microsoft\\Internet Explorer\\Security\" /V \"DisableSecuritySettingsCheck\" /T \"REG_DWORD\" /D \"00000001\" /F"
	);

	my @enable_perm_cmds = (
		"REG ADD \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones\\3\" /V \"1806\" /T \"REG_DWORD\" /D \"00000001\" /F",
		"REG ADD \"HKLM\\SOFTWARE\\Policies\\Microsoft\\Internet Explorer\\Security\" /V \"DisableSecuritySettingsCheck\" /T \"REG_DWORD\" /D \"00000000\" /F",
		"REG ADD \"HKLM\\SOFTWARE\\Policies\\Microsoft\\Internet Explorer\\Security\" /V \"DisableSecuritySettingsCheck\" /T \"REG_DWORD\" /D \"00000000\" /F"
	);

	foreach my $cmd (@disable_perm_cmds){
		(return 0 &amp;&amp; output(":: PERMISSION COMMAND \"$cmd\" FAILED\n")) unless run_command($cmd);
	}

	#thanks, creator of python 2.7 package. second argument is whether or not it's okay if the command fails
	#PetrelPlatformInstaller has no way to suppress reboot, rebuilding install order&amp;args from the logs it created on attempted silent run.
	#my @installCommands = (
	#	["\"$appdeploy_path\\RuntimeEnvironment\\SQLSysClrTypes.msi\" ARPSYSTEMCOMPONENT=1 MSIFASTINSTALL=7 REBOOT=ReallySuppress CURRENTDIRECTORY=K:\win10\appdist\schlumberger.2017\Petrel CLIENTUILEVEL=3 MSICLIENTUSESEXTERNALUI=1 CLIENTPROCESSID=6008", 0],
	#	["\"$appdeploy_path\\SdiDriver\\SDI APS x64.msi\" MSIFASTINSTALL=7 REBOOT=ReallySuppress CURRENTDIRECTORY=C:\WINDOWS\SysWOW64 CLIENTUILEVEL=3 MSICLIENTUSESEXTERNALUI=1 CLIENTPROCESSID=4920", 0],
	#	["\"$appdeploy_path\\Petrel\\Petrel 2017 (64-bit).msi\" ARPSYSTEMCOMPONENT=1 MSIFASTINSTALL=7 INSTALLDIR=C:\Program Files\Schlumberger\Petrel 2017 PETRELOPTIMIZATIONPROP=0 APPDATAROAMING=C:\Users\t-cts28d\AppData\Roaming REBOOT=ReallySuppress CURRENTDIRECTORY=C:\WINDOWS\SysWOW64 CLIENTUILEVEL=3 MSICLIENTUSESEXTERNALUI=1 CLIENTPROCESSID=4920", 0],
	#	["\"$appdeploy_path\\PetrelHelp\\Petrel 2017 Help.msi\" ARPSYSTEMCOMPONENT=1 MSIFASTINSTALL=7 APPDATAROAMING=C:\Users\t-cts28d\AppData\Roaming REBOOT=ReallySuppress CURRENTDIRECTORY=C:\WINDOWS\SysWOW64 CLIENTUILEVEL=3 MSICLIENTUSESEXTERNALUI=1 CLIENTPROCESSID=4920", 0],
	#	["\"$appdeploy_path\\PetrelHelp\\Petrel 2017 Manuals.msi\" ARPSYSTEMCOMPONENT=1 MSIFASTINSTALL=7 REBOOT=ReallySuppress CURRENTDIRECTORY=C:\WINDOWS\SysWOW64 CLIENTUILEVEL=3 MSICLIENTUSESEXTERNALUI=1 CLIENTPROCESSID=4920", 0],
	#	["\"$appdeploy_path\\Intersect Connector\\Petrel 2017 INTERSECT Connector.msi\" ARPSYSTEMCOMPONENT=1 MSIFASTINSTALL=7 IXVERSION=2017 REBOOT=ReallySuppress CURRENTDIRECTORY=C:\WINDOWS\SysWOW64 CLIENTUILEVEL=3 MSICLIENTUSESEXTERNALUI=1 CLIENTPROCESSID=4920", 0],
	#	["\"$appdeploy_path\\PlugIns\\Artifacts\\GPM_Installer.msi\" ARPSYSTEMCOMPONENT=1 MSIFASTINSTALL=7 PETRELINSTALLLOCATION=C:\Program Files\Schlumberger\Petrel 2017 REBOOT=ReallySuppress CURRENTDIRECTORY=C:\WINDOWS\SysWOW64 CLIENTUILEVEL=3 MSICLIENTUSESEXTERNALUI=1 CLIENTPROCESSID=4920", 0],
	#	["\"$appdeploy_path\\PlugIns\\Artifacts\\GRM_17.1.0.0_x64.msi\" ARPSYSTEMCOMPONENT=1 MSIFASTINSTALL=7 REBOOT=ReallySuppress CURRENTDIRECTORY=C:\WINDOWS\SysWOW64 CLIENTUILEVEL=3 MSICLIENTUSESEXTERNALUI=1 CLIENTPROCESSID=4920", 0],
	#);
	my @installCommands = (
		# Windows/VC prerequisites
		# ["\"$appdeploy_path\\RuntimeEnvironment\\Windows6.1-KB2533623-x64.msu\" /quiet /norestart", 0],
		["\"$appdeploy_path\\RuntimeEnvironment\\\\VC2008\\vcredist__2008_ATL_x86.exe\" /q", 0],
		["\"$appdeploy_path\\RuntimeEnvironment\\\\VC2008\\vcredist_x64.exe\" /q", 0],
		["\"$appdeploy_path\\RuntimeEnvironment\\\\VC2008\\vcredist_x86.exe\" /q", 0],
		["\"$appdeploy_path\\RuntimeEnvironment\\\\VC2010\\vcredist_x64.exe\" /quiet /norestart", 0],
		["\"$appdeploy_path\\RuntimeEnvironment\\\\VC2010\\vcredist_x86.exe\" /quiet /norestart", 0],
		["\"$appdeploy_path\\RuntimeEnvironment\\\\VC2012U4\\vcredist_x64.exe\" /quiet /norestart", 0],
		["\"$appdeploy_path\\RuntimeEnvironment\\\\VC2012U4\\vcredist_x86.exe\" /quiet /norestart", 0],
		["\"$appdeploy_path\\RuntimeEnvironment\\\\VC2015\\vcredist_x64.exe\" /quiet /norestart", 1],
	
		["\"$appdeploy_path\\RuntimeEnvironment\\SQLSysClrTypes.msi\" /qn /norestart", 0],
		["\"$appdeploy_path\\SdiDriver\\SDI APS x64.msi\" /qn /norestart", 0],
		["\"$appdeploy_path\\Petrel\\Petrel 2017 (64-bit).msi\" /qn /norestart", 1],
		["\"$appdeploy_path\\PetrelHelp\\Petrel 2017 Help.msi\" /qn /norestart", 0],
		["\"$appdeploy_path\\PetrelHelp\\Petrel 2017 Manuals.msi\" /qn /norestart", 0],
		["\"$appdeploy_path\\Intersect Connector\\Petrel 2017 INTERSECT Connector.msi\" /qn /norestart", 0],
		["\"$appdeploy_path\\PlugIns\\Artifacts\\GPM_Installer.msi\" /qn /norestart", 0],
		["\"$appdeploy_path\\PlugIns\\Artifacts\\GRM_17.1.0.0_x64.msi\" /qn /norestart", 0],
		
		["\"$appdeploy_path\\PlugIns\\REM-X_Installer_2017.1.msi\" /qn /norestart", 0],
		["\"$appdeploy_path\\PlugIns\\RokDocQIPluginInstaller.msi\" /qn /norestart", 0],
		["\"$appdeploy_path\\GuruContentManager\\GuruContentManager.msi\" /qn /norestart", 0],
		
	);
	
	my $success = 0;
	my $allDone = 1;

	output("Installing Petrel 2017... \n");

	for (my $i = 0; $i &lt; scalar @installCommands; $i++) {
		output("\t" . $installCommands[$i][0] . ": ");
		if ($i == 2) {
			$success = run_command($installCommands[$i][0], 'IgnoreExitCodes'=&gt;[1]);
		}
		else {
			$success = run_command($installCommands[$i][0]);
		}
		output($success ? "Done!\n" : "FAILED: $!\n");
		$allDone &amp;&amp;= $installCommands[$i][1] || $success;
	}

	if ($allDone) {
		output("Looks like it was a success!\n");
	}
	else {
		output("Something went wrong!\n");
	}

	foreach my $cmd (@enable_perm_cmds){
		(return 0 &amp;&amp; output(":: PERMISSION COMMAND \"$cmd\" FAILED\n")) unless run_command($cmd);
	}

	return $allDone;  
}

sub postinstall
{
    output("\nSetting License Environment Variable...\n");
    my $license_var = $ENV{'SLBSLS_LICENSE_FILE'};
    my $server = "1724\@schlumberger-hw.lic.mst.edu";
    if(!defined($license_var)) {
        run_command("setx /m SLBSLS_LICENSE_FILE \"$server\"");
    } elsif ($license_var !~ /$server/) {
        run_command("setx /m SLBSLS_LICENSE_FILE \"$server;\%SLBSLS_LICENSE_FILE\%\"");
    }

    return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    no_source_files =&gt; 1,
    exit_on_failure =&gt; 1,
    # preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    # msi_name =&gt; 'installer.msi',
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\schlumberger.2017\Petrel\update.pl</FullName>
    <Length>7011</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-12-07T14:52:10.0844842-06:00</CreationTime>
    <CreationTimeUtc>2017-12-07T20:52:10.0844842Z</CreationTimeUtc>
    <LastWriteTime>2018-07-17T10:23:33.8642472-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-17T15:23:33.8642472Z</LastWriteTimeUtc>
    <LastAccessTime>2018-01-24T16:42:45.2608695-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-01-24T22:42:45.2608695Z</LastAccessTimeUtc>
    <Text># Petrel 2017.1
# Package Created Winter 2018
# Packaged by Alex Schrimpf


=pod

Begin-Doc
Modified:
Name:
Type:
Description:
Language: Perl
LastUpdatedBy:
Version:
Doc-Package-Info
Doc-SVN-Repository:
RCSId:
End-Doc

=cut

use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'petrel.2017_1',
        package_revision =&gt; '',
    );
}

use lib ( '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 'C:\temp' );

use InstallMonkey::Shared;

my $appdeploy_path = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\schlumberger.2017\\Petrel 2017";

use IM_helper(
    \%INSTALLMONKEY_OPTIONS,
    v4.04,
    (
    	"TOGGLE_SECURITY" =&gt; [
    		sub{

				my %security_keys = (
					'HKEY_CURRENT_USER/Software/Microsoft/Windows/CurrentVersion/Internet Settings/Zones/3' =&gt; '1806',
					'HKEY_LOCAL_MACHINE/Software/Microsoft/Windows/CurrentVersion/Internet Settings/Zones/3' =&gt; '1806',
				);

				while(my ($key,$value) = each %security_keys){
					IM_helper::get_reg_value_data(
						key=&gt;$key,
						value=&gt;$value,
						succ_cb=&gt;sub{
							my $value_data = {@_}-&gt;{results};
							if(defined $value_data){
								IM_helper::set_reg_key_values(
									key=&gt;$key,
									values=&gt;[
										$value=&gt;[
											('0x0000000'.(!$value_data)),
											'REG_DWORD'
										]
									]
								);
							}
						}
					);
				}
				return 1;
    		}
    	],

    	"PREREQS" =&gt; [
			sub{

				my @vcredists = (
					"start /wait \"\" \"$appdeploy_path\\RuntimeEnvironment\\VC2008\\vcredist__2008_ATL_x86.exe\" /q /norestart",
					"start /wait \"\" \"$appdeploy_path\\RuntimeEnvironment\\VC2008\\vcredist_x64.exe\" /q /norestart",
					"start /wait \"\" \"$appdeploy_path\\RuntimeEnvironment\\VC2008\\vcredist_x86.exe\" /q /norestart",
					"start /wait \"\" \"$appdeploy_path\\RuntimeEnvironment\\VC2010\\vcredist_x64.exe\" /quiet /norestart",
					"start /wait \"\" \"$appdeploy_path\\RuntimeEnvironment\\VC2010\\vcredist_x86.exe\" /quiet /norestart",
					"start /wait \"\" \"$appdeploy_path\\RuntimeEnvironment\\VC2012U4\\vcredist_x64.exe\" /quiet /norestart",
					"start /wait \"\" \"$appdeploy_path\\RuntimeEnvironment\\VC2012U4\\vcredist_x86.exe\" /quiet /norestart",
					"start /wait \"\" \"$appdeploy_path\\RuntimeEnvironment\\VC2015\\vc_redist.x64.exe\" /quiet /norestart",
				);

				foreach my $installer (@vcredists){
					# Ignore whether command succeeds in case a timeout occurs.
					IM_helper::run_command(
					  command=&gt;$installer,
					  # Timeout after 3 Minutes. I had to do this because if there is a newer version of vc_redist installed the installer will error out and hang on a dialogue box.
					  # I'm not sure of a better way to handle this other than hard coding checking for newer vc_redis versions.
					  # From my testing installing each of these typically takes less than 20 seconds so 3 min should be sufficient.
					  timeout=&gt;(3*60)
					);
				}

				return 1;
			},
			sub{
				IM_helper::run_command(
					command=&gt;"start /wait \"\" \"$appdeploy_path\\RuntimeEnvironment\\SQLSysClrTypes.msi\" /qn /norestart"
				);
			},
			sub{
				IM_helper::run_command(
					command=&gt;"start /wait \"\" \"$appdeploy_path\\SdiDriver\\SDI APS x64.msi\" /qn /norestart"
				);
			}
    	],

        "INSTALL" =&gt; [
            sub {
                IM_helper::run_command(
                    description =&gt; 'Main Petrel Installer',
                    command =&gt; "\"$appdeploy_path\\Petrel\\Petrel 2017 (64-bit).msi\" /qn /norestart"
                );
            },
            sub {
                IM_helper::run_command(
                    description =&gt; 'Petrel Help Installer',
                    command =&gt; "\"$appdeploy_path\\PetrelHelp\\Petrel 2017 Help.msi\" /qn /norestart"
                );
            },
            sub {
                IM_helper::run_command(
                    description =&gt; 'Petrel Manuals Installer',
                    command =&gt; "\"$appdeploy_path\\PetrelHelp\\Petrel 2017 Manuals.msi\" /qn /norestart"
                );
            },
            sub {
                IM_helper::run_command(
                    description =&gt; 'Petrel Intersect Connector Installer',
                    command =&gt; "\"$appdeploy_path\\Intersect Connector\\Petrel 2017 INTERSECT Connector.msi\" /qn /norestart"
                );
            },
            sub {
                IM_helper::run_command(
                    description =&gt; 'Petrel Guru Content Manager Installer',
                    command =&gt; "\"$appdeploy_path\\GuruContentManager\\GuruContentManager.msi\" /qn /norestart"
                );
            },
            #New licesne stuff
           sub {
               IM_helper::run_command(
                   description =&gt; 'System Center Viewer',
                   command =&gt; "\"$appdeploy_path\\System center viewer\\System Center Viewer.msi\" /qn /norestart"
               );
           },
            sub {
              IM_helper::run_command(
                 description =&gt; 'Blueback Project Tracker',
                 command =&gt; "\"$appdeploy_path\\Tracker_6.2.0_2017_64bit MSI\\Crawler and plug-in installer\\Blueback Project Tracker 6.2.0.297+aabadf1 for Petrel 2017.msi\" /qn /norestart"
              );
            }



        ],

        "LICENSE" =&gt;[
        	sub{
        		IM_helper::push_to_system_var(
        			name=&gt;'SLBSLS_LICENSE_FILE',
        			value=&gt;"1724\@schlumberger-hw.lic.mst.edu"
        		);
        	}
        ],

        "UNINSTALL" =&gt; [
	        sub{
				my @uninstall_display_names = (
					"Petrel 2017 (64-bit)",
					"Petrel 2017 Manuals",
					"Petrel 2017 IXConnector",
					"Petrel 2017 Help",
					"Guru Content Manager 2017",
					"SDI Drivers"
				);

				foreach my $display_name (@uninstall_display_names){
					IM_helper::uninstall_using_programs_and_features(
	                	display_name=&gt; $display_name
	            	);
	            }
	            return	1;
	        },
	        sub {
	            delete_product_registry_key(get_package_id());
	        },
       	]

    )
);

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt;
      [ 'clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    no_source_files =&gt; 1,
    no_install_check =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    no_product_key =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    install_sub =&gt;
	    $IM_helper::exec_call_stack_override
	    ||
	    sub{
	    	IM_helper::exec_call_stacks(
	    		ids=&gt;["TOGGLE_SECURITY","PREREQS","INSTALL","TOGGLE_SECURITY","LICENSE"]
	    	)
	    }
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\schlumberger.2017\Techlog\update.pl</FullName>
    <Length>3675</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-12-11T15:19:56.7305354-06:00</CreationTime>
    <CreationTimeUtc>2017-12-11T21:19:56.7305354Z</CreationTimeUtc>
    <LastWriteTime>2018-01-29T15:55:26.0934548-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-29T21:55:26.0934548Z</LastWriteTimeUtc>
    <LastAccessTime>2017-12-11T15:19:56.7305354-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-12-11T21:19:56.7305354Z</LastAccessTimeUtc>
    <Text># Techlog 2017.2 - wellbore information aggregate
# Package generated with GenGen on 2017-DEC-11 15:52
# Packaged by Grayson Gratop

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
      package_id =&gt; 'techlog.2017_2',
      package_revision =&gt; '20171211T1552',
  );
}

# Add InstallMonkey Library to the path
use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use Getopt::Long;
use InstallMonkey::Shared;

GetOptions(
  'uninstall' =&gt; sub { exit(!uninstall()); },
);

my $appdeploy_path = "\\\\minerfiles.mst.edu\\dfs\\software\\appdeploy\\schlumberger.2017\\Techlog 2017.2";
my $allUsersDesktop = get_allusers_desktop();
my $allUsersStartmenu = get_allusers_start_menu();
my $startmenudir = "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs";

my $techlogDir = "C:\\Program Files\\Schlumberger\\Techlog 2017.2 (r234070)\\bin64";

sub install {
  #thanks, creator of python 2.7 package. second argument is whether or not it's okay if the command fails
  my @installCommands = (
    ["\"$appdeploy_path\\Install Techlog 2017.2 (r234070) (64-bit).exe\" /Silent", 0],
	["setx /m SLBSLS_LICENSE_FILE \"techloglic;1724\@schlumberger-eth.lic.mst.edu;1724\@schlumberger-hw.lic.mst.edu", 0],
        
  );

  #that techloglic entry is there because techlog will somehow look in
  #C:\Program Files\Schlumberger\Techlog\bin64\&lt;server in SLBSLS_LICENSE_FILE&gt;
  #i don't know why it does this, but it needs to be there in every schlumberger
  #package so everyone plays nice

  my $success = 0;
  my $allDone = 1;

  output("Installing Techlog 2017.2... \n");

  for (my $i = 0; $i &lt; scalar @installCommands; $i++) {
    output("\t" . $installCommands[$i][0] . ": ");
    if ($i == 2)
    {
      $success = run_command($installCommands[$i][0], 'IgnoreExitCodes'=&gt;[1]);
    }
    else
    {
      $success = run_command($installCommands[$i][0]);
    }
    output($success ? "Done!\n" : "FAILED: $!\n");
    $allDone &amp;&amp;= $installCommands[$i][1] || $success;
  }

  if ($allDone) {
    output("Looks like it was a success!\n");
  }
  else {
    output("Something went wrong!\n");
  }

  return $allDone;
}


sub postInstall {
  my $iconSuccess = 0;

  #Delete icons in every user's Desktop folder (excluding Default). Thanks, StackOverflow
  opendir(DIR, 'C:\\Users');
  my @users = grep { (!/^\.\.?$/) &amp;&amp; (-d "C:\\Users\\$_") &amp;&amp; ($_ ne 'Default') } readdir(DIR);
  closedir(DIR);

  foreach my $place (@users) {
    $iconSuccess += run_command("DEL /Q \"C:\\Users\\$place\\Desktop\\Techlog64 2015.3.lnk\"");
	$iconSuccess += run_command("DEL /Q \"C:\\Users\\$place\\Desktop\\Techlog 2017.2 (r234070).lnk\"");
  }

  output($iconSuccess ? "$iconSuccess desktop icon(s) were removed.\n"
                      : "Did not remove any desktop icons.\n");

  return 1;
}


do_install(
  allowed_versions =&gt; [OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  no_source_files =&gt; 1,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postInstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\schlumberger.2017\Visage\update.pl</FullName>
    <Length>3831</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-12-11T16:21:50.9907244-06:00</CreationTime>
    <CreationTimeUtc>2017-12-11T22:21:50.9907244Z</CreationTimeUtc>
    <LastWriteTime>2018-01-03T14:12:53.033433-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-03T20:12:53.033433Z</LastWriteTimeUtc>
    <LastAccessTime>2017-12-11T17:03:08.643473-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-12-11T23:03:08.643473Z</LastAccessTimeUtc>
    <Text># Visgae 2017.2 - wellbore information aggregate
# Package generated with GenGen on 2017-DEC-11 15:52
# Packaged by Kele Shi

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
      package_id =&gt; 'Visage.2017_2',
      package_revision =&gt; '20171211T1552',
  );
}

# Add InstallMonkey Library to the path
use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use Getopt::Long;
use InstallMonkey::Shared;

GetOptions(
  'uninstall' =&gt; sub { exit(!uninstall()); },
);

my $appdeploy_path = "\\\\minerfiles.mst.edu\\dfs\\software\\appdeploy\\schlumberger.2017\\Visage 2017.2";
my $allUsersDesktop = get_allusers_desktop();
my $allUsersStartmenu = get_allusers_start_menu();
my $startmenudir = "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs";
my $applogs = get_applogs_dir();

my $visageDir = "C:\\Program Files\\Schlumberger\\Visage 2017.2 (r234070)\\bin64";

sub install {
  #thanks, creator of python 2.7 package. second argument is whether or not it's okay if the command fails
  my @installCommands = (
    ["\"$appdeploy_path\\2017.2_VISAGE_DVD\\PC\\RuntimeEnvironment\\VC2012\\vcredist_x64.exe\" /S /v/qn", 0],
    ["msiexec.exe /quiet /i \"$appdeploy_path\\2017.2_VISAGE_DVD\\PC\\VISAGE\\VISAGE_Installer.msi\"", 0],
	["msiexec.exe /quiet /i \"$appdeploy_path\\2017.2_VISAGE_DVD\\PC\\ECLRUN\\ECLRUN_Installer.msi\"", 0],
	["\"$appdeploy_path\\2017.2_VISAGE_DVD\\3rdparty\\PC\\resource\\IntelMPI\\w_mpi-rt_p_5.1.3.180.exe\" --silent -a install --eula=accept --output=\"C:\\temp.txt\"", 0],
    
  );

 

  my $success = 0;
  my $allDone = 1;

  output("Installing Visage 2017.2... \n");

  for (my $i = 0; $i &lt; scalar @installCommands; $i++) {
    output("\t" . $installCommands[$i][0] . ": ");
    if ($i == 2)
    {
      $success = run_command($installCommands[$i][0], 'IgnoreExitCodes'=&gt;[1]);
    }
    else
    {
      $success = run_command($installCommands[$i][0]);
    }
    output($success ? "Done!\n" : "FAILED: $!\n");
    $allDone &amp;&amp;= $installCommands[$i][1] || $success;
  }

  if ($allDone) {
    output("Looks like it was a success!\n");
  }
  else {
    output("Something went wrong!\n");
  }

  return $allDone;
}


sub postInstall {
	my $iconSuccess = 0; my $logsuccess = 0;
	#MPI installer doesn't like applogs (and won't run w/o output file), so move it now.
	$logsuccess = run_command("move \"C:\\temp.txt\" \"$applogs\\Visage-2017.2-MPI.txt\" /Y");
	output($logsuccess ? "Done!\n" : "FAILED: $!\n");
	#Delete icons in every user's Desktop folder (excluding Default). Thanks, StackOverflow
	opendir(DIR, 'C:\\Users');
	my @users = grep { (!/^\.\.?$/) &amp;&amp; (-d "C:\\Users\\$_") &amp;&amp; ($_ ne 'Default') } readdir(DIR);
	closedir(DIR);

	foreach my $place (@users) {
		$iconSuccess += run_command("DEL /Q \"C:\\Users\\$place\\Desktop\\Visage 2017.2.lnk\"");
	}

	output($iconSuccess ? "$iconSuccess desktop icon(s) were removed.\n"
					  : "Did not remove any desktop icons.\n");

	return 1;
}


do_install(
  allowed_versions =&gt; [OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  no_source_files =&gt; 1,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postInstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\SciFinder.webapp\prod\update.pl</FullName>
    <Length>1234</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-08-01T12:56:44.8194231-05:00</CreationTime>
    <CreationTimeUtc>2018-08-01T17:56:44.8194231Z</CreationTimeUtc>
    <LastWriteTime>2018-08-01T12:59:59.0573868-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-08-01T17:59:59.0573868Z</LastWriteTimeUtc>
    <LastAccessTime>2018-08-01T12:56:44.8194231-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-08-01T17:56:44.8194231Z</LastAccessTimeUtc>
    <Text># SketchUp Free
# Package Created 2018-08-01
# Packaged by Matthes, Alexander (S&amp;T-IT Employee)
# Last Updated --

BEGIN {
    %::INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'SciFinder.webapp',
        package_revision =&gt; '20180801T1259',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

sub install {
	output("Copying shortcut to start menu\n");
	if(!run_command("xcopy \"$srcfiles\\SciFinder.url\" \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\" /Y"))
    {
        output("Installation failed!\n");
        return 0;
    }
    
    output("Installation successful!");
    return 1;
}

do_install( 
    exit_on_failure =&gt; 1,
    allowed_versions          =&gt; [ OSVER_WIN10_SP0 ],
    allowed_os_architectures  =&gt; [ OSARCH_x64 ],
    allowed_regs              =&gt; [ "clc", "desktop", "traveling", "virtual-desktop", "virtual-clc" ],
    install_sub               =&gt; \&amp;install,

    
);

IM_Exit(EXIT_SUCCESS);

########################################################################</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\seismosignal.2016\prod\update.pl</FullName>
    <Length>1883</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-09T13:48:26.593679-05:00</CreationTime>
    <CreationTimeUtc>2017-06-09T18:48:26.593679Z</CreationTimeUtc>
    <LastWriteTime>2017-06-14T14:41:40.868794-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-14T19:41:40.868794Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-09T13:48:26.593679-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-09T18:48:26.593679Z</LastAccessTimeUtc>
    <Text># SeismoSignal 2016
# Package created 6/9/2017
# Packagd by Sergey Gruzdev
# Last edited 6/9/2017 by Sergey Gruzdev

use warnings;
use strict;

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'seismosignal.2016',
		package_revision =&gt; '20170609T1302',
	);
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

my $src = get_pkg_sourcefiles();

GetOptions('uninstall' =&gt; sub{exit(uninstall())});

sub uninstall
{
  # Uninstall via msiexec
  if(install_msi(app_id =&gt; "$src\\SeismoSignal 2016.msi", msi_action_flag =&gt; 'x'))
  {
    print "Uninstalled SeismoSignal 2016 successfully!\n";
    # Delete reg key
	print "Deleting product registry key...\n";
	delete_product_registry_key(get_package_name());
  }
  else
  {
    print "Error: failed to uninstall!\n";
	return 0;
  }
  print "Uninstallation complete!\n";
  return 1;
}

sub postinstall
{
  # Register licenses
  if(!run_command("regedit /s \"$src\\license.reg\""))
  {
    print "Error: could not register license.reg! Try again!\n";
	return 0;
  }
  print "License registered, postinstall complete!\n";
  return 1;
}

do_install
(
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'virtual-clc', 'virtual-desktop', 'traveling'],
  exit_on_failure =&gt; 1,
  msi_name =&gt; 'SeismoSignal 2016.msi',
  postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\sketchupfree.online\prod\update.pl</FullName>
    <Length>1244</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-07-13T08:39:13.5929235-05:00</CreationTime>
    <CreationTimeUtc>2018-07-13T13:39:13.5929235Z</CreationTimeUtc>
    <LastWriteTime>2018-07-13T10:07:59.9825788-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-13T15:07:59.9825788Z</LastWriteTimeUtc>
    <LastAccessTime>2018-07-13T08:39:13.5929235-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-07-13T13:39:13.5929235Z</LastAccessTimeUtc>
    <Text># SketchUp Free
# Package Created July 13, 2018
# Packaged by Matthes, Alexander (S&amp;T-IT Employee)
# Last Updated --

BEGIN {
    %::INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'sketchupfree.online',
        package_revision =&gt; '20180713T0838',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

sub install {
	output("Copying shortcut to start menu\n");
	if(!run_command("xcopy \"$srcfiles\\SketchUp Free.url\" \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\" /Y"))
    {
        output("Installation failed!\n");
        return 0;
    }
    
    output("Installation successful!");
    return 1;
}

do_install( 
    exit_on_failure =&gt; 1,
    allowed_versions          =&gt; [ OSVER_WIN10_SP0 ],
    allowed_os_architectures  =&gt; [ OSARCH_x64 ],
    allowed_regs              =&gt; [ "clc", "desktop", "traveling", "virtual-desktop", "virtual-clc" ],
    install_sub               =&gt; \&amp;install,

    
);

IM_Exit(EXIT_SUCCESS);

########################################################################</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\slammer.x\dev\update.pl</FullName>
    <Length>1463</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-06T14:07:58.3998035-05:00</CreationTime>
    <CreationTimeUtc>2017-06-06T19:07:58.3998035Z</CreationTimeUtc>
    <LastWriteTime>2017-06-13T09:46:20.5876318-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-13T14:46:20.5876318Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-06T14:07:58.3998035-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-06T19:07:58.3998035Z</LastAccessTimeUtc>
    <Text>
    # slammer
    # Package Created May 22, 2017
    # Packaged by Krueger, Benjamin (S&amp;T IT Student Employee)
    # Last Updated --

    BEGIN {
        %::INSTALLMONKEY_OPTIONS = (
            package_id =&gt; 'slammer.x',
            package_revision =&gt; '20170522T1456',
        );
    }

    use lib (
        '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
        $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
        'C:\temp',
    );
    use InstallMonkey::Shared;

    my $srcfiles = get_pkg_sourcefiles();
    my $log_dir = get_applogs_dir();

sub install {
    run_command("mkdir C:\\SLAMMER");
    run_command("xcopy C:\\SourceFiles\\slammer.x\\SLAMMER C:\\SLAMMER /s /e ");
    return 1;
}
sub postinstall {
    my $startdir = get_allusers_start_menu().'\\Programs\\Slammer';
    create_shortcut(
        'target' =&gt; "C:\\SLAMMER\\programs\\",
        'link'   =&gt; "${startdir}\\Slammer.lnk",
        'description' =&gt; 'Slammer dir link'
    );
}

    do_install( 
        exit_on_failure =&gt; 1,
        allowed_versions          =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
        allowed_os_architectures  =&gt; [ OSARCH_x64 ],
        allowed_regs              =&gt; [ "clc", "desktop", "traveling", "virtual-desktop", "virtual-clc" ],
        install_sub               =&gt; \&amp;install,
    );

    IM_Exit(EXIT_SUCCESS);

    ########################################################################
    </Text>
  </Script>
  <Script>
    <Name>template0.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\smart.11_4\dev\template0.pl</FullName>
    <Length>1090</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-05-25T13:32:56.1862471-05:00</CreationTime>
    <CreationTimeUtc>2017-05-25T18:32:56.1862471Z</CreationTimeUtc>
    <LastWriteTime>2017-05-25T13:32:56.1862471-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-05-25T18:32:56.1862471Z</LastWriteTimeUtc>
    <LastAccessTime>2017-05-25T13:32:56.1862471-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-05-25T18:32:56.1862471Z</LastAccessTimeUtc>
    <Text>
#Package Name: smart
#Packaged By: Alex Schrimpf
#Packaged On: 2017-4-25
#Last Updated: 2017-4-25

=pod

Comments: comments
Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
	%::INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'smart.11_4',
		package_revision =&gt; '2017425T1332',
	);
}

use lib (
'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
'C:\temp',
);

use InstallMonkey::Shared;
my $srcfiles = get_pkg_sourcefiles();

GetOptions(

	'install' =&gt; sub { },
		
	'postinstall' =&gt; sub {}    
);

sub install
{

	return 1;
}

sub postinstall
{

	return 1;
}

do_install(
    allowed_versions =&gt; [  OSVER_WIN10_SP0,  OSVER_WIN10_SP1  ],
    allowed_os_architectures =&gt; [  OSARCH_x64 ],
    allowed_regs =&gt; [  'clc',  'desktop' ],
    exit_on_failure =&gt; 1,

	install_sub =&gt; \&amp;install, 
		
	postinstall_sub =&gt; \&amp;postinstall
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>template1.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\smart.11_4\dev\template1.pl</FullName>
    <Length>1353</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-05-25T13:33:17.3558542-05:00</CreationTime>
    <CreationTimeUtc>2017-05-25T18:33:17.3558542Z</CreationTimeUtc>
    <LastWriteTime>2017-05-25T13:33:17.3558542-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-05-25T18:33:17.3558542Z</LastWriteTimeUtc>
    <LastAccessTime>2017-05-25T13:33:17.3558542-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-05-25T18:33:17.3558542Z</LastAccessTimeUtc>
    <Text>
#Package Name: smart
#Packaged By: Alex Schrimpf
#Packaged On: 2017-4-25
#Last Updated: 2017-4-25

=pod

Comments: comments
Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
	%::INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'smart.11_4',
		package_revision =&gt; '2017425T1332',
	);
}

use lib (
'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
'C:\temp',
);

use InstallMonkey::Shared;
my $srcfiles = get_pkg_sourcefiles();

GetOptions(

	'install' =&gt; sub { },
		
	'postinstall' =&gt; sub {}    
);

sub install
{

    if(!run_command("$srcfiles\\SMARTEducationSoftware.msi /q TRANSFORMS=\"MST_install.mst\""))
    {
        output("EXECUTION OF \"$srcfiles\\SMARTEducationSoftware.msi /q TRANSFORMS=\"MST_install.mst\"\" IN SUB \"install\" FAILED\n");
        return 0;
    }

	return 1;
}

sub postinstall
{

	return 1;
}

do_install(
    allowed_versions =&gt; [  OSVER_WIN10_SP0,  OSVER_WIN10_SP1  ],
    allowed_os_architectures =&gt; [  OSARCH_x64 ],
    allowed_regs =&gt; [  'clc',  'desktop' ],
    exit_on_failure =&gt; 1,

	install_sub =&gt; \&amp;install, 
		
	postinstall_sub =&gt; \&amp;postinstall
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>template2.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\smart.11_4\dev\template2.pl</FullName>
    <Length>1351</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-05-25T13:33:37.9014493-05:00</CreationTime>
    <CreationTimeUtc>2017-05-25T18:33:37.9014493Z</CreationTimeUtc>
    <LastWriteTime>2017-05-25T13:33:37.9014493-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-05-25T18:33:37.9014493Z</LastWriteTimeUtc>
    <LastAccessTime>2017-05-25T13:33:37.9014493-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-05-25T18:33:37.9014493Z</LastAccessTimeUtc>
    <Text>
#Package Name: smart
#Packaged By: Alex Schrimpf
#Packaged On: 2017-4-25
#Last Updated: 2017-4-25

=pod

Comments: comments
Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
	%::INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'smart.11_4',
		package_revision =&gt; '2017425T1332',
	);
}

use lib (
'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
'C:\temp',
);

use InstallMonkey::Shared;
my $srcfiles = get_pkg_sourcefiles();

GetOptions(

	'install' =&gt; sub { },
		
	'postinstall' =&gt; sub {}    
);

sub install
{

    if(!run_command("$srcfiles\\SMARTEducationSoftware.msi /q TRANSFORMS=\"MST_install.mst\"))
    {
        output("EXECUTION OF \"$srcfiles\\SMARTEducationSoftware.msi /q TRANSFORMS=\"MST_install.mst\\" IN SUB \"install\" FAILED\n");
        return 0;
    }

	return 1;
}

sub postinstall
{

	return 1;
}

do_install(
    allowed_versions =&gt; [  OSVER_WIN10_SP0,  OSVER_WIN10_SP1  ],
    allowed_os_architectures =&gt; [  OSARCH_x64 ],
    allowed_regs =&gt; [  'clc',  'desktop' ],
    exit_on_failure =&gt; 1,

	install_sub =&gt; \&amp;install, 
		
	postinstall_sub =&gt; \&amp;postinstall
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\smartgit.17_0_3\prod\update.pl</FullName>
    <Length>1408</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-07-06T12:27:56.0777913-05:00</CreationTime>
    <CreationTimeUtc>2017-07-06T17:27:56.0777913Z</CreationTimeUtc>
    <LastWriteTime>2017-07-06T12:36:13.1417145-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-07-06T17:36:13.1417145Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-06T12:27:56.0777913-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-06T17:27:56.0777913Z</LastAccessTimeUtc>
    <Text>BEGIN{
    %INSTALLMONKEY_OPTIONS =(
        package_id =&gt; "SmartGit.17_0_3",
        package_revision =&gt; "20170706T1230"
    )
}

use lib(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;
GetOptions('uninstall' =&gt; sub {exit(!uninstall());});

sub install {
    output("Runninng SmartGit Setup executable..\n");
    if(!run_command("".get_pkg_sourcefiles()."\\setup-17_0_3-jre.exe /VERYSILENT"))
    {
        output("SmartGit installation failed.\n");
        return 0;
    }
    return 1;
}

sub postinstall
{
    #get rid of the icon.
     run_command('DEL "C:\\Users\\Public\\Desktop\\SmartGit.lnk"');
     my $shortcutdir = get_allusers_start_menu().'\SmartGit';
    return 1;   
}
do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1,OSVER_WIN8_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64,OSARCH_x86],
    allowed_regs =&gt; ['desktop','virtual-desktop','traveling','clc','virtual-clc'],
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);
IM_Exit(EXIT_SUCCESS);
sub uninstall
{
    if(!run_command('"C:\Program Files (x86)\SmartGit\unins000.exe"'))
    {
        output("uninstall failed");
        return 0;
    }
    delete_product_registry_key(get_package_name().".".get_version());
    return 1;
}</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\smartgit.18_1_1\prod\update.pl</FullName>
    <Length>1467</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-22T13:29:23.7078731-05:00</CreationTime>
    <CreationTimeUtc>2018-05-22T18:29:23.7078731Z</CreationTimeUtc>
    <LastWriteTime>2018-05-22T13:44:21.0681817-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-22T18:44:21.0681817Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-22T13:29:23.7078731-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-22T18:29:23.7078731Z</LastAccessTimeUtc>
    <Text>

# Latest Update by Gavin Altermatt on 5/22/2018

BEGIN{
    %INSTALLMONKEY_OPTIONS =(
        package_id =&gt; "SmartGit.18_1_1",
        package_revision =&gt; "20182205T1332"
    )
}

use lib(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;
GetOptions('uninstall' =&gt; sub {exit(!uninstall());});

sub install {
    output("Runninng SmartGit Setup executable..\n");
    if(!run_command("".get_pkg_sourcefiles()."\\smartgit-18_1_1-setup.exe /VERYSILENT"))
    {
        output("SmartGit installation failed.\n");
        return 0;
    }
    return 1;
}

sub postinstall
{
    #get rid of the icon.
     run_command('DEL "C:\\Users\\Public\\Desktop\\SmartGit.lnk"');
     my $shortcutdir = get_allusers_start_menu().'\SmartGit';
    return 1;
}
do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1,OSVER_WIN8_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64,OSARCH_x86],
    allowed_regs =&gt; ['desktop','virtual-desktop','traveling','clc','virtual-clc'],
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);
IM_Exit(EXIT_SUCCESS);
sub uninstall
{
    if(!run_command('"C:\Program Files (x86)\SmartGit\unins000.exe"'))
    {
        output("uninstall failed");
        return 0;
    }
    delete_product_registry_key(get_package_name().".".get_version());
    return 1;
}
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\smartgit.7_1_3\prod\update.pl</FullName>
    <Length>1405</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-07-15T09:18:15.2658483-05:00</CreationTime>
    <CreationTimeUtc>2016-07-15T14:18:15.2658483Z</CreationTimeUtc>
    <LastWriteTime>2016-07-14T16:41:47.014767-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-07-14T21:41:47.014767Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-15T09:18:15.2658483-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-15T14:18:15.2658483Z</LastAccessTimeUtc>
    <Text>BEGIN{
    %INSTALLMONKEY_OPTIONS =(
        package_id =&gt; "SmartGit.7_3_1",
        package_revision =&gt; "73120160714T1623"
    )
}

use lib(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;
GetOptions('uninstall' =&gt; sub {exit(!uninstall());});

sub install {
    output("Runninng SmartGit Setup executable..\n");
    if(!run_command("".get_pkg_sourcefiles()."\\setup-7_1_3.exe /VERYSILENT"))
    {
        output("SmartGit installation failed.\n");
        return 0;
    }
    return 1;
}

sub postinstall
{
    #get rid of the icon.
     run_command('DEL "C:\\Users\\Public\\Desktop\\SmartGit.lnk"');
     my $shortcutdir = get_allusers_start_menu().'\SmartGit';
    return 1;   
}
do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1,OSVER_WIN8_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64,OSARCH_x86],
    allowed_regs =&gt; ['desktop','virtual-desktop','traveling','clc','virtual-clc'],
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);
IM_Exit(EXIT_SUCCESS);
sub uninstall
{
    if(!run_command('"C:\Program Files (x86)\SmartGit\unins000.exe"'))
    {
        output("uninstall failed");
        return 0;
    }
    delete_product_registry_key(get_package_name().".".get_version());
    return 1;
}</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\smartnotebook.11_4\prod\update.pl</FullName>
    <Length>3122</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-05-17T13:25:43.6752813-05:00</CreationTime>
    <CreationTimeUtc>2017-05-17T18:25:43.6752813Z</CreationTimeUtc>
    <LastWriteTime>2017-05-25T11:14:26.3588458-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-05-25T16:14:26.3588458Z</LastWriteTimeUtc>
    <LastAccessTime>2017-05-17T13:25:43.6752813-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-05-17T18:25:43.6752813Z</LastAccessTimeUtc>
    <Text>#Smart Notebook 11.4 update
# Package Created May 2017
# Packaged by Alex Schrimpf
# Last Updated 2017-05-18

=pod

Begin-Doc
Modified: $Date: 2017-05-16 9:40:42 -0600 (Thurs, 18 May 2017) $
Name: Smart Notebook 11.4 Installer
Type: script
Description: 
Comments: Loads the msi with a modified mst installer called MST_install.mst. This contains the settings such as license, automatic activation,etc...s
Language: Perl
LastUpdatedBy: $Author: Schrimpf $
Version: $Revision:  $
Doc-Package-Info: 
Doc-SVN-Repository: $URL:  $
RCSId: $Id: $
End-Doc

=cut

use strict;
use warnings;

use File::Path;
use File::Copy qw(move);

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'smartnotebook.11_4',
        package_revision =&gt; '20170516T1350',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;
my $srcfiles =  get_pkg_sourcefiles();

sub install {

    output("\nInstalling Smart Notebook 11.4...");
    if(!run_command("$srcfiles\\SMARTEducationSoftware.msi /q TRANSFORMS=\"MST_install.mst\""))
    {
        output("Failed to install Smart Notebook 11.4\n");
        return 0;
    }

    return 1;
}

sub postinstall
{
	#Update registry so it doesn't try to update
	use Win32::Registry;
	$main::HKEY_LOCAL_MACHINE-&gt;Open( "SOFTWARE\\WOW6432Node\\SMART Technologies\\Product Update",my $key)or die "Failed to find key";
	$key-&gt;SetValueEx('Mode',my $Reserved,&amp;REG_DWORD,2) or die "Failed to set key";

	#delete desktop shortcuts
	my $shortcut = "C:\\Users\\Public\\Desktop\\SMART Notebook 11.lnk";
	if(!unlink($shortcut)){
		output("Failed to delete notebook desktop shortcut");
		return 0;
	}

    $shortcut = "C:\\Users\\Public\\Desktop\\SMART Ink Document Viewer.lnk";
    if(!unlink($shortcut)){
        output("Failed to delete SMART Ink desktop shortcut");
        return 0;
    }

    #delete office folder
    my $folder = "C:\\Program Files (x86)\\SMART Technologies\\Education Software\\";

    if(!move $folder.'Office\\SMARTInk-SBSDKProxy.exe', $folder.'\\SMARTInk-SBSDKProxy.exe'){
        output("Failed to move SMART Ink Proxy application");
        return 0;
    }

    if(!rmtree $folder.'Office'){
        output("Failed to delete office folder");
        return 0;
    }

    if(!mkdir ($folder.'Office',755)){
        output("Failed to make office folder");
        return 0;
    }

    if(!move $folder.'\\SMARTInk-SBSDKProxy.exe', $folder.'Office\\SMARTInk-SBSDKProxy.exe'){
        output("Failed to move SMART Ink Proxy application");
        return 0;
    }

    return 1;
}

do_install( 
    allowed_versions =&gt; [ OSVER_WIN10_SP0  ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [ 'clc', 'desktop', 'traveling',
                      'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);
IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\software2deploy.8_9_2\prod\update.pl</FullName>
    <Length>2980</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-01-03T15:32:08.9225016-06:00</CreationTime>
    <CreationTimeUtc>2017-01-03T21:32:08.9225016Z</CreationTimeUtc>
    <LastWriteTime>2017-01-03T16:22:54.4637904-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-01-03T22:22:54.4637904Z</LastWriteTimeUtc>
    <LastAccessTime>2017-01-03T15:32:08.9225016-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-01-03T21:32:08.9225016Z</LastAccessTimeUtc>
    <Text># Software2 Deploy 8.9.2
# Created by Chris Schaaf

#Adds necessary files to machines designed for Software2 usage
#	Creates a shortcut on the desktop to http://softwarehub.mst.edu
#	Inserts the following registry keys:
#		a.	HKLM\Software\Software2\Hub\Environment
#		b.	HKLM\Software\Software2\Hub, RegSZ:SVORUO=1 
#		c.	HKLM\Software\Software2\Hub, RegSZ:SVOROS=1
#	Installs Application Jukebox Client

#Application Jukebox Player = Cloudpaging Player

=pod

Begin-Doc
Modified:
Name: software2deploy
Type: script
Description: see above
Language: Perl
RCSId:
Comments:

End-Doc

=cut

use strict;
use warnings;
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'software2deploy.8_9_2',
        package_revision =&gt; '20161229T1358',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use File::Spec;
use File::Basename;
use File::Path;
use File::Copy;
use Getopt::Long;
use Win32::Registry;
use Data::Dumper;

# All Variables (except success values):

my $src = get_pkg_sourcefiles();
my $desk = get_allusers_desktop();

################################################################################
################################################################################
sub preinstall {
	return 1;
}
################################################################################
################################################################################
sub install {
	output("\nInstalling Cloudpaging Player... ");
	if(!run_command("\"$src\\Application Jukebox Player x64.msi\" /qn")) {
		output("FAIL: $?\n");
		return 0;
	}
	output("OK\n");
	return 1;
}
################################################################################
################################################################################
sub postinstall {
	output("Performing registry changes... ");
	if(!run_command("regedit /s \"$src\\s2.reg\"")){
		output("FAIL: $?");
		return 0;
	}
	#I'm using the icon from the s2 hub website. It's only 32x32, might want to source
	#	a higher res one for the production run
	output("OK\nPlacing Shortcut... ");
	if(!run_command("copy \"$src\\Software Hub.url\" \"$desk\\Software Hub.url\"")){
		output("FAIL: $?\n");
		return 0;
	}
	output("OK\nDeleting Cloudpaging Player Shortcut... ");
	if(!run_command("del /F \"$desk\\Cloudpaging Player.lnk\"")) {
		output("FAIL: $?\n");
		return 0;
	}
	output("OK\n");
	return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    #preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);



</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\software2deploy.9_0_1\dev\update.pl</FullName>
    <Length>2980</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-04-20T13:37:42.3988335-05:00</CreationTime>
    <CreationTimeUtc>2017-04-20T18:37:42.3988335Z</CreationTimeUtc>
    <LastWriteTime>2017-03-22T10:04:00.6437841-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-03-22T15:04:00.6437841Z</LastWriteTimeUtc>
    <LastAccessTime>2017-04-20T13:37:42.3988335-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-04-20T18:37:42.3988335Z</LastAccessTimeUtc>
    <Text># Software2 Deploy 9.0.1
# Created by Chris Schaaf

#Adds necessary files to machines designed for Software2 usage
#	Creates a shortcut on the desktop to http://softwarehub.mst.edu
#	Inserts the following registry keys:
#		a.	HKLM\Software\Software2\Hub\Environment
#		b.	HKLM\Software\Software2\Hub, RegSZ:SVORUO=1 
#		c.	HKLM\Software\Software2\Hub, RegSZ:SVOROS=1
#	Installs Application Jukebox Client

#Application Jukebox Player = Cloudpaging Player

=pod

Begin-Doc
Modified:
Name: software2deploy
Type: script
Description: see above
Language: Perl
RCSId:
Comments:

End-Doc

=cut

use strict;
use warnings;
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'software2deploy.9.0.1',
        package_revision =&gt; '20170313T1100',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use File::Spec;
use File::Basename;
use File::Path;
use File::Copy;
use Getopt::Long;
use Win32::Registry;
use Data::Dumper;

# All Variables (except success values):

my $src = get_pkg_sourcefiles();
my $desk = get_allusers_desktop();

################################################################################
################################################################################
sub preinstall {
	return 1;
}
################################################################################
################################################################################
sub install {
	output("\nInstalling Cloudpaging Player... ");
	if(!run_command("\"$src\\Application Jukebox Player x64.msi\" /qn")) {
		output("FAIL: $?\n");
		return 0;
	}
	output("OK\n");
	return 1;
}
################################################################################
################################################################################
sub postinstall {
	output("Performing registry changes... ");
	if(!run_command("regedit /s \"$src\\s2.reg\"")){
		output("FAIL: $?");
		return 0;
	}
	#I'm using the icon from the s2 hub website. It's only 32x32, might want to source
	#	a higher res one for the production run
	output("OK\nPlacing Shortcut... ");
	if(!run_command("copy \"$src\\Software Hub.lnk\" \"$desk\\Software Hub.lnk\"")){
		output("FAIL: $?\n");
		return 0;
	}
	output("OK\nDeleting Cloudpaging Player Shortcut... ");
	if(!run_command("del /F \"$desk\\Cloudpaging Player.lnk\"")) {
		output("FAIL: $?\n");
		return 0;
	}
	output("OK\n");
	return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    #preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);



</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\software2deploy.9_0_1\prod\update.pl</FullName>
    <Length>2980</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-03-22T10:01:44.8899735-05:00</CreationTime>
    <CreationTimeUtc>2017-03-22T15:01:44.8899735Z</CreationTimeUtc>
    <LastWriteTime>2017-03-22T10:04:00.6437841-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-03-22T15:04:00.6437841Z</LastWriteTimeUtc>
    <LastAccessTime>2017-03-22T10:01:44.8899735-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-03-22T15:01:44.8899735Z</LastAccessTimeUtc>
    <Text># Software2 Deploy 9.0.1
# Created by Chris Schaaf

#Adds necessary files to machines designed for Software2 usage
#	Creates a shortcut on the desktop to http://softwarehub.mst.edu
#	Inserts the following registry keys:
#		a.	HKLM\Software\Software2\Hub\Environment
#		b.	HKLM\Software\Software2\Hub, RegSZ:SVORUO=1 
#		c.	HKLM\Software\Software2\Hub, RegSZ:SVOROS=1
#	Installs Application Jukebox Client

#Application Jukebox Player = Cloudpaging Player

=pod

Begin-Doc
Modified:
Name: software2deploy
Type: script
Description: see above
Language: Perl
RCSId:
Comments:

End-Doc

=cut

use strict;
use warnings;
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'software2deploy.9.0.1',
        package_revision =&gt; '20170313T1100',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use File::Spec;
use File::Basename;
use File::Path;
use File::Copy;
use Getopt::Long;
use Win32::Registry;
use Data::Dumper;

# All Variables (except success values):

my $src = get_pkg_sourcefiles();
my $desk = get_allusers_desktop();

################################################################################
################################################################################
sub preinstall {
	return 1;
}
################################################################################
################################################################################
sub install {
	output("\nInstalling Cloudpaging Player... ");
	if(!run_command("\"$src\\Application Jukebox Player x64.msi\" /qn")) {
		output("FAIL: $?\n");
		return 0;
	}
	output("OK\n");
	return 1;
}
################################################################################
################################################################################
sub postinstall {
	output("Performing registry changes... ");
	if(!run_command("regedit /s \"$src\\s2.reg\"")){
		output("FAIL: $?");
		return 0;
	}
	#I'm using the icon from the s2 hub website. It's only 32x32, might want to source
	#	a higher res one for the production run
	output("OK\nPlacing Shortcut... ");
	if(!run_command("copy \"$src\\Software Hub.lnk\" \"$desk\\Software Hub.lnk\"")){
		output("FAIL: $?\n");
		return 0;
	}
	output("OK\nDeleting Cloudpaging Player Shortcut... ");
	if(!run_command("del /F \"$desk\\Cloudpaging Player.lnk\"")) {
		output("FAIL: $?\n");
		return 0;
	}
	output("OK\n");
	return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    #preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);



</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\software2deploy.9_0_1\prod.old\update.pl</FullName>
    <Length>2980</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-03-13T10:53:57.441359-05:00</CreationTime>
    <CreationTimeUtc>2017-03-13T15:53:57.441359Z</CreationTimeUtc>
    <LastWriteTime>2017-03-13T10:55:33.4144046-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-03-13T15:55:33.4144046Z</LastWriteTimeUtc>
    <LastAccessTime>2017-03-13T10:53:57.441359-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-03-13T15:53:57.441359Z</LastAccessTimeUtc>
    <Text># Software2 Deploy 9.0.1
# Created by Chris Schaaf

#Adds necessary files to machines designed for Software2 usage
#	Creates a shortcut on the desktop to http://softwarehub.mst.edu
#	Inserts the following registry keys:
#		a.	HKLM\Software\Software2\Hub\Environment
#		b.	HKLM\Software\Software2\Hub, RegSZ:SVORUO=1 
#		c.	HKLM\Software\Software2\Hub, RegSZ:SVOROS=1
#	Installs Application Jukebox Client

#Application Jukebox Player = Cloudpaging Player

=pod

Begin-Doc
Modified:
Name: software2deploy
Type: script
Description: see above
Language: Perl
RCSId:
Comments:

End-Doc

=cut

use strict;
use warnings;
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'software2deploy.9.0.1',
        package_revision =&gt; '20170313T1100',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use File::Spec;
use File::Basename;
use File::Path;
use File::Copy;
use Getopt::Long;
use Win32::Registry;
use Data::Dumper;

# All Variables (except success values):

my $src = get_pkg_sourcefiles();
my $desk = get_allusers_desktop();

################################################################################
################################################################################
sub preinstall {
	return 1;
}
################################################################################
################################################################################
sub install {
	output("\nInstalling Cloudpaging Player... ");
	if(!run_command("\"$src\\Application Jukebox Player x64.msi\" /qn")) {
		output("FAIL: $?\n");
		return 0;
	}
	output("OK\n");
	return 1;
}
################################################################################
################################################################################
sub postinstall {
	output("Performing registry changes... ");
	if(!run_command("regedit /s \"$src\\s2.reg\"")){
		output("FAIL: $?");
		return 0;
	}
	#I'm using the icon from the s2 hub website. It's only 32x32, might want to source
	#	a higher res one for the production run
	output("OK\nPlacing Shortcut... ");
	if(!run_command("copy \"$src\\Software Hub.url\" \"$desk\\Software Hub.url\"")){
		output("FAIL: $?\n");
		return 0;
	}
	output("OK\nDeleting Cloudpaging Player Shortcut... ");
	if(!run_command("del /F \"$desk\\Cloudpaging Player.lnk\"")) {
		output("FAIL: $?\n");
		return 0;
	}
	output("OK\n");
	return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    #preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);



</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\software2shortcuts.1_0_0\prod\update.pl</FullName>
    <Length>2375</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-03-31T09:25:06.582076-05:00</CreationTime>
    <CreationTimeUtc>2017-03-31T14:25:06.582076Z</CreationTimeUtc>
    <LastWriteTime>2017-03-31T14:01:12.4196406-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-03-31T19:01:12.4196406Z</LastWriteTimeUtc>
    <LastAccessTime>2017-03-31T09:25:06.582076-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-03-31T14:25:06.582076Z</LastAccessTimeUtc>
    <Text># Software2 Deploy Desktop Shortcuts
# Created by Chris Schaaf


=pod

Begin-Doc
Modified:
Name: software2shortcut
Type: script
Description: see above
Language: Perl
RCSId:
Comments:

End-Doc

=cut

use strict;
use warnings;
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'software2shortcuts.1_0_0',
        package_revision =&gt; '20170331T1100',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use File::Spec;
use File::Basename;
use File::Path;
use File::Copy;
use Getopt::Long;
use Win32::Registry;
use Data::Dumper;

# All Variables (except success values):

my $src = get_pkg_sourcefiles();
my $desk = get_allusers_desktop();

################################################################################
################################################################################
sub preinstall {
    return 1;
}
################################################################################
################################################################################
sub install {
    return 1;
}
################################################################################
################################################################################
sub postinstall {

    #I'm using the icon from the s2 hub website. It's only 32x32, might want to source
    #    a higher res one for the production run
    output("OK\nPlacing Shortcut 1/2... ");
    if(!run_command("copy \"$src\\Software Hub Quickstart.url\" \"$desk\\Software Hub Quickstart.url\"")){
        output("FAIL: $?\n");
        return 0;
    }
    output("\nPlacing Shortcut 2/2... ");
    if(!run_command("copy \"$src\\Software Hub Survey.url\" \"$desk\\Software Hub Survey.url\"")){
        output("FAIL: $?\n");
        return 0;
    }
    output("\nDone!");
    return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    #preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);



</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\software2shortcuts.2_0_0\prod\update.pl</FullName>
    <Length>1799</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-07-20T10:18:54.7308929-05:00</CreationTime>
    <CreationTimeUtc>2017-07-20T15:18:54.7308929Z</CreationTimeUtc>
    <LastWriteTime>2018-03-22T12:52:42.448176-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-03-22T17:52:42.448176Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-20T10:18:54.7308929-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-20T15:18:54.7308929Z</LastAccessTimeUtc>
    <Text># Software2 Deploy Desktop Shortcuts
# Created by Chris Schaaf
# Updated by Austin Wall 2018-03-22


=pod

Begin-Doc
Modified:
Name: software2shortcut
Type: script
Description: see above
Language: Perl
RCSId:
Comments:

End-Doc

=cut

use strict;
use warnings;
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'software2shortcuts.2_0_0',
        package_revision =&gt; '20180322T1252',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use File::Spec;
use File::Basename;
use File::Path;
use File::Copy;
use Getopt::Long;
use Win32::Registry;
use Data::Dumper;

# All Variables (except success values):

my $src = get_pkg_sourcefiles();
my $desk = get_allusers_desktop();

################################################################################
################################################################################
sub install {

    output("OK\nPlacing Shortcut 1/2... ");
    if(!run_command("copy \"$src\\AppsAnywhere Getting Started.url\" \"$desk\\AppsAnywhere Getting Started.url\"")){
        output("FAIL: $?\n");
        return 0;
    }
    output("\nPlacing Shortcut 2/2... ");
    if(!run_command("copy \"$src\\AppsAnywhere Survey.url\" \"$desk\\AppsAnywhere Survey.url\"")){
        output("FAIL: $?\n");
        return 0;
    }
    output("\nDone!");
    return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\software2shortcuts.3_0_0\prod\update.pl</FullName>
    <Length>1437</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-07-27T15:23:39.8123249-05:00</CreationTime>
    <CreationTimeUtc>2018-07-27T20:23:39.8123249Z</CreationTimeUtc>
    <LastWriteTime>2018-07-27T15:25:13.0117645-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-27T20:25:13.0117645Z</LastWriteTimeUtc>
    <LastAccessTime>2018-07-27T15:23:39.8123249-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-07-27T20:23:39.8123249Z</LastAccessTimeUtc>
    <Text># Software2 Deploy Desktop Shortcuts
# Created by Austin Wall on 2018-07-27
# Updated by --

use strict;
use warnings;
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'software2shortcuts.3_0_0',
        package_revision =&gt; '20180727T1524',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use File::Spec;
use File::Basename;
use File::Path;
use File::Copy;
use Getopt::Long;
use Win32::Registry;
use Data::Dumper;

# All Variables (except success values):

my $src = get_pkg_sourcefiles();
my $desk = get_allusers_desktop();

################################################################################
################################################################################
sub install {

    output("OK\nPlacing Shortcut... ");
    if(!run_command("copy \"$src\\AppsAnywhere Getting Started.url\" \"$desk\\AppsAnywhere Getting Started.url\"")){
        output("FAIL: $?\n");
        return 0;
    }
    output("\nDone!");
    return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\solidcam.2015\prod\update.pl</FullName>
    <Length>3078</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-02-19T12:58:48.8905652-06:00</CreationTime>
    <CreationTimeUtc>2016-02-19T18:58:48.8905652Z</CreationTimeUtc>
    <LastWriteTime>2016-04-26T16:00:57.5768493-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-04-26T21:00:57.5768493Z</LastWriteTimeUtc>
    <LastAccessTime>2016-02-19T12:58:48.8905652-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-02-19T18:58:48.8905652Z</LastAccessTimeUtc>
    <Text># SolidCAM - "iMachining - The Revolution in CAM!"
# Packaged by Grayson Gratop on 2016-Feb-19 12:58

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
      package_id =&gt; 'solidcam.2015',
      package_revision =&gt; '20160219T1258',
  );
}

# Add InstallMonkey Library to the path
use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);

use InstallMonkey::Shared;

my $srcfilesdir = get_pkg_sourcefiles();
my $allUsersDesktop = get_allusers_desktop();
my $allUsersStartmenu = get_allusers_start_menu();


sub install {
  my $success = 1;

  output("Installing MSVC++ prerequisites... \n");

  $success &amp;= run_command("$srcfilesdir\\vcredist_x86-2008-sp1.exe /q /norestart", 'IgnoreExitCodes' =&gt; [ 3010 &amp; 0xFF ]); # reboot wanted
  $success &amp;= run_command("$srcfilesdir\\vcredist_x64-2008-sp1.exe /q /norestart", 'IgnoreExitCodes' =&gt; [ 3010 &amp; 0xFF ]); # reboot wanted
  $success &amp;= run_command("$srcfilesdir\\vcredist_x86-2012-u4.exe /q /norestart", 'IgnoreExitCodes' =&gt; [ 3010 &amp; 0xFF ]); # reboot wanted
  $success &amp;= run_command("$srcfilesdir\\vcredist_x64-2012-u4.exe /q /norestart", 'IgnoreExitCodes' =&gt; [ 3010 &amp; 0xFF ]); # reboot wanted

  if (!$success) {
    output("Failed!\n");
    return 0;
  }

 output("Installing SolidCAM... \n");

 #Yes, we're using AutoIt here. I'd avoid it if I could.
 $success &amp;= run_command("$srcfilesdir\\SolidCAM2015.msi /q /norestart");
 
 if (!$success) {
   output("Failed!\n");
   return 0;
 }

 output("Done!\n");

  return $success;
}


sub postInstall {
  ####
  #Configure license by copying generic file and putting in the computer's hostname
  ####

  output("Configuring license...\n");

  #grab template .ini file
  open(FILE, "$srcfilesdir\\hasplm.ini");
  undef $/;
  my $config = &lt;FILE&gt;;
  close(FILE);

  #get hostname and repace REPLACEYO with it in the .ini
  my %command_info;
  run_command("hostname", ReturnCommandInfo =&gt; \%command_info);

  my $hostname = $command_info{'Output'};
  $hostname =~ s/\n//;
  $config =~ s/REPLACEYO/$hostname/;

  #write it out
  open(FILE, '&gt;', "C:\\Program Files (x86)\\Common Files\\Aladdin Shared\\HASP\\hasplm.ini");
  print FILE $config;
  close(FILE);

  output("Done!\n");

  return 1;
}


do_install( 
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
  allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postInstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\solidworks-flowsim.2015\prod\update.pl</FullName>
    <Length>2606</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-09-07T16:13:20.2157417-05:00</CreationTime>
    <CreationTimeUtc>2016-09-07T21:13:20.2157417Z</CreationTimeUtc>
    <LastWriteTime>2016-09-08T08:34:21.8133069-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-09-08T13:34:21.8133069Z</LastWriteTimeUtc>
    <LastAccessTime>2016-09-07T16:13:20.2157417-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-09-07T21:13:20.2157417Z</LastAccessTimeUtc>
    <Text># Solidworks 2015 - Flow Simulation
# Chris Schaaf

=pod

Begin-Doc
Created: $Date: 2016-09-07 (June 7, 2016) $
Name: SolidWorks 2015 Flow Simulation Add-in
Type: script
Description:
Language: Perl
RCSId: $Id$
Comments:
  Solidworks 2015 did not include the necessary Flow Simulation module.
	Since it can be installed at a separate time, this exists as a patch
	only to be run on a computer with SolidWorks 2015 already installed.
End-Doc

=cut

use strict;
use warnings;
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'solidworks.2015.flowsim',
        package_revision =&gt; '20160907T1151',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use File::Spec;
use File::Basename;
use File::Path;

my $dir_data = get_pkg_sourcefiles();
my $dir_logs = 'C:\Windows\System32\UMRInst\AppLogs';
my $admin_image_path_fs = "\"$dir_data\\Flow Simulation\\SOLIDWORKS Flow Simulation.msi\"";
my $sw_serial = '"9710 0087 0819 1082 4G28 JFBB"';
my $inst_path_fs = '"C:\Program Files\Flow Simulation\"';
my $snl_server = '25734@solidworks.lic.mst.edu';

sub install {
	#manually copy subdirectory to speed up this patch
	#my $srvsrc = "\\\\minerfiles.mst.edu\\dfs\\Software\\itwindist\\win10\\appdist\\solidworks.2015\\prod";
	#if(!run_command("xcopy \"$srvsrc\\Flow Simulation\" \"$dir_data\\Flow Simulation\\\" /E")){
	#	output("Source copy failed: $!\n");
	#	return 0;
	#}
	output("\nMain installs: \n\n");
	my $install =
		"msiexec /i $admin_image_path_fs INSTALLDIR=$inst_path_fs " .
		"SOLIDWORKSSERIALNUMBER=$sw_serial " .
		"LOGPERFORMANCE=1 SNLSERVER=$snl_server TRANSFORMS=1033.mst " .
		"ADDLOCAL=All /qn /log \"$dir_logs\\solidworks_2015-flowsimulation.log\" /norestart";
	my $success = run_command($install, 'IgnoreExitCodes' =&gt; [3010]);
	if ($success != 1) {
		output("Failed: $success $!\n");
		return 0;
	}
	output("Install succeeded.\n");
	return 1;
}

sub postinstall {
	#create start menu shortcut, this isn't done by default but I think we'd want it
	return 1;
}


do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    #preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
	no_source_files =&gt; 0,
    need_reboot =&gt; 1,
);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\solidworks.2015\dev\update.pl</FullName>
    <Length>5124</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-09-12T16:07:59.3400535-05:00</CreationTime>
    <CreationTimeUtc>2016-09-12T21:07:59.3400535Z</CreationTimeUtc>
    <LastWriteTime>2016-09-12T16:26:04.6910823-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-09-12T21:26:04.6910823Z</LastWriteTimeUtc>
    <LastAccessTime>2016-09-12T16:07:59.3400535-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-09-12T21:07:59.3400535Z</LastAccessTimeUtc>
    <Text># Solidworks 2015
# Chris Schaaf
# Trying to use a silent run of Solidworks Install Manager

# NOTE: This install will not work with Windows 10 until "Features" (like .NET)
#  are figured out.

# This program uses a TON of prerequisites. In order to keep it simple and
#   readable, I placed all the install commands into a hash with the name
#   of that prereq as the key, which is numbered.
# This should help readability in the command line and shorten this script.

=pod

Begin-Doc
Modified: $Date: 2016-06-07 (June 7, 2016) $
Name: SolidWorks 2015 Installer
Type: script
Description:
Language: Perl
RCSId: $Id: update.pl 712 2011-06-10 21:20:17Z thartman $
Comments:
  In comparison to older SolidWorks installs, 2015 has different prereqs and
    has the ability to run from an admin installation. This is an attempt at
    that.
End-Doc

=cut

use strict;
use warnings;
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'solidworks.2015',
        package_revision =&gt; '20150606T1409',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use File::Spec;
use File::Basename;
use File::Path;
use File::Copy;
use Getopt::Long;
use Win32::Registry;
use Data::Dumper;

# All Variables (except success values):

my $reg = 'Software\Policies\Microsoft\Windows\Installer';
my $reg_parent = 'Software\Policies\Microsoft\Windows';
my $handle = "";
my $dword_name = "RemappedElevatedProxiesPolicy";
my $dword_value = 1;

my $sw_serial = '"9710 0087 0819 1082 4G28 JFBB"';

my $inst_path_sw = '"C:\Program Files\SolidWorks 2015\"';
my $inst_path_ed = '"C:\Program Files\eDrawings Client\"';
my $inst_path_fs = '"C:\Program Files\Flow Simulation\"';

my $snl_server = '25734@solidworks.lic.mst.edu';


# For the Visual Basic Fix.
my $vba_path = "C:\\Program Files\\Common Files\\Microsoft Shared\\VBA\\VBA7.1\\";
my $new_path = "C:\\Program Files\\Common Files\\Microsoft Shared\\VBA\\VBA7.1\\1033\\";

my %files = (
	0 =&gt; "apc71.dll",
	1 =&gt; "VBE7.DLL",
	2 =&gt; "VBEUI.DLL",
	3 =&gt; "VBEUIRES.DLL",
);

################################################################################
################################################################################
sub preinstall {
	# This registry hack is required to make Solidworks 2015 install correctly,
	#   because of a specific Windows Update.
	# Without it, it will fail to run properly.
	# This change is undone at postinstall.
	output("Temporary registry fix: ");
	$HKEY_LOCAL_MACHINE -&gt; Create($reg, $handle);
	$handle -&gt; SetValueEx($dword_name,0,REG_DWORD(),1);

	output("Preinstall succeeded.\n");
	return 1;
}
################################################################################
################################################################################
sub install {
	#I don't know if this will work out of the box, or install every prereq we need, but I'm gonna give it a shot
	my $install = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\solidworks.2015\\SOLIDWORKS Admin\\SOLIDWORKS 2015 SP2.1\\startswinstall.exe";
	my $success = run_command("\"$install\" /silent", 'IgnoreExitCodes' =&gt; [3010]);
	if ($success != 1) {
		output("Failed: $success $!\n");
		return 0;
	}
	output("Installs succeeded.\n");
	return 1;
}
################################################################################
################################################################################
sub postinstall {
	# Undoing the registry fix.
	output("\nRegistry fix cleanup: ");
	$HKEY_LOCAL_MACHINE -&gt; Open($reg_parent, $handle);
	$handle -&gt; DeleteKey("Installer");
	output("Successful\n\n");
  
	if (!create_activesetup_action(
			 'Identifier' =&gt; 'Solidworks2015_fixshortcut_20160901',
			 'ComponentID' =&gt; 'Solidworks2015x64',
			 'Description' =&gt; 'Remove shortcut autocreated on user desktop',
			 'Version' =&gt; '2015',
			 'StubPath' =&gt; "\%COMSPEC\% /c DEL /Q \"\%USERPROFILE\%\\Desktop\\SOLIDWORKS 2015 x64 Edition.lnk\"",
		)) {
		output("     Error: cannot create Active Setup action to delete desktop icon.\n");
	}
	if (!create_activesetup_action(
			 'Identifier' =&gt; 'eDrawings2015_fixshortcut_20160901',
			 'ComponentID' =&gt; 'eDrawings2015x64',
			 'Description' =&gt; 'Remove shortcut autocreated on user desktop',
			 'Version' =&gt; '2015',
			 'StubPath' =&gt; "\%COMSPEC\% /c DEL /Q \"\%USERPROFILE\%\\Desktop\\.eDrawings 2015 x64 Editionlnk\"",
		)) {
		output("     Error: cannot create Active Setup action to delete desktop icon.\n");
	}
	return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    need_reboot =&gt; 1,
	no_source_files =&gt; 1,
);



</Text>
  </Script>
  <Script>
    <Name>update-noflowsim.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\solidworks.2015\prod\update-noflowsim.pl</FullName>
    <Length>9101</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-09-09T08:46:55.3412727-05:00</CreationTime>
    <CreationTimeUtc>2016-09-09T13:46:55.3412727Z</CreationTimeUtc>
    <LastWriteTime>2016-09-09T08:47:38.9599911-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-09-09T13:47:38.9599911Z</LastWriteTimeUtc>
    <LastAccessTime>2016-09-09T08:46:55.3412727-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-09-09T13:46:55.3412727Z</LastAccessTimeUtc>
    <Text># Solidworks 2015
# Daniel T. Holtzclaw
# Trying a new method that uses an admin install instead of the messy one from
#   before. This should be smaller and (hopefully) lighter.

# NOTE: This install will not work with Windows 10 until "Features" (like .NET)
#  are figured out.

# This program uses a TON of prerequisites. In order to keep it simple and
#   readable, I placed all the install commands into a hash with the name
#   of that prereq as the key, which is numbered.
# This should help readability in the command line and shorten this script.

=pod

Begin-Doc
Modified: $Date: 2016-06-07 (June 7, 2016) $
Name: SolidWorks 2015 Installer
Type: script
Description:
Language: Perl
RCSId: $Id: update.pl 712 2011-06-10 21:20:17Z thartman $
Comments:
  In comparison to older SolidWorks installs, 2015 has different prereqs and
    has the ability to run from an admin installation. This is an attempt at
    that.
End-Doc

=cut

use strict;
use warnings;
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'solidworks.2015',
        package_revision =&gt; '20150606T1409',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use File::Spec;
use File::Basename;
use File::Path;
use File::Copy;
use Getopt::Long;
use Win32::Registry;
use Data::Dumper;

# All Variables (except success values):

my $reg = 'Software\Policies\Microsoft\Windows\Installer';
my $reg_parent = 'Software\Policies\Microsoft\Windows';
my $handle = "";
my $dword_name = "RemappedElevatedProxiesPolicy";
my $dword_value = 1;

my $dir_data = get_pkg_sourcefiles();
my $toolbox = "\"$dir_data\\SOLIDWORKS\\Toolbox\"";
my $dir_pre = "$dir_data\\prereqs";
my $dir_logs = 'C:\Windows\System32\UMRInst\AppLogs';

my $admin_image_path_sw = "\"$dir_data\\SOLIDWORKS\\SOLIDWORKS.msi\"";
my $admin_image_path_ed = "\"$dir_data\\eDrawings\\eDrawings.msi\"";

my $sw_serial = '"9710 0087 0819 1082 4G28 JFBB"';

my $inst_path_sw = '"C:\Program Files\SolidWorks 2015\"';
my $inst_path_ed = '"C:\Program Files\eDrawings Client\"';

my $snl_server = '25734@solidworks.lic.mst.edu';


# For the Visual Basic Fix.
my $vba_path = "C:\\Program Files\\Common Files\\Microsoft Shared\\VBA\\VBA7.1\\";
my $new_path = "C:\\Program Files\\Common Files\\Microsoft Shared\\VBA\\VBA7.1\\1033\\";

my %files = (
	0 =&gt; "apc71.dll",
	1 =&gt; "VBE7.DLL",
	2 =&gt; "VBEUI.DLL",
	3 =&gt; "VBEUIRES.DLL",
);

#Silent options for the below? /qb is not sufficient for a quiet/silent install!
my $inst_command_sw =
	"msiexec /i $admin_image_path_sw INSTALLDIR=$inst_path_sw " .
	"SOLIDWORKSSERIALNUMBER=$sw_serial ENABLEPERFORMANCE=1 " .
	"OFFICEOPTION=3 ADDLOCAL=SolidWorks,SolidWorksToolbox TOOLBOXFOLDER=$toolbox"
	. " /qn " . "/log \"$dir_logs\\solidworks_2015-solidworks.log\" /norestart";
#Toolbox error notification: https://forum.solidworks.com/thread/49419
# NOTE: Fixed

my $inst_command_ed =
	"msiexec /i $admin_image_path_ed INSTALLDIR=$inst_path_ed " .
	"LOGPERFORMANCE=1 SNLSERVER=$snl_server TRANSFORMS=1033.mst " .
	"ADDLOCAL=All /qn /log \"$dir_logs\\solidworks_2015-edrawings.log\" /norestart";

my %prereqs_installs = (
	#"Name" =&gt; "Install Command"
	#This is also in the install order too.
	"00 - .NET Framework 3.5 SP1"
	=&gt; "\"$dir_pre\\dotNetFX\\dotnetfx35.exe\" /q /norestart",
	"01 - Office Web"
	=&gt; "\"$dir_pre\\OfficeWeb\\owc11.exe\" /quiet",
	"02 - VCRedist '05 x86"
	=&gt; "msiexec /i \"$dir_pre\\VCRedist\\vcredist_x86\\vcredist.msi\" /quiet /log \"$dir_logs\\solidworks_2015-vcredist_2005_x86.log\" /norestart",
	"03 - VCRedist '05 x64"
	=&gt; "msiexec /i \"$dir_pre\\VCRedist\\vcredist_x64\\vcredist.msi\" /quiet /log \"$dir_logs\\solidworks_2015-vcredist_2005_x64.log\" /norestart",
	"04 - VCRedist '08 x86"
	=&gt; "msiexec /i \"$dir_pre\\VCRedist9\\vcredist_x86\\vc_red.msi\" /quiet /log \"$dir_logs\\solidworks_2015-vcredist_2008_x86.txt\" /norestart",
	"05 - VCRedist '08 x64"
	=&gt; "msiexec /i \"$dir_pre\\VCRedist9\\vcredist_x64\\vc_red.msi\" /quiet /log \"$dir_logs\\solidworks_2015-vcredist_2008_x64.txt\" /norestart",
	"06 - VCRedist '10 x86"
	=&gt; "\"$dir_pre\\VCRedist10\\vcredist_x86.exe\" /q /log \"$dir_logs\\solidworks_2015-vcredist_2010_x86.txt\" /norestart",
	"07 - VCRedist '10 x64"
	=&gt; "\"$dir_pre\\VCRedist10\\vcredist_x64.exe\" /q /log \"$dir_logs\\solidworks_2015-vcredist_2010_x64.txt\" /norestart",
	"08 - VCRedist '12 x86"
	=&gt; "\"$dir_pre\\VCRedist11\\vcredist_x86.exe\" /quiet /log \"$dir_logs\\solidworks_2015-vcredist_2012_x86.txt\" /norestart",
	"09 - VCRedist '12 x64"
	=&gt; "\"$dir_pre\\VCRedist11\\vcredist_x64.exe\" /quiet /log \"$dir_logs\\solidworks_2015-vcredist_2012_x64.txt\" /norestart",
	"10 - Visual Studio Tools for Applications"
	=&gt; "msiexec /i \"$dir_pre\\VSTA\\vsta_aide.msi\" /quiet /qn /log \"$dir_logs\\solidworks_2015-vsta.log\" /norestart",
	"11 - Remote Debugger"
	=&gt; "\"$dir_pre\\RemoteDebugger\\install.exe\" /q /l \"$dir_logs\\solidworks_2015-remote_debugger.txt\"",
	# Visual Basic
	# NOTE: Despite the fact there are a million vba71 files, we need only install
	#   vba71.msi. All the others are localized versions.
	# Visual Basic does not install correctly.
	"12 - Visual Basic 7.1"
	=&gt; "msiexec /i \"$dir_pre\\VBA\\vba71_1033.msi\" /quiet /qn /log \"$dir_logs\\solidworks_2015-VisualBasic.log\" /norestart",
	"13 - .NET Framework 4.5"
	=&gt; "\"$dir_pre\\dotNetFX\\dotnetfx45_full_x86_x64.exe\" /q /log \"$dir_logs\\solidworks_2015-dotnet_45.log\" /norestart",
	"14 - Bonjour"
	=&gt; "msiexec /i \"$dir_pre\\Bonjour\\Bonjour64.msi\" /quiet /qn /log \"$dir_logs\\solidworks_2015-bonjour.log\" /norestart",
);

my %installs  = (
	"00 - SolidWorks 2015" =&gt; $inst_command_sw,
	"01 - eDrawings" =&gt; $inst_command_ed,
);
################################################################################
################################################################################
sub preinstall {
	# This registry hack is required to make Solidworks 2015 install correctly,
	#   because of a specific Windows Update.
	# Without it, it will fail to run properly.
	# This change is undone at postinstall.
	output("Temporary registry fix: ");
	$HKEY_LOCAL_MACHINE -&gt; Create($reg, $handle);
	$handle -&gt; SetValueEx($dword_name,0,REG_DWORD(),1);
	output("Successful\n\n");

	output("Preinstalls: \n\n");

	foreach my $key (sort keys %prereqs_installs) {
		output("$key:\n  " . $prereqs_installs{$key} . "\n  Result: ");
		my $success = run_command($prereqs_installs{$key}, 'IgnoreExitCodes' =&gt; [3010]);
		if ($success != 1) {
			output("Failed: $success $!\n");
			return 0;
		}

		output("Succeeded\n\n");
	}
	output("Preinstall succeeded.\n");
	return 1;
}
################################################################################
################################################################################
sub install {
	output("\nMain installs: \n\n");

	foreach my $key (sort keys %installs) {
		output("$key:\n  " . $installs{$key} . "\n  Result: ");
		my $success = run_command($installs{$key}, 'IgnoreExitCodes' =&gt; [3010]);
		if ($success != 1) {
			output("Failed: $success $!\n");
			return 0;
		}

		output("Succeeded\n\n");
	}
	output("Installs succeeded.\n");
	return 1;
}
################################################################################
################################################################################
sub postinstall {
	# Undoing the registry fix.
	output("\nRegistry fix cleanup: ");
	$HKEY_LOCAL_MACHINE -&gt; Open($reg_parent, $handle);
	$handle -&gt; DeleteKey("Installer");
	output("Successful\n\n");
  
	if (!create_activesetup_action(
			 'Identifier' =&gt; 'Solidworks2015_fixshortcut_20160901',
			 'ComponentID' =&gt; 'Solidworks2015x64',
			 'Description' =&gt; 'Remove shortcut autocreated on user desktop',
			 'Version' =&gt; '2015',
			 'StubPath' =&gt; "\%COMSPEC\% /c DEL /Q \"\%USERPROFILE\%\\Desktop\\SOLIDWORKS 2015 x64 Edition.lnk\"",
		)) {
		output("     Error: cannot create Active Setup action to delete desktop icon.\n");
		return 0;
	}
	if (!create_activesetup_action(
			 'Identifier' =&gt; 'eDrawings2015_fixshortcut_20160901',
			 'ComponentID' =&gt; 'eDrawings2015x64',
			 'Description' =&gt; 'Remove shortcut autocreated on user desktop',
			 'Version' =&gt; '2015',
			 'StubPath' =&gt; "\%COMSPEC\% /c DEL /Q \"\%USERPROFILE\%\\Desktop\\.eDrawings 2015 x64 Editionlnk\"",
		)) {
		output("     Error: cannot create Active Setup action to delete desktop icon.\n");
		return 0;
	}
	return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    need_reboot =&gt; 1,
);



</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\solidworks.2015\prod\update.pl</FullName>
    <Length>9583</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-06-07T10:05:43.6130074-05:00</CreationTime>
    <CreationTimeUtc>2016-06-07T15:05:43.6130074Z</CreationTimeUtc>
    <LastWriteTime>2016-09-07T13:51:35.665087-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-09-07T18:51:35.665087Z</LastWriteTimeUtc>
    <LastAccessTime>2016-09-07T10:13:18.6235486-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-09-07T15:13:18.6235486Z</LastAccessTimeUtc>
    <Text># Solidworks 2015
# Daniel T. Holtzclaw
# Trying a new method that uses an admin install instead of the messy one from
#   before. This should be smaller and (hopefully) lighter.

# NOTE: This install will not work with Windows 10 until "Features" (like .NET)
#  are figured out.

# This program uses a TON of prerequisites. In order to keep it simple and
#   readable, I placed all the install commands into a hash with the name
#   of that prereq as the key, which is numbered.
# This should help readability in the command line and shorten this script.

=pod

Begin-Doc
Modified: $Date: 2016-06-07 (June 7, 2016) $
Name: SolidWorks 2015 Installer
Type: script
Description:
Language: Perl
RCSId: $Id: update.pl 712 2011-06-10 21:20:17Z thartman $
Comments:
  In comparison to older SolidWorks installs, 2015 has different prereqs and
    has the ability to run from an admin installation. This is an attempt at
    that.
End-Doc

=cut

use strict;
use warnings;
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'solidworks.2015',
        package_revision =&gt; '20150606T1409',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use File::Spec;
use File::Basename;
use File::Path;
use File::Copy;
use Getopt::Long;
use Win32::Registry;
use Data::Dumper;

# All Variables (except success values):

my $reg = 'Software\Policies\Microsoft\Windows\Installer';
my $reg_parent = 'Software\Policies\Microsoft\Windows';
my $handle = "";
my $dword_name = "RemappedElevatedProxiesPolicy";
my $dword_value = 1;

my $dir_data = get_pkg_sourcefiles();
my $toolbox = "\"$dir_data\\SOLIDWORKS\\Toolbox\"";
my $dir_pre = "$dir_data\\prereqs";
my $dir_logs = 'C:\Windows\System32\UMRInst\AppLogs';

my $admin_image_path_sw = "\"$dir_data\\SOLIDWORKS\\SOLIDWORKS.msi\"";
my $admin_image_path_ed = "\"$dir_data\\eDrawings\\eDrawings.msi\"";
my $admin_image_path_fs = "\"$dir_data\\Flow Simulation\\SOLIDWORKS Flow Simulation.msi\"";

my $sw_serial = '"9710 0087 0819 1082 4G28 JFBB"';

my $inst_path_sw = '"C:\Program Files\SolidWorks 2015\"';
my $inst_path_ed = '"C:\Program Files\eDrawings Client\"';
my $inst_path_fs = '"C:\Program Files\Flow Simulation\"';

my $snl_server = '25734@solidworks.lic.mst.edu';


# For the Visual Basic Fix.
my $vba_path = "C:\\Program Files\\Common Files\\Microsoft Shared\\VBA\\VBA7.1\\";
my $new_path = "C:\\Program Files\\Common Files\\Microsoft Shared\\VBA\\VBA7.1\\1033\\";

my %files = (
	0 =&gt; "apc71.dll",
	1 =&gt; "VBE7.DLL",
	2 =&gt; "VBEUI.DLL",
	3 =&gt; "VBEUIRES.DLL",
);

#Silent options for the below? /qb is not sufficient for a quiet/silent install!
my $inst_command_sw =
	"msiexec /i $admin_image_path_sw INSTALLDIR=$inst_path_sw " .
	"SOLIDWORKSSERIALNUMBER=$sw_serial ENABLEPERFORMANCE=1 " .
	"OFFICEOPTION=3 ADDLOCAL=SolidWorks,SolidWorksToolbox TOOLBOXFOLDER=$toolbox"
	. " /qn " . "/log \"$dir_logs\\solidworks_2015-solidworks.log\" /norestart";
#Toolbox error notification: https://forum.solidworks.com/thread/49419
# NOTE: Fixed

my $inst_command_ed =
	"msiexec /i $admin_image_path_ed INSTALLDIR=$inst_path_ed " .
	"LOGPERFORMANCE=1 SNLSERVER=$snl_server TRANSFORMS=1033.mst " .
	"ADDLOCAL=All /qn /log \"$dir_logs\\solidworks_2015-edrawings.log\" /norestart";

my $inst_command_fs =
	"msiexec /i $admin_image_path_fs INSTALLDIR=$inst_path_fs " .
	"SOLIDWORKSSERIALNUMBER=$sw_serial " .
	"LOGPERFORMANCE=1 SNLSERVER=$snl_server TRANSFORMS=1033.mst " .
	"ADDLOCAL=All /qn /log \"$dir_logs\\solidworks_2015-flowsimulation.log\" /norestart";

my %prereqs_installs = (
	#"Name" =&gt; "Install Command"
	#This is also in the install order too.
	"00 - .NET Framework 3.5 SP1"
	=&gt; "\"$dir_pre\\dotNetFX\\dotnetfx35.exe\" /q /norestart",
	"01 - Office Web"
	=&gt; "\"$dir_pre\\OfficeWeb\\owc11.exe\" /quiet",
	"02 - VCRedist '05 x86"
	=&gt; "msiexec /i \"$dir_pre\\VCRedist\\vcredist_x86\\vcredist.msi\" /quiet /log \"$dir_logs\\solidworks_2015-vcredist_2005_x86.log\" /norestart",
	"03 - VCRedist '05 x64"
	=&gt; "msiexec /i \"$dir_pre\\VCRedist\\vcredist_x64\\vcredist.msi\" /quiet /log \"$dir_logs\\solidworks_2015-vcredist_2005_x64.log\" /norestart",
	"04 - VCRedist '08 x86"
	=&gt; "msiexec /i \"$dir_pre\\VCRedist9\\vcredist_x86\\vc_red.msi\" /quiet /log \"$dir_logs\\solidworks_2015-vcredist_2008_x86.txt\" /norestart",
	"05 - VCRedist '08 x64"
	=&gt; "msiexec /i \"$dir_pre\\VCRedist9\\vcredist_x64\\vc_red.msi\" /quiet /log \"$dir_logs\\solidworks_2015-vcredist_2008_x64.txt\" /norestart",
	"06 - VCRedist '10 x86"
	=&gt; "\"$dir_pre\\VCRedist10\\vcredist_x86.exe\" /q /log \"$dir_logs\\solidworks_2015-vcredist_2010_x86.txt\" /norestart",
	"07 - VCRedist '10 x64"
	=&gt; "\"$dir_pre\\VCRedist10\\vcredist_x64.exe\" /q /log \"$dir_logs\\solidworks_2015-vcredist_2010_x64.txt\" /norestart",
	"08 - VCRedist '12 x86"
	=&gt; "\"$dir_pre\\VCRedist11\\vcredist_x86.exe\" /quiet /log \"$dir_logs\\solidworks_2015-vcredist_2012_x86.txt\" /norestart",
	"09 - VCRedist '12 x64"
	=&gt; "\"$dir_pre\\VCRedist11\\vcredist_x64.exe\" /quiet /log \"$dir_logs\\solidworks_2015-vcredist_2012_x64.txt\" /norestart",
	"10 - Visual Studio Tools for Applications"
	=&gt; "msiexec /i \"$dir_pre\\VSTA\\vsta_aide.msi\" /quiet /qn /log \"$dir_logs\\solidworks_2015-vsta.log\" /norestart",
	"11 - Remote Debugger"
	=&gt; "\"$dir_pre\\RemoteDebugger\\install.exe\" /q /l \"$dir_logs\\solidworks_2015-remote_debugger.txt\"",
	# Visual Basic
	# NOTE: Despite the fact there are a million vba71 files, we need only install
	#   vba71.msi. All the others are localized versions.
	# Visual Basic does not install correctly.
	"12 - Visual Basic 7.1"
	=&gt; "msiexec /i \"$dir_pre\\VBA\\vba71_1033.msi\" /quiet /qn /log \"$dir_logs\\solidworks_2015-VisualBasic.log\" /norestart",
	"13 - .NET Framework 4.5"
	=&gt; "\"$dir_pre\\dotNetFX\\dotnetfx45_full_x86_x64.exe\" /q /log \"$dir_logs\\solidworks_2015-dotnet_45.log\" /norestart",
	"14 - Bonjour"
	=&gt; "msiexec /i \"$dir_pre\\Bonjour\\Bonjour64.msi\" /quiet /qn /log \"$dir_logs\\solidworks_2015-bonjour.log\" /norestart",
);

my %installs  = (
	"00 - SolidWorks 2015" =&gt; $inst_command_sw,
	"01 - eDrawings" =&gt; $inst_command_ed,
	"02 - Flow Simulation" =&gt; $inst_command_fs,
);
################################################################################
################################################################################
sub preinstall {
	# This registry hack is required to make Solidworks 2015 install correctly,
	#   because of a specific Windows Update.
	# Without it, it will fail to run properly.
	# This change is undone at postinstall.
	output("Temporary registry fix: ");
	$HKEY_LOCAL_MACHINE -&gt; Create($reg, $handle);
	$handle -&gt; SetValueEx($dword_name,0,REG_DWORD(),1);
	output("Successful\n\n");

	output("Preinstalls: \n\n");

	foreach my $key (sort keys %prereqs_installs) {
		output("$key:\n  " . $prereqs_installs{$key} . "\n  Result: ");
		my $success = run_command($prereqs_installs{$key}, 'IgnoreExitCodes' =&gt; [3010]);
		if ($success != 1) {
			output("Failed: $success $!\n");
			return 0;
		}

		output("Succeeded\n\n");
	}
	output("Preinstall succeeded.\n");
	return 1;
}
################################################################################
################################################################################
sub install {
	output("\nMain installs: \n\n");

	foreach my $key (sort keys %installs) {
		output("$key:\n  " . $installs{$key} . "\n  Result: ");
		my $success = run_command($installs{$key}, 'IgnoreExitCodes' =&gt; [3010]);
		if ($success != 1) {
			output("Failed: $success $!\n");
			return 0;
		}

		output("Succeeded\n\n");
	}
	output("Installs succeeded.\n");
	return 1;
}
################################################################################
################################################################################
sub postinstall {
	# Undoing the registry fix.
	output("\nRegistry fix cleanup: ");
	$HKEY_LOCAL_MACHINE -&gt; Open($reg_parent, $handle);
	$handle -&gt; DeleteKey("Installer");
	output("Successful\n\n");
  
	if (!create_activesetup_action(
			 'Identifier' =&gt; 'Solidworks2015_fixshortcut_20160901',
			 'ComponentID' =&gt; 'Solidworks2015x64',
			 'Description' =&gt; 'Remove shortcut autocreated on user desktop',
			 'Version' =&gt; '2015',
			 'StubPath' =&gt; "\%COMSPEC\% /c DEL /Q \"\%USERPROFILE\%\\Desktop\\SOLIDWORKS 2015 x64 Edition.lnk\"",
		)) {
		output("     Error: cannot create Active Setup action to delete desktop icon.\n");
		return 0;
	}
	if (!create_activesetup_action(
			 'Identifier' =&gt; 'eDrawings2015_fixshortcut_20160901',
			 'ComponentID' =&gt; 'eDrawings2015x64',
			 'Description' =&gt; 'Remove shortcut autocreated on user desktop',
			 'Version' =&gt; '2015',
			 'StubPath' =&gt; "\%COMSPEC\% /c DEL /Q \"\%USERPROFILE\%\\Desktop\\.eDrawings 2015 x64 Editionlnk\"",
		)) {
		output("     Error: cannot create Active Setup action to delete desktop icon.\n");
		return 0;
	}
	return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    need_reboot =&gt; 1,
);



</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\solidworks.2016\prod\update.pl</FullName>
    <Length>6122</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-20T14:30:55.2706611-05:00</CreationTime>
    <CreationTimeUtc>2017-06-20T19:30:55.2706611Z</CreationTimeUtc>
    <LastWriteTime>2017-06-21T14:21:51.7076223-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-21T19:21:51.7076223Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-20T14:30:55.223859-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-20T19:30:55.223859Z</LastAccessTimeUtc>
    <Text># Solidworks 2016
# Created by Daniel T. Holtzclaw
# Last Updated by Chris Schaaf
# Trying a new method that uses an admin install instead of the messy one from
#   before. This should be smaller and (hopefully) lighter.

# NOTE: This install will not work with Windows 10 until "Features" (like .NET)
#  are figured out.

# This program uses a TON of prerequisites. In order to keep it simple and
#   readable, I placed all the install commands into a hash with the name
#   of that prereq as the key, which is numbered.
# This should help readability in the command line and shorten this script.

# 2017-06 | cts28d
# The startswinstall option to run the admin image installer works fine, but
#	must be copied to the machine to be run on first due to Windows' 256-char
#	path limit

=pod

Begin-Doc
Modified: $Date: 2016-06-07 (June 7, 2016) $
Name: SolidWorks 2016 Installer
Type: script
Description:
Language: Perl
RCSId: $Id: update.pl 712 2011-06-10 21:20:17Z thartman $
Comments:
  In comparison to older SolidWorks installs, 2016 has different prereqs and
    has the ability to run from an admin installation. This is an attempt at
    that.
End-Doc

=cut

use strict;
use warnings;
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'solidworks.2016',
        package_revision =&gt; '20161227T1507',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use File::Spec;
use File::Basename;
use File::Path;
use File::Copy;
use Getopt::Long;
use Win32::Registry;
use Data::Dumper;

# All Variables (except success values):

my $reg = 'Software\Policies\Microsoft\Windows\Installer';
my $reg_parent = 'Software\Policies\Microsoft\Windows';
my $handle = "";
my $dword_name = "RemappedElevatedProxiesPolicy";

my $src = get_pkg_sourcefiles();
my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\software\\itwindist\\appdeploy\\solidworks.2016\\SOLIDWORKS 2016 SP5.0";

################################################################################
################################################################################
sub preinstall {
	# This registry hack is required to make Solidworks 2016 install correctly,
	#   because of a specific Windows Update.
	# Without it, it will fail to run properly.
	# This change is undone at postinstall.
	output("Temporary registry fix: ");
	$HKEY_LOCAL_MACHINE -&gt; Create($reg, $handle);
	$handle -&gt; SetValueEx($dword_name,0,REG_DWORD(),1);
	output("Successful\n\n");
	output("Copying admin image (10GB): ");
	if(!run_command("robocopy \"$appdeploy\" \"$src\" /E", 'IgnoreExitCodes' =&gt; [1, 2, 3])){
		output("FAIL: $!\n");
		return 0;
	}
	output("OK\n");
	return 1;
}
################################################################################
################################################################################
sub install {
	output("\nRunning admin installer: \n");
	my $success = run_command("\"$src\\startswinstall.exe\" /now", 'IgnoreExitCodes' =&gt; [3010]);
	if (!$success) {
		output("FAIL: $!\n");
		return 0;
	}
	output("OK\n");
	return 1;
}
################################################################################
################################################################################
sub postinstall {
	# Undoing the registry fix.
	output("\nRegistry fix cleanup: ");
	$HKEY_LOCAL_MACHINE -&gt; Open($reg_parent, $handle);
	$handle -&gt; DeleteKey("Installer");
	output("Successful\n\n");
	
	my $desk = get_allusers_desktop();
	run_command("DEL /Q \"$desk\\SOLIDWORKS 2016 x64 Edition.lnk\"");
	run_command("DEL /Q \"$desk\\eDrawings 2016 x64 Edition.lnk\"");
	run_command("DEL /Q \"$desk\\SOLIDWORKS Composer Player 2016 - x64 Edition.lnk\"");
	run_command("DEL /Q \"$desk\\SOLIDWORKS Electrical.lnk\"");
	
	if (!create_activesetup_action(
		'Identifier' =&gt; 'Solidworks2016_fixshortcut_20170621',
		'ComponentID' =&gt; 'Solidworks2016x64',
		'Description' =&gt; 'Remove shortcut autocreated on user desktop',
		'Version' =&gt; '2016',
		'StubPath' =&gt; "\%COMSPEC\% /c DEL /Q \"\%USERPROFILE\%\\Desktop\\SOLIDWORKS 2016 x64 Edition.lnk\"",
		)) {
		output("     Error: cannot create Active Setup action to delete desktop icon.\n");
		return 0;
	}
	if (!create_activesetup_action(
		'Identifier' =&gt; 'eDrawings2016_fixshortcut_20170621',
		'ComponentID' =&gt; 'eDrawings2016x64',
		'Description' =&gt; 'Remove shortcut autocreated on user desktop',
		'Version' =&gt; '2016',
		'StubPath' =&gt; "\%COMSPEC\% /c DEL /Q \"\%USERPROFILE\%\\Desktop\\eDrawings 2016 x64 Edition.lnk\"",
		)) {
		output("     Error: cannot create Active Setup action to delete desktop icon.\n");
		return 0;
	}
	if (!create_activesetup_action(
		'Identifier' =&gt; 'SwComposer_fixshortcut_20170621',
		'ComponentID' =&gt; 'SWComposer2016x64',
		'Description' =&gt; 'Remove shortcut autocreated on user desktop',
		'Version' =&gt; '2016',
		'StubPath' =&gt; "\%COMSPEC\% /c DEL /Q \"\%USERPROFILE\%\\Desktop\\SOLIDWORKS Composer Player 2016 - x64 Edition.lnk\"",
		)) {
		output("     Error: cannot create Active Setup action to delete desktop icon.\n");
		return 0;
	}
	if (!create_activesetup_action(
		'Identifier' =&gt; 'SwElectrical_fixshortcut_20170621',
		'ComponentID' =&gt; 'SWElectrical2016x64',
		'Description' =&gt; 'Remove shortcut autocreated on user desktop',
		'Version' =&gt; '2016',
		'StubPath' =&gt; "\%COMSPEC\% /c DEL /Q \"\%USERPROFILE\%\\Desktop\\SOLIDWORKS Electrical.lnk\"",
		)) {
		output("     Error: cannot create Active Setup action to delete desktop icon.\n");
		return 0;
	}
	return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    need_reboot =&gt; 1,
);



</Text>
  </Script>
  <Script>
    <Name>update-sp5.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\solidworks.2016\prod.old\update-sp5.pl</FullName>
    <Length>10833</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-22T08:33:14.9275165-05:00</CreationTime>
    <CreationTimeUtc>2017-06-22T13:33:14.9275165Z</CreationTimeUtc>
    <LastWriteTime>2017-06-20T12:36:11.9454078-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-20T17:36:11.9454078Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-22T08:33:14.9275165-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-22T13:33:14.9275165Z</LastAccessTimeUtc>
    <Text># Solidworks 2016
# Created by Daniel T. Holtzclaw
# Last Updated by Chris Schaaf
# Trying a new method that uses an admin install instead of the messy one from
#   before. This should be smaller and (hopefully) lighter.

# NOTE: This install will not work with Windows 10 until "Features" (like .NET)
#  are figured out.

# This program uses a TON of prerequisites. In order to keep it simple and
#   readable, I placed all the install commands into a hash with the name
#   of that prereq as the key, which is numbered.
# This should help readability in the command line and shorten this script.

#2016-12-28|cts28d
# The default Admin Image install setup from Solidworks has a number of issues,
# 	at this point this is still the simplest and best method known. The admin install
#	when ran with its default "startswinstall /now" will never send a failure state.
#	It'll pop up a window telling you it failed, but it will return success regardless.
#	The installer is limited by the 256-char-max limitation in Windows and cannot be run
#	directly from $appdeploy. However it cannot be copied over, giving a message about
#	not having a valid admin image to install whenever you move it.
#Flow Sim is the only thing included in win10/appdist/... due to its long file paths.
#	It cannot be installed from appdeploy, it will fail with error 1603/1309.

=pod

Begin-Doc
Modified: $Date: 2016-06-07 (June 7, 2016) $
Name: SolidWorks 2016 Installer
Type: script
Description:
Language: Perl
RCSId: $Id: update.pl 712 2011-06-10 21:20:17Z thartman $
Comments:
  In comparison to older SolidWorks installs, 2016 has different prereqs and
    has the ability to run from an admin installation. This is an attempt at
    that.
End-Doc

=cut

use strict;
use warnings;
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'solidworks.2016',
        package_revision =&gt; '20161227T1507',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use File::Spec;
use File::Basename;
use File::Path;
use File::Copy;
use Getopt::Long;
use Win32::Registry;
use Data::Dumper;

# All Variables (except success values):

my $reg = 'Software\Policies\Microsoft\Windows\Installer';
my $reg_parent = 'Software\Policies\Microsoft\Windows';
my $handle = "";
my $dword_name = "RemappedElevatedProxiesPolicy";
my $dword_value = 1;

my $src = get_pkg_sourcefiles();
my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\software\\itwindist\\appdeploy\\solidworks.2016\\SOLIDWORKS 2016 SP5.0\\64bit";
#my $toolbox = "\"$src\\SOLIDWORKS\\Toolbox\"";
my $toolbox = "\"$src\\Toolbox\"";
#my $toolbox = "\"$appdeploy\\Toolbox\"";
#my $prereq = "$src\\prereqs";
my $applogs = 'C:\Windows\System32\UMRInst\AppLogs';

my $admin_image_path_sw = "\"$src\\SOLIDWORKS\\SolidWorks.Msi\"";
my $admin_image_path_ed = "\"$appdeploy\\eDrawings\\eDrawings.msi\"";
my $admin_image_path_fs = "\"$src\\SOLIDWORKS Flow Simulation\\SolidWorks Flow Simulation.msi\"";

my $sw_serial = '"9710 0087 0819 1082 4G28 JFBB"';

my $inst_path_sw = '"C:\Program Files\SolidWorks 2016\"';
my $inst_path_ed = '"C:\Program Files\eDrawings Client\"';
my $inst_path_fs = '"C:\Program Files\Flow Simulation\"';

my $snl_server = '25734@solidworks.lic.mst.edu';


# For the Visual Basic Fix.
my $vba_path = "C:\\Program Files\\Common Files\\Microsoft Shared\\VBA\\VBA7.1\\";
my $new_path = "C:\\Program Files\\Common Files\\Microsoft Shared\\VBA\\VBA7.1\\1033\\";

my %files = (
	0 =&gt; "apc71.dll",
	1 =&gt; "VBE7.DLL",
	2 =&gt; "VBEUI.DLL",
	3 =&gt; "VBEUIRES.DLL",
);

#Silent options for the below? /qb is not sufficient for a quiet/silent install!
my $inst_command_sw =
	"msiexec /i $admin_image_path_sw INSTALLDIR=$inst_path_sw " .
	"SOLIDWORKSSERIALNUMBER=$sw_serial ENABLEPERFORMANCE=1 " .
	"OFFICEOPTION=3 ADDLOCAL=SolidWorks,SolidWorksToolbox TOOLBOXFOLDER=$toolbox"
	. " /qn " . "/log \"$applogs\\solidworks_2016-solidworks.log\" /norestart";
#Toolbox error notification: https://forum.solidworks.com/thread/49419
# NOTE: Fixed

my $inst_command_ed =
	"msiexec /i $admin_image_path_ed INSTALLDIR=$inst_path_ed " .
	"LOGPERFORMANCE=1 SNLSERVER=$snl_server TRANSFORMS=1033.mst " .
	"ADDLOCAL=All /qn /log \"$applogs\\solidworks_2016-edrawings.log\" /norestart";

my $inst_command_fs =
	"msiexec /i $admin_image_path_fs INSTALLDIR=$inst_path_fs " .
	"SOLIDWORKSSERIALNUMBER=$sw_serial " .
	"LOGPERFORMANCE=1 SNLSERVER=$snl_server TRANSFORMS=1033.mst " .
	"ADDLOCAL=All /qn /log \"$applogs\\solidworks_2016-flowsimulation.log\" /norestart";

my %prereqs_installs = (
	#"Name" =&gt; "Install Command"
	#This is also in the install order too.
	# "00 - .NET Framework 3.5 SP1"
	# =&gt; "\"$appdeploy\\.Net_Framework_3.5\\dotnetfx35.exe\" /q /norestart",
	"01 - Office Web"
	=&gt; "\"$appdeploy\\OfficeWeb_11\\owc11.exe\" /quiet",
	"02 - VCRedist '05 x86"
	=&gt; "msiexec /i \"$appdeploy\\Microsoft_C++_2005_Redistributable\\vcredist.msi\" /quiet /log \"$applogs\\solidworks_2016-vcredist_2005_x86.log\" /norestart",
	"03 - VCRedist '05 x64"
	=&gt; "msiexec /i \"$appdeploy\\Microsoft_C++_2005_Redistributable_(x64)\\vcredist.msi\" /quiet /log \"$applogs\\solidworks_2016-vcredist_2005_x64.log\" /norestart",
	"04 - VCRedist '08 x86"
	=&gt; "msiexec /i \"$appdeploy\\Microsoft_C++_2008_Redistributable\\vc_red.msi\" /quiet /log \"$applogs\\solidworks_2016-vcredist_2008_x86.txt\" /norestart",
	"05 - VCRedist '08 x64"
	=&gt; "msiexec /i \"$appdeploy\\Microsoft_C++_2008_Redistributable_(x64)\\vc_red.msi\" /quiet /log \"$applogs\\solidworks_2016-vcredist_2008_x64.txt\" /norestart",
	"06 - VCRedist '10 x86"
	=&gt; "\"$appdeploy\\Microsoft_C++_2010_Redistributable\\vcredist_x86.exe\" /q /log \"$applogs\\solidworks_2016-vcredist_2010_x86.txt\" /norestart",
	"07 - VCRedist '10 x64"
	=&gt; "\"$appdeploy\\Microsoft_C++_2010_Redistributable_(x64)\\vcredist_x64.exe\" /q /log \"$applogs\\solidworks_2016-vcredist_2010_x64.txt\" /norestart",
	"08 - VCRedist '12 x86"
	=&gt; "\"$appdeploy\\Microsoft_C++_2012_Redistributable\\vcredist_x86.exe\" /quiet /log \"$applogs\\solidworks_2016-vcredist_2012_x86.txt\" /norestart",
	"09 - VCRedist '12 x64"
	=&gt; "\"$appdeploy\\Microsoft_C++_2012_Redistributable_(x64)\\vcredist_x64.exe\" /quiet /log \"$applogs\\solidworks_2016-vcredist_2012_x64.txt\" /norestart",
	"10 - Visual Studio Tools for Applications"
	=&gt; "msiexec /i \"$appdeploy\\Microsoft_VSTA\\vsta_aide.msi\" /quiet /qn /log \"$applogs\\solidworks_2016-vsta.log\" /norestart",
	"11 - Remote Debugger"
	=&gt; "\"$appdeploy\\VSRemoteDebugger\\install.exe\" /q /l \"$applogs\\solidworks_2016-remote_debugger.txt\"",
	# Visual Basic
	# NOTE: Despite the fact there are a million vba71 files, we need only install
	#   vba71.msi. All the others are localized versions.
	# Visual Basic does not install correctly.
	"12 - Visual Basic 7.1"
	=&gt; "msiexec /i \"$appdeploy\\Microsoft_VBA_1033\\vba71_1033.msi\" /quiet /qn /log \"$applogs\\solidworks_2016-VisualBasic.log\" /norestart",
	"13 - .NET Framework 4.5.2"
	=&gt; "\"$appdeploy\\.Net_Framework_4.5.2\\NDP452-KB2901907-x86-x64-AllOS-ENU.exe\" /q /log \"$applogs\\solidworks_2016-dotnet_45.log\" /norestart",
	"14 - Bonjour"
	=&gt; "msiexec /i \"$appdeploy\\Bonjour\\Bonjour64.msi\" /quiet /qn /log \"$applogs\\solidworks_2016-bonjour.log\" /norestart",
);

my %installs  = (
	"00 - SolidWorks 2016" =&gt; $inst_command_sw,
	"01 - eDrawings" =&gt; $inst_command_ed,
	"02 - Flow Simulation" =&gt; $inst_command_fs,
);
################################################################################
################################################################################
sub preinstall {
	# This registry hack is required to make Solidworks 2016 install correctly,
	#   because of a specific Windows Update.
	# Without it, it will fail to run properly.
	# This change is undone at postinstall.
	output("Temporary registry fix: ");
	$HKEY_LOCAL_MACHINE -&gt; Create($reg, $handle);
	$handle -&gt; SetValueEx($dword_name,0,REG_DWORD(),1);
	output("Successful\n\n");

	output("Preinstalls: \n\n");

	foreach my $key (sort keys %prereqs_installs) {
		output("$key:\n  " . $prereqs_installs{$key} . "\n  Result: ");
		my $success = run_command($prereqs_installs{$key}, 'IgnoreExitCodes' =&gt; [3010]);
		if ($success != 1) {
			output("Failed: $success $!\n");
			return 0;
		}

		output("Succeeded\n\n");
	}
	output("Preinstall succeeded.\n");
	return 1;
}
################################################################################
################################################################################
sub install {
	output("\nMain installs: \n\n");

	foreach my $key (sort keys %installs) {
		output("$key:\n  " . $installs{$key} . "\n  Result: ");
		my $success = run_command($installs{$key}, 'IgnoreExitCodes' =&gt; [3010]);
		if ($success != 1) {
			output("Failed: $success $!\n");
			return 0;
		}

		output("Succeeded\n\n");
	}
	output("Installs succeeded.\n");
	return 1;
}
################################################################################
################################################################################
sub postinstall {
	# Undoing the registry fix.
	output("\nRegistry fix cleanup: ");
	$HKEY_LOCAL_MACHINE -&gt; Open($reg_parent, $handle);
	$handle -&gt; DeleteKey("Installer");
	output("Successful\n\n");
  
	if (!create_activesetup_action(
			 'Identifier' =&gt; 'Solidworks2016_fixshortcut_20160901',
			 'ComponentID' =&gt; 'Solidworks2016x64',
			 'Description' =&gt; 'Remove shortcut autocreated on user desktop',
			 'Version' =&gt; '2016',
			 'StubPath' =&gt; "\%COMSPEC\% /c DEL /Q \"\%USERPROFILE\%\\Desktop\\SOLIDWORKS 2016 x64 Edition.lnk\"",
		)) {
		output("     Error: cannot create Active Setup action to delete desktop icon.\n");
		return 0;
	}
	if (!create_activesetup_action(
			 'Identifier' =&gt; 'eDrawings2016_fixshortcut_20160901',
			 'ComponentID' =&gt; 'eDrawings2016x64',
			 'Description' =&gt; 'Remove shortcut autocreated on user desktop',
			 'Version' =&gt; '2016',
			 'StubPath' =&gt; "\%COMSPEC\% /c DEL /Q \"\%USERPROFILE\%\\Desktop\\.eDrawings 2016 x64 Editionlnk\"",
		)) {
		output("     Error: cannot create Active Setup action to delete desktop icon.\n");
		return 0;
	}
	return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    need_reboot =&gt; 1,
);



</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\solidworks.2016\prod.old\update.pl</FullName>
    <Length>10829</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-22T08:33:14.9431172-05:00</CreationTime>
    <CreationTimeUtc>2017-06-22T13:33:14.9431172Z</CreationTimeUtc>
    <LastWriteTime>2017-01-05T14:26:20.1979385-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-01-05T20:26:20.1979385Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-22T08:33:14.9431172-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-22T13:33:14.9431172Z</LastAccessTimeUtc>
    <Text># Solidworks 2016
# Created by Daniel T. Holtzclaw
# Last Updated by Chris Schaaf
# Trying a new method that uses an admin install instead of the messy one from
#   before. This should be smaller and (hopefully) lighter.

# NOTE: This install will not work with Windows 10 until "Features" (like .NET)
#  are figured out.

# This program uses a TON of prerequisites. In order to keep it simple and
#   readable, I placed all the install commands into a hash with the name
#   of that prereq as the key, which is numbered.
# This should help readability in the command line and shorten this script.

#2016-12-28|cts28d
# The default Admin Image install setup from Solidworks has a number of issues,
# 	at this point this is still the simplest and best method known. The admin install
#	when ran with its default "startswinstall /now" will never send a failure state.
#	It'll pop up a window telling you it failed, but it will return success regardless.
#	The installer is limited by the 256-char-max limitation in Windows and cannot be run
#	directly from $appdeploy. However it cannot be copied over, giving a message about
#	not having a valid admin image to install whenever you move it.
#Flow Sim is the only thing included in win10/appdist/... due to its long file paths.
#	It cannot be installed from appdeploy, it will fail with error 1603/1309.

=pod

Begin-Doc
Modified: $Date: 2016-06-07 (June 7, 2016) $
Name: SolidWorks 2016 Installer
Type: script
Description:
Language: Perl
RCSId: $Id: update.pl 712 2011-06-10 21:20:17Z thartman $
Comments:
  In comparison to older SolidWorks installs, 2016 has different prereqs and
    has the ability to run from an admin installation. This is an attempt at
    that.
End-Doc

=cut

use strict;
use warnings;
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'solidworks.2016',
        package_revision =&gt; '20161227T1507',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use File::Spec;
use File::Basename;
use File::Path;
use File::Copy;
use Getopt::Long;
use Win32::Registry;
use Data::Dumper;

# All Variables (except success values):

my $reg = 'Software\Policies\Microsoft\Windows\Installer';
my $reg_parent = 'Software\Policies\Microsoft\Windows';
my $handle = "";
my $dword_name = "RemappedElevatedProxiesPolicy";
my $dword_value = 1;

my $src = get_pkg_sourcefiles();
my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\software\\itwindist\\appdeploy\\solidworks.2016\\SOLIDWORKS 2016 SP2.0\\64bit";
#my $toolbox = "\"$src\\SOLIDWORKS\\Toolbox\"";
my $toolbox = "\"$src\\Toolbox\"";
#my $toolbox = "\"$appdeploy\\Toolbox\"";
#my $prereq = "$src\\prereqs";
my $applogs = 'C:\Windows\System32\UMRInst\AppLogs';

my $admin_image_path_sw = "\"$src\\SOLIDWORKS\\SolidWorks.Msi\"";
my $admin_image_path_ed = "\"$appdeploy\\eDrawings\\eDrawings.msi\"";
my $admin_image_path_fs = "\"$src\\SOLIDWORKS Flow Simulation\\SolidWorks Flow Simulation.msi\"";

my $sw_serial = '"9710 0087 0819 1082 4G28 JFBB"';

my $inst_path_sw = '"C:\Program Files\SolidWorks 2016\"';
my $inst_path_ed = '"C:\Program Files\eDrawings Client\"';
my $inst_path_fs = '"C:\Program Files\Flow Simulation\"';

my $snl_server = '25734@solidworks.lic.mst.edu';


# For the Visual Basic Fix.
my $vba_path = "C:\\Program Files\\Common Files\\Microsoft Shared\\VBA\\VBA7.1\\";
my $new_path = "C:\\Program Files\\Common Files\\Microsoft Shared\\VBA\\VBA7.1\\1033\\";

my %files = (
	0 =&gt; "apc71.dll",
	1 =&gt; "VBE7.DLL",
	2 =&gt; "VBEUI.DLL",
	3 =&gt; "VBEUIRES.DLL",
);

#Silent options for the below? /qb is not sufficient for a quiet/silent install!
my $inst_command_sw =
	"msiexec /i $admin_image_path_sw INSTALLDIR=$inst_path_sw " .
	"SOLIDWORKSSERIALNUMBER=$sw_serial ENABLEPERFORMANCE=1 " .
	"OFFICEOPTION=3 ADDLOCAL=SolidWorks,SolidWorksToolbox TOOLBOXFOLDER=$toolbox"
	. " /qn " . "/log \"$applogs\\solidworks_2016-solidworks.log\" /norestart";
#Toolbox error notification: https://forum.solidworks.com/thread/49419
# NOTE: Fixed

my $inst_command_ed =
	"msiexec /i $admin_image_path_ed INSTALLDIR=$inst_path_ed " .
	"LOGPERFORMANCE=1 SNLSERVER=$snl_server TRANSFORMS=1033.mst " .
	"ADDLOCAL=All /qn /log \"$applogs\\solidworks_2016-edrawings.log\" /norestart";

my $inst_command_fs =
	"msiexec /i $admin_image_path_fs INSTALLDIR=$inst_path_fs " .
	"SOLIDWORKSSERIALNUMBER=$sw_serial " .
	"LOGPERFORMANCE=1 SNLSERVER=$snl_server TRANSFORMS=1033.mst " .
	"ADDLOCAL=All /qn /log \"$applogs\\solidworks_2016-flowsimulation.log\" /norestart";

my %prereqs_installs = (
	#"Name" =&gt; "Install Command"
	#This is also in the install order too.
	"00 - .NET Framework 3.5 SP1"
	=&gt; "\"$appdeploy\\.Net_Framework_3.5\\dotnetfx35.exe\" /q /norestart",
	"01 - Office Web"
	=&gt; "\"$appdeploy\\OfficeWeb_11\\owc11.exe\" /quiet",
	"02 - VCRedist '05 x86"
	=&gt; "msiexec /i \"$appdeploy\\Microsoft_C++_2005_Redistributable\\vcredist.msi\" /quiet /log \"$applogs\\solidworks_2016-vcredist_2005_x86.log\" /norestart",
	"03 - VCRedist '05 x64"
	=&gt; "msiexec /i \"$appdeploy\\Microsoft_C++_2005_Redistributable_(x64)\\vcredist.msi\" /quiet /log \"$applogs\\solidworks_2016-vcredist_2005_x64.log\" /norestart",
	"04 - VCRedist '08 x86"
	=&gt; "msiexec /i \"$appdeploy\\Microsoft_C++_2008_Redistributable\\vc_red.msi\" /quiet /log \"$applogs\\solidworks_2016-vcredist_2008_x86.txt\" /norestart",
	"05 - VCRedist '08 x64"
	=&gt; "msiexec /i \"$appdeploy\\Microsoft_C++_2008_Redistributable_(x64)\\vc_red.msi\" /quiet /log \"$applogs\\solidworks_2016-vcredist_2008_x64.txt\" /norestart",
	"06 - VCRedist '10 x86"
	=&gt; "\"$appdeploy\\Microsoft_C++_2010_Redistributable\\vcredist_x86.exe\" /q /log \"$applogs\\solidworks_2016-vcredist_2010_x86.txt\" /norestart",
	"07 - VCRedist '10 x64"
	=&gt; "\"$appdeploy\\Microsoft_C++_2010_Redistributable_(x64)\\vcredist_x64.exe\" /q /log \"$applogs\\solidworks_2016-vcredist_2010_x64.txt\" /norestart",
	"08 - VCRedist '12 x86"
	=&gt; "\"$appdeploy\\Microsoft_C++_2012_Redistributable\\vcredist_x86.exe\" /quiet /log \"$applogs\\solidworks_2016-vcredist_2012_x86.txt\" /norestart",
	"09 - VCRedist '12 x64"
	=&gt; "\"$appdeploy\\Microsoft_C++_2012_Redistributable_(x64)\\vcredist_x64.exe\" /quiet /log \"$applogs\\solidworks_2016-vcredist_2012_x64.txt\" /norestart",
	"10 - Visual Studio Tools for Applications"
	=&gt; "msiexec /i \"$appdeploy\\Microsoft_VSTA\\vsta_aide.msi\" /quiet /qn /log \"$applogs\\solidworks_2016-vsta.log\" /norestart",
	"11 - Remote Debugger"
	=&gt; "\"$appdeploy\\VSRemoteDebugger\\install.exe\" /q /l \"$applogs\\solidworks_2016-remote_debugger.txt\"",
	# Visual Basic
	# NOTE: Despite the fact there are a million vba71 files, we need only install
	#   vba71.msi. All the others are localized versions.
	# Visual Basic does not install correctly.
	"12 - Visual Basic 7.1"
	=&gt; "msiexec /i \"$appdeploy\\Microsoft_VBA_1033\\vba71_1033.msi\" /quiet /qn /log \"$applogs\\solidworks_2016-VisualBasic.log\" /norestart",
	"13 - .NET Framework 4.5.2"
	=&gt; "\"$appdeploy\\.Net_Framework_4.5.2\\NDP452-KB2901907-x86-x64-AllOS-ENU.exe\" /q /log \"$applogs\\solidworks_2016-dotnet_45.log\" /norestart",
	"14 - Bonjour"
	=&gt; "msiexec /i \"$appdeploy\\Bonjour\\Bonjour64.msi\" /quiet /qn /log \"$applogs\\solidworks_2016-bonjour.log\" /norestart",
);

my %installs  = (
	"00 - SolidWorks 2016" =&gt; $inst_command_sw,
	"01 - eDrawings" =&gt; $inst_command_ed,
	"02 - Flow Simulation" =&gt; $inst_command_fs,
);
################################################################################
################################################################################
sub preinstall {
	# This registry hack is required to make Solidworks 2016 install correctly,
	#   because of a specific Windows Update.
	# Without it, it will fail to run properly.
	# This change is undone at postinstall.
	output("Temporary registry fix: ");
	$HKEY_LOCAL_MACHINE -&gt; Create($reg, $handle);
	$handle -&gt; SetValueEx($dword_name,0,REG_DWORD(),1);
	output("Successful\n\n");

	output("Preinstalls: \n\n");

	foreach my $key (sort keys %prereqs_installs) {
		output("$key:\n  " . $prereqs_installs{$key} . "\n  Result: ");
		my $success = run_command($prereqs_installs{$key}, 'IgnoreExitCodes' =&gt; [3010]);
		if ($success != 1) {
			output("Failed: $success $!\n");
			return 0;
		}

		output("Succeeded\n\n");
	}
	output("Preinstall succeeded.\n");
	return 1;
}
################################################################################
################################################################################
sub install {
	output("\nMain installs: \n\n");

	foreach my $key (sort keys %installs) {
		output("$key:\n  " . $installs{$key} . "\n  Result: ");
		my $success = run_command($installs{$key}, 'IgnoreExitCodes' =&gt; [3010]);
		if ($success != 1) {
			output("Failed: $success $!\n");
			return 0;
		}

		output("Succeeded\n\n");
	}
	output("Installs succeeded.\n");
	return 1;
}
################################################################################
################################################################################
sub postinstall {
	# Undoing the registry fix.
	output("\nRegistry fix cleanup: ");
	$HKEY_LOCAL_MACHINE -&gt; Open($reg_parent, $handle);
	$handle -&gt; DeleteKey("Installer");
	output("Successful\n\n");
  
	if (!create_activesetup_action(
			 'Identifier' =&gt; 'Solidworks2016_fixshortcut_20160901',
			 'ComponentID' =&gt; 'Solidworks2016x64',
			 'Description' =&gt; 'Remove shortcut autocreated on user desktop',
			 'Version' =&gt; '2016',
			 'StubPath' =&gt; "\%COMSPEC\% /c DEL /Q \"\%USERPROFILE\%\\Desktop\\SOLIDWORKS 2016 x64 Edition.lnk\"",
		)) {
		output("     Error: cannot create Active Setup action to delete desktop icon.\n");
		return 0;
	}
	if (!create_activesetup_action(
			 'Identifier' =&gt; 'eDrawings2016_fixshortcut_20160901',
			 'ComponentID' =&gt; 'eDrawings2016x64',
			 'Description' =&gt; 'Remove shortcut autocreated on user desktop',
			 'Version' =&gt; '2016',
			 'StubPath' =&gt; "\%COMSPEC\% /c DEL /Q \"\%USERPROFILE\%\\Desktop\\.eDrawings 2016 x64 Editionlnk\"",
		)) {
		output("     Error: cannot create Active Setup action to delete desktop icon.\n");
		return 0;
	}
	return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    need_reboot =&gt; 1,
);



</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\solidworks.2017\prod\update.pl</FullName>
    <Length>4008</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-22T09:53:58.710856-05:00</CreationTime>
    <CreationTimeUtc>2017-06-22T14:53:58.710856Z</CreationTimeUtc>
    <LastWriteTime>2018-06-20T12:58:43.3049958-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-20T17:58:43.3049958Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-22T09:53:58.710856-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-22T14:53:58.710856Z</LastAccessTimeUtc>
    <Text># Solidworks 2017
# Created by Daniel T. Holtzclaw
# Last Updated by Chris Schaaf
# Trying a new method that uses an admin install instead of the messy one from
#   before. This should be smaller and (hopefully) lighter.

# 2017-06 | cts28d
# The startswinstall option to run the admin image installer works fine, but
#	must be copied to the machine to be run on first due to Windows' 256-char
#	path limit

=pod

Begin-Doc
Modified: $Date: 2017-06-07 (June 7, 2017) $
Name: SolidWorks 2017 Installer
Type: script
Description:
Language: Perl
RCSId: $Id: update.pl 712 2011-06-10 21:20:17Z thartman $
Comments:
  In comparison to older SolidWorks installs, 2017 has different prereqs and
    has the ability to run from an admin installation. This is an attempt at
    that.
End-Doc

=cut

use strict;
use warnings;
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'solidworks.2017',
        package_revision =&gt; '20170622T1507',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use File::Spec;
use File::Basename;
use File::Path;
use File::Copy;
use Getopt::Long;
use Win32::Registry;
use Data::Dumper;

# All Variables (except success values):

my $reg = 'Software\Policies\Microsoft\Windows\Installer';
my $reg_parent = 'Software\Policies\Microsoft\Windows';
my $handle = "";
my $dword_name = "RemappedElevatedProxiesPolicy";

my $src = get_pkg_sourcefiles();
my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\software\\itwindist\\appdeploy\\solidworks.2017\\SOLIDWORKS 2017 SP3.0";

################################################################################
################################################################################
sub preinstall {
	# This registry hack is required to make Solidworks 2017 install correctly,
	#   because of a specific Windows Update.
	# Without it, it will fail to run properly.
	# This change is undone at postinstall.
	output("Temporary registry fix: ");
	$HKEY_LOCAL_MACHINE -&gt; Create($reg, $handle);
	$handle -&gt; SetValueEx($dword_name,0,REG_DWORD(),1);
	output("Successful\n\n");
	output("Copying admin image (13GB): ");
	if(!run_command("robocopy \"$appdeploy\" \"$src\" /E", 'IgnoreExitCodes' =&gt; [1, 2, 3])){
		output("FAIL: $!\n");
		return 0;
	}
	output("OK\n");
	return 1;
}
################################################################################
################################################################################
sub install {
	output("\nRunning admin installer: \n");
	my $success = run_command("\"$src\\startswinstall.exe\" /now", 'IgnoreExitCodes' =&gt; [3010]);
	if (!$success) {
		output("FAIL: $!\n");
		return 0;
	}
	output("OK\n");
	return 1;
}
################################################################################
################################################################################
sub postinstall {
	# Undoing the registry fix.
	output("\nRegistry fix cleanup: ");
	$HKEY_LOCAL_MACHINE -&gt; Open($reg_parent, $handle);
	$handle -&gt; DeleteKey("Installer");
	output("Successful\n\n");

	my $desk = get_allusers_desktop();
	run_command("DEL /Q \"$desk\\SOLIDWORKS 2017.lnk\"");
	run_command("DEL /Q \"$desk\\eDrawings 2017 x64 Edition.lnk\"");
	run_command("DEL /Q \"$desk\\SOLIDWORKS Composer Player 2017.lnk\"");
	run_command("DEL /Q \"$desk\\SOLIDWORKS Electrical.lnk\"");
	run_command("DEL /Q \"$desk\\SOLIDWORKS Visualize 2017.lnk\"");

	return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    need_reboot =&gt; 1,
);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\solidworks.2018\prod\update.pl</FullName>
    <Length>3707</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-23T10:07:17.7397744-05:00</CreationTime>
    <CreationTimeUtc>2018-05-23T15:07:17.7397744Z</CreationTimeUtc>
    <LastWriteTime>2018-06-25T11:02:06.7571224-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-25T16:02:06.7571224Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-23T10:07:17.7397744-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-23T15:07:17.7397744Z</LastAccessTimeUtc>
    <Text># Solidworks 2018
# Created by Daniel T. Holtzclaw
# Last Updated by Cameron Loren (2018-06-20)
# Trying a new method that uses an admin install instead of the messy one from
#   before. This should be smaller and (hopefully) lighter.

# 2017-06 | cts28d
# The startswinstall option to run the admin image installer works fine, but
#	must be copied to the machine to be run on first due to Windows' 256-char
#	path limit


use strict;
use warnings;
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'solidworks.2018',
        package_revision =&gt; '20180620T1255',
    );
}
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use File::Spec;
use File::Basename;
use File::Path;
use File::Copy;
use Getopt::Long;
use Win32::Registry;
use Data::Dumper;

# All Variables (except success values):

my $reg = 'Software\Policies\Microsoft\Windows\Installer';
my $reg_parent = 'Software\Policies\Microsoft\Windows';
my $handle = "";
my $dword_name = "RemappedElevatedProxiesPolicy";

my $src = get_pkg_sourcefiles();
my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\software\\itwindist\\appdeploy\\solidworks.2018\\SOLIDWORKS 2018 SP3.0";

################################################################################
################################################################################
sub preinstall {
	# This registry hack is required to make Solidworks 2018 install correctly,
	#   because of a specific Windows Update.
	# Without it, it will fail to run properly.
	# This change is undone at postinstall.
	output("Temporary registry fix: ");
	$HKEY_LOCAL_MACHINE -&gt; Create($reg, $handle);
	$handle -&gt; SetValueEx($dword_name,0,REG_DWORD(),1);
	output("Successful\n\n");
	output("Copying admin image (17GB): ");
	if(!run_command("robocopy \"$appdeploy\" \"$src\" /E", 'IgnoreExitCodes' =&gt; [1, 2, 3])){
		output("FAIL: $!\n");
		return 0;
	}
	output("OK\n");
	return 1;
}
################################################################################
################################################################################
sub install {
	output("\nRunning admin installer: \n");
	my $success = run_command("\"$src\\startswinstall.exe\" /now", 'IgnoreExitCodes' =&gt; [3010]);
	if (!$success) {
		output("FAIL: $!\n");
		return 0;
	}
	output("OK\n");
	return 1;
}
################################################################################
################################################################################
sub postinstall {
	# Undoing the registry fix.
	output("\nRegistry fix cleanup: ");
	$HKEY_LOCAL_MACHINE -&gt; Open($reg_parent, $handle);
	$handle -&gt; DeleteKey("Installer");
	output("Successful\n\n");

	my $desk = get_allusers_desktop();
	run_command("DEL /Q \"$desk\\SOLIDWORKS 2018.lnk\"");
	run_command("DEL /Q \"$desk\\eDrawings 2018 x64 Edition.lnk\"");
	run_command("DEL /Q \"$desk\\SOLIDWORKS Composer Player 2018.lnk\"");
	run_command("DEL /Q \"$desk\\SOLIDWORKS Electrical.lnk\"");
	run_command("DEL /Q \"$desk\\SOLIDWORKS Visualize 2018.lnk\"");
  run_command("DEL /Q \"$desk\\SOLIDWORKS Manage 2018.lnk\"");

	return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    need_reboot =&gt; 1,
);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\spotify\prod\update.pl</FullName>
    <Length>0</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-02-13T08:27:03.5833894-06:00</CreationTime>
    <CreationTimeUtc>2018-02-13T14:27:03.5833894Z</CreationTimeUtc>
    <LastWriteTime>2018-05-02T11:29:57.1044248-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-02T16:29:57.1044248Z</LastWriteTimeUtc>
    <LastAccessTime>2018-02-13T08:27:03.630286-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-02-13T14:27:03.630286Z</LastAccessTimeUtc>
    <Text />
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\spss.24\dev\update.pl</FullName>
    <Length>6210</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-08T15:09:44.6348838-05:00</CreationTime>
    <CreationTimeUtc>2017-06-08T20:09:44.6348838Z</CreationTimeUtc>
    <LastWriteTime>2017-06-22T14:54:16.6145154-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-22T19:54:16.6145154Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-15T13:19:29.397731-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-15T18:19:29.397731Z</LastAccessTimeUtc>
    <Text># Package Name: SPSS 24
# Package Created June 15, 2017
# Packaged By Jason S. Holm (Using code from previous version)
# Last Updated: Never

# Software and Perl File Location(s)
#
# "R:\Software\itwindist\win10\appdist\spss.24\prod\update.pl"
#
# R:\Software\itwindist\win10\appdist\spss.24\prod\data\campus_license.txt
# R:\Software\itwindist\win10\appdist\spss.24\prod\data\firewallexceptions.txt
# R:\Software\itwindist\win10\appdist\spss.24\prod\data\logfile.txt
# R:\Software\itwindist\win10\appdist\spss.24\prod\data\SPSS_Amos_24_win32.exe
# R:\Software\itwindist\win10\appdist\spss.24\prod\data\SPSS_Statistics_24.msi
# R:\Software\itwindist\win10\appdist\spss.24\prod\data\SPSS_Statistics_24_win64.exe

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;
use Win32::TieRegistry;
use Getopt::Long;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'SPSS.24',
        package_revision =&gt; '20170620T1118',
    );
}

# Add InstallMonkey Library to the path
my $umrinst = $ENV{'WINDIR'}.'\SYSTEM32\UMRINST';
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    '$umrinst',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;


use Getopt::Long;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'SPSS.24',
        package_revision =&gt; '20170620T1118',
    );
}

# Add InstallMonkey Library to the path
my $umrinst = $ENV{'WINDIR'}.'\SYSTEM32\UMRINST';
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    '$umrinst',
    'C:\temp',
);
# use InstallMonkey::Shared;
use Getopt::Long;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

GetOptions(
    'uninstall' =&gt; sub { exit(!uninstall()); },
);


# Need to find where the application ID for:
#   SPSS24
#   AMOS24

sub uninstall
{
    my $success = 1;

    output("Uninstalling SPSS: ");
    my $uninstall_log = get_package_id().'_uninstall.txt';
    $success &amp;=
        install_msi(
            'app_id'              =&gt; '{C3BA73A4-2A45-4036-8541-4F5F8146078B}', # SPSS
            'msi_action_flag'     =&gt; 'x',
            'logfile_name'        =&gt; $uninstall_log,
        );
    output("OK\n");

	
	    output("Uninstalling Amos: ");
    $uninstall_log = get_package_id().'-amos_uninstall.txt';
    $success &amp;=
        install_msi(
            'app_id'              =&gt; '{2B603859-DCA2-45DD-92DF-98542E78BAA8}', # Amos
            'msi_action_flag'     =&gt; 'x',
            'logfile_name'        =&gt; $uninstall_log,
            'logfile_indirection' =&gt; 1,
        );
    output("OK\n");
    if($success)
    {
        delete_product_registry_key(get_package_id());
    }

    return $success;
}


sub install
{
        # my $temp_log_spss = $ENV{'WINDIR'}."\\temp\\spss-24-main.txt";
        # Should this be...
        my $temp_log_location = "\\temp\\spss_24_main.txt";
        my $temp_log_spss = $ENV{'WINDIR'}.$temp_log_location;
        chomp($temp_log_spss);

		
		
		
		
		    my @command = (
                   "msiexec.exe /i",
                   "\"$srcfiles\\SPSS_Statistics_24.msi\"",
                   "/qn",
                   "/norestart",
                   "INSTALLPYTHON=\"1\"",
                   "ENABLE_JAB=\"1\"",
                   "COMPANYNAME=\"Missouri S&amp;T\"",
                   "DISABLE_COMMUTE=\"1\"",
                   "LICENSETYPE=\"Network\"",
                   "LSHOST=\"spss.lic.mst.edu\"",
                   "/L*V \"$temp_log_spss\"",
                  );
    # This was inside the @command at the bottom...removed for testing.
    # "/L*V \"$temp_log_spss\"", #

    output("Installing SPSS 24: ");
    if(!run_command(join(' ',@command)))
    {
     return 0;
    }
    output("Success!\n");





    my $temp_log_amos_location = "\\temp\\spss_24_amos.txt";
    my $temp_log_amos = $ENV{'WINDIR'}.$temp_log_amos_location;
    chomp($temp_log_amos);


    @command = (
        "$srcfiles\\SPSS_Amos_24_win32.exe /S /V\" /qn",
		"/l* \"$temp_log_amos\"",
        "/norestart",
        "LICENSETYPE=\"Network\"",
        "LSHOST=\"spss.lic.mst.edu\"",
        "DISABLE_COMMUTE=1\"",
    );
    # This was inside the @command between $srcfiles and /norestart
        # "/l* \"$temp_log_amos\"",
    output("Installing Amos 24: ");
    if(!run_command(join(' ',@command)))
    {
     return 0;
    }
    output("Success!\n");

        # Changed such that the two log files are not copied into the same file...I think this might have caused an error that SCCM
        # failed the installed...and for the mooment, both lines are on hold for testing.

		run_command("copy $temp_log_spss $log_dir /y");
        run_command("copy $temp_log_amos $log_dir /y");

    return 1;
}

sub postinstall {

    # I copied these firewall rules from the last package, just prevents java confirmation dialog
    run_command("netsh -f $srcfiles\\firewallexceptions.txt");

    my $LSHOST = $ENV{'LSHOST'};
    if( !defined($LSHOST) )
    {
        run_command("setx /m LSHOST spss.lic.mst.edu");
    }
    elsif( $LSHOST !~ /spss.lic.mst.edu/ )
    {
        run_command("setx /m LSHOST \"$LSHOST:spss.lic.mst.edu:\"");
    }

    return 1;
}

do_install(
    allowed_versions =&gt; ['OSVER_WIN7_SP0', 'OSVER_WIN7_SP1', 'OSVER_WIN10_SP0'],
    allowed_os_architectures =&gt; ['x64'],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    # prerequisite_sub =&gt; \&amp;prerequisite,
    # preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit('EXIT_SUCCESS');



		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	
	


















</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\spss.24\prod\update.pl</FullName>
    <Length>4369</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-15T13:37:17.109639-05:00</CreationTime>
    <CreationTimeUtc>2017-06-15T18:37:17.109639Z</CreationTimeUtc>
    <LastWriteTime>2017-08-15T16:11:41.290449-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-08-15T21:11:41.290449Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-22T16:02:27.0479179-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-22T21:02:27.0479179Z</LastAccessTimeUtc>
    <Text># Package Name: SPSS 24
# Package Created: June 15, 2017
# Packaged By: Jason S. Holm
# Updated: June 26, 2017 (Jason S. Holm): Updated Code to Strict.
# Updated: August 15, 2017 (Jason S. Holm): Removed Win7 SP0 and SP1 as allowed versions.
# Updated: August 15, 2017 (Jason S. Holm): Corrected list items that should not have single quotes...need to review this coding standard.


=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;
use Win32::TieRegistry;

use Getopt::Long;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'SPSS.24',
        package_revision =&gt; '20170815T1518',
    );
}

# Add InstallMonkey Library to the path - 201706261017 added extra backslashes.
my $umrinst = $ENV{'WINDIR'}.'\\SYSTEM32\\UMRINST';
use lib (
    '\\\\minerfiles.mst.edu\\dfs\\software\\loginscripts\\im',
    '$umrinst',
    'C:\\temp',
);

use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();


# SPSS Install

sub install
{
    my $temp_log_location = "\\temp\\spss_24_main.txt";
	my $temp_log_spss = $ENV{'WINDIR'}.$temp_log_location;
	chomp($temp_log_spss);

        my @command_spss = (
               "msiexec.exe /i",
               "\"$srcfiles\\SPSS_Statistics_24.msi\"",
		       "/qn",
		       "/norestart",
		       "INSTALLPYTHON=\"1\"",
		       "ENABLE_JAB=\"1\"",
		       "COMPANYNAME=\"Missouri S&amp;T\"",
               "DISABLE_COMMUTE=\"1\"",
               "LICENSETYPE=\"Network\"",
               "LSHOST=\"spss.lic.mst.edu\"",
               "/L*V \"$temp_log_spss\"",
              );
	
        output("Installing SPSS 24: ");
        if(!run_command(join(' ',@command_spss)))
        {
		 print "Failed! Could not install SPSS 24!\n";
         return 0;
        }
		else
		{
         output("Success! SPSS installed!\n\n");
		 output("Now attempting to install AMOS...\n");
		 
		 
		 # AMOS Install Portion
	
         # my $temp_log_amos_location = "\\temp\\spss_24_amos.txt";	
         # my $temp_log_amos = $ENV{'WINDIR'}.$temp_log_amos_location;
         # chomp($temp_log_amos);

	
         my @command_amos = (
               "$srcfiles\\SPSS_Amos_24_win32.exe /S /V\" /qn",
               "/norestart",
               "LICENSETYPE=\"Network\"",
               "LSHOST=\"spss.lic.mst.edu\"",
               "DISABLE_COMMUTE=1\"",
              );

         output("Installing Amos 24: ");
         if(!run_command(join(' ',@command_amos)))
         {
		  print "Failed! Could not install Amos 24!\n";
          return 0;
         }
		 else
		 {
          output("Success! AMOS installed!\n\n");
		  output("Both SPSS and AMOS are now installed!\n\n");
		 }
		}
			

    run_command("copy $temp_log_spss $log_dir /y");
	# run_command("copy $temp_log_amos $log_dir /y");

    return 1;
}

sub postinstall {

    output("Making update to firewall rules such that the user does not get a java dialog box or alert...");
    # I copied these firewall rules from the last package, just prevents java confirmation dialog
    run_command("netsh -f $srcfiles\\firewallexceptions.txt");
	output("done!\n\n");
	
	output("Checking if license server host information is set...");
	
    my $LSHOST = $ENV{'LSHOST'};
    if( !defined($LSHOST) )
    {
	    output("no. Correcting...\n");
		output("Setting host as spss.lic.mst.edu...");
        run_command("setx /m LSHOST spss.lic.mst.edu");
		output("done!\n");
    }
    elsif( $LSHOST !~ /spss.lic.mst.edu/ )
    {
	    output("host information does exist, but SPSS was not specified...fixing...");
        run_command("setx /m LSHOST \"$LSHOST:spss.lic.mst.edu:\"");
		output("done!\n");
    }
    else
	{
	 output("interesting...the license server for SPSS was already specified.\n\n");
	}
    return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    # prerequisite_sub =&gt; \&amp;prerequisite,
    # preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\spss.25\prod\update.pl</FullName>
    <Length>2976</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-07-09T09:21:17.1859153-05:00</CreationTime>
    <CreationTimeUtc>2018-07-09T14:21:17.1859153Z</CreationTimeUtc>
    <LastWriteTime>2018-07-09T10:16:29.500929-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-09T15:16:29.500929Z</LastWriteTimeUtc>
    <LastAccessTime>2018-07-09T09:21:17.1859153-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-07-09T14:21:17.1859153Z</LastAccessTimeUtc>
    <Text># Package Name: SPSS 25
# Package Created: July 9th, 2018
# Packaged By: Cameron Loren

use strict;
use warnings;
use Win32::TieRegistry;
use Getopt::Long;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'SPSS.25',
        package_revision =&gt; '20180709T0936',
    );
}

# Add InstallMonkey Library to the path - 201706261017 added extra backslashes.
my $umrinst = $ENV{'WINDIR'}.'\\SYSTEM32\\UMRINST';
use lib (
    '\\\\minerfiles.mst.edu\\dfs\\software\\loginscripts\\im',
    '$umrinst',
    'C:\\temp',
);

use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();


# SPSS Install
sub install
{
    my $temp_log_location = "\\temp\\spss_25_main.txt";
	  my $temp_log_spss = $ENV{'WINDIR'}.$temp_log_location;
    chomp($temp_log_spss);

    my @command_spss = (
               "msiexec.exe /i",
               "\"$srcfiles\\SPSS_Statistics_25.msi\"",
		       "/qn",
		       "/norestart",
		       "INSTALLPYTHON=\"1\"",
		       "ENABLE_JAB=\"1\"",
		       "COMPANYNAME=\"Missouri S&amp;T\"",
               "DISABLE_COMMUTE=\"1\"",
               "LICENSETYPE=\"Network\"",
               "LSHOST=\"spss.lic.mst.edu\"",
               "/L*V \"$temp_log_spss\"",
              );

    output("Installing SPSS 25: ");
    if(!run_command(join(' ',@command_spss)))
    {
		  print "Failed! Could not install SPSS 25!\n";
      return 0;
    }
		else
		{
      output("Both SPSS 25 is now installed!\n\n");
		}
    run_command("copy $temp_log_spss $log_dir /y");
    return 1;
}

sub postinstall
{

    output("Making update to firewall rules such that the user does not get a java dialog box or alert...");
    # I copied these firewall rules from the last package, just prevents java confirmation dialog
    run_command("netsh -f $srcfiles\\firewallexceptions.txt");
	  output("done!\n\n");

    output("Checking if license server host information is set...");

    my $LSHOST = $ENV{'LSHOST'};
    if( !defined($LSHOST) )
    {
	    output("no. Correcting...\n");
		  output("Setting host as spss.lic.mst.edu...");
      run_command("setx /m LSHOST spss.lic.mst.edu");
		  output("done!\n");
    }
    elsif( $LSHOST !~ /spss.lic.mst.edu/ )
    {
	    output("host information does exist, but SPSS was not specified...fixing...");
      run_command("setx /m LSHOST \"$LSHOST:spss.lic.mst.edu:\"");
		  output("done!\n");
    }
    else
  	{
  	 output("interesting...the license server for SPSS was already specified.\n\n");
  	}
    return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    # prerequisite_sub =&gt; \&amp;prerequisite,
    # preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\srod.8_2\prod\update.pl</FullName>
    <Length>1350</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-16T13:06:09.3588566-05:00</CreationTime>
    <CreationTimeUtc>2018-05-16T18:06:09.3588566Z</CreationTimeUtc>
    <LastWriteTime>2018-05-18T13:30:23.8576861-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-18T18:30:23.8576861Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-16T13:06:09.3588566-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-16T18:06:09.3588566Z</LastAccessTimeUtc>
    <Text># SROD
# Package Created May 16th, 2018
# Packaged by Cameron Loren
# Last Updated --

BEGIN {
    %::INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'srod.8_2',
        package_revision =&gt; '20180516T0106',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

sub install {
    if(!run_command("$srcfiles\\Setup.exe /silent"))
    {
        output("Installation failed!\n");
        return 0;
    }

    output("Installation successful!");

    return 1;
}

sub post {
  output("Removing icons from public: ");
  my $Remove1 = run_command("del \"%systemdrive%\\Users\\Public\\Desktop\\SROD.lnk\" /Q");
  output($Remove1 ? "Success!\n" : "FAILED: $!\n");

  return ($Remove1 || $Remove2);
}

do_install(
    exit_on_failure =&gt; 1,
    allowed_versions          =&gt; [ OSVER_WIN10_SP0 ],
    allowed_os_architectures  =&gt; [ OSARCH_x64 ],
    allowed_regs              =&gt; [ "clc", "desktop", "traveling", "virtual-desktop", "virtual-clc" ],
    install_sub               =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;post,

);

IM_Exit(EXIT_SUCCESS);

########################################################################
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\star_ccm.11_02_010\prod\update.pl</FullName>
    <Length>2139</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-05-31T13:24:23.7065854-05:00</CreationTime>
    <CreationTimeUtc>2016-05-31T18:24:23.7065854Z</CreationTimeUtc>
    <LastWriteTime>2016-07-08T13:34:03.6016197-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-07-08T18:34:03.6016197Z</LastWriteTimeUtc>
    <LastAccessTime>2016-05-31T13:24:23.7065854-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-05-31T18:24:23.7065854Z</LastAccessTimeUtc>
    <Text># Star CCM 11.02.010
# Package Created May 2016
# Package created by Ronith (based on Ray Morgan's)
# Last Updated ...

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS =
    (
        package_id =&gt; 'star_ccm.11_02_010',
        package_revision =&gt; '20160531T1300',
    );
}


use lib
(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);


use InstallMonkey::Shared;


my $srcfiles = get_pkg_sourcefiles();

sub install
{
    output("Installing STAR-CCM+.\nThis will take a while.");
    my $params = "-i silent -f $srcfiles\\setup.txt";

    if(!run_command("$srcfiles\\STAR-CCM+_CadClients11.02.010.exe $params"))
    {
        output("\n");
        output("Error installing STAR-CCM+.  Please check the logs.");
        output("\n");

        return 0;
    }
    return 1;
}

sub postinstall
{
    run_command("netsh advfirewall firewall add rule \"allow STAR-CCM+\" dir=in action=allow program=\"C:\\program files\\cd-adapco\\star-ccm+11.02.010\\star\\lib\\win64\\intel12.1\\lib\\star-ccm+.exe\" enable=yes profile=domain");
    output("Deleting desktop icons...");
    my $desktop = get_allusers_desktop();
    run_command("DEL /Q \"$desktop\\STAR-CCM+ 11.02.010 for Windows 64.lnk\"");
    run_command("DEL /Q \"$desktop\\STAR-View+ 11.02.010 for Windows 64.lnk\"");
    run_command("setx CDLMD_LICENSE_FILE 1791\@cd-adapco.lic.mst.edu -m");
}

do_install
(
    allowed_versions =&gt; [ OSVER_WIN10_SP0, OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [ 'desktop', 'clc', 'traveling', 'virtual-desktop',
                        'virtual-clc' ],

    exit_on_failure =&gt; 1,
    need_reboot =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);


IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\stimplan.7_2\prod\update.pl</FullName>
    <Length>3445</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-07-21T09:54:33.5088828-05:00</CreationTime>
    <CreationTimeUtc>2017-07-21T14:54:33.5088828Z</CreationTimeUtc>
    <LastWriteTime>2017-10-30T09:58:03.9779597-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-10-30T14:58:03.9779597Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-21T09:54:33.5088828-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-21T14:54:33.5088828Z</LastAccessTimeUtc>
    <Text># StimPlan 7.2
# Package Created July 2017
# Packaged by Charlie Hendricks for 6.11
# Updated by Grayson Gratop for 7.02
# Updated by Sergey Gruzdev for 7.2
# Last Updated 2017-7-21

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;
use Getopt::Long;

GetOptions(
    'uninstall' =&gt; sub { exit(!uninstall()); },
);

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'stimplan.7_02',
        package_revision =&gt; '20151029T1457',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Win32::TieRegistry( Delimiter=&gt;"/");

my $sourcefilesdir = get_pkg_sourcefiles();

sub install 
{
  # Set system variable
  $Registry-&gt;{"HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Control/Session Manager/Environment//NSITECHN_LICENSE_FILE"} = "1727\@stimplan.lic.mst.edu";  # Run the installer in silent mode  
  
  output("Installing StimPlan 3D 7.2:");
  if(!run_command("$sourcefilesdir\\StimPlan_Network_Lic_V720_SETUP.exe /SILENT /HIDE"))
  {
    # Rip
	print "FAILED!\n";
	return 0;
  }
  print "Success!\n";
  return 1;
}

sub postinstall {

  ####
  #Copy license file stuff
  ####

  run_command("mkdir C:\\flexlm");

  if (!run_command("copy $sourcefilesdir\\license.dat C:\\flexlm")) {
    output("File copy for license.dat has failed!\n");
    return 0;
  }
  else {
    output("license.dat file has been copied the C:\\flexlm directory.\n");
  }


  if (!run_command("copy $sourcefilesdir\\ID.nsi \"C:\\Program Files (x86)\\NSI Technologies\\StimPlan\"")) {
    output("File copy for ID.nsi file failed!\n");
    return 0;
  }
  else {
    output("ID.nsi file has been copied to install directory.\n");
  }

  ####
  #Remove desktop icons from everywhere
  ####

  opendir(DIR, 'C:\\Users');
  my @users = grep { (!/^\.\.?$/) &amp;&amp; (-d "C:\\Users\\$_") &amp;&amp; ($_ ne 'Default') } readdir(DIR);
  closedir(DIR);

  foreach my $place (@users) {
    run_command("DEL /Q \"C:\\Users\\$place\\Desktop\\StimPlan 3D 7.20.lnk\"");
  }

  output("Desktop icons removed.\n");

  ####
  #Remove uninstall shortcut in Start Menu
  ####

  #if (!run_command("DEL /Q \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StimPlan 3D\\Uninstall StimPlan 3D 7.20.lnk\"")) {
  #  output("Could not delete uninstall shortcut in the Start Menu for some reason...\n");
  #}
  #output("Start Menu uninstall shortcut removed.\n");

  return 1;
}

sub uninstall {
  output("Uninstallating StimPlan 3D 7.2...\n");
  if (run_command('"C:\\Program Files (x86)\\NSI Technologies\\StimPlan_Network_Lic_V720_SETUP_19974.exe" /SILENT /HIDE')) {
    delete_product_registry_key(get_package_name().".".get_version());
  }
  else {
    return 0;
  }

  return 1;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x86, OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
   postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\stk.10_13\dev\update.pl</FullName>
    <Length>3981</Length>
    <Extension>.pl</Extension>
    <CreationTime>2015-11-19T14:13:27.607236-06:00</CreationTime>
    <CreationTimeUtc>2015-11-19T20:13:27.607236Z</CreationTimeUtc>
    <LastWriteTime>2015-11-19T15:10:45.8417936-06:00</LastWriteTime>
    <LastWriteTimeUtc>2015-11-19T21:10:45.8417936Z</LastWriteTimeUtc>
    <LastAccessTime>2015-11-19T14:13:27.607236-06:00</LastAccessTime>
    <LastAccessTimeUtc>2015-11-19T20:13:27.607236Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Package Created November 2015
# Packaged by Dzu Pham
# Last Updated 11/10/10

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'stk.10_1.3',

        # some unique id that's updated any time the package undergoes
        #  any sort of minor revision
        package_revision =&gt; '20151118T1111',

#         # if different from default location
#         output_log =&gt; 'path_to_output_log',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
my $cwd = cwd();
my $applogs=get_applogs_dir();
my $pgfiles=$ENV{"ProgramFiles"};
my $pgfilesx86=$ENV{"ProgramFiles(x86)"};
my $audesktop=$ENV{"public"}."\\desktop";
my $pgdata=$ENV{"ProgramData"};

sub preinstall {
 	run_command("start /wait \"\" \"$sourcefilesdir\\Prerequirements\\Microsoft\\vcredist\\v2008\\vcredist_x86.exe\" /q");
 	run_command("start /wait \"\" \"$sourcefilesdir\\Prerequirements\\Microsoft\\vcredist\\v2008\\x64\\vcredist_x64.exe\" /q");
 	run_command("start /wait \"\" \"$sourcefilesdir\\Prerequirements\\Microsoft\\VSRedist\\PIA\\9.0.21022\\vs90_piaredist.exe\" /q");
 	run_command("start /wait \"\" msiexec /qn /i \"$sourcefilesdir\\Prerequirements\\Microsoft\\msxml6\\v6.0.0.0\\msxml6.msi\" /l* \"$applogs\\msxml6.stk.9_2.txt\"");
 	run_command("start /wait \"\" msiexec /qn /i \"$sourcefilesdir\\Prerequirements\\Microsoft\\msxml6\\v6.0.0.0\\msxml6_x64.msi\" /l* \"$applogs\\msxml6_x64.stk.9_2.txt\"");
 	run_command("start /wait \"\" \"$sourcefilesdir\\STK_License_Manager\\v3.0.11\\setup.exe\" /S /v/qn");

 	return 1;
}

 sub install {
   output("Installing STK 10.1.3: \n");
   output((run_command("start /wait \"\" \"$sourcefilesdir\\STK\\setup.exe\" /S /V/qn")?"OK":"FAILED").."\n");
   output((run_command("copy \"$cwd\\license.lic\" \"$pgdata\\AGI\\LicenseData\" /y")?"OK":"FAILED").."\n");
	 run_command("del /q \"$audesktop\\STK 10.lnk\"");
	 run_command("del /q \"$audesktop\\STK Viewer 10.lnk\"");
	 return 1;
 }

sub postinstall {
	run_command("netsh advfirewall firewall add rule name=\"STK 10\" dir=in action=allow program=\"C:\\Program Files (x86)\\agi\\stk 10\\bin\\aguiapplication.exe\"");
	run_command("netsh advfirewall firewall add rule name=\"STK 10\" dir=out action=allow program=\"C:\\Program Files (x86)\\agi\\stk 10\\bin\\aguiapplication.exe\"");
	run_command("copy \"$sourcefilesdir\\activesetup.cmd\" \"$pgfilesx86\\AGI\\STK 10\"");


	if (!create_activesetup_action(
             'Identifier' =&gt; 'STK_10.1.3_Folder_Creation',
             'ComponentID' =&gt; 'STK10.1.3',
             'Description' =&gt; 'Creates STK 10.1.3 folder in user\'s documents folder so new user setup does not fail',
             'Version' =&gt; '10.1.3',
             'StubPath' =&gt; "\"C:\\Program Files (x86)\\AGI\\STK 10\\activesetup.cmd\"",
        )) {
        output("     Error: cannot create Active Setup action.\n");
        return 0;
    }

	return 1;
 }

do_install(
    allowed_versions =&gt; [OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,

);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\stk.10_13\prod\update.pl</FullName>
    <Length>3981</Length>
    <Extension>.pl</Extension>
    <CreationTime>2015-12-18T15:32:07.3598597-06:00</CreationTime>
    <CreationTimeUtc>2015-12-18T21:32:07.3598597Z</CreationTimeUtc>
    <LastWriteTime>2015-11-19T15:10:45.8417936-06:00</LastWriteTime>
    <LastWriteTimeUtc>2015-11-19T21:10:45.8417936Z</LastWriteTimeUtc>
    <LastAccessTime>2015-12-18T15:32:07.3598597-06:00</LastAccessTime>
    <LastAccessTimeUtc>2015-12-18T21:32:07.3598597Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Package Created November 2015
# Packaged by Dzu Pham
# Last Updated 11/10/10

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'stk.10_1.3',

        # some unique id that's updated any time the package undergoes
        #  any sort of minor revision
        package_revision =&gt; '20151118T1111',

#         # if different from default location
#         output_log =&gt; 'path_to_output_log',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
my $cwd = cwd();
my $applogs=get_applogs_dir();
my $pgfiles=$ENV{"ProgramFiles"};
my $pgfilesx86=$ENV{"ProgramFiles(x86)"};
my $audesktop=$ENV{"public"}."\\desktop";
my $pgdata=$ENV{"ProgramData"};

sub preinstall {
 	run_command("start /wait \"\" \"$sourcefilesdir\\Prerequirements\\Microsoft\\vcredist\\v2008\\vcredist_x86.exe\" /q");
 	run_command("start /wait \"\" \"$sourcefilesdir\\Prerequirements\\Microsoft\\vcredist\\v2008\\x64\\vcredist_x64.exe\" /q");
 	run_command("start /wait \"\" \"$sourcefilesdir\\Prerequirements\\Microsoft\\VSRedist\\PIA\\9.0.21022\\vs90_piaredist.exe\" /q");
 	run_command("start /wait \"\" msiexec /qn /i \"$sourcefilesdir\\Prerequirements\\Microsoft\\msxml6\\v6.0.0.0\\msxml6.msi\" /l* \"$applogs\\msxml6.stk.9_2.txt\"");
 	run_command("start /wait \"\" msiexec /qn /i \"$sourcefilesdir\\Prerequirements\\Microsoft\\msxml6\\v6.0.0.0\\msxml6_x64.msi\" /l* \"$applogs\\msxml6_x64.stk.9_2.txt\"");
 	run_command("start /wait \"\" \"$sourcefilesdir\\STK_License_Manager\\v3.0.11\\setup.exe\" /S /v/qn");

 	return 1;
}

 sub install {
   output("Installing STK 10.1.3: \n");
   output((run_command("start /wait \"\" \"$sourcefilesdir\\STK\\setup.exe\" /S /V/qn")?"OK":"FAILED").."\n");
   output((run_command("copy \"$cwd\\license.lic\" \"$pgdata\\AGI\\LicenseData\" /y")?"OK":"FAILED").."\n");
	 run_command("del /q \"$audesktop\\STK 10.lnk\"");
	 run_command("del /q \"$audesktop\\STK Viewer 10.lnk\"");
	 return 1;
 }

sub postinstall {
	run_command("netsh advfirewall firewall add rule name=\"STK 10\" dir=in action=allow program=\"C:\\Program Files (x86)\\agi\\stk 10\\bin\\aguiapplication.exe\"");
	run_command("netsh advfirewall firewall add rule name=\"STK 10\" dir=out action=allow program=\"C:\\Program Files (x86)\\agi\\stk 10\\bin\\aguiapplication.exe\"");
	run_command("copy \"$sourcefilesdir\\activesetup.cmd\" \"$pgfilesx86\\AGI\\STK 10\"");


	if (!create_activesetup_action(
             'Identifier' =&gt; 'STK_10.1.3_Folder_Creation',
             'ComponentID' =&gt; 'STK10.1.3',
             'Description' =&gt; 'Creates STK 10.1.3 folder in user\'s documents folder so new user setup does not fail',
             'Version' =&gt; '10.1.3',
             'StubPath' =&gt; "\"C:\\Program Files (x86)\\AGI\\STK 10\\activesetup.cmd\"",
        )) {
        output("     Error: cannot create Active Setup action.\n");
        return 0;
    }

	return 1;
 }

do_install(
    allowed_versions =&gt; [OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,

);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\stk.11_0_1\dev\update.pl</FullName>
    <Length>4333</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-08-08T09:49:47.9277422-05:00</CreationTime>
    <CreationTimeUtc>2016-08-08T14:49:47.9277422Z</CreationTimeUtc>
    <LastWriteTime>2016-07-08T13:34:25.3172373-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-07-08T18:34:25.3172373Z</LastWriteTimeUtc>
    <LastAccessTime>2016-08-08T09:49:47.9277422-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-08-08T14:49:47.9277422Z</LastAccessTimeUtc>
    <Text># STK 11.0.1
# Package Created May 2016
# Packaged by Ronith (based on Dzu's 2015 package)
# Last Updated ...

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'stk.11_0_1',

        # some unique id that's updated any time the package undergoes
        #  any sort of minor revision
        package_revision =&gt; '20160527T0930',

#         # if different from default location
#         output_log =&gt; 'path_to_output_log',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
my $cwd = cwd();
my $applogs=get_applogs_dir();
my $pgfiles=$ENV{"ProgramFiles"};
my $pgfilesx86=$ENV{"ProgramFiles(x86)"};
my $audesktop=$ENV{"public"}."\\desktop";
my $pgdata=$ENV{"ProgramData"};

sub preinstall {
 	run_command("start /wait \"\" \"$sourcefilesdir\\Prerequirements\\vcredist\\v2008\\vcredist_x86.exe\" /q");
 	run_command("start /wait \"\" \"$sourcefilesdir\\Prerequirements\\vcredist\\v2008\\x64\\vcredist_x64.exe\" /q");
	run_command("start /wait \"\" \"$sourcefilesdir\\Prerequirements\\vcredist\\v2010\\x86\\vcredist_x86.exe\" /q");
 	run_command("start /wait \"\" \"$sourcefilesdir\\Prerequirements\\vcredist\\v2010\\x64\\vcredist_x64.exe\" /q");
	run_command("start /wait \"\" \"$sourcefilesdir\\Prerequirements\\vcredist\\v2012\\x86\\vcredist_x86.exe\" /q");
 	run_command("start /wait \"\" \"$sourcefilesdir\\Prerequirements\\vcredist\\v2012\\x64\\vcredist_x64.exe\" /q");
	run_command("start /wait \"\" \"$sourcefilesdir\\Prerequirements\\symbol_server\\v3.0.3.5\\rssredistinstaller.msi\" /q");
	run_command("start /wait \"\" \"$sourcefilesdir\\Prerequirements\\rootsupd\\v6.0.2600.0\\rootsupd.exe\" /q");
 	run_command("start /wait \"\" \"$sourcefilesdir\\STK_License_Manager\\v3.0.14\\setup.exe\" /S /v/qn");
 	return 1;
}

 sub install {
	output("Installing STK 11.0.1: \n");
	output((run_command("start /wait \"\" \"$sourcefilesdir\\STK\\setup.exe\" /S /V/qn")?"OK":"FAILED").."\n");
	output((run_command("copy \"$cwd\\license.lic\" \"$pgdata\\AGI\\LicenseData\" /y")?"OK":"FAILED").."\n");
	 run_command("del /q /F \"$audesktop\\STK 11 x64.lnk\"");
	 run_command("del /q  /F \"$audesktop\\STK Viewer 11 x64.lnk\"");
	return 1;
 }

sub postinstall {
	output("Installing STK add-ons and supplements\n");
	run_command("start /wait \"\" \"$sourcefilesdir\\STK_Planetary_Data_Supplement\\v11.0.0\\setup.exe\" /S /v/qn");
	run_command("start /wait \"\" \"$sourcefilesdir\\QualNet\\v11.0.1\\setup.exe\" /S /v/qn");
	run_command("start /wait \"\" \"$sourcefilesdir\\STK_Engine_Resources\\v11.0.1\\setup.exe\" /S /v/qn");
	run_command("start /wait \"\" \"$sourcefilesdir\\STKSEET\\v11.0.1\\setup.exe\" /S /v/qn");
	run_command("start /wait \"\" \"$sourcefilesdir\\STK_Parallel_Computing\\v11.0.0\\setup.exe\" /S /v/qn");
	run_command("start /wait \"\" \"$sourcefilesdir\\Matlab_Connectors\\v1.0.5\\setup.exe\" /S /v/qn");
	run_command("start /wait \"\" \"$sourcefilesdir\\STKUiPlugins\\v11.0.1\\install.exe\" /S /v/qn");
	run_command("netsh advfirewall firewall add rule name=\"STK 11\" dir=in action=allow program=\"C:\\Program Files\\agi\\stk 11\\bin\\aguiapplication.exe\"");
	run_command("netsh advfirewall firewall add rule name=\"STK 11\" dir=out action=allow program=\"C:\\Program Files\\agi\\stk 11\\bin\\aguiapplication.exe\"");
	return 1;
 }

do_install(
    allowed_versions =&gt; [ OSVER_WIN10_SP0,OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,

);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\stk.11_0_1\prod\update.pl</FullName>
    <Length>4333</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-05-26T11:20:08.3021316-05:00</CreationTime>
    <CreationTimeUtc>2016-05-26T16:20:08.3021316Z</CreationTimeUtc>
    <LastWriteTime>2016-07-08T13:34:25.3172373-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-07-08T18:34:25.3172373Z</LastWriteTimeUtc>
    <LastAccessTime>2016-05-26T11:20:08.3489325-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-05-26T16:20:08.3489325Z</LastAccessTimeUtc>
    <Text># STK 11.0.1
# Package Created May 2016
# Packaged by Ronith (based on Dzu's 2015 package)
# Last Updated ...

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'stk.11_0_1',

        # some unique id that's updated any time the package undergoes
        #  any sort of minor revision
        package_revision =&gt; '20160527T0930',

#         # if different from default location
#         output_log =&gt; 'path_to_output_log',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
my $cwd = cwd();
my $applogs=get_applogs_dir();
my $pgfiles=$ENV{"ProgramFiles"};
my $pgfilesx86=$ENV{"ProgramFiles(x86)"};
my $audesktop=$ENV{"public"}."\\desktop";
my $pgdata=$ENV{"ProgramData"};

sub preinstall {
 	run_command("start /wait \"\" \"$sourcefilesdir\\Prerequirements\\vcredist\\v2008\\vcredist_x86.exe\" /q");
 	run_command("start /wait \"\" \"$sourcefilesdir\\Prerequirements\\vcredist\\v2008\\x64\\vcredist_x64.exe\" /q");
	run_command("start /wait \"\" \"$sourcefilesdir\\Prerequirements\\vcredist\\v2010\\x86\\vcredist_x86.exe\" /q");
 	run_command("start /wait \"\" \"$sourcefilesdir\\Prerequirements\\vcredist\\v2010\\x64\\vcredist_x64.exe\" /q");
	run_command("start /wait \"\" \"$sourcefilesdir\\Prerequirements\\vcredist\\v2012\\x86\\vcredist_x86.exe\" /q");
 	run_command("start /wait \"\" \"$sourcefilesdir\\Prerequirements\\vcredist\\v2012\\x64\\vcredist_x64.exe\" /q");
	run_command("start /wait \"\" \"$sourcefilesdir\\Prerequirements\\symbol_server\\v3.0.3.5\\rssredistinstaller.msi\" /q");
	run_command("start /wait \"\" \"$sourcefilesdir\\Prerequirements\\rootsupd\\v6.0.2600.0\\rootsupd.exe\" /q");
 	run_command("start /wait \"\" \"$sourcefilesdir\\STK_License_Manager\\v3.0.14\\setup.exe\" /S /v/qn");
 	return 1;
}

 sub install {
	output("Installing STK 11.0.1: \n");
	output((run_command("start /wait \"\" \"$sourcefilesdir\\STK\\setup.exe\" /S /V/qn")?"OK":"FAILED").."\n");
	output((run_command("copy \"$cwd\\license.lic\" \"$pgdata\\AGI\\LicenseData\" /y")?"OK":"FAILED").."\n");
	 run_command("del /q /F \"$audesktop\\STK 11 x64.lnk\"");
	 run_command("del /q  /F \"$audesktop\\STK Viewer 11 x64.lnk\"");
	return 1;
 }

sub postinstall {
	output("Installing STK add-ons and supplements\n");
	run_command("start /wait \"\" \"$sourcefilesdir\\STK_Planetary_Data_Supplement\\v11.0.0\\setup.exe\" /S /v/qn");
	run_command("start /wait \"\" \"$sourcefilesdir\\QualNet\\v11.0.1\\setup.exe\" /S /v/qn");
	run_command("start /wait \"\" \"$sourcefilesdir\\STK_Engine_Resources\\v11.0.1\\setup.exe\" /S /v/qn");
	run_command("start /wait \"\" \"$sourcefilesdir\\STKSEET\\v11.0.1\\setup.exe\" /S /v/qn");
	run_command("start /wait \"\" \"$sourcefilesdir\\STK_Parallel_Computing\\v11.0.0\\setup.exe\" /S /v/qn");
	run_command("start /wait \"\" \"$sourcefilesdir\\Matlab_Connectors\\v1.0.5\\setup.exe\" /S /v/qn");
	run_command("start /wait \"\" \"$sourcefilesdir\\STKUiPlugins\\v11.0.1\\install.exe\" /S /v/qn");
	run_command("netsh advfirewall firewall add rule name=\"STK 11\" dir=in action=allow program=\"C:\\Program Files\\agi\\stk 11\\bin\\aguiapplication.exe\"");
	run_command("netsh advfirewall firewall add rule name=\"STK 11\" dir=out action=allow program=\"C:\\Program Files\\agi\\stk 11\\bin\\aguiapplication.exe\"");
	return 1;
 }

do_install(
    allowed_versions =&gt; [ OSVER_WIN10_SP0,OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,

);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\stk.11_2\prod\update.pl</FullName>
    <Length>8970</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-01-10T14:43:20.464209-06:00</CreationTime>
    <CreationTimeUtc>2018-01-10T20:43:20.464209Z</CreationTimeUtc>
    <LastWriteTime>2018-01-24T21:30:41.5814227-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-25T03:30:41.5814227Z</LastWriteTimeUtc>
    <LastAccessTime>2018-01-10T14:44:27.871981-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-01-10T20:44:27.871981Z</LastAccessTimeUtc>
    <Text># STK 11.2
# Package Created Winter 2016
# Last Updated 2017-1-5 by Alex Schrimpf

=pod

Begin-Doc
Modified: 
Name: 
Type:
Description: 
Language: Perl
LastUpdatedBy:
Version:
Doc-Package-Info
Doc-SVN-Repository:
RCSId:
End-Doc

=cut

use strict;
use warnings;
our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'stk.11_2',
        package_revision =&gt; '',
    );
}

use lib ( '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 'C:\temp' );

use InstallMonkey::Shared;

use IM_helper(
   \%INSTALLMONKEY_OPTIONS,
    v4.04,
    (
      "PREREQS" =&gt; [
          sub{
              my @vcredists = (
                "start /wait \"\" \"$IM_helper::source_files\\Prerequirements\\vcredist\\v2010\\x86\\vcredist_x86.exe\" /q /norestart",
                "start /wait \"\" \"$IM_helper::source_files\\Prerequirements\\vcredist\\v2010\\x64\\vcredist_x64.exe\" /q /norestart",
                "start /wait \"\" \"$IM_helper::source_files\\Prerequirements\\vcredist\\v2012\\x86\\vcredist_x86.exe\" /q /norestart",
                "start /wait \"\" \"$IM_helper::source_files\\Prerequirements\\vcredist\\v2012\\x64\\vcredist_x64.exe\" /q /norestart",
                "start /wait \"\" \"$IM_helper::source_files\\Prerequirements\\vcredist\\v2015\\x86\\vc_redist.x86.exe\" /q /norestart",
                "start /wait \"\" \"$IM_helper::source_files\\Prerequirements\\vcredist\\v2015\\x64\\vc_redist.x64.exe\" /q /norestart",
              );

              foreach my $installer (@vcredists){
                # Ignore whether command succeeds in case a timeout occurs.
                IM_helper::run_command(
                  command=&gt;$installer,
                  # Timeout after 3 Minutes. I had to do this because if there is a newer version of vc_redist installed the installer will error out and hang on a dialogue box.
                  # I'm not sure of a better way to handle this other than hard coding checking for newer vc_redis versions. 
                  # From my testing installing each of these typically takes less than 20 seconds so 3 min should be sufficient.
                  timeout=&gt;(3*60) 
                );
              }

              return 1;
          },
          sub{
              IM_helper::run_command(
                command=&gt;"start /wait \"\" \"$IM_helper::source_files\\STK_License_Manager\\v3.0.17\\setup.exe\" /S /v/qn"
              );
          },
      ],
      "INSTALL" =&gt; [
          sub{
              IM_helper::run_command(
                command=&gt;"start /wait \"\" \"$IM_helper::source_files\\STK\\setup.exe\" /S /V/qn"
              );
          },
          sub{
              IM_helper::write_file(
                file=&gt;"$ENV{ProgramData}\\AGI\\LicenseData\\license.lic",
                data=&gt;IM_helper::normalize_text(
                  text=&gt;
                  qq|
                    SERVER agi.lic.mst.edu 0 1715
                    USE_SERVER
                  |
                )
              );
          },
          sub{
              IM_helper::del_files(
                files=&gt;
                [
                  "$ENV{public}\\desktop\\STK 11 x64.lnk",
                  "$ENV{public}\\desktop\\STK Viewer 11 x64.lnk"
                ]
              );
         }
      ],
      "SUPPLEMENTS" =&gt; [
          sub{

              my @supplements = (
                "start /wait \"\" \"$IM_helper::source_files\\STK_Planetary_Data_Supplement\\v11.2.0\\setup.exe\" /S /v/qn" =&gt; "STK Planetary Data Supplement 11 x64",
                "start /wait \"\" \"$IM_helper::source_files\\QualNet\\v11.2.0\\setup.exe\" /S /v/qn" =&gt; "QualNet Interface for STK Communications 11 x64",
                "start /wait \"\" \"$IM_helper::source_files\\STK_Engine_Resources\\v11.2.0\\setup.exe\" /S /v/qn" =&gt; "STK Engine Deployment Resources 11 x64",
                "start /wait \"\" \"$IM_helper::source_files\\STKSEET\\v11.2.0\\setup.exe\" /S /v/qn" =&gt; undef,
                "start /wait \"\" \"$IM_helper::source_files\\STK_Parallel_Computing\\v11.2.0\\setup.exe\" /S /v/qn" =&gt; undef,
                "start /wait \"\" \"$IM_helper::source_files\\Matlab_Connectors\\v1.0.7\\setup.exe\" /S /v/qn" =&gt; "STK MATLAB Connector 1.0 x64",
                # Ticket submiter requested to not use this
                #"start /wait \"\" \"$sourcefilesdir\\STKUiPlugins\\v11.2.0\\ArcGIS_REST\\v11.2.0\\setup.exe\" /S /v/qn" =&gt; ?,       
                "start /wait \"\" \"$IM_helper::source_files\\STKUiPlugins\\v11.2.0\\CzmlExporter\\v11.2.0\\setup.exe\" /S /v/qn" =&gt; "STK CZML Exporter Plugin 11 x64",
                "start /wait \"\" \"$IM_helper::source_files\\STKUiPlugins\\v11.2.0\\NavFiles\\v11.2.0\\setup.exe\" /S /v/qn" =&gt; "STK Navigation Files Plugin 11 x64",
                "start /wait \"\" \"$IM_helper::source_files\\STKUiPlugins\\v11.2.0\\SpectrumAnalyzer\\v11.2.0\\setup.exe\" /S /v/qn" =&gt; "STK Spectrum Analyzer Plugin 11 x64",
                "start /wait \"\" \"$IM_helper::source_files\\STKUiPlugins\\v11.2.0\\WMS\\v11.2.0\\setup.exe\" /S /v/qn" =&gt; "STK Web Map Service Plugin 11 x64"
              );
              
              # Wait for previous installation to finish by checking programs and features list. Some of these installers will fork and exit before they finish installing. 
              # This causes the next installer to fail since two can't be running at the same time.
              my $check_interval = 30;#seconds
              my $max_checks = 10;

              my $last_display_name = undef;
              for (my $i = 0; $i &lt; scalar @supplements;$i+=2){
                my $command = @supplements[$i];
                my $display_name = @supplements[$i+1];
                if(defined $last_display_name){
                    my $check_counter = 0;
                    while(!IM_helper::get_install_locations(quiet=&gt;1,display_name=&gt;$last_display_name)){
                        IM_helper::flush_msg(msg=&gt;($last_display_name." HASN'T FINISHED INSTALLING WAITING $check_interval SEC\n"));
                        sleep($check_interval);
                        if((++$check_counter)&gt;=($max_checks*$check_interval)){
                            IM_helper::flush_msg(msg=&gt;("MAXIMUM WAIT TIME OF ".($check_interval*$check_counter)." SECONDS EXCEEDED\n",type=&gt;'error'));
                            return 0;
                        }
                    }
                }

                return 0 unless IM_helper::run_command(
                    command=&gt;$command
                );
                $last_display_name = $display_name;
              }
              return 1;
          },
          sub{
              return (
                IM_helper::run_command(
                  command=&gt;"netsh advfirewall firewall add rule name=\"STK 11\" dir=in action=allow program=\"C:\\Program Files\\agi\\stk 11\\bin\\aguiapplication.exe"
                ) 
                &amp;&amp;
                IM_helper::run_command(
                  command=&gt;"netsh advfirewall firewall add rule name=\"STK 11\" dir=out action=allow program=\"C:\\Program Files\\agi\\stk 11\\bin\\aguiapplication.exe"
                )
              );
          },
      ],
      "UNINSTALL" =&gt; [
          sub{    

              my @uninstall_display_names = (
                "STK Planetary Data Supplement 11 x64",
                "QualNet Interface for STK Communications 11 x64",
                "STK Engine Deployment Resources 11 x64",
                "STK MATLAB Connector 1.0 x64",
                "STK CZML Exporter Plugin 11 x64",
                "STK Navigation Files Plugin 11 x64",
                "STK Spectrum Analyzer Plugin 11 x64",
                "STK Web Map Service Plugin 11 x64",
                "STK 11 x64",
                "STK License Manager",
              );

              foreach my $display_name (@uninstall_display_names){
                IM_helper::uninstall_using_programs_and_features(
                    display_name=&gt; $display_name
                );
              }

              return 1;
          },
          sub {
              delete_product_registry_key($INSTALLMONKEY_OPTIONS{package_id});
          },          
      ]
    )
);

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt;
      [ 'clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    no_install_check =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    no_product_key =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    install_sub =&gt; $IM_helper::exec_call_stack_override || sub{IM_helper::exec_call_stacks(ids=&gt;["PREREQS","INSTALL","SUPPLEMENTS"])}
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\stk.11_2\prod.old\update.pl</FullName>
    <Length>8082</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-15T13:54:49.6967405-06:00</CreationTime>
    <CreationTimeUtc>2017-11-15T19:54:49.6967405Z</CreationTimeUtc>
    <LastWriteTime>2018-01-08T09:58:39.6537466-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-08T15:58:39.6537466Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-15T13:54:49.6967405-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-15T19:54:49.6967405Z</LastAccessTimeUtc>
    <Text># STK 11.2
# Package Created May 2016
# Packaged by Ronith (based on Dzu's 2015 package)
# Updated 2017-11-15 for 11.2 by Grayson Gratop
# Last Updated 2017-1-5 by Alex Schrimpf

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
    # same name as the appdist directory
    package_id =&gt; 'stk.11_2',

    # some unique id that's updated any time the package undergoes
    #  any sort of minor revision
    package_revision =&gt; '20171115T1355',

    # # if different from default location
    # output_log =&gt; 'path_to_output_log',
  );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
my $cwd = cwd();
my $applogs=get_applogs_dir();
my $pgfiles=$ENV{"ProgramFiles"};
my $pgfilesx86=$ENV{"ProgramFiles(x86)"};
my $audesktop=$ENV{"public"}."\\desktop";
my $pgdata=$ENV{"ProgramData"};

sub get_install_locations{
    my $display_name = shift;

    my %uninstall_commands;
    $uninstall_commands{x86} = `powershell \"Get-ItemProperty HKLM:\\Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* | Where-Object {\$_.DisplayName -eq \\\"$display_name\\\"} | Select-Object InstallLocation | Format-List
\"`;
    $uninstall_commands{x64} = `powershell \"Get-ItemProperty HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* | Where-Object {\$_.DisplayName -eq \\\"$display_name\\\"} | Select-Object InstallLocation | Format-List
\"`;
    my %results_install_strings;
    $results_install_strings{x86} = ();
    $results_install_strings{x64} = ();

    local $/ = '';

    while(my($key,$value) = each %uninstall_commands){
        my @uninstall_strings = split/\n\n/, $value;
        @uninstall_strings = grep /\S/, @uninstall_strings;
        foreach my $i(@uninstall_strings){
            $i =~ s/InstallLocation : //;
            $i =~ s/^                  //gm;
            $i =~ s/\R//g;
            $i =~ s/ +/ /;
            push(@{$results_install_strings{$key}},$i);
        }
    }

    return (scalar $results_install_strings{x86} || scalar $results_install_strings{x64});
}

sub wait_for_install{
   my $display_name = shift;
   while(!get_install_locations($display_name)){output("\n\t:: ERROR \"$display_name\" HASN'T FINISHED INSTALLING WAITING 10 SEC.\n");sleep 10; }#10 sec
   return 1;
}

sub runCommandList {
  my @installers = @{$_[0]};

  my $success = 0;
  
  for (my $i = 0; $i &lt; scalar @installers; $i++) {
    output("\t" . $installers[$i][1] . ": ");
    if($i){
      wait_for_install($installers[$i-1][1]);
    }
    $success = run_command($installers[$i][0]);
    output($success ? "Done!\n" : "FAILED: $!\n");
    if (!$success) { last; }
  }

  if ($success) {
    output("Finished!\n");
  }
  else {
    output("Something went wrong!\n");
  }

  return $success;
}

sub preinstall {
  my @installers = (
    ["start /wait \"\" \"$sourcefilesdir\\Prerequirements\\vcredist\\v2010\\x86\\vcredist_x86.exe\" /q /norestart", "Microsoft Visual C++ 2010  x64 Redistributable - 10.0.40219"],
    ["start /wait \"\" \"$sourcefilesdir\\Prerequirements\\vcredist\\v2010\\x64\\vcredist_x64.exe\" /q /norestart", "Microsoft Visual C++ 2010  x86 Redistributable - 10.0.40219"],
    ["start /wait \"\" \"$sourcefilesdir\\Prerequirements\\vcredist\\v2012\\x86\\vcredist_x86.exe\" /q /norestart", "Microsoft Visual C++ 2012 Redistributable (x86) - 11.0.61030"],
    ["start /wait \"\" \"$sourcefilesdir\\Prerequirements\\vcredist\\v2012\\x64\\vcredist_x64.exe\" /q /norestart", "Microsoft Visual C++ 2012 Redistributable (x64) - 11.0.61030"],
    ["start /wait \"\" \"$sourcefilesdir\\Prerequirements\\vcredist\\v2015\\x86\\vc_redist.x86.exe\" /q /norestart", "Microsoft Visual C++ 2015 Redistributable (x86) - 14.0.24212"],
    ["start /wait \"\" \"$sourcefilesdir\\Prerequirements\\vcredist\\v2015\\x64\\vc_redist.x64.exe\" /q /norestart", "Microsoft Visual C++ 2015 Redistributable (x64) - 14.0.24212"],
    ["start /wait \"\" \"$sourcefilesdir\\STK_License_Manager\\v3.0.17\\setup.exe\" /S /v/qn", "STK License Manager"]
  );

  if(!run_command("\"$sourcefilesdir\\Prerequirements\\rootsupd\\v6.0.2600.0\\rootsupd.exe\"")){
    output(":: ERROR FAILED TO UPDATE THE ROOT KEYS\n");
    return 0;
  }

  return runCommandList(\@installers);
}

sub install {
  output("Installing STK 11.2: \n");

  my @installers = (
    ["start /wait \"\" \"$sourcefilesdir\\STK\\setup.exe\" /S /V/qn", "STK 11 x64"],
  );

  if(!run_command("copy \"$cwd\\license.lic\" \"$pgdata\\AGI\\LicenseData\" /y")){
    output(":: ERROR FAILED TO COPY THE LICENSE FILE\n");
    return 0;
  }

  if(!run_command("del /q /F \"$audesktop\\STK 11 x64.lnk\"")){
    output(":: ERROR FAILED TO DELETE THE SHORTCUT 1\n");
  }

  if(!run_command("del /q  /F \"$audesktop\\STK Viewer 11 x64.lnk\"")){
    output(":: ERROR FAILED TO DELETE THE SHORTCUT 2\n");
  }

  return runCommandList(\@installers);
}

sub postinstall {
  output("Installing STK add-ons and supplements\n");

  my @installers = (
    ["start /wait \"\" \"$sourcefilesdir\\STK_Planetary_Data_Supplement\\v11.2.0\\setup.exe\" /S /v/qn", "STK Planetary Data Supplement 11 x64"],
    ["start /wait \"\" \"$sourcefilesdir\\QualNet\\v11.2.0\\setup.exe\" /S /v/qn", "QualNet Interface for STK Communications 11 x64"],
    ["start /wait \"\" \"$sourcefilesdir\\STK_Engine_Resources\\v11.2.0\\setup.exe\" /S /v/qn", "STK Engine Deployment Resources 11 x64"],
    ["start /wait \"\" \"$sourcefilesdir\\STKSEET\\v11.2.0\\setup.exe\" /S /v/qn", "STK Space Environment and Effects Tool 11 x64"],
    ["start /wait \"\" \"$sourcefilesdir\\STK_Parallel_Computing\\v11.2.0\\setup.exe\" /S /v/qn", "STK Parallel Computing 11"],
    ["start /wait \"\" \"$sourcefilesdir\\Matlab_Connectors\\v1.0.7\\setup.exe\" /S /v/qn", "STK MATLAB Connector 1.0 x64"],
    # Ticket submiter requested to not use this
    #["start /wait \"\" \"$sourcefilesdir\\STKUiPlugins\\v11.2.0\\ArcGIS_REST\\v11.2.0\\setup.exe\" /S /v/qn", ""], 
    ["start /wait \"\" \"$sourcefilesdir\\STKUiPlugins\\v11.2.0\\CzmlExporter\\v11.2.0\\setup.exe\" /S /v/qn", "STK CZML Exporter Plugin 11 x64"], 
    ["start /wait \"\" \"$sourcefilesdir\\STKUiPlugins\\v11.2.0\\NavFiles\\v11.2.0\\setup.exe\" /S /v/qn", "STK Navigation Files Plugin 11 x64"], 
    ["start /wait \"\" \"$sourcefilesdir\\STKUiPlugins\\v11.2.0\\SpectrumAnalyzer\\v11.2.0\\setup.exe\" /S /v/qn", "STK Spectrum Analyzer Plugin 11 x64"], 
    ["start /wait \"\" \"$sourcefilesdir\\STKUiPlugins\\v11.2.0\\WMS\\v11.2.0\\setup.exe\" /S /v/qn", "STK Web Map Service Plugin 11 x64"], 
  );

  if(!run_command("netsh advfirewall firewall add rule name=\"STK 11\" dir=in action=allow program=\"C:\\Program Files\\agi\\stk 11\\bin\\aguiapplication.exe")){
    output(":: ERROR FAILED TO SET FIREWALL RULE 1\n");
    return 0;
  }

  if(!run_command("netsh advfirewall firewall add rule name=\"STK 11\" dir=out action=allow program=\"C:\\Program Files\\agi\\stk 11\\bin\\aguiapplication.exe")){
    output(":: ERROR FAILED TO SET FIREWALL RULE 2\n");
    return 0;
  }

  return runCommandList(\@installers);
}

do_install(
  allowed_versions =&gt; [ OSVER_WIN10_SP0,OSVER_WIN7_SP0,OSVER_WIN7_SP1],
  allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
  allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
  exit_on_failure =&gt; 1,
  preinstall_sub =&gt; \&amp;preinstall,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\strata.0_5_6\dev\update.pl</FullName>
    <Length>1777</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-05T16:11:55.6914791-05:00</CreationTime>
    <CreationTimeUtc>2017-06-05T21:11:55.6914791Z</CreationTimeUtc>
    <LastWriteTime>2017-08-17T15:32:46.3651749-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-08-17T20:32:46.3651749Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-05T16:11:55.6914791-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-05T21:11:55.6914791Z</LastAccessTimeUtc>
    <Text># strata
    # Package Created June 05, 2017
    # Packaged by Krueger, Benjamin (S&amp;T IT Student Employee)
    # Last Updated 8/4/2017 by Sergey Gruzdev

    BEGIN {
        %::INSTALLMONKEY_OPTIONS = (
            package_id =&gt; 'strata.0_5_6',
            package_revision =&gt; '20170605T1611',
        );
    }

    use lib (
        '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
        $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
        'C:\temp',
    );
    use InstallMonkey::Shared;

    my $src = get_pkg_sourcefiles();
    my $log_dir = get_applogs_dir();
	my $start = build_path(get_allusers_start_menu(), "Strata");
	
    sub install {
        if(!run_command($src."\\Strata-mingw64-v0.5.5-97ca19c.exe /S /D=C:\\Program Files\\Strata"))
        {
            output("Installation failed!\n");
            return 0;
        }
        
        output("Installation successful!");
        return 1;
    }
    sub postinstall {
		output("Placing Start Menu Shortcut: ");
		run_command("mkdir \"$start\"", 'IgnoreExitCodes' =&gt; [1]);
		if(!run_command("robocopy \"$src\\Strata\" \"$start\" /E", 'IgnoreExitCodes' =&gt; [1])) {
			output("FAILED: $!\n");
			return 0;
		}
		output("OK\n");
		return 1;
    }
    do_install( 
        exit_on_failure =&gt; 1,
        allowed_versions          =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
        allowed_os_architectures  =&gt; [ OSARCH_x64 ],
        allowed_regs              =&gt; [ "clc", "desktop", "traveling", "virtual-desktop", "virtual-clc" ],
        install_sub               =&gt; \&amp;install,
        postinstall_sub           =&gt; \&amp;postinstall 
    );

    IM_Exit(EXIT_SUCCESS);

    ########################################################################
    </Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\strata.0_5_6\prod\update.pl</FullName>
    <Length>1777</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-08-17T15:39:32.5040491-05:00</CreationTime>
    <CreationTimeUtc>2017-08-17T20:39:32.5040491Z</CreationTimeUtc>
    <LastWriteTime>2017-08-17T15:32:46.3651749-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-08-17T20:32:46.3651749Z</LastWriteTimeUtc>
    <LastAccessTime>2017-08-17T15:39:32.5040491-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-08-17T20:39:32.5040491Z</LastAccessTimeUtc>
    <Text># strata
    # Package Created June 05, 2017
    # Packaged by Krueger, Benjamin (S&amp;T IT Student Employee)
    # Last Updated 8/4/2017 by Sergey Gruzdev

    BEGIN {
        %::INSTALLMONKEY_OPTIONS = (
            package_id =&gt; 'strata.0_5_6',
            package_revision =&gt; '20170605T1611',
        );
    }

    use lib (
        '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
        $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
        'C:\temp',
    );
    use InstallMonkey::Shared;

    my $src = get_pkg_sourcefiles();
    my $log_dir = get_applogs_dir();
	my $start = build_path(get_allusers_start_menu(), "Strata");
	
    sub install {
        if(!run_command($src."\\Strata-mingw64-v0.5.5-97ca19c.exe /S /D=C:\\Program Files\\Strata"))
        {
            output("Installation failed!\n");
            return 0;
        }
        
        output("Installation successful!");
        return 1;
    }
    sub postinstall {
		output("Placing Start Menu Shortcut: ");
		run_command("mkdir \"$start\"", 'IgnoreExitCodes' =&gt; [1]);
		if(!run_command("robocopy \"$src\\Strata\" \"$start\" /E", 'IgnoreExitCodes' =&gt; [1])) {
			output("FAILED: $!\n");
			return 0;
		}
		output("OK\n");
		return 1;
    }
    do_install( 
        exit_on_failure =&gt; 1,
        allowed_versions          =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
        allowed_os_architectures  =&gt; [ OSARCH_x64 ],
        allowed_regs              =&gt; [ "clc", "desktop", "traveling", "virtual-desktop", "virtual-clc" ],
        install_sub               =&gt; \&amp;install,
        postinstall_sub           =&gt; \&amp;postinstall 
    );

    IM_Exit(EXIT_SUCCESS);

    ########################################################################
    </Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\sublime_text.3126\prod\update.pl</FullName>
    <Length>1234</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-12-09T14:41:09.640825-06:00</CreationTime>
    <CreationTimeUtc>2016-12-09T20:41:09.640825Z</CreationTimeUtc>
    <LastWriteTime>2016-12-09T15:03:39.1135759-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-12-09T21:03:39.1135759Z</LastWriteTimeUtc>
    <LastAccessTime>2016-12-09T14:41:09.7344268-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-12-09T20:41:09.7344268Z</LastAccessTimeUtc>
    <Text># Sublime Text build 3126
# Package Created Dec 9, 2016
# Packaged by Ronith Muttur

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'sublime_text.3126',
        package_revision =&gt; '20161209T1445',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
my $srcfiles= get_pkg_sourcefiles();
my $desktop = $ENV{"public"}."\\desktop";

sub install
{
  output("\nInstalling Subime Text 3126: ");
  output((run_command("$srcfiles\\setup.exe /NORESTART /VERYSILENT")?"OK":"FAILED").."\n");

  return 1;
}
do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\subpump.2018.1_0\prod\update.pl</FullName>
    <Length>4037</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-20T10:13:42.070671-05:00</CreationTime>
    <CreationTimeUtc>2018-06-20T15:13:42.070671Z</CreationTimeUtc>
    <LastWriteTime>2018-06-20T12:39:52.4453373-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-20T17:39:52.4453373Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-20T10:13:42.1502451-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-20T15:13:42.1502451Z</LastAccessTimeUtc>
    <Text># Kingdom 2017
# Package Created June 2018
# Packaged by Alex Schrimpf

=pod

Begin-Doc
Modified: 
Name: 
Type:
Description: 
Language: Perl
LastUpdatedBy:
Version:
Doc-Package-Info
Doc-SVN-Repository:
RCSId:
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'subpump.2018.1_0',
        package_revision =&gt; '',
    );
}

use lib ( '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 'C:\temp' );

use InstallMonkey::Shared;

my $INSTALL_DIR = "C:\\Program Files (x86)\\IHS\\SubPUMP";

use IM_helper(
    \%INSTALLMONKEY_OPTIONS,
    v5.01,
    (
        "INSTALL" =&gt; [
            sub {
                return 0 unless IM_helper::run_command(
                    command=&gt;"start /wait \"\" \"$IM_helper::source_files\\setup.exe\" -s -a /s /f1\"$IM_helper::source_files\\Setup.iss\""
                );

                #Installer spawns another process so wait for it to show up in "Program and Features" menu
                IM_helper::flush_msg(msg=&gt;"Waiting for installer to finish...");
                while(!IM_helper::get_install_locations(
                    display_name=&gt; "SubPUMP",
                    quiet=&gt;1
                )){
                    sleep(5);
                }
                return 1;           
            },
        ],
        "LICENSE" =&gt; [
            sub {
                IM_helper::cp_file(
                    from=&gt;"$IM_helper::source_files\\license.dat",
                    to_dir=&gt;$INSTALL_DIR
                )
            },
            sub {
                return IM_helper::create_reg_key(
                    root=&gt;"HKEY_LOCAL_MACHINE/",
                    key=&gt;'SOFTWARE/Wow6432Node/FLEXlm License Manager/',
                    succ_cb=&gt;sub{
                        IM_helper::set_reg_key_values(
                            key=&gt;'HKEY_LOCAL_MACHINE/SOFTWARE/Wow6432Node/FLEXlm License Manager/',
                            values=&gt;["IHS_LICENSE_FILE",["1718@\\ihs.lic.mst.edu",'REG_SZ']],
                        );
                    }
                )
            },
            sub {
                IM_helper::push_to_system_var(
                    name  =&gt; "IHS_LICENSE_FILE",
                    value =&gt; "1718\@ihs.lic.mst.edu"
                );
            }
        ],
        "UNINSTALL" =&gt; [
            sub {
                IM_helper::get_uninstall_strings(
                        display_name=&gt;"SubPUMP",
                        succ_cb=&gt;sub{
                            if(!exists({@_}-&gt;{x64})){
                                return 0;
                            }
                            return IM_helper::run_command(
                                command=&gt;"start /wait \"\" @{{@_}-&gt;{x64}} /s /f1\"$IM_helper::source_files\\Uninstall.iss\"",
                                description=&gt;"SubPUMP Uninstaller"
                            );
                        }
                );            
                IM_helper::flush_msg(msg=&gt;"Waiting for uninstaller to finish...\n");
                while(IM_helper::get_install_locations(
                    display_name=&gt; "SubPUMP",
                    quiet=&gt;1
                )){
                    sleep(5);
                }     
                return 1;       
            }
        
        ]
    )
);

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt;
      [ 'clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    no_install_check =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    no_product_key =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    install_sub =&gt; $IM_helper::exec_call_stack_override || sub{IM_helper::exec_call_stacks(ids=&gt;["LICENSE","INSTALL"])}
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\SurfCam.2017_r1\prod\update.pl</FullName>
    <Length>5114</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-01-14T14:31:30.299852-06:00</CreationTime>
    <CreationTimeUtc>2018-01-14T20:31:30.299852Z</CreationTimeUtc>
    <LastWriteTime>2018-05-05T02:36:32.5901416-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-05T07:36:32.5901416Z</LastWriteTimeUtc>
    <LastAccessTime>2018-01-14T14:31:30.299852-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-01-14T20:31:30.299852Z</LastAccessTimeUtc>
    <Text># SurfCam 2017 R1
# Package Created Fall 2017
# Packaged by Alex Schrimpf
# Last Updated Fall 2017 by Alex Schrimpf

=pod

Begin-Doc
Modified: 
Name: 
Type:
Description: 
Language: Perl
LastUpdatedBy:
Version:
Doc-Package-Info
Doc-SVN-Repository:
RCSId:
End-Doc

=cut

use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'SurfCam.2017_r1',
        package_revision =&gt; '',
    );
}

use lib ( '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 'C:\temp' );

use InstallMonkey::Shared;

my $umr_scripts_dir = "C:\\Windows\\System32\\UMRInst\\scripts\\".get_package_id();

use IM_helper(
    \%INSTALLMONKEY_OPTIONS,
    v4.06,
    (
        "INSTALL" =&gt; [
            sub {
                IM_helper::run_command(
                    description =&gt; 'Solidlink Installer',
                    command =&gt; "$IM_helper::source_files\\SurfTrad2017R1_English_DVD_Image\\SurfTrad2017R1_DVD\\Solidlink\\setup.exe /VERYSILENT"
                );           
            },
            sub {
                IM_helper::run_command(
                    description =&gt; 'CLS Installer',
                    command =&gt; "$IM_helper::source_files\\SurfTrad2017R1_English_DVD_Image\\SurfTrad2017R1_DVD\\CLS\\setup.exe /S /v/qn"
                );           
            },
            sub {
                IM_helper::run_command(
                    description =&gt; 'SurfCam Prereqs Installers',
                    command =&gt; "$IM_helper::source_files\\SurfTrad2017R1_English_DVD_Image\\SurfTrad2017R1_DVD\\SURFCAM2017R1\\setup.exe /S /v/qn\"DISABLE_IMPORT_DATA=1\"",
                    ignore_codes =&gt; [83],
                    succ_cb=&gt; sub{
                        IM_helper::del_files(
                            files=&gt;['C:\Users\Public\Desktop\Adobe Reader 9.lnk']
                        );
                        return 1;
                    }
                );           
            },
            sub {
                IM_helper::run_command(
                    description =&gt; 'SurfCam Installer',
                    command =&gt; "\"$IM_helper::source_files\\SURFCAM Traditional 2017.msi\" /quiet /norestart ",
                    succ_cb=&gt; sub{
                        IM_helper::del_files(
                            files=&gt;[
                                'C:\Users\Public\Desktop\SURFCAM 2017 - Samples64.lnk',
                                'C:\Users\Public\Desktop\SURFCAM Traditional 2017.lnk'
                            ]
                        );
                        return 1;
                    }
                );           
            },
            sub {
                IM_helper::run_command(
                    description =&gt; 'Migration Tool',
                    command =&gt; "$IM_helper::source_files\\SurfTrad2017R1_English_DVD_Image\\SurfTrad2017R1_DVD\\MigTool\\SURFCAMMigrationTool.msi /quiet"
                );           
            },
            sub {
                IM_helper::run_command(
                    description =&gt; 'Launcher',
                    command =&gt; "$IM_helper::source_files\\SurfTrad2017R1_English_DVD_Image\\SurfTrad2017R1_DVD\\Launcher\\setup.exe /VERYSILENT",
                    succ_cb=&gt; sub{
                        IM_helper::del_files(
                            files=&gt;['C:\Users\Public\Desktop\Vero Launcher.lnk']
                        );
                        return 1;
                    }
                );           
            },
            sub {
                IM_helper::cp_file(
                    from=&gt;"$IM_helper::source_files\\license.reg",
                    to_dir=&gt;$umr_scripts_dir,
                    succ_cb=&gt; sub{
                        IM_helper::create_activesetup(
                            command=&gt;"regedit /s \"$umr_scripts_dir\\license.reg\"",
                            description=&gt;"licenses SurfCam on user login"
                        );                  
                    }
                );
            },
            sub {
                IM_helper::write_file(
                    file=&gt;'C:\ProgramData\Vero Software\2017.10\CLS\config.xml',
                    data=&gt;
qq|&lt;?xml version="1.0"?&gt;
&lt;Configuration&gt;&lt;PreferredDongle&gt;24&lt;/PreferredDongle&gt;&lt;NoNet&gt;False&lt;/NoNet&gt;&lt;ServerName&gt;surfcam.lic.mst.edu&lt;/ServerName&gt;&lt;LicenseMask&gt;3008,&lt;/LicenseMask&gt;&lt;/Configuration&gt;|
                );
            }
        ],
    )
);

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt;
      [ 'clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    no_install_check =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    no_product_key =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    install_sub =&gt; $IM_helper::exec_call_stack_override || sub{IM_helper::exec_call_stacks(ids=&gt;["INSTALL"])}
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\surpac.6_8\prod\update.pl</FullName>
    <Length>2906</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-12-12T09:13:28.606039-06:00</CreationTime>
    <CreationTimeUtc>2017-12-12T15:13:28.606039Z</CreationTimeUtc>
    <LastWriteTime>2017-12-11T13:05:46.4455308-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-12-11T19:05:46.4455308Z</LastWriteTimeUtc>
    <LastAccessTime>2017-12-12T09:13:28.606039-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-12-12T15:13:28.606039Z</LastAccessTimeUtc>
    <Text># Package created 11/14/2017
# Package created by Sergey Gruzdev
# Last Updated 11/14/2017 by Sergey Gruzdev

=pod

Begin-Doc
Modified: $Date$
Name: $Name$
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'surpac.6_8',
        package_revision =&gt; '20171411T1414',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $src = get_pkg_sourcefiles();
my $logs = get_applogs_dir();

sub install
{
  print "Installing GEOVIA Surpac...\n";
  if(!run_command("msiexec /i $src\\Surpac6.8\\products\\Surpac_6.8_CDInstallation.msi /quiet /qn /l*v \"$logs\\surpac.6_8.txt\""))
  {
    print "FAILED!\n";
	return 0;
  }
  print "Succeeded!\n";
  return 1;
}

sub postinstall
{
  print "Installed GEOVIA License Manager\n";
  # Install minesched
  if(!install_msi(msi=&gt;"$src\\DVD\\products\\MineSched_x64.msi"))
  {
    print "FATAL ERROR: failed to install MineSched!\n";
	return 0;
  }
  print "Installed MineSched\n";
  # Update minesched
  if(!install_msi(msi=&gt;"$src\\Update\\GEOVIAMineSched.msp"))
  {
    print "ERROR: failed to update MineSched to 9.1.0!\n";
	return 0;
  }
  print "Updated MineSched to 9.1.0\n";
  
  # Delete shortcuts
  run_command("del \"C:\\Users\\Public\\Desktop\\GEOVIA MineSched 9.1.0 (x64).lnk\"");
  run_command("del \"C:\\Users\\Public\\Desktop\\GEOVIA Surpac 6.8.lnk\"");
  run_command("del \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\GEOVIA\\GEOVIA Surpac 6.8\"");
  print "Deleted shortcuts!\n";
  
  # Configure licensing by copying over the configured shortcuts
  if(!run_command("xcopy \"$src\\GEOVIA Surpac 6.8.lnk\" \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\GEOVIA\\GEOVIA Surpac 6.8.lnk\" /I /Q /Y"))
  {
    print "Error could not copy configured shortcut!\n";
  }
  print "Copied over new shortcut!\n";
  
  # Give users permissions on the installation folder
  output("\nGranting users permissions: ");
  if(!run_command( "icacls \"C:\\68\" /T /C /grant Users:(OI)(CI)M" ))
  {
    output("FAILED\n");
    return 0;
  }
  output("OK\n");
  print "Installation complete!\n";
  return 1;
}

do_install
(
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
  #msi_name =&gt; "Surpac6.8\\products\\Surpac_6.8_x64_CDInstallation.msi",
  postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\swi_prolog.7_6_4\prod\update.pl</FullName>
    <Length>1085</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-16T12:11:44.2144899-05:00</CreationTime>
    <CreationTimeUtc>2018-05-16T17:11:44.2144899Z</CreationTimeUtc>
    <LastWriteTime>2018-05-31T10:14:12.9871274-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-31T15:14:12.9871274Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-16T12:11:44.2144899-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-16T17:11:44.2144899Z</LastAccessTimeUtc>
    <Text># SWI Prolog
# Package Created May 16th, 2018
# Packaged by Cameron Loren
# Last Updated --

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %::INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'swi_prolog.7_6_4',
        package_revision =&gt; '20180516T1212',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();

sub install {
    if(!run_command("$srcfiles\\swipl-w64-764.exe /S"))
    {
        output("Installation failed!\n");
        return 0;
    }

    output("Installation successful!");
    return 1;
}

do_install(
    exit_on_failure =&gt; 1,
    allowed_versions          =&gt; [ OSVER_WIN10_SP0 ],
    allowed_os_architectures  =&gt; [ OSARCH_x64 ],
    allowed_regs              =&gt; [ "clc", "desktop", "traveling", "virtual-desktop", "virtual-clc" ],
    install_sub               =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);

########################################################################
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\tableau_desktop.10_4_1\prod\update.pl</FullName>
    <Length>2553</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-29T15:42:13.2922259-06:00</CreationTime>
    <CreationTimeUtc>2017-11-29T21:42:13.2922259Z</CreationTimeUtc>
    <LastWriteTime>2017-12-01T16:04:34.8241763-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-12-01T22:04:34.8241763Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-29T15:42:13.2922259-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-29T21:42:13.2922259Z</LastAccessTimeUtc>
    <Text>#Tableau Desktop
#Package Created November 2017
#Packaged by Chris Schaaf

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;
use File::Copy;
use File::Spec;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'tableaudesktop.10_4_1',
        package_revision =&gt; '20171127T1515',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\\dfs\\software\\loginscripts\\im',
    $ENV{'WINDIR'}.'\\SYSTEM32\\UMRINST',
    'C:\\temp',
);
use InstallMonkey::Shared;

use Getopt::Long;

sub usage {
    print qq(
usage: $0 [--help] [--uninstall]

);
}
GetOptions(
    'help' =&gt; sub { usage(); exit(0); },
    #'uninstall' =&gt; sub { exit(!uninstall()); },
);

my $src = get_pkg_sourcefiles();
my $installer = build_path(get_pkg_sourcefiles(), "TableauDesktop-64bit-10-4-1.exe");

do_install(
	allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1],
	allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
	allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
	exit_on_failure =&gt; 1,
	
	install_sub =&gt; \&amp;install,
	postinstall_sub =&gt; \&amp;postinst_sub,
);
IM_Exit(EXIT_SUCCESS);


sub install{
	output("Installing Tableau Desktop 10.4.1: ");
	if(!run_command("$installer /quiet /norestart ACCEPTEULA=1 DESKTOPSHORTCUT=0", 'IgnoreExitCodes' =&gt; [3010])) {
		output("FAILED: $!\n");
		return 0;
	}
	else{ output("OK\nCopying batch file for license handling: "); }
	if(!run_command("copy /Y \"$src\\tableau.bat\" \"$ENV{'PROGRAMFILES'}\\Tableau\\Tableau 10.4\\bin\\tableau.bat\"")) {
		output("FAILED: $!\n");
		return 0;
	}
	else{ output("OK\n"); }
	return 1;
}


sub postinst_sub{
	my $shortcutName = "Tableau 10.4.lnk";
	output("Deleting Start Menu Shortcut: ");
	if(!run_command("del \"$ENV{'PROGRAMDATA'}\\Microsoft\\Windows\\Start Menu\\Programs\\$shortcutName\"")) {
		output("FAILED: $!\n");
		return 0;
	}
	else { output("OK\n"); }
	output("Replacing Shortcut with Batch Script shortcut: ");
	#Credit to Joshua Jones for batch script
	if(!run_command("copy /Y \"$src\\$shortcutName\" \"$ENV{'PROGRAMDATA'}\\Microsoft\\Windows\\Start Menu\\Programs\\$shortcutName\"")) {
		output("FAILED: $!\n");
		return 0;
	}
	else { output("OK\n"); }
	return 1;

}</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\tableau_desktop.2018_1\prod\update.pl</FullName>
    <Length>2865</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-07-10T09:41:37.4930735-05:00</CreationTime>
    <CreationTimeUtc>2018-07-10T14:41:37.4930735Z</CreationTimeUtc>
    <LastWriteTime>2018-07-11T16:58:12.6185568-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-11T21:58:12.6185568Z</LastWriteTimeUtc>
    <LastAccessTime>2018-07-10T09:41:37.4930735-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-07-10T14:41:37.4930735Z</LastAccessTimeUtc>
    <Text>#Tableau Desktop
#Package Created November 2017
#Packaged by Chris Schaaf
#Package updated by Sergey Gruzdev, July 2018
#		To install Tableu 2018.1

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;
use File::Copy;
use File::Spec;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'tableaudesktop.2018_1',
        package_revision =&gt; '20180710T0822',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\\dfs\\software\\loginscripts\\im',
    $ENV{'WINDIR'}.'\\SYSTEM32\\UMRINST',
    'C:\\temp',
);
use InstallMonkey::Shared;

use Getopt::Long;

sub usage {
    print qq(usage: $0 [--help]); # [--uninstall]
}

GetOptions(
    'help' =&gt; sub { usage(); exit(0); },
    #'uninstall' =&gt; sub { exit(!uninstall()); },
);

my $src = get_pkg_sourcefiles();
my $installer = build_path(get_pkg_sourcefiles(), "TableauDesktop-64bit-2018-1-2.exe");

do_install(
	allowed_versions =&gt; [OSVER_WIN10_SP0],
	allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
	allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
	exit_on_failure =&gt; 1,
	
	install_sub =&gt; \&amp;install,
	postinstall_sub =&gt; \&amp;postinst_sub,
);
IM_Exit(EXIT_SUCCESS);


sub install{
	output("Installing Tableau Desktop 2018.1: ");
	if(!run_command("$installer /quiet /norestart ACCEPTEULA=1 DESKTOPSHORTCUT=0", 'IgnoreExitCodes' =&gt; [3010])) {
		output("FAILED: $!\n");
		return 0;
	}
	else{ output("OK\nCopying batch file for license handling: "); }
	if(!run_command("copy /Y \"$src\\tableau.bat\" \"$ENV{'PROGRAMFILES'}\\Tableau\\Tableau 2018.1\\bin\"")) {
		output("FAILED: $!\n");
		return 0;
	}
	else{ output("OK\n"); }
	return 1;
}


sub postinst_sub{
	my $shortcutName = "Tableau 2018.1.lnk";
	output("Deleting Start Menu Shortcut: ");
	if(!run_command("del \"$ENV{'PROGRAMDATA'}\\Microsoft\\Windows\\Start Menu\\Programs\\$shortcutName\"")) {
		output("FAILED: $!\n");
		return 0;
	}
	else { output("OK\n"); }
	output("Replacing Shortcut with Batch Script shortcut: ");
	#Credit to Joshua Jones for batch script
	if(!run_command("copy /Y \"$src\\$shortcutName\" \"$ENV{'PROGRAMDATA'}\\Microsoft\\Windows\\Start Menu\\Programs\\$shortcutName\"")) {
		output("FAILED: $!\n");
		return 0;
	}
	else { output("OK\n"); }
	
	output("Adding desktop shortcut shortcut: ");
	#Credit to Joshua Jones for batch script
	if(!run_command("copy /Y \"$src\\$shortcutName\" \"C:\\Users\\Public\\Public Desktop\"")) {
		output("FAILED: $!\n");
		return 0;
	}
	else { output("OK\n"); }
	return 1;

}</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\tdm-gcc.5_1_0\prod\update.pl</FullName>
    <Length>2132</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-13T13:46:03.2673173-05:00</CreationTime>
    <CreationTimeUtc>2017-06-13T18:46:03.2673173Z</CreationTimeUtc>
    <LastWriteTime>2017-07-19T09:26:34.7456669-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-07-19T14:26:34.7456669Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-19T09:26:22.6957006-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-19T14:26:22.6957006Z</LastAccessTimeUtc>
    <Text># Package Created June 2017
# Packaged by Alex Schrimpf
# Last Updated 2017-07-17

=pod

Begin-Doc
Modified: $Date$
Name: TDM-GCC Installer
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

use File::Path;
use Win32::TieRegistry;

my $log_file = get_default_app_log();

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'tdm-gcc.5_1_0-2',
        package_revision =&gt; '20170612T126',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;

sub install {
    my $srcfiles = get_pkg_sourcefiles();
    
    my %szip_locs;
    $szip_locs{"x64"} = "C:\\Program\ Files\\7-Zip\\7z.exe";
    $szip_locs{"x86"} = "C:\\Program\ Files\ (x86)\\7-zip\\7z.exe";

    output(":Looking for 7-zip\n");
    my $szip_loc;
    my $found = 0;
    while((my $dir = each (%szip_locs)) &amp;&amp; !$found){
	$szip_loc = $szip_locs{$dir};
	if($found = -e $szip_loc){
		output("::Found at $szip_loc\n");
	}
    }
    
    if(!$found){
    	output("ERROR: Could not find 7zip\n");
	return 0;
    }

    output(":Extracting files from $srcfiles\n"); 
    if(!run_command("\"$szip_loc\" x \"$srcfiles\\TDM-GCC-64.zip\" -oC:\\ -aos")){   
    	output("ERROR: Could not extract files\n");
	return 0;
    }
    output("::Done\n");

    output(":Modifying Environment Variables\n");
    if(!run_command("setx /M PATH \"C:\\TDM-GCC-64\\bin;%path%\"")){
	output("ERROR: Could not modify \"PATH\"\n");	    
    	return 0;	
    }
    output("::Done\n");

    return 1;
}

do_install( 
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [ 'desktop', 'clc', 'traveling',
                      'virtual-desktop', 'virtual-clc' ],
    install_sub =&gt; \&amp;install,
    exit_on_failure =&gt; 1
);
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\tecplot360.2016.r2\prod\update.pl</FullName>
    <Length>3538</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-12-06T13:40:01.0373073-06:00</CreationTime>
    <CreationTimeUtc>2016-12-06T19:40:01.0373073Z</CreationTimeUtc>
    <LastWriteTime>2018-07-26T13:30:43.4079642-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-26T18:30:43.4079642Z</LastWriteTimeUtc>
    <LastAccessTime>2016-12-06T13:47:03-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-12-06T19:47:03Z</LastAccessTimeUtc>
    <Text># InstallMonkey Template
# Package Created 2016-11-29
# Packaged by Mark Raymond Jr.
# Used 2014 Script
# Last updated 2018 by Sergey Gruzdev

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'tecplot360.2016.R2',

        # some unique id that's updated any time the package undergoes
        #  any sort of minor revision
        package_revision =&gt; '20161129T1115',

#         # if different from default location
#         output_log =&gt; 'path_to_output_log',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;


my $sourcefilesdir = get_pkg_sourcefiles();
my $applogs=get_applogs_dir();
my $pgfiles=$ENV{"ProgramFiles"};
my $audesktop=$ENV{"public"}."\\desktop";

# Be sure that any custom install subs (install_sub, preinstall_sub, or 
# postinstall_sub) return a success/failure value.
# If you don't do any error checking, at least return 1 so that the
# install will continue. The installer aborts (nicely) on failure.
#
 sub install {
     if(!run_command("\"$sourcefilesdir\\tecplot360ex_win64.exe\" /S /v/qn"))
     {
        output("\nInstallation failed!\n");
        return 0;
     }

     return 1;
 }

 sub postinstall {

=rem
    if(!run_command("COPY \"$sourcefilesdir\\activesetup.pl\" \"$pgfiles\\Tecplot\\Tecplot 360 EX 2016 R2\""))
    {
        output("Error copying license to %PROGRAMFILES%\n");
        return 0;
    }
=cut
    
	if(!run_command("copy \"$sourcefilesdir\\360ex.lic\" \"$pgfiles\\Tecplot\\Tecplot 360 EX 2016 R2\" /y"))
    {
        output("Error copying license to %PROGRAMFILES%\n");
        return 0;
    }

    if(!run_command("del /q \"$audesktop\\Tecplot*.lnk\""))
    {
        output("Error deleting desktop shortcut.");
        return 0;
    }
	
	# Open C:\Program Files\Tecplot\Tecplot 360 EX 2016 R2\tecplotlm.lic and add 'HOST tecplot.lic.mst.edu 0 27100'
	open(my $licFile, '&gt;&gt;', "C:\\Program Files\\Tecplot\\Tecplot 360 EX 2016 R2\\tecplotlm.lic") or die "Could not open C:\\Program Files\\Tecplot\\Tecplot 360 EX 2016 R2\\tecplotlm.lic!\n";
	print $licFile "HOST tecplot.lic.mst.edu 0 27100";
	close $licFile;
	
=rem   
    output("Creating activesetup entry.");

    create_activesetup_action(
        'Identifier' =&gt; $INSTALLMONKEY_OPTIONS{'package_id'}.'_setup',
        'ComponentID' =&gt; $INSTALLMONKEY_OPTIONS{'package_id'},
        'Description' =&gt; 'Add license for TecPlot 360 2016.',
        'Version' =&gt; '1.0',
        'StubPath' =&gt; "$pgfiles\\Tecplot\\Tecplot 360 EX 2016 R2\\activesetup.pl");
=cut
	 return 1;
 }
 

 
do_install( 
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
    allowed_os_architectures =&gt; ['x64'],
    allowed_regs =&gt; ["clc", "desktop", "traveling", "virtual-desktop", "virtual-clc"],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\tegrityrecorder.7_5_2393\prod\update.pl</FullName>
    <Length>9735</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-07-22T14:06:19.5383937-05:00</CreationTime>
    <CreationTimeUtc>2016-07-22T19:06:19.5383937Z</CreationTimeUtc>
    <LastWriteTime>2016-07-21T14:07:44.4839777-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-07-21T19:07:44.4839777Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-22T14:06:19.5383937-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-22T19:06:19.5383937Z</LastAccessTimeUtc>
    <Text># Tegrity Recorder 7.5.2393
# Package Created July 2015
# Packaged by Ben Krueger
# Based on previous package by Sam Pilla

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'tegrity.7_5_2301',
        package_revision =&gt; '20160115T1300',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
my $logfile = 'C:\Windows\System32\UMRInst\AppLogs\TegrityLogging.txt';

use Getopt::Long;
GetOptions
(
	'uninstall' =&gt; sub { exit (!uninstall());},
);

# This package has lots of small components. I copied over the installation order- and all the FireFox plugins and such- from charlie's 1018 version of the package.
# The main change I made was to switch from manually calling ExecMsi with run_command to using the install_msi function, which has Todd magic sprinkled in which made it so it no longer pops up the
# "Are you 100% CERTAINLY SURE you want to run this msi?" dialog box for each component it installs. I assume these wouldn't pop up when it was run as the system account, but this
# does make it so a manual installation also "just werkz" and doesn't need you to click yes 12ish times.
sub install 
{
  #install tablet PC redist
  if(!install_msi('msi' =&gt; $sourcefilesdir."\\TPCInkRedist.msi", 'logfile' =&gt; $logfile)){
    output("The tablet PC ink redistrutable was NOT installed successfully!\n");
    return 0;
  }
  else{
    output("The tablet PC ink redistrutable was installed successfully!\n");
  }
  
  #install SAPI 5.1
  if(!install_msi('msi' =&gt; $sourcefilesdir."\\SetupSAPI5.1.msi", 'logfile' =&gt; $logfile)){
    output("SAPI 5.1 was NOT installed successfully!\n");
    return 0;
  }
  else{
    output("SAPI 5.1 was installed successfully!\n");
  }
  
  #install windows media 11 redist
  if(!install_msi('msi' =&gt; $sourcefilesdir."\\SetupWMF11.msi", 'logfile' =&gt; $logfile)){
    output("Windows Media Format 11 sereies redistrutable was NOT installed successfully!\n");
    return 0;
  }
  else{
    output("Windows Media Format 11 series redistrutable was installed successfully!\n");
  }
  
  #install Tegrity podcasting utils 
  if(!install_msi('msi' =&gt; $sourcefilesdir."\\SetupUtils.msi", 'logfile' =&gt; $logfile)){
    output("Tegrity Video Podcasting Utilities were NOT installed successfully!\n");
    return 0;
  }
  else{
    output("Tegrity Video Podcasting Utilities were installed successfully!\n");
  }
  
  #install x86 C++ redist
  if(!install_msi('msi' =&gt; $sourcefilesdir."\\TegVC2013Redist.msi", 'logfile' =&gt; $logfile)){
    output("Microsoft Virtual C++ Redistributable x86 package was NOT installed succcessfully!\n");
    return 0;
  }
  else{
    output("Microsoft Virtual C++ Redistributable x86 package was installed succcessfully!\n");
  }
  
  #install x64 C++ redist
  if(!install_msi('msi' =&gt; $sourcefilesdir."\\TegVC2013Redistx64.msi", 'logfile' =&gt; $logfile)){
    output("Microsoft Virtual C++ Redistributable x64 package was NOT installed succcessfully!\n");
    return 0;
  }
  else{
    output("Microsoft Virtual C++ Redistributable x64 package was installed succcessfully!\n");
  }
  
  #install tegrity
  if(!install_msi('msi' =&gt; $sourcefilesdir."\\TegInstaller.msi", 'logfile' =&gt; $logfile)){
    output("Tegrity installer was NOT installed successfully!\n");
    return 0;
  }
  else{
    output("Tegrity installer was installed successfully!\n");
  }

  #install tegrity plugins
  if(!install_msi('msi' =&gt; $sourcefilesdir."\\TegPlugins.msi", 'logfile' =&gt; $logfile)){
    output("Plugins NOT installed successfully!\n");
    return 0;
  }
  else{
    output("Plugins installed successfully!\n");
  }  
  
  #install tegrity recorder
  if(!install_msi('msi' =&gt; $sourcefilesdir."\\Setup.msi", 'logfile' =&gt; $logfile)){
    output("Tegrity recorder was NOT installed successfully!\n");
    return 0;
  }
  else{
    output("Tegrity recorder was installed successfully!\n");
  }
  return 1;
}
my $programFiles = get_arch_programfiles(OSARCH_x86);
sub postinstall
{
  #install firefox windows media plugin
  if(!install_msi('msi' =&gt; $sourcefilesdir."\\ffplugin\\ffplugin.msi", 'logfile' =&gt; $logfile)){
    output("Tegrity Firefox plugin installation failed!\n"); 
    return 0;
  }
  else{
    output("Tegrity Firefox plugin has been installed!\n");
  }
  
  #install firefox DRM extension
  if(!run_command("XCOPY \"$sourcefilesdir\\tegplug\@tegrity.com\" \"C:\\Program Files (x86)\\Mozilla Firefox\\extensions\\tegplug\@tegrity.com\" /I /Y /Q /E"))
  {
    output("Firefox DRM extension was not installed!\n");
    return 0;
  }
  else{
    output("Firefox DRM extension was installed!\n");
  }
  #set firewall exceptions for firefox
  if(!run_command("netsh -f \"$sourcefilesdir\\firewall.txt\""))
  {
    output("Firewall exception not set!\n");
    return 0;
  }
  else{
    output("Firewall exceptions were set!\n");
  }
  
  #install plugin linker
  if(!install_msi('msi' =&gt; $sourcefilesdir."\\TegPlugins.msi", 'logfile' =&gt; $logfile)){
    output("Plugin linker has not been installed!/n");
    return 0;
  }
  else{
    output("Plugin linker has been installed!\n");
  }
  #Move DRMActiveX files
  if(!run_command("XCOPY \"$sourcefilesdir\\DRM\" \"C:\\Windows\\Downloaded Program Files\" /I /Y /Q "))
  {
    output("Required DRMActiveX files were not copied!\n");
    return 0;
  }
  else{
    output("DRMActiveX files were copied!\n");
  }
  #Install DRMActiveX.dll using regsvr32.exe
  if(!run_command("regsvr32.exe /s \"C:\\Windows\\Downloaded Program Files\\DRMActiveX.dll\""))
  {
	output("Registering .dll failed!\n");
	return 0;
  }
  else{
	output("Registering .dll file successfull!\n");
  }
  # Move the registry key that active setup will be using for the HKCU
  if(!run_command("XCOPY \"$sourcefilesdir\\DRMTrust.reg\" \"%PROGRAMDATA%\\mst\\standard\\Tegrity\\\" /I /Y /Q "))
  {
    output("Active Setup files were not copied correctly! Please run installation again!\n");
    return 0;
  }
  else{
    output("Active Setup files have been copied!\n");
  }
  # Install the registry key for Active Setup
  if(!run_command("REGEDIT /S \"$sourcefilesdir\\ActiveSetup.reg\""))
  {
    output("Active Setup has not been set! Please try installation again!\n");
  }
  else{
    output("Active Setup has been set successfully!\n");
  }
  return 1;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

sub uninstall
{
	if(!run_command("msiexec.exe /qn /x $sourcefilesdir\\TPCInkRedist.msi"))
	{
		output("The tablet PC ink redistrutable was NOT uninstalled successfully!\n");
		return 0;
	}
	else
	{
		output("The tablet PC ink redistrutable was uninstalled successfully!\n");
	}
  
	#install SAPI 5.1
	if(!run_command("msiexec.exe /qn /x $sourcefilesdir\\SetupSAPI5.1.msi"))
	{
		output("SAPI 5.1 was NOT uninstalled successfully!\n");
		return 0;
	}
	else
	{
		output("SAPI 5.1 was uninstalled successfully!\n");
	}
  
	#install windows media 11 redist
	if(!run_command("msiexec.exe /qn /x $sourcefilesdir\\SetupWMF11.msi"))
	{
		output("Windows Media Format 11 sereies redistrutable was NOT uninstalled successfully!\n");
		return 0;
	}
	else
	{
		output("Windows Media Format 11 series redistrutable was uninstalled successfully!\n");
	}
  
	#install Tegrity podcasting utils 
	if(!run_command("msiexec.exe /qn /x $sourcefilesdir\\SetupUtils.msi"))
	{
		output("Tegrity Video Podcasting Utilities were NOT uninstalled successfully!\n");
		return 0;
	}
	else
	{
		output("Tegrity Video Podcasting Utilities were uninstalled successfully!\n");
	}
  
	#install x86 C++ redist
	if(!run_command("msiexec.exe /qn /x $sourcefilesdir\\TegVC2013Redist.msi"))
	{
		output("Microsoft Virtual C++ Redistributable x86 package was NOT uninstalled succcessfully!\n");
		return 0;
	}
	else
	{
		output("Microsoft Virtual C++ Redistributable x86 package was uninstalled succcessfully!\n");
	}
  
	#install x64 C++ redist
	if(!run_command("msiexec.exe /qn /x $sourcefilesdir\\TegVC2013Redistx64.msi"))
	{
		output("Microsoft Virtual C++ Redistributable x64 package was NOT uninstalled succcessfully!\n");
		return 0;
	}
	else
	{
		output("Microsoft Virtual C++ Redistributable x64 package was uninstalled succcessfully!\n");
	}
  
	#install tegrity
	if(!run_command("msiexec.exe /qn /x $sourcefilesdir\\TegInstaller.msi"))
	{
		output("Tegrity installer was NOT uninstalled successfully!\n");
		return 0;
	}
	else
	{
		output("Tegrity installer was uninstalled successfully!\n");
	}

	#install tegrity plugins
	if(!run_command("msiexec.exe /qn /x $sourcefilesdir\\TegPlugins.msi"))
	{
		output("Plugins NOT uninstalled successfully!\n");
		return 0;
	}
	else
	{
		output("Plugins uninstalled successfully!\n");
	}  
  
	#install tegrity recorder
	if(!run_command("msiexec.exe /qn /x $sourcefilesdir\\Setup.msi"))
	{
		output("Tegrity recorder was NOT uninstalled successfully!\n");
		return 0;
	}
	else
	{
		output("Tegrity recorder was uninstalled successfully!\n");
	}
	
	delete_product_registry_key(get_package_id());
}</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\tegrityrecorder.7_5_2458\prod\update.pl</FullName>
    <Length>9755</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-05-17T09:31:58.8145807-05:00</CreationTime>
    <CreationTimeUtc>2017-05-17T14:31:58.8145807Z</CreationTimeUtc>
    <LastWriteTime>2017-05-17T09:56:02.2416518-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-05-17T14:56:02.2416518Z</LastWriteTimeUtc>
    <LastAccessTime>2017-05-17T09:31:58.8145807-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-05-17T14:31:58.8145807Z</LastAccessTimeUtc>
    <Text># Tegrity Recorder 7.5.2498
# Package Created July 2015
# Packaged updated by Chris Schaaf - May 2017
# Based on previous package by Sam Pilla

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'tegrity.7_5_2458',
        package_revision =&gt; '20170517T1000',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
my $logfile = 'C:\Windows\System32\UMRInst\AppLogs\TegrityLogging.txt';

use Getopt::Long;
GetOptions
(
	'uninstall' =&gt; sub { exit (!uninstall());},
);

# This package has lots of small components. I copied over the installation order- and all the FireFox plugins and such- from charlie's 1018 version of the package.
# The main change I made was to switch from manually calling ExecMsi with run_command to using the install_msi function, which has Todd magic sprinkled in which made it so it no longer pops up the
# "Are you 100% CERTAINLY SURE you want to run this msi?" dialog box for each component it installs. I assume these wouldn't pop up when it was run as the system account, but this
# does make it so a manual installation also "just werkz" and doesn't need you to click yes 12ish times.
sub install 
{
  #install tablet PC redist
  if(!install_msi('msi' =&gt; $sourcefilesdir."\\TPCInkRedist.msi", 'logfile' =&gt; $logfile)){
    output("The tablet PC ink redistrutable was NOT installed successfully!\n");
    return 0;
  }
  else{
    output("The tablet PC ink redistrutable was installed successfully!\n");
  }
  
  #install SAPI 5.1
  if(!install_msi('msi' =&gt; $sourcefilesdir."\\SetupSAPI5.1.msi", 'logfile' =&gt; $logfile)){
    output("SAPI 5.1 was NOT installed successfully!\n");
    return 0;
  }
  else{
    output("SAPI 5.1 was installed successfully!\n");
  }
  
  #install windows media 11 redist
  if(!install_msi('msi' =&gt; $sourcefilesdir."\\SetupWMF11.msi", 'logfile' =&gt; $logfile)){
    output("Windows Media Format 11 sereies redistrutable was NOT installed successfully!\n");
    return 0;
  }
  else{
    output("Windows Media Format 11 series redistrutable was installed successfully!\n");
  }
  
  #install Tegrity podcasting utils 
  if(!install_msi('msi' =&gt; $sourcefilesdir."\\SetupUtils.msi", 'logfile' =&gt; $logfile)){
    output("Tegrity Video Podcasting Utilities were NOT installed successfully!\n");
    return 0;
  }
  else{
    output("Tegrity Video Podcasting Utilities were installed successfully!\n");
  }
  
  #install x86 C++ redist
  if(!install_msi('msi' =&gt; $sourcefilesdir."\\TegVC2013Redist.msi", 'logfile' =&gt; $logfile)){
    output("Microsoft Virtual C++ Redistributable x86 package was NOT installed succcessfully!\n");
    return 0;
  }
  else{
    output("Microsoft Virtual C++ Redistributable x86 package was installed succcessfully!\n");
  }
  
  #install x64 C++ redist
  if(!install_msi('msi' =&gt; $sourcefilesdir."\\TegVC2013Redistx64.msi", 'logfile' =&gt; $logfile)){
    output("Microsoft Virtual C++ Redistributable x64 package was NOT installed succcessfully!\n");
    return 0;
  }
  else{
    output("Microsoft Virtual C++ Redistributable x64 package was installed succcessfully!\n");
  }
  
  #install tegrity
  if(!install_msi('msi' =&gt; $sourcefilesdir."\\TegInstaller.msi", 'logfile' =&gt; $logfile)){
    output("Tegrity installer was NOT installed successfully!\n");
    return 0;
  }
  else{
    output("Tegrity installer was installed successfully!\n");
  }

  #install tegrity plugins
  if(!install_msi('msi' =&gt; $sourcefilesdir."\\TegPlugins.msi", 'logfile' =&gt; $logfile)){
    output("Plugins NOT installed successfully!\n");
    return 0;
  }
  else{
    output("Plugins installed successfully!\n");
  }  
  
  #install tegrity recorder
  if(!install_msi('msi' =&gt; $sourcefilesdir."\\Setup.msi", 'logfile' =&gt; $logfile)){
    output("Tegrity recorder was NOT installed successfully!\n");
    return 0;
  }
  else{
    output("Tegrity recorder was installed successfully!\n");
  }
  return 1;
}
my $programFiles = get_arch_programfiles(OSARCH_x86);
sub postinstall
{
  #install firefox windows media plugin
  if(!install_msi('msi' =&gt; $sourcefilesdir."\\ffplugin\\ffplugin.msi", 'logfile' =&gt; $logfile)){
    output("Tegrity Firefox plugin installation failed!\n"); 
    return 0;
  }
  else{
    output("Tegrity Firefox plugin has been installed!\n");
  }
  
  #install firefox DRM extension
  if(!run_command("XCOPY \"$sourcefilesdir\\tegplug\@tegrity.com\" \"C:\\Program Files (x86)\\Mozilla Firefox\\extensions\\tegplug\@tegrity.com\" /I /Y /Q /E"))
  {
    output("Firefox DRM extension was not installed!\n");
    return 0;
  }
  else{
    output("Firefox DRM extension was installed!\n");
  }
  #set firewall exceptions for firefox
  if(!run_command("netsh -f \"$sourcefilesdir\\firewall.txt\""))
  {
    output("Firewall exception not set!\n");
    return 0;
  }
  else{
    output("Firewall exceptions were set!\n");
  }
  
  #install plugin linker
  if(!install_msi('msi' =&gt; $sourcefilesdir."\\TegPlugins.msi", 'logfile' =&gt; $logfile)){
    output("Plugin linker has not been installed!/n");
    return 0;
  }
  else{
    output("Plugin linker has been installed!\n");
  }
  #Move DRMActiveX files
  if(!run_command("XCOPY \"$sourcefilesdir\\DRM\" \"C:\\Windows\\Downloaded Program Files\" /I /Y /Q "))
  {
    output("Required DRMActiveX files were not copied!\n");
    return 0;
  }
  else{
    output("DRMActiveX files were copied!\n");
  }
  #Install DRMActiveX.dll using regsvr32.exe
  if(!run_command("regsvr32.exe /s \"C:\\Windows\\Downloaded Program Files\\DRMActiveX.dll\""))
  {
	output("Registering .dll failed!\n");
	return 0;
  }
  else{
	output("Registering .dll file successfull!\n");
  }
  # Move the registry key that active setup will be using for the HKCU
  if(!run_command("XCOPY \"$sourcefilesdir\\DRMTrust.reg\" \"%PROGRAMDATA%\\mst\\standard\\Tegrity\\\" /I /Y /Q "))
  {
    output("Active Setup files were not copied correctly! Please run installation again!\n");
    return 0;
  }
  else{
    output("Active Setup files have been copied!\n");
  }
  # Install the registry key for Active Setup
  if(!run_command("REGEDIT /S \"$sourcefilesdir\\ActiveSetup.reg\""))
  {
    output("Active Setup has not been set! Please try installation again!\n");
  }
  else{
    output("Active Setup has been set successfully!\n");
  }
  return 1;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

sub uninstall
{
	if(!run_command("msiexec.exe /qn /x $sourcefilesdir\\TPCInkRedist.msi"))
	{
		output("The tablet PC ink redistrutable was NOT uninstalled successfully!\n");
		return 0;
	}
	else
	{
		output("The tablet PC ink redistrutable was uninstalled successfully!\n");
	}
  
	#install SAPI 5.1
	if(!run_command("msiexec.exe /qn /x $sourcefilesdir\\SetupSAPI5.1.msi"))
	{
		output("SAPI 5.1 was NOT uninstalled successfully!\n");
		return 0;
	}
	else
	{
		output("SAPI 5.1 was uninstalled successfully!\n");
	}
  
	#install windows media 11 redist
	if(!run_command("msiexec.exe /qn /x $sourcefilesdir\\SetupWMF11.msi"))
	{
		output("Windows Media Format 11 sereies redistrutable was NOT uninstalled successfully!\n");
		return 0;
	}
	else
	{
		output("Windows Media Format 11 series redistrutable was uninstalled successfully!\n");
	}
  
	#install Tegrity podcasting utils 
	if(!run_command("msiexec.exe /qn /x $sourcefilesdir\\SetupUtils.msi"))
	{
		output("Tegrity Video Podcasting Utilities were NOT uninstalled successfully!\n");
		return 0;
	}
	else
	{
		output("Tegrity Video Podcasting Utilities were uninstalled successfully!\n");
	}
  
	#install x86 C++ redist
	if(!run_command("msiexec.exe /qn /x $sourcefilesdir\\TegVC2013Redist.msi"))
	{
		output("Microsoft Virtual C++ Redistributable x86 package was NOT uninstalled succcessfully!\n");
		return 0;
	}
	else
	{
		output("Microsoft Virtual C++ Redistributable x86 package was uninstalled succcessfully!\n");
	}
  
	#install x64 C++ redist
	if(!run_command("msiexec.exe /qn /x $sourcefilesdir\\TegVC2013Redistx64.msi"))
	{
		output("Microsoft Virtual C++ Redistributable x64 package was NOT uninstalled succcessfully!\n");
		return 0;
	}
	else
	{
		output("Microsoft Virtual C++ Redistributable x64 package was uninstalled succcessfully!\n");
	}
  
	#install tegrity
	if(!run_command("msiexec.exe /qn /x $sourcefilesdir\\TegInstaller.msi"))
	{
		output("Tegrity installer was NOT uninstalled successfully!\n");
		return 0;
	}
	else
	{
		output("Tegrity installer was uninstalled successfully!\n");
	}

	#install tegrity plugins
	if(!run_command("msiexec.exe /qn /x $sourcefilesdir\\TegPlugins.msi"))
	{
		output("Plugins NOT uninstalled successfully!\n");
		return 0;
	}
	else
	{
		output("Plugins uninstalled successfully!\n");
	}  
  
	#install tegrity recorder
	if(!run_command("msiexec.exe /qn /x $sourcefilesdir\\Setup.msi"))
	{
		output("Tegrity recorder was NOT uninstalled successfully!\n");
		return 0;
	}
	else
	{
		output("Tegrity recorder was uninstalled successfully!\n");
	}
	
	delete_product_registry_key(get_package_id());
}</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\test\prod\update.pl</FullName>
    <Length>2105</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-05T18:21:28.9700371-05:00</CreationTime>
    <CreationTimeUtc>2018-05-05T23:21:28.9700371Z</CreationTimeUtc>
    <LastWriteTime>2018-05-05T18:28:16.7880727-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-05T23:28:16.7880727Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-05T18:21:29.0795893-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-05T23:21:29.0795893Z</LastAccessTimeUtc>
    <Text># Zoom 4.1
# Package Created Fall 2017
# Packaged by Alex Schrimpf
# Last Updated Fall 2017 by Alex Schrimpf

=pod

Begin-Doc
Modified: 
Name: 
Type:
Description: 
Language: Perl
LastUpdatedBy:
Version:
Doc-Package-Info
Doc-SVN-Repository:
RCSId:
End-Doc

=cut

use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'IM_helper_test.1_1',
        package_revision =&gt; '',
    );
}

use lib ( '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 'C:\temp' );

use InstallMonkey::Shared;

use IM_helper(
    \%INSTALLMONKEY_OPTIONS,
    v4.06,
    (
        "START" =&gt; [
            sub {
                sleep 5;       
            },
        ],
        "INSTALL" =&gt; [
            sub {
                IM_helper::flush_msg(
                    msg=&gt;"2ND",
                );
                sleep 4;        
                IM_helper::flush_msg(
                    msg=&gt;"2ND DONE",
                );
            },
            sub { 
                IM_helper::flush_msg(
                    msg=&gt;"3RD",
                );
                sleep 30;
            }
        ],
        "UNINSTALL" =&gt; [
            sub{
               IM_helper::uninstall_using_programs_and_features(
                    display_name=&gt; "Zoom",
                );
            },
            sub {
                delete_product_registry_key(get_package_id());
            },
        ]
    )
);

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt;
      [ 'clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    no_install_check =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    no_product_key =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    install_sub =&gt; $IM_helper::exec_call_stack_override || sub{IM_helper::exec_call_stacks(ids=&gt;["START","INSTALL"])}
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\texmaker.5_0_2\prod\update.pl</FullName>
    <Length>2853</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-09T15:13:26.4964529-06:00</CreationTime>
    <CreationTimeUtc>2017-11-09T21:13:26.4964529Z</CreationTimeUtc>
    <LastWriteTime>2017-11-09T15:13:26.4964529-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-11-09T21:13:26.4964529Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-09T15:13:26.4964529-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-09T21:13:26.4964529Z</LastAccessTimeUtc>
    <Text># Texmaker 5.0.2 - Free cross-platform LaTeX editor
# Package generated with GenGen on 2017-Nov-09 15:13
# Packaged by Grayson Gratop

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'texmaker.5_0_2',
    package_revision =&gt; '20171109T1513',
  );
}

# Add InstallMonkey Library to the path
use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use Getopt::Long;
use InstallMonkey::Shared;

GetOptions(
  'uninstall' =&gt; sub { exit(!uninstall()); },
);

my $srcfilesdir = get_pkg_sourcefiles();
my $allUsersDesktop = get_allusers_desktop();
my $allUsersStartmenu = get_allusers_start_menu();
my $startmenudir = "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs";


sub install {
  #thanks, creator of python 2.7 package. second argument is whether or not it's okay if the command fails
  my @installCommands = (
    ["msiexec /qb /i $srcfilesdir\\Texmaker_5.0.2_Win_x64.msi", 0]
  );

  my $success = 0;
  my $allDone = 1;
  
  output("Installing Texmaker 5.0.2... \n");
  
  for (my $i = 0; $i &lt; scalar @installCommands; $i++) {
    output("\t" . $installCommands[$i][0] . ": ");
    $success = run_command($installCommands[$i][0]);
    output($success ? "Done!\n" : "FAILED: $!\n");
    $allDone &amp;&amp;= $installCommands[$i][1] || $success;
  }

  if ($allDone) {
    output("Looks like it was a success!\n");
  }
  else {
    output("Something went wrong!\n");
  }

  return $allDone;
}


sub postInstall {
  my $iconSuccess = 0;

  #Delete icons in every user's Desktop folder (excluding Default). Thanks, StackOverflow
  opendir(DIR, 'C:\\Users');
  my @users = grep { (!/^\.\.?$/) &amp;&amp; (-d "C:\\Users\\$_") &amp;&amp; ($_ ne 'Default') } readdir(DIR);
  closedir(DIR);

  foreach my $place (@users) {
    $iconSuccess += run_command("DEL /Q \"C:\\Users\\$place\\Desktop\\Texmaker.lnk\"");
  }

  output($iconSuccess ? "$iconSuccess desktop icon(s) were removed.\n"
                      : "Did not remove any desktop icons.\n");



  return 1;
}


do_install( 
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
  allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postInstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\textpad.7_5_1\dev\update.pl</FullName>
    <Length>1330</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-06T09:22:38.7865865-05:00</CreationTime>
    <CreationTimeUtc>2017-06-06T14:22:38.7865865Z</CreationTimeUtc>
    <LastWriteTime>2017-06-07T10:09:55.1487202-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-07T15:09:55.1487202Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-06T09:22:38.7865865-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-06T14:22:38.7865865Z</LastAccessTimeUtc>
    <Text># Textpad 7.5.1
# Package Created June 2017
# Packaged by Alex Schrimpf
# Last Updated 2017-06-07

=pod

Begin-Doc
Modified: $Date:
Name: Smart Notebook 11.4 Installer
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author: Schrimpf $
Version: $Revision:  $
Doc-Package-Info: 
Doc-SVN-Repository: $URL:  $
RCSId: $Id: $
End-Doc

=cut

use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'textpad.7_5_1',
        package_revision =&gt; '20170606T1350',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);

use InstallMonkey::Shared;
use Getopt::Long;
my $srcfiles =  get_pkg_sourcefiles();

sub install {

    output("\nTextpad 7_5_1...");
    if(!run_command("$srcfiles\\setup.exe /S /v/qn"))
    {
        output("Failed to install Textpad 7_5_1\n");
        return 0;
    }

    return 1;
}


do_install( 
    allowed_versions =&gt; [ OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [ OSARCH_x32,OSARCH_x64 ],
    allowed_regs =&gt; [ 'clc', 'desktop', 'traveling',
                      'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
);
IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\textpad.7_5_1\prod\update.pl</FullName>
    <Length>4020</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-07T10:29:18.9311002-05:00</CreationTime>
    <CreationTimeUtc>2017-06-07T15:29:18.9311002Z</CreationTimeUtc>
    <LastWriteTime>2017-06-07T10:33:21.8589718-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-07T15:33:21.8589718Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-07T10:29:18.9311002-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-07T15:29:18.9311002Z</LastAccessTimeUtc>
    <Text># Textpad 7.4.0
# Package Copied from TextPad 7.4.0 by Ryan Andrews on June 5, 2015
# Last Updated 2017-06-07 By Alex Schrimpf

use strict;
use warnings;
use Getopt::Long;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'textpad.7_5_1',

        # some unique id that's updated any time the package undergoes
        #  any sort of minor revision
        package_revision =&gt; '20150605T1156',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
# my $cwd = cwd();
# my $log_dir = get_applogs_dir();

GetOptions(
	'uninstall' =&gt; sub { exit ( !uninstall());},
);

#/////////////////////////////////////////////////////////////////////////#
sub uninstall
{
	InstallMonkey::Shared::copy_source_files(); # If we don't already have them, we need them
    output("Uninstalling Textpad 7.5.1: ");
	
	#my $success = install_msi(
    #    msi =&gt; cmd_quote(build_path($srcfiles, "TextPad 7.msi", )),
    #    msi_action_flag =&gt; 'x'
    #);
    my $Path = cmd_quote(build_path($srcfiles, "TextPad 7.msi"));
    my $success = run_command("msiexec.exe /x $Path /quiet");
	
	output(($success ? "OK\n" : "Failed\n" ));
	
	if($success)
	{
		delete_product_registry_key(get_package_id());
	}
}
#/////////////////////////////////////////////////////////////////////////#
sub preinstall
{
  #probably dont need a preinstall
  return 1;
}

sub install
{
  print "\nInstalling Textpad 7.5.1: ";
  #push_dir($srcfiles);
  # my $source = "$srcfiles\\TEMPLATE";
  # my $dest = "C:\\TEMPLATE";
  # run_command("xcopy \"$source\" \"$dest\" /s/y/i"); #copy program files for quicker install
  my $MSI = install_msi(
    msi =&gt; cmd_quote(build_path($srcfiles, "TextPad 7.msi", ))
  );
  
  if(!$MSI)
  {
    print "FAILED!!\n";
    return 0;
  }
  else
  {
    print "Success\n";
  }
  #pop_dir();
  return 1;
}
#/////////////////////////////////////////////////////////////////////////#
sub postinstall 
{
  # copy license file
  print "\nInstalling License settings...";
  my $source = "$srcfiles\\TextPadKey.xml";
  my $dest = "%ProgramData%\\Helios\\TextPad\\";
  if(!run_command("xcopy \"$source\" \"$dest\" /s/y/i")){ 
    print "FAILED!!\n";
  }
  else{
    print "OK.\n";
  }
  return 1;
}
#/////////////////////////////////////////////////////////////////////////#
do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
#    prerequisite_sub =&gt; \&amp;prereq_sub,
#    prerequisite_sub_x86 =&gt; \&amp;prereq86_sub,
#    prerequisite_sub_x64 =&gt; \&amp;prereq64_sub,
#    preinstall_sub =&gt; \&amp;preinstall,
#    preinstall_sub_x86 =&gt; \&amp;preinst86_sub,
#    preinstall_sub_x64 =&gt; \&amp;preinst64_sub,
   # install_sub =&gt; \&amp;install,
#    install_sub_x86 =&gt; \&amp;inst86_sub,
#    install_sub_x64 =&gt; \&amp;inst64_sub,
   postinstall_sub =&gt; \&amp;postinstall,
#    postinstall_sub_x86 =&gt; \&amp;postinst86_sub,
#    postinstall_sub_x64 =&gt; \&amp;postinst64_sub,
   msi_name =&gt; 'textpad 7.msi',                     #changed from 6
#    msi_name_x86 =&gt; 'installer86.msi',
#    msi_name_x64 =&gt; 'installer64.msi',
#    msi_ignore_exit_codes =&gt; [ ],
#    msi_ignore_exit_codes_x86 =&gt; [ ],
#    msi_ignore_exit_codes_x64 =&gt; [ ],
   additional_msi_properties =&gt; 'REBOOT="ReallySuppress"',
#    additional_msi_properties_x86 =&gt; 'REBOOT="ReallySuppress"',
#    additional_msi_properties_x64 =&gt; 'REBOOT="ReallySuppress"',
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\texworks.0_6_0\prod\update.pl</FullName>
    <Length>1446</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-07-14T14:14:53.6912339-05:00</CreationTime>
    <CreationTimeUtc>2016-07-14T19:14:53.6912339Z</CreationTimeUtc>
    <LastWriteTime>2016-08-04T15:56:22.5232133-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-08-04T20:56:22.5232133Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-14T14:14:53.7380348-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-14T19:14:53.7380348Z</LastAccessTimeUtc>
    <Text># TeXWorks 0.6.0
# Package Created July 2016
# Packaged by Ronith
# Last Updated ...

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'texworks.0_6_0',
        package_revision =&gt; '20160804T1310',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
my $audesktop=$ENV{"public"}."\\desktop";

 sub install {
	output("installing TeXWorks 0.6.0\n");
	run_command("$sourcefilesdir\\setup.exe /VERYSILENT");
	output("Installation complete! \n");
   return 1;
}

sub postinstall{
	output("removing desktop icons \n");
	run_command("del /q /F \"$audesktop\\TeXworks.lnk\"");
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling','virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
	install_sub =&gt; \&amp;install,
	postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);


</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\TeXWorks.0_6_2\prod\update.pl</FullName>
    <Length>1567</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-08T15:09:27.2789817-06:00</CreationTime>
    <CreationTimeUtc>2017-11-08T21:09:27.2789817Z</CreationTimeUtc>
    <LastWriteTime>2017-11-08T15:13:26.5244663-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-11-08T21:13:26.5244663Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-08T15:09:27.2789817-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-08T21:09:27.2789817Z</LastAccessTimeUtc>
    <Text># TeXWorks 0.6.2
# Package Created July 2016
# Packaged by Ronith
# Last Updated from v0.6.0 by Alex Schrimpf

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'texworks.0_6_2',
        package_revision =&gt; '20171108T1310',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
my $audesktop=$ENV{"public"}."\\desktop";

 sub install {
	output("INSTALLING TEXWORKS 0.6.2\n");
	if(!run_command("$sourcefilesdir\\TeXworks-win-setup-0.6.2-201704300708-git_7ecce17.exe /VERYSILENT")){
        output(":: FAILED\n\n");
        return 0;
    }
   output(": DONE\n\n");
   return 1;
}

sub postinstall{
	output("removing desktop icons \n");
	run_command("del /q /F \"$audesktop\\TeXworks.lnk\"");
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling','virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
	install_sub =&gt; \&amp;install,
	postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);


</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\thermaldesktop.5_8\dev\update.pl</FullName>
    <Length>2195</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-05-31T09:00:12.7806496-05:00</CreationTime>
    <CreationTimeUtc>2017-05-31T14:00:12.7806496Z</CreationTimeUtc>
    <LastWriteTime>2017-12-06T16:26:34.2366639-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-12-06T22:26:34.2366639Z</LastWriteTimeUtc>
    <LastAccessTime>2017-05-31T09:00:12.7806496-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-05-31T14:00:12.7806496Z</LastAccessTimeUtc>
    <Text>
    # Thermal Desktop
    # Package Created May 31, 2017
    # Packaged by Krueger, Benjamin (S&amp;T IT Student Employee)
    # Last Updated --

    BEGIN {
        %::INSTALLMONKEY_OPTIONS = (
            package_id =&gt; 'thermaldesktop.5_8',
            package_revision =&gt; '20170531T0859',
        );
    }

    use lib (
        '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
        $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
        'C:\temp',
    );
    use InstallMonkey::Shared;

    my $srcfiles = get_pkg_sourcefiles();
    my $log_dir = get_applogs_dir();
    sub preinstall {
        if(run_command("fsutil 8dot3name query c:"))
        {
            output("Enable Short file name creation");
            run_command("REG ADD \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\FileSystem\" /v NtfsDisable8dot3NameCreation /d 1 /f");
        }
        

    }
    sub install {
        output("Installing Thermal Desktop Academic 5.8:");
        run_command($srcfiles."\\ThermalDesktopAcad58_64.exe /S",IgnoreExitCodes =&gt; [1]);
        sleep(250);
        output("Installing SindaFluint58");
        $succ = run_command($srcfiles."\\SindaFluint58L.exe /S",IgnoreExitCodes =&gt; [1]);
        output(($succ)?"OK":"FAILED"/"\n");
        return $succ;
    }
    sub postinstall {
        output("Licensing thermaldesktop");
        my $licexe = "\"C:\\Program Files\\Cullimore and Ring\\Shared64\\LicenseManager.exe\"";
        my $licfile = $srcfiles."\\19516_thermaldesk-01_V5.8.lpk";
        run_command($licexe." ".$licfile);
        sleep(100);
        KillProcess("LicenseManager.exe");
    }

    do_install( 
        exit_on_failure =&gt; 1,
        allowed_versions          =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
        allowed_os_architectures  =&gt; [ OSARCH_x64 ],
        allowed_regs              =&gt; [ "clc", "desktop", "traveling", "virtual-desktop", "virtual-clc" ],
        install_sub               =&gt; \&amp;install,
        preinstall_sub            =&gt; \&amp;preinstall,
        
    );

    IM_Exit(EXIT_SUCCESS);

    ########################################################################
    </Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\thermaldesktop.5_8\prod\update.pl</FullName>
    <Length>4322</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-01-15T13:43:02.1291809-06:00</CreationTime>
    <CreationTimeUtc>2018-01-15T19:43:02.1291809Z</CreationTimeUtc>
    <LastWriteTime>2018-01-24T10:37:51.3694071-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-24T16:37:51.3694071Z</LastWriteTimeUtc>
    <LastAccessTime>2018-01-15T13:43:02.1291809-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-01-15T19:43:02.1291809Z</LastAccessTimeUtc>
    <Text># Thermal Desktop 5.8
# Package Created Fall 2017
# Packaged by Alex Schrimpf
# Last Updated Fall 2017 by Alex Schrimpf


=pod

Begin-Doc
Modified: 
Name: 
Type:
Description: 
Language: Perl
LastUpdatedBy:
Version:
Doc-Package-Info
Doc-SVN-Repository:
RCSId:
End-Doc

=cut

use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'thermaldesktop.5_8',
        package_revision =&gt; '',
    );
}

use lib ( '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 'C:\temp' );

use InstallMonkey::Shared;

use IM_helper(
    \%INSTALLMONKEY_OPTIONS,
    v4.04,
    (
        "INSTALL" =&gt; [
            sub {
                IM_helper::create_reg_key(
                    root =&gt; "HKEY_LOCAL_MACHINE/",
                    key =&gt; "software/Cullimore and Ring",
                );
            },
            sub {
                IM_helper::set_reg_key_values(
                    key=&gt; 'HKEY_LOCAL_MACHINE/software/Cullimore and Ring/',
                    values=&gt; ['SHARED_LOC'=&gt;['C:\Program Files\Cullimore and Ring\Shared64','REG_SZ']]
                );
            },
            # Enable short file name creation. Says to in the docs.
            sub {
                IM_helper::run_command(
                    description =&gt; "Checking for Short file name creation",
                    command =&gt; "fsutil 8dot3name query c:",
                    succ_cb =&gt; sub {
                                IM_helper::set_reg_key_values(
                                    key=&gt; 'HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Control/FileSystem/',
                                    values=&gt; ['NtfsDisable8dot3NameCreation'=&gt;['0x00000000','REG_DWORD']]
                                );
                            }
                );
            },
            sub {
                IM_helper::run_command(
                    description =&gt; "Installing SindaFluint58L6",
                    command =&gt; "$IM_helper::source_files\\SindaFluint58L6.exe /S",
                );
            },
  
            sub {
                IM_helper::run_command(
                    description =&gt; "Installing Thermal Desktop Academic 5.8",
                    command =&gt; "$IM_helper::source_files\\ThermalDesktopAcad58_64.exe /S",
                );
            },

        ],
        "LICENSE" =&gt;
        [
            sub {
                IM_helper::cp_file(
                    from =&gt; "$IM_helper::source_files\\sinda.lic",
                    to_dir =&gt; "C:\\Program Files (x86)\\Cullimore and Ring\\SindaFluint\\bin"
                );
            },  
            sub {
                IM_helper::cp_file(
                    from =&gt; "$IM_helper::source_files\\radcad.lic",
                    to_dir =&gt; "C:\\Program Files\\Cullimore and Ring\\Thermal Desktop"
                );
            },
            sub {
               IM_helper::run_command(
                    description =&gt; 'Setting Thermal Desktop System Variable',
                    command =&gt; "setx CRTECH_LICENSE_FILE 27000\@thermaldesktop.lic.mst.edu -m"
                );
            },    
        ],
        "UNINSTALL" =&gt; [
            sub {
                IM_helper::uninstall_using_programs_and_features(
                    display_name =&gt; "Thermal Desktop"
                );
            },
            sub {
                IM_helper::uninstall_using_programs_and_features(
                    display_name =&gt; "SindaFluint"  
                );
            },
            sub {
                delete_product_registry_key(get_package_id());
            },
        ]
    )
);

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt;
      [ 'clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    no_install_check =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    no_product_key =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    install_sub =&gt; $IM_helper::exec_call_stack_override || sub{IM_helper::exec_call_stacks(ids=&gt;["INSTALL","LICENSE"])}
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\thermocalc.2016a\dev\update.pl</FullName>
    <Length>1557</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-07-11T10:50:36.8261113-05:00</CreationTime>
    <CreationTimeUtc>2016-07-11T15:50:36.8261113Z</CreationTimeUtc>
    <LastWriteTime>2016-07-18T13:42:42.0540189-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-07-18T18:42:42.0540189Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-11T10:50:36.8573119-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-11T15:50:36.8573119Z</LastAccessTimeUtc>
    <Text># Package created July 8 2016
# Package created by Austin Wall
# Last updated -- by --

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
	%INSTALLMONKEY_OPTIONS = 
	(
		package_id =&gt; 'thermocalc.2016a',
		package_revision =&gt; '20160711T1051'
	);
}	

use lib
(
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);

use InstallMonkey::Shared;

my $getapplogsdir = get_applogs_dir();
my $sourcefilesdir = get_pkg_sourcefiles();

my $product_name = "Thermo-Calc 2016a";
my $executable = "windows-installation-x64-6.0.0.18309.exe";
sub install
{
	#output("Looking up cname...\n");
	#my $nslookup = `nslookup thermocalc.lic.mst.edu`;
	#$nslookup =~ /^(Name: *)(?&lt;name&gt;.*)$/gmi;
	#my $server_name = $+{name};
	#my $server_name = 'thermocalc.lic.mst.edu';
	my $args = " --mode unattended --installation_mode custom --optionfile $sourcefilesdir\\optionfile.txt";
	output("Installing $product_name...\n");
	if(!run_command("$sourcefilesdir\\$executable $args"))
	{
		output("$product_name installation failed!\n");
		return 0;
	}
	output("$product_name installation succeeded!\n");
	return 1;
	#$ENV{'LHOST'} = 'thermocalc.lic.mst.edu';
}

do_install
(
	allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
	allowed_os_architectures =&gt; [ OSARCH_x64 ],
	allowed_regs =&gt; [ 'clc', 'desktop' , 'traveling' , 'virtual-clc', 'virtual-desktop' ],
	exit_on_failure =&gt; 1,
	install_sub =&gt; \&amp;install,
);


IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\thermocalc.2016a\prod\update.pl</FullName>
    <Length>1557</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-07-18T13:48:30.6583227-05:00</CreationTime>
    <CreationTimeUtc>2016-07-18T18:48:30.6583227Z</CreationTimeUtc>
    <LastWriteTime>2016-07-18T13:42:42.0540189-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-07-18T18:42:42.0540189Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-18T13:48:30.6583227-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-18T18:48:30.6583227Z</LastAccessTimeUtc>
    <Text># Package created July 8 2016
# Package created by Austin Wall
# Last updated -- by --

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
	%INSTALLMONKEY_OPTIONS = 
	(
		package_id =&gt; 'thermocalc.2016a',
		package_revision =&gt; '20160711T1051'
	);
}	

use lib
(
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);

use InstallMonkey::Shared;

my $getapplogsdir = get_applogs_dir();
my $sourcefilesdir = get_pkg_sourcefiles();

my $product_name = "Thermo-Calc 2016a";
my $executable = "windows-installation-x64-6.0.0.18309.exe";
sub install
{
	#output("Looking up cname...\n");
	#my $nslookup = `nslookup thermocalc.lic.mst.edu`;
	#$nslookup =~ /^(Name: *)(?&lt;name&gt;.*)$/gmi;
	#my $server_name = $+{name};
	#my $server_name = 'thermocalc.lic.mst.edu';
	my $args = " --mode unattended --installation_mode custom --optionfile $sourcefilesdir\\optionfile.txt";
	output("Installing $product_name...\n");
	if(!run_command("$sourcefilesdir\\$executable $args"))
	{
		output("$product_name installation failed!\n");
		return 0;
	}
	output("$product_name installation succeeded!\n");
	return 1;
	#$ENV{'LHOST'} = 'thermocalc.lic.mst.edu';
}

do_install
(
	allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
	allowed_os_architectures =&gt; [ OSARCH_x64 ],
	allowed_regs =&gt; [ 'clc', 'desktop' , 'traveling' , 'virtual-clc', 'virtual-desktop' ],
	exit_on_failure =&gt; 1,
	install_sub =&gt; \&amp;install,
);


IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\thermocalc.2017a\dev\update.pl</FullName>
    <Length>1596</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-05-31T08:43:31.7405992-05:00</CreationTime>
    <CreationTimeUtc>2017-05-31T13:43:31.7405992Z</CreationTimeUtc>
    <LastWriteTime>2017-07-24T14:48:18.961445-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-07-24T19:48:18.961445Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-11T10:50:36-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-11T15:50:36Z</LastAccessTimeUtc>
    <Text># Package created May 31 2017
# Package created by Benjamin Krueger
# Last updated -- by -- Benjamin Krueger

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
	%INSTALLMONKEY_OPTIONS = 
	(
		package_id =&gt; 'thermocalc.2017a',
		package_revision =&gt; '20170531T0845'
	);
}	

use lib
(
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);

use InstallMonkey::Shared;

my $getapplogsdir = get_applogs_dir();
my $sourcefilesdir = get_pkg_sourcefiles();

my $product_name = "Thermo-Calc 2017a";
my $executable = "windows-installation-x64-2017a.37753.exe";
sub install
{
	output("Looking up cname...\n");
	my $nslookup = `nslookup thermocalc.lic.mst.edu`;
	$nslookup =~ /^(Name: *)(?&lt;name&gt;.*)$/gmi;
	my $server_name = $+{name};
	my $server_name = 'thermocalc.lic.mst.edu';
	my $args = " --mode unattended --installation_mode custom --optionfile $sourcefilesdir\\optionfile.txt";
	output("Installing $product_name...\n");
	if(!run_command("$sourcefilesdir\\$executable $args",IgnoreExitCodes =&gt; [1]))
	{
		output("$product_name installation failed!\n");
		return 0;
	}
	output("$product_name installation succeeded!\n");
	return 1;
	$ENV{'LHOST'} = 'thermocalc.lic.mst.edu';
}

do_install
(
	allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
	allowed_os_architectures =&gt; [ OSARCH_x64 ],
	allowed_regs =&gt; [ 'clc', 'desktop' , 'traveling' , 'virtual-clc', 'virtual-desktop' ],
	exit_on_failure =&gt; 1,
	install_sub =&gt; \&amp;install,
);


IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\tortoisesvn.1_9_4\prod\update.pl</FullName>
    <Length>1514</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-12-02T14:57:21.4769097-06:00</CreationTime>
    <CreationTimeUtc>2016-12-02T20:57:21.4769097Z</CreationTimeUtc>
    <LastWriteTime>2016-12-02T15:20:20.9802381-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-12-02T21:20:20.9802381Z</LastWriteTimeUtc>
    <LastAccessTime>2016-12-02T14:57:21.4769097-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-12-02T20:57:21.4769097Z</LastAccessTimeUtc>
    <Text># TortoiseSVN 1.9.4
# Package Created December 2016
# Packaged by Chris Schaaf 
# Last Update ...

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'tortoisesvn.1_9_4',
        package_revision =&gt; '20161202T1500',
    );
}

use lib (
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
my $applogs=get_applogs_dir();
my $programfiles = get_arch_programfiles(OSARCH_x64);

sub install{
	output("Installing TortoiseSVN 1.9.4: ");
    if(!run_command("$sourcefilesdir\\TortoiseSVN-1.9.4.27285-x64-svn-1.9.4.msi /qn"))
    {
        output("FAIL: $!\n");
        return 0;
    }
    else{
        output("OK\n");
    }
    return 1;
}

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                     'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
	install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\tortoise_svn.1_9_7\prod\update.pl</FullName>
    <Length>1434</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-08T09:44:13.6200962-06:00</CreationTime>
    <CreationTimeUtc>2017-11-08T15:44:13.6200962Z</CreationTimeUtc>
    <LastWriteTime>2017-11-08T09:28:36.4094192-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-11-08T15:28:36.4094192Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-08T09:44:13.6200962-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-08T15:44:13.6200962Z</LastAccessTimeUtc>
    <Text># Package created 11/8/2017
# Package created by Sergey Gruzdev
# Last Updated 11/8/2017 by Sergey Gruzdev

=pod

Begin-Doc
Modified: $Date$
Name: $Name$
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'tortoise_svn.1_9__7',
        package_revision =&gt; '20170811T0917',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

my $src = get_pkg_sourcefiles();

GetOptions(
    'uninstall' =&gt; sub { exit(!uninstall()); },
);

sub uninstall
{
  if(!install_msi(app_id =&gt; "$src\\TortoiseSVN-1.9.7.27907-x64-svn-1.9.7.msi", msi_action_flag =&gt; 'x'))
  {
    print "Error: could not uninstall TortoiseSVN!\n";
	exit(1);
  }
  print "Uninstalled TortoiseSVN succesfully!\n";
  exit(0);
}

do_install
(
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x86, OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  msi_name =&gt; "TortoiseSVN-1.9.7.27907-x64-svn-1.9.7.msi",
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\turningpoint.7_3_0\prod\update.pl</FullName>
    <Length>2812</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-07-12T15:37:33.7242966-05:00</CreationTime>
    <CreationTimeUtc>2016-07-12T20:37:33.7242966Z</CreationTimeUtc>
    <LastWriteTime>2016-07-12T15:25:19.6370908-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-07-12T20:25:19.6370908Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-12T15:37:33.7242966-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-12T20:37:33.7242966Z</LastAccessTimeUtc>
    <Text>#TurningPointCloud 7_3_0
#Package Created July 2016
#Packaged by:Benjamin Krueger
#Last Updated 2016-07-12 by Benjamin Krueger

=pod

Begin-Doc
Modified: $Date$
Name: Turningpoint 7.3.0 installer
Type: script
Description: Installs version 7.3.0 of TurningPoint
Language: Perl
LastUpdatedBy: $Author: bokkw4$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut
BEGIN{
    %INSTALLMONKEY_OPTIONS =(
        package_id =&gt; "TurningPointCloud.7_3_0_116",
        package_revision =&gt; "73011620160712T947"
    )
}

use lib(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;
GetOptions('uninstall' =&gt; sub {exit(!uninstall());});
#so the installer given to me will works in an odd fashion
#it will extract an msi and use msiexec to install the program
#yet provides no option in which to just extract an msi.
#so I install the program with silent install parameters.
sub install {
    output("Runninng Turning Point Cloud Setup executable..\n");
    if(!run_command("".get_pkg_sourcefiles()."\\TurningPointCloudInstall.exe /S /v/qn"))
    {
        output("Turning Point Cloud installation failed.\n");
        return 0;
    }
    return 1;
}
#Since the program was installed as an msi (although not through install monkey)
#I can remove it quite easily through install monkey.

sub postinstall
{
    #get rid of the icon.
     run_command('DEL "C:\\Users\\Public\\Desktop\\TurningPoint Cloud.lnk"');
     my $shortcutdir = get_allusers_start_menu().'\TurningPointCloud';
     #create start menu shortcut
     output("Creating shortcut in $shortcutdir\n");
     mkdir $shortcutdir unless -d $shortcutdir;
     if(!create_shortcut(
		'target' 	  =&gt; 'C:\Program Files (x86)\Turning Technologies\TurningPoint Cloud\TurningPoint Cloud.exe',
		'link' 		  =&gt; $shortcutdir.'\Turning Point Cloud.lnk',
		'description' =&gt; 'Launches TurningPointCloud',
		)
    )
	{
		output("\nERROR: Could not create shortcut.\n");
	}
    return 1;   
}
do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1,OSVER_WIN8_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64,OSARCH_x86],
    allowed_regs =&gt; ['desktop','virtual-desktop','traveling','clc','virtual-clc'],
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);
IM_Exit(EXIT_SUCCESS);
sub uninstall
{
    output("Uninstalling Turning Point Cloud:");
    my $outcome = install_msi(app_id =&gt; '{b5725511-8661-4444-b107-1d1a1578c00b}',msi_action_flag =&gt; 'x');
    output(($outcome?'OK':'Failed')."\n");
    if($outcome)
    {
        delete_product_registry_key(get_package_name().".".get_version());
    }
    return 1;
}</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\turningpoint.8_2_0_30\prod\update.pl</FullName>
    <Length>2820</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-02T08:51:53.7112804-05:00</CreationTime>
    <CreationTimeUtc>2017-06-02T13:51:53.7112804Z</CreationTimeUtc>
    <LastWriteTime>2017-06-02T09:26:15.8369359-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-02T14:26:15.8369359Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-12T15:37:33-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-12T20:37:33Z</LastAccessTimeUtc>
    <Text>#TurningPointCloud 8.2.0
#Package Created June 2017
#Packaged by:Benjamin Krueger
#Last Updated 2017-06-02 by Benjamin Krueger

=pod

Begin-Doc
Modified: $Date$
Name: Turningpoint 7.3.0 installer
Type: script
Description: Installs version 7.3.0 of TurningPoint
Language: Perl
LastUpdatedBy: $Author: bokkw4$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut
BEGIN{
    %INSTALLMONKEY_OPTIONS =(
        package_id =&gt; "turningpoint.8_2_0_30",
        package_revision =&gt; "20170602T0854"
    )
}

use lib(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;
GetOptions('uninstall' =&gt; sub {exit(!uninstall());});
#so the installer given to me will works in an odd fashion
#it will extract an msi and use msiexec to install the program
#yet provides no option in which to just extract an msi.
#so I install the program with silent install parameters.
sub install {
    output("Runninng Turning Point Cloud Setup executable..\n");
    if(!run_command("".get_pkg_sourcefiles()."\\TurningPointInstaller-08.02.00-0030.exe /S /v/qn"))
    {
        output("Turning Point Cloud installation failed.\n");
        return 0;
    }
    return 1;
}
#Since the program was installed as an msi (although not through install monkey)
#I can remove it quite easily through install monkey.

sub postinstall
{
    #get rid of the icon.
     run_command('DEL "C:\\Users\\Public\\Desktop\\TurningPoint App.lnk"');
     my $shortcutdir = get_allusers_start_menu().'\TurningPointCloud';
     #create start menu shortcut
     output("Creating shortcut in $shortcutdir\n");
     mkdir $shortcutdir unless -d $shortcutdir;
     if(!create_shortcut(
		'target' 	  =&gt; 'C:\Program Files (x86)\Turning Technologies\TurningPoint App\TurningPoint.exe',
		'link' 		  =&gt; $shortcutdir.'\Turning Point Cloud.lnk',
		'description' =&gt; 'Launches TurningPointCloud',
		)
    )
	{
		output("\nERROR: Could not create shortcut.\n");
	}
    return 1;   
}
do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1,OSVER_WIN8_SP0,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64,OSARCH_x86],
    allowed_regs =&gt; ['desktop','virtual-desktop','traveling','clc','virtual-clc'],
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);
IM_Exit(EXIT_SUCCESS);

sub uninstall
{
    output("Uninstalling Turning Point Cloud:");
    my $outcome = install_msi(app_id =&gt; '{c3a5f725-a6d3-4a5e-9d60-ba4a14af6999}',msi_action_flag =&gt; 'x');
    output(($outcome?'OK':'Failed')."\n");
    if($outcome)
    {
        delete_product_registry_key(get_package_name().".".get_version());
    }
    return 1;
}</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\turningpoint.8_5_0_39\prod\update.pl</FullName>
    <Length>3150</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-07-12T08:41:54.7897203-05:00</CreationTime>
    <CreationTimeUtc>2018-07-12T13:41:54.7897203Z</CreationTimeUtc>
    <LastWriteTime>2018-07-12T12:49:59.2971262-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-12T17:49:59.2971262Z</LastWriteTimeUtc>
    <LastAccessTime>2018-07-12T09:19:47.8220047-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-07-12T14:19:47.8220047Z</LastAccessTimeUtc>
    <Text>#TurningPointCloud 8.2.0
#Package Created June 2017
#Packaged by:Benjamin Krueger
#Updated 2017-06-02 by Benjamin Krueger
#Last Updated July 12, 2018 by Gavin Altermatt

=pod

Begin-Doc
Modified: $Date$
Name: Turningpoint 7.3.0 installer
Type: script
Description: Installs version 7.3.0 of TurningPoint
Language: Perl
LastUpdatedBy: $Author: bokkw4$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut
BEGIN{
    %INSTALLMONKEY_OPTIONS =(
        package_id =&gt; "turningpoint.8_5_0_39",
        package_revision =&gt; "20180712T0922"
    )
}

use lib(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;
GetOptions('uninstall' =&gt; sub {exit(!uninstall());});
#so the installer given to me will works in an odd fashion
#it will extract an msi and use msiexec to install the program
#yet provides no option in which to just extract an msi.
#so I install the program with silent install parameters.
sub install {
    output("Runninng Turning Point Cloud Setup executable..\n");
    if(!run_command("".get_pkg_sourcefiles()."\\TurningPoint_Installer_8.5.0.39.exe /S /v/qn"))
    {
        output("Turning Point Cloud installation failed.\n");
        return 0;
    }
    return 1;
}
#Since the program was installed as an msi (although not through install monkey)
#I can remove it quite easily through install monkey.

sub postinstall
{
    #get rid of the icon.
     run_command('DEL "C:\\Users\\Public\\Desktop\\TurningPoint App.lnk"');
     my $shortcutdir = get_allusers_start_menu().'\TurningPointCloud';
     #create start menu shortcut
     output("Creating shortcut in $shortcutdir\n");
     mkdir $shortcutdir unless -d $shortcutdir;
     if(!create_shortcut(
		'target' 	  =&gt; 'C:\Program Files (x86)\Turning Technologies\TurningPoint App\TurningPoint.exe',
		'link' 		  =&gt; $shortcutdir.'\Turning Point Cloud.lnk',
		'description' =&gt; 'Launches TurningPointCloud',
		)
    )
	{
		output("\nERROR: Could not create shortcut.\n");
	}
    return 1;
    if(!run_command("DEL /q \"%public%\\Users\\Public\\Desktop\\TurningPoint App.lnk\"")){
      output("Could not delete desktop icon!\n");
      #return 0; # No reason to really stop on something like this
    } else {
      output("Removed desktop shortcut!\n");
    }
return 1;


}
do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1,OSVER_WIN8_SP0,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64,OSARCH_x86],
    allowed_regs =&gt; ['desktop','virtual-desktop','traveling','clc','virtual-clc'],
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);
IM_Exit(EXIT_SUCCESS);

sub uninstall
{
    output("Uninstalling Turning Point Cloud:");
    my $outcome = install_msi(app_id =&gt; '{c3a5f725-a6d3-4a5e-9d60-ba4a14af6999}',msi_action_flag =&gt; 'x');
    output(($outcome?'OK':'Failed')."\n");
    if($outcome)
    {
        delete_product_registry_key(get_package_name().".".get_version());
    }
    return 1;
}
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\Unity.2017_2\prod\update.pl</FullName>
    <Length>1806</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-13T14:10:17.0320223-06:00</CreationTime>
    <CreationTimeUtc>2017-11-13T20:10:17.0320223Z</CreationTimeUtc>
    <LastWriteTime>2017-11-13T14:48:35.4252894-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-11-13T20:48:35.4252894Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-13T14:10:17.0320223-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-13T20:10:17.0320223Z</LastAccessTimeUtc>
    <Text># Package December 2015
# Package created by Ryan Andrews
# Updated November 2017 by Chris Schaaf


=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'unity.2017_2',
        package_revision =&gt; '20171108T1550',
    );
}


use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);


use InstallMonkey::Shared;
use Getopt::Long;


my $src = get_pkg_sourcefiles();
my $applogsdir = get_applogs_dir();
my $AppID = get_package_id();

sub install {
    output("Installing Unity 2017.2 via provided batch file: ");
	# ignore restart warnings. batch file modified to have full path of installers, complains otherwise
    if (!run_command("$src\\install.bat", 'IgnoreExitCodes' =&gt; [3010])) {
        output("FAILED: $!\n");
		return 0;
    }
	output("OK");
    return 1;
}

sub postinstall {
	my $desk = get_allusers_desktop();
	output("Deleting desktop icon... ");
	if(!run_command("del \"$desk\\Unity 2017.2.0f3 (64-bit).lnk\" /F")) {
		output("Could not delete icon: $!\n");
	}
	else {
		output("OK\n");
	}
	return 1;
}

do_install (
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [ 'desktop', 'clc', 'traveling', 'virtual-desktop',
                        'virtual-clc' ],

    exit_on_failure =&gt; 1,
	needs_restart =&gt; 1,
    install_sub =&gt; \&amp;install,
	postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\Unity.x\prod\update.pl</FullName>
    <Length>2651</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-12-29T11:07:42.3196423-06:00</CreationTime>
    <CreationTimeUtc>2016-12-29T17:07:42.3196423Z</CreationTimeUtc>
    <LastWriteTime>2017-01-31T11:19:32.3584315-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-01-31T17:19:32.3584315Z</LastWriteTimeUtc>
    <LastAccessTime>2017-01-31T11:17:18-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-01-31T17:17:18Z</LastAccessTimeUtc>
    <Text># Package December 2015
# Package created by Ryan Andrews
# Updated December 2016 by Chris Schaaf


=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'unity.5_5_0',
        package_revision =&gt; '20161230T1050',
    );
}


use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);


use InstallMonkey::Shared;
use Getopt::Long;


my $src = get_pkg_sourcefiles();
my $applogsdir = get_applogs_dir();
my $AppID = get_package_id();

sub install {
    my $path = "$src\\";

    output("Installing Unity 5.5.0: \n\n");
    output("\tStep 1: Unity (This will take a while):  ");
    if (run_command("$path\\UnitySetup64.exe /S")) {
        output("OKAY\n");
        output("\tStep 2: Unity Web Player: ");
        #5.3.7f1, looking around seems like this is no longer being updated?
        if (run_command("$path\\UnityWebPlayer.exe /S")) {
            output("OKAY\n");
            output("\tStep 3: Unity Standard Assets: ");
			if(run_command("$path\\UnityStandardAssetsSetup.exe /S")) {
				# output("OKAY\n");
				# output("\tStep 4: Microsoft Visual Studio Community 2015 (This will take a while): ");
				# if (run_command("$path\\vs_community.exe /quiet /norestart", 'IgnoreExitCodes' =&gt; [3010])) {
				# 	output("OKAY\n");
				# }
				# else {
				# 	output("FAILED: $!");
				# 	return 0;
				# }
			}
            else {
                output("FAILED: $!");
                return 0;
            }
        }
        else {
            output("FAILED: $!");
            return 0;
        }
    }
    else {
        output("FAILED: $!");
        return 0;
    }
	
    return 1;
}

sub postinstall {
	my $desk = get_allusers_desktop();
	output("Deleting desktop icon... ");
	if(!run_command("del \"$desk\\Unity 5.5.0f3 (64-bit).lnk\" /F")) {
		output("Could not delete icon: $!\n");
	}
	else {
		output("OK\n");
	}
	return 1;
}

do_install (
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [ 'desktop', 'clc', 'traveling', 'virtual-desktop',
                        'virtual-clc' ],

    exit_on_failure =&gt; 1,
	needs_restart =&gt; 1,
    install_sub =&gt; \&amp;install,
	postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\Unity.x\prod-old\update.pl</FullName>
    <Length>2687</Length>
    <Extension>.pl</Extension>
    <CreationTime>2015-12-10T09:17:13.3051078-06:00</CreationTime>
    <CreationTimeUtc>2015-12-10T15:17:13.3051078Z</CreationTimeUtc>
    <LastWriteTime>2016-01-19T14:56:34.9633609-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-01-19T20:56:34.9633609Z</LastWriteTimeUtc>
    <LastAccessTime>2015-12-10T09:17:13.3051078-06:00</LastAccessTime>
    <LastAccessTimeUtc>2015-12-10T15:17:13.3051078Z</LastAccessTimeUtc>
    <Text># Package December 2015
# Package created by Ryan Andrews


=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS =
	(
        package_id =&gt; 'unity.5_2_2',
        package_revision =&gt; '20151210T0918',
    );
}


use lib
(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);


use InstallMonkey::Shared;
use Getopt::Long;


my $sourcefilesdir = get_pkg_sourcefiles();
my $applogsdir = get_applogs_dir();
my $AppID = get_package_id();

#my $Uninstall = 0;
######
#GetOptions(
#    'uninstall' =&gt; sub { exit(!uninstall()); },
#) || die "Usage: $!";
######
sub install
{
    my $path = "$sourcefilesdir\\";

    output("Installing Unity 5.2.2: \n\n");
    output("\tStep 1: Unity (This will take a while):  ");
    my $Success = run_command("$path\\UnitySetup64.exe /S");
    if ($Success)
    {
        output("OKAY\n");
        output("\tStep 2: Unity Web Player: ");
        $Success = run_command("$path\\UnityWebPlayerDevelopment.exe /S");
        if ($Success)
        {
            output("OKAY\n");
            output("\tStep 3: Unity Standard Assets: ");
            $Success = run_command("$path\\UnityStandardAssetsSetup.exe /S");
            if ($Success)
            {
                output("OKAY\n");
                output("\tStep 4: Microsoft Visual Studio Community 2015: ");
                $Success = run_command("$path\\vstu.msi /qn /norestart");
                if ($Success)
                {
                    output("OKAY\n");
                }
                else
                {
                    output("FAILED: $!");
                    return $Success;
                }
            }
            else
            {
                output("FAILED: $!");
                return $Success;
            }
        }
        else
        {
            output("FAILED: $!");
            return $Success;
        }
    }
    else
    {
        output("FAILED: $!");
        return $Success;
    }

    return $Success;
}

do_install
(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
    allowed_os_architectures =&gt; [ OSARCH_x64 ],
    allowed_regs =&gt; [ 'desktop', 'clc', 'traveling', 'virtual-desktop',
                        'virtual-clc' ],

    exit_on_failure =&gt; 1,

    install_sub =&gt; \&amp;install,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\unreal.4_15\prod\update.pl</FullName>
    <Length>4796</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-08-09T15:52:44.2614433-05:00</CreationTime>
    <CreationTimeUtc>2017-08-09T20:52:44.2614433Z</CreationTimeUtc>
    <LastWriteTime>2017-08-28T10:48:24.4595411-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-08-28T15:48:24.4595411Z</LastWriteTimeUtc>
    <LastAccessTime>2017-08-09T15:52:44.2614433-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-08-09T20:52:44.2614433Z</LastAccessTimeUtc>
    <Text># Unreal Engine
# Package Created 2015-12-11
# Packaged by Mark Raymond Jr.
# This package installs the Launcher for Unreal Engine and
# copies over the actual engine.
# Updated 2016-01-11 by Dillon Lustick, moved files to appdeploy
# Updated 2016-08-24 by Chris Schaaf, fixed missing file and prereq errors
# Updated 2016-09-2 by Ben Krueger, fixed dependency error message.
# Updated 2016-09-26 by Austin Wall, fixed missing underscore on line 70.
=pod

Begin-Doc
Modified: $Date$
Name: $Name$
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'unrealengine.4_15',
        package_revision =&gt; '20170612T1029',
    );
}


use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);


use InstallMonkey::Shared;

my $src = get_pkg_sourcefiles();
my $appd = "\\\\minerfiles.mst.edu\\dfs\\software\\appdeploy\\unreal.4_15";
my $vs17appd = "\\\\minerfiles.mst.edu\\dfs\\software\\itwindist\\appdeploy\\visual_studio.2017";
my $pf = "$ENV{'ProgramFiles'}";
my $pf86 = "$ENV{'ProgramFiles(x86)'}";
my $ue4dir = "UE_4.17";
my $vs17loc = "C:\\VS2017";
my $dxinstall = build_path($src, 'DirectXRedist', 'DXSETUP.exe');
my $vsstart = "$ENV{'PROGRAMDATA'}\\Microsoft\\Windows\\Start Menu\\Programs";

sub pre_install {
		output("Fixing file permisison: ");
	if(!run_command("reg import \"$src\\internetsecurity.reg\"")) {
		output("FAILED: $!\n");
		return 0;
	}
	output("OK\nInstalling Visual C++ 2015 redistributables with new method:\n\tx86: ");
	if(!run_command("$src\\vc_redist.x86.exe /install /quiet /norestart", 'IgnoreExitCodes'=&gt;[3010,1638])) {
		output("FAILED: $!\n");
		return 0;
	}
    output("OK\n\tx64: ");
	if(!run_command("$src\\vc_redist.x64.exe /install /quiet /norestart", 'IgnoreExitCodes' =&gt; [3010 ,1638])) {
		output("FAILED: $!\n");
		return 0;
	}
    output("OK\nInstalling DirectX redist: ");
    if(!run_command("$dxinstall /silent")) {
        output("FAILED: $!\n");
		return 0;
    }
	output("OK\n");
    return 1;
}

sub install {
	output("Installing Launcher: ");
	if(!run_command("\"$src\\EpicGamesLauncherInstaller-3.0.0-3443963.msi\" /qn /norestart")){
		output("FAILED: $!\n");
		return 0;
	}
    output("OK\nDownloading engine files (4.3GB): ");
	#This is a 17GB install, so we're copying it from appdeploy as a .7z archive (~5GB) to download
	if(!run_command("robocopy \"$appd\\engine\" \"$src\"  /E", 'IgnoreExitCodes' =&gt; [1, 2, 3])){
		output("FAILED: $!\n");
		return 0;
	}
	#Depending on network and machine, it's faster to DL+unzip than to just download. Way less network load at least.
	#Using 7za standalone included in $src
	output("OK\nInstalling engine... (18GB)");
	if(!run_command("$src\\7za.exe x \"$src\\$ue4dir.7z\" -o\"$pf\\Epic Games\" -y")){
		output("FAILED: $!\n");
		return 0;
	}
	output("OK\n");
    return 1;
}

sub post_install {
	my $desk = get_allusers_desktop();
    my $start = get_allusers_start_menu();
	output("Configuring Start Menu shortcuts... ");
	run_command("mkdir \"$start\\Programs\\Unreal Engine\"");
    run_command("copy \"$src\\startmenu\\UE4Editor.lnk\" \"$start\\Programs\\Unreal Engine\\UE4Editor.lnk\" /Y", 'IgnoreExitCodes' =&gt; [1, 2, 3]);
    output("OK\nSetting firewall rules... ");
    run_command("netsh advfirewall firewall add rule name=\"Unreal\" dir=in action=allow program=\"$pf\\Epic Games\\$ue4dir\\Engine\\Binaries\\Win64\\UE4Editor.exe\" enable=yes");
	output("OK\nCopying Program Data... "); #This folder didn't want to distribute properly so it's also in appdeploy.
	if(!run_command("Robocopy \"$appd\\Epic\" C:\\ProgramData\\Epic /E /TEE", 'IgnoreExitCodes' =&gt; [1, 2, 3]))
	{
        output("FAILED: $!\n");
        return 0;
    }
	output("OK\nDeleting Desktop Shortcuts... ");
	run_command("DEL /Q \"$desk\\Epic Games Launcher.lnk\"");
	run_command("reg import \"$src\\epicsoftware.reg\"");
	#my $calcs_path = build_path("C:","Windows","System32","icacls.exe");
	#my $dir_path = 	 build_path("Program Files","Epic Games","UE_4.17");
	#run_command("${calcs_path} ${dir_path} /grant Everyone:F");
	return 1;
}

do_install( 
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
    allowed_os_architectures =&gt; [ OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-desktop'],
        
    exit_on_failure =&gt; 1,
    preinstall_sub =&gt; \&amp;pre_install,
    install_sub =&gt; \&amp;install,
	postinstall_sub =&gt; \&amp;post_install
);


IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\unreal.4_15\prod.old\update.pl</FullName>
    <Length>4163</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-08-07T10:05:27.0292852-05:00</CreationTime>
    <CreationTimeUtc>2017-08-07T15:05:27.0292852Z</CreationTimeUtc>
    <LastWriteTime>2017-08-08T10:01:20.8654231-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-08-08T15:01:20.8654231Z</LastWriteTimeUtc>
    <LastAccessTime>2017-08-07T10:05:27.0292852-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-08-07T15:05:27.0292852Z</LastAccessTimeUtc>
    <Text># Unreal Engine
# Package Created 2015-12-11
# Packaged by Mark Raymond Jr.
# This package installs the Launcher for Unreal Engine and
# copies over the actual engine.
# Updated 2016-01-11 by Dillon Lustick, moved files to appdeploy
# Updated 2016-08-24 by Chris Schaaf, fixed missing file and prereq errors
# Updated 2016-09-2 by Ben Krueger, fixed dependency error message.
# Updated 2016-09-26 by Austin Wall, fixed missing underscore on line 70.
=pod

Begin-Doc
Modified: $Date$
Name: $Name$
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN
{
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'unrealengine.4_15',
        package_revision =&gt; '20170612T1029',
    );
}


use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);


use InstallMonkey::Shared;

my $src = get_pkg_sourcefiles();
my $appd = "\\\\minerfiles.mst.edu\\dfs\\software\\appdeploy\\unreal.4_15";
my $vs17appd = "\\\\minerfiles.mst.edu\\dfs\\software\\appdeploy\\visual_studio.2017";
my $pf = "$ENV{'ProgramFiles'}";
my $pf86 = "$ENV{'ProgramFiles(x86)'}";
my $vs17loc = "C:\\VS2017";
my $dxinstall = build_path($src, 'DirectXRedist', 'DXSETUP.exe');

sub pre_install {
    output("Installing Visual C++ 2015 redistributables with new method:\n\tx86: ");
	if(!run_command("$src\\vc_redist.x86.exe /install /quiet /norestart", 'IgnoreExitCodes'=&gt;[3010,1638])) {
		output("FAILED: $!\n");
		return 0;
	}
    output("OK\n\tx64: ");
	if(!run_command("$src\\vc_redist.x64.exe /install /quiet /norestart", 'IgnoreExitCodes' =&gt; [3010 ,1638])) {
		output("FAILED: $!\n");
		return 0;
	}
    output("OK\nInstalling DirectX redist: ");
    if(!run_command("$dxinstall /silent")) {
        output("FAILED: $!\n");
		return 0;
    }
	output("OK\nInstalling Windows 8.1 SDK: ");
	if(!run_command("\"$src\\sdksetup.exe\" /quiet /norestart")){
		output("FAILED: $!\n");
		return 0;
	}
	output("OK\n");
    return 1;
}

sub install {    
    output("Downloading engine files (4.3GB): ");
	#This is a 17GB install, so we're copying it from appdeploy as a .7z archive (~5GB) to download
	if(!run_command("robocopy \"$appd\\engine\" \"$src\"  /E", 'IgnoreExitCodes' =&gt; [1, 2, 3])){
		output("FAILED: $!\n");
		return 0;
	}
    output("OK\n");
	
	#Depending on network and machine, it's faster to DL+unzip than to just download. Way less network load at least.
	#Using 7za standalone included in $src
	output("Installing engine... (18GB)");
	if(!run_command("$src\\7za.exe x \"$src\\Epic Games.7z\" -o\"$pf\" -y")){
		output("FAILED: $!\n");
		return 0;
	}
	output("OK\n");
    
    my $start_menu = get_allusers_start_menu();
	output("Configuring Start Menu shortcuts... ");
	run_command("mkdir \"$start_menu\\Programs\\Unreal Engine\"");
    run_command("copy \"$src\\startmenu\\UE4Editor.lnk\" \"$start_menu\\Programs\\Unreal Engine\\UE4Editor.lnk\" /Y", 'IgnoreExitCodes' =&gt; [1, 2, 3]);
    output("OK\n");
	output("Setting firewall rules... ");
    run_command("netsh advfirewall firewall add rule name=\"Unreal\" dir=in action=allow program=\"C:\\Program Files\\Epic Games\\UE_4.15\\Engine\\Binaries\\Win64\\UE4Editor.exe\" enable=yes");
	output("OK\n");
	#This folder didn't want to distribute properly so it's also in appdeploy.
    output("Copying Program Data... ");
	if(!run_command("Robocopy \"$appd\\Epic\" C:\\ProgramData\\Epic /E /TEE", 'IgnoreExitCodes' =&gt; [1, 2, 3]))
	{
        output("FAILED: $!\n");
        return 0;
    }
	output("OK\n");
	run_command("reg import \"$src\\epicsoftware.reg\"");
	
	
    
    return 1;
}

do_install( 
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
    allowed_os_architectures =&gt; [ OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-desktop'],
        
    exit_on_failure =&gt; 1,
    
    install_sub =&gt; \&amp;install
);


IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\veracrypt.1_22\dev\update.pl</FullName>
    <Length>1470</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-15T08:22:58.5535094-05:00</CreationTime>
    <CreationTimeUtc>2018-06-15T13:22:58.5535094Z</CreationTimeUtc>
    <LastWriteTime>2018-06-18T11:58:22.8759494-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-18T16:58:22.8759494Z</LastWriteTimeUtc>
    <LastAccessTime>2018-07-11T12:30:37.6357026-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-07-11T17:30:37.6357026Z</LastAccessTimeUtc>
    <Text>#Veracrypt 1.22
# Package Created June 14th, 2018
# Packaged by Cameron Loren
# Last updated by Cameron Loren

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'veracrypt.1_22',
        package_revision =&gt; '20180614T1228',
    );
}

# Add InstallMonkey Library to the path
use lib (
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
sub install{
	output("Installing Veracrypt 1.22\n");
    if(!run_command("$sourcefilesdir\\VC_AutoIT.exe $sourcefilesdir\\\"VeraCrypt Setup 1.22.exe\""))
    {
        output("Veracrypt 1.22 installation did not complete!\n");
        return 0;
    }
    else
    {
        output("Veracrypt 1.22 installation was successful!\n");
    }
    return 1;
}

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                     'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
	  need_reboot =&gt; 0,
    install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\veracrypt.1_22\prod\update.pl</FullName>
    <Length>1470</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-14T12:27:03.9660262-05:00</CreationTime>
    <CreationTimeUtc>2018-06-14T17:27:03.9660262Z</CreationTimeUtc>
    <LastWriteTime>2018-06-18T11:58:22.8759494-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-18T16:58:22.8759494Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-14T12:27:03.9660262-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-14T17:27:03.9660262Z</LastAccessTimeUtc>
    <Text>#Veracrypt 1.22
# Package Created June 14th, 2018
# Packaged by Cameron Loren
# Last updated by Cameron Loren

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'veracrypt.1_22',
        package_revision =&gt; '20180614T1228',
    );
}

# Add InstallMonkey Library to the path
use lib (
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
sub install{
	output("Installing Veracrypt 1.22\n");
    if(!run_command("$sourcefilesdir\\VC_AutoIT.exe $sourcefilesdir\\\"VeraCrypt Setup 1.22.exe\""))
    {
        output("Veracrypt 1.22 installation did not complete!\n");
        return 0;
    }
    else
    {
        output("Veracrypt 1.22 installation was successful!\n");
    }
    return 1;
}

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                     'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
	  need_reboot =&gt; 0,
    install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\virtualbox.5_0_22\prod\update.pl</FullName>
    <Length>3110</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-06-20T12:43:24.7058144-05:00</CreationTime>
    <CreationTimeUtc>2016-06-20T17:43:24.7058144Z</CreationTimeUtc>
    <LastWriteTime>2016-06-20T13:09:22.114964-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-06-20T18:09:22.114964Z</LastWriteTimeUtc>
    <LastAccessTime>2016-06-20T12:43:24.7682156-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-06-20T17:43:24.7682156Z</LastAccessTimeUtc>
    <Text># VirtualBox 5.0.10 - Machine Virtualizer
# Package Created December 2015
# Packaged by Grayson Gratop

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
      package_id =&gt; 'virtualbox.5_0_22',
      package_revision =&gt; '20160620T1317',
  );
}

# Add InstallMonkey Library to the path
use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use Getopt::Long;
use InstallMonkey::Shared;

GetOptions(
  'uninstall' =&gt; sub { exit(!uninstall()); },
);

my $srcfilesdir = get_pkg_sourcefiles();
my $allUsersDesktop = get_allusers_desktop();
my $allUsersStartmenu = get_allusers_start_menu();

my $installerName = 'VirtualBox-5.0.22-108108-Win.exe';

sub install {
  ##################################
  # Install the program!
  ##################################
  if(!run_command("\"$srcfilesdir\\$installerName\" --silent")) {
    output("VirtualBox 5.0.22 was not installed correctly!\n");
    return 0;
  }
  else {
    output("VirtualBox 5.0.22 has been installed!\n");
  }
  return 1;
}

sub postInstall {
  ##################################
  # Remove the desktop icon (.lnk)
  ##################################
  my $success = 1;

  if(!run_command("DEL /q \"$allUsersDesktop\\Orace VM VirtualBox.lnk\"")){
    $success = 0;
  }

  #Delete icons in every user's Desktop folder (excluding Public, All Users, and Default). Thanks, StackOverflow
  opendir(DIR, 'C:\\Users');
  my @users = grep { (!/^\.\.?$/) &amp;&amp; (-d "C:\\Users\\$_") &amp;&amp; !(/All Users/) &amp;&amp; ($_ ne 'Default') } readdir(DIR);
  closedir(DIR);

  foreach my $place (@users) {
    if (!run_command("DEL /Q \"C:\\Users\\$place\\Desktop\\Oracle VM VirtualBox.lnk\"")) {
      $success = 0;
    }
  }

  if ($success) {
    output("Desktop icons removed.\n");
  }
  else {
    output("Could not delete all desktop icons! Some will still linger on desktops.\n");
  }

  return 1;
}

sub uninstall {
  output("Uninstalling VirtualBox 5.0.22... ");

  my $command = "MsiExec.exe /Q /X{A961B9B7-C851-411E-907A-E7E96C631369}";
  my $success = run_command($command);
  if ($success) {
    output("Success!\n");
    delete_product_registry_key(get_package_name().".".get_version());
  }
  else {
    output("FAILED!\n");
  }

  return $success;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postInstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\virtualbox.5_1_8\prod\update.pl</FullName>
    <Length>3138</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-12-01T15:01:21.4564356-06:00</CreationTime>
    <CreationTimeUtc>2016-12-01T21:01:21.4564356Z</CreationTimeUtc>
    <LastWriteTime>2016-12-01T15:01:21.4876364-06:00</LastWriteTime>
    <LastWriteTimeUtc>2016-12-01T21:01:21.4876364Z</LastWriteTimeUtc>
    <LastAccessTime>2016-12-01T15:01:21.4876364-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-12-01T21:01:21.4876364Z</LastAccessTimeUtc>
    <Text># VirtualBox 5.1.8 - Machine Virtualizer
# Package Created December 2015
# Packaged by Grayson Gratop
#Updated 12/1/12016 by Jason Mao

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
      package_id =&gt; 'virtualbox.5_1_8',
      package_revision =&gt; '20161201T1317',
  );
}

# Add InstallMonkey Library to the path
use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use Getopt::Long;
use InstallMonkey::Shared;

GetOptions(
  'uninstall' =&gt; sub { exit(!uninstall()); },
);

my $srcfilesdir = get_pkg_sourcefiles();
my $allUsersDesktop = get_allusers_desktop();
my $allUsersStartmenu = get_allusers_start_menu();

my $installerName = 'VirtualBox-5.1.8-111374-Win.exe';

sub install {
  ##################################
  # Install the program!
  ##################################
  if(!run_command("\"$srcfilesdir\\$installerName\" --silent")) {
    output("VirtualBox 5.1.8 was not installed correctly!\n");
    return 0;
  }
  else {
    output("VirtualBox 5.1.8 has been installed!\n");
  }
  return 1;
}

sub postInstall {
  ##################################
  # Remove the desktop icon (.lnk)
  ##################################
  my $success = 1;

  if(!run_command("DEL /q \"$allUsersDesktop\\Orace VM VirtualBox.lnk\"")){
    $success = 0;
  }

  #Delete icons in every user's Desktop folder (excluding Public, All Users, and Default). Thanks, StackOverflow
  opendir(DIR, 'C:\\Users');
  my @users = grep { (!/^\.\.?$/) &amp;&amp; (-d "C:\\Users\\$_") &amp;&amp; !(/All Users/) &amp;&amp; ($_ ne 'Default') } readdir(DIR);
  closedir(DIR);

  foreach my $place (@users) {
    if (!run_command("DEL /Q \"C:\\Users\\$place\\Desktop\\Oracle VM VirtualBox.lnk\"")) {
      $success = 0;
    }
  }

  if ($success) {
    output("Desktop icons removed.\n");
  }
  else {
    output("Could not delete all desktop icons! Some will still linger on desktops.\n");
  }

  return 1;
}

sub uninstall {
  output("Uninstalling VirtualBox 5.1.8... ");

  my $command = "MsiExec.exe /Q /X{A961B9B7-C851-411E-907A-E7E96C631369}";
  my $success = run_command($command);
  if ($success) {
    output("Success!\n");
    delete_product_registry_key(get_package_name().".".get_version());
  }
  else {
    output("FAILED!\n");
  }

  return $success;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postInstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\virtualbox.5_2_0\prod\update.pl</FullName>
    <Length>3185</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-08T13:10:08.0663237-06:00</CreationTime>
    <CreationTimeUtc>2017-11-08T19:10:08.0663237Z</CreationTimeUtc>
    <LastWriteTime>2017-11-08T13:16:28.1745873-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-11-08T19:16:28.1745873Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-08T13:10:08.0663237-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-08T19:10:08.0663237Z</LastAccessTimeUtc>
    <Text># VirtualBox 5.2.0 - Machine Virtualizer
# Package Created December 2015
# Packaged by Grayson Gratop
# Updated for 5.2.0 12/1/2016 by Jason Mao
# Updated for 5.2.0 11/8/2017 by Grayson Gratop

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
      package_id =&gt; 'virtualbox.5_2_0',
      package_revision =&gt; '20171108T1311',
  );
}

# Add InstallMonkey Library to the path
use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use Getopt::Long;
use InstallMonkey::Shared;

GetOptions(
  'uninstall' =&gt; sub { exit(!uninstall()); },
);

my $srcfilesdir = get_pkg_sourcefiles();
my $allUsersDesktop = get_allusers_desktop();
my $allUsersStartmenu = get_allusers_start_menu();

my $installerName = 'VirtualBox-5.2.0-118431-Win.exe';

sub install {
  ##################################
  # Install the program!
  ##################################
  if(!run_command("\"$srcfilesdir\\$installerName\" --silent")) {
    output("VirtualBox 5.2.0 was not installed correctly!\n");
    return 0;
  }
  else {
    output("VirtualBox 5.2.0 has been installed!\n");
  }
  return 1;
}

sub postInstall {
  ##################################
  # Remove the desktop icon (.lnk)
  ##################################
  my $success = 1;

  if(!run_command("DEL /q \"$allUsersDesktop\\Orace VM VirtualBox.lnk\"")){
    $success = 0;
  }

  #Delete icons in every user's Desktop folder (excluding Public, All Users, and Default). Thanks, StackOverflow
  opendir(DIR, 'C:\\Users');
  my @users = grep { (!/^\.\.?$/) &amp;&amp; (-d "C:\\Users\\$_") &amp;&amp; !(/All Users/) &amp;&amp; ($_ ne 'Default') } readdir(DIR);
  closedir(DIR);

  foreach my $place (@users) {
    if (!run_command("DEL /Q \"C:\\Users\\$place\\Desktop\\Oracle VM VirtualBox.lnk\"")) {
      $success = 0;
    }
  }

  if ($success) {
    output("Desktop icons removed.\n");
  }
  else {
    output("Could not delete all desktop icons! Some will still linger on desktops.\n");
  }

  return 1;
}

sub uninstall {
  output("Uninstalling VirtualBox 5.2.0... ");

  my $command = "MsiExec.exe /Q /X{1E6A323C-1BE9-49B6-8FDC-107307DBC6CE}";
  my $success = run_command($command);
  if ($success) {
    output("Success!\n");
    delete_product_registry_key(get_package_name().".".get_version());
  }
  else {
    output("FAILED!\n");
  }

  return $success;
}

do_install( 
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
  allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postInstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\visio_prof.2016\prod\update.pl</FullName>
    <Length>5278</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-02-15T12:56:16.5714705-06:00</CreationTime>
    <CreationTimeUtc>2016-02-15T18:56:16.5714705Z</CreationTimeUtc>
    <LastWriteTime>2018-01-11T21:45:06.5900271-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-12T03:45:06.5900271Z</LastWriteTimeUtc>
    <LastAccessTime>2016-02-15T12:56:16.5714705-06:00</LastAccessTime>
    <LastAccessTimeUtc>2016-02-15T18:56:16.5714705Z</LastAccessTimeUtc>
    <Text># Microsoft Visio Professional 2013
# Package Created June 2011
# Packaged by Ryan Andrews

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'visio_prof.2016',
        package_revision =&gt; '20160215T1307',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use IM_helper(
    \%INSTALLMONKEY_OPTIONS,
    v3.01
);
use InstallMonkey::Shared;

my $sourcefiles = get_pkg_sourcefiles();
use Getopt::Long;
GetOptions
(
    'uninstall' =&gt; \&amp;uninstall
);
my $applog = get_default_app_log();

my $ACTIVESETUP_SCRIPT_LOC = "C:\\WINDOWS\\System32\\UMRInst\\scripts\\$INSTALLMONKEY_OPTIONS{package_id}\\activate.pl";

##########################################################################

sub prerequisite
{
    #Look for Office and write script file that licenses visio
    return IM_helper::get_install_locations(
        display_name=&gt;'Microsoft Office Professional Plus 2016',

        succ_cb=&gt; sub{
            my $install_loc = @{{@_}-&gt;{x86}}[0] || return 0;
            
            my $license_service_script = "$install_loc\\Office16\\ospp.vbs"; 

            return IM_helper::write_file(
                file=&gt;$ACTIVESETUP_SCRIPT_LOC,
                data=&gt;
qq|
my \$text = `nslookup -type=srv _vlmcs._tcp 2&gt;&amp;1 \| findstr \"hostname\"`;
\$text =~ m/.*=\\s*(\\S+)/;
(system('cscript \"$license_service_script\" /sethst:'.\$1) == 0) or die \"Failed to set KMS hostname\";
(system('cscript \"$license_service_script\" /act') == 0) or die \"Failed to active all licenses\";
print \"License script completed successfully\n\";
exit(0);
|
            );
        },

        fail_cb=&gt; sub{
            output("\nThis product requires office 2016 x86 to be installed.\n");
            return 0;
        }
    );
}


sub install
{
    my $installer_config_file_loc = gen_temp_file_name();

    return 0 
    unless IM_helper::write_file(
        file=&gt;$installer_config_file_loc,
        data=&gt;
qq|&lt;!-- Config copied from ECE version, make sure to change PIDKEY --&gt;
&lt;Configuration Product="VisPro"&gt;
    &lt;PIDKEY Value="YJ8DN-VTHT7-WJKQ4-FX7FP-76DPB" /&gt;
    &lt;Setting Id="AUTO_ACTIVATE" Value="1" /&gt;
    &lt;Display Level="none" CompletionNotice="no" SuppressModal="yes" AcceptEula="yes" /&gt;
    &lt;Logging Type="standard" Path="%WINDIR%\\System32\\UMRINST\\applogs" Template="Visio_2013_Pro_Install_*.log" /&gt;
    &lt;USERNAME Value="Missouri S&amp;amp;T" /&gt;
    &lt;COMPANYNAME Value="Missouri S&amp;amp;T" /&gt;
    &lt;Setting Id="SETUP_REBOOT" Value="Never" /&gt;
    &lt;Setting Id="REBOOT" Value="ReallySuppress" /&gt;
&lt;/Configuration&gt;
|
    );

    return IM_helper::run_command(
        description=&gt;"Visio Professional Installer",
        command=&gt;"START \"\" /WAIT \"${sourcefiles}\\setup.exe\" /config \"$installer_config_file_loc\""
    );
}

sub postinstall
{
    output("Creating activesetup thing...\n");
    return IM_helper::create_activesetup(
        command=&gt;"perl \"$ACTIVESETUP_SCRIPT_LOC\"",
        description=&gt;"visio prof 2016 activesetup",
        version=&gt;"1"
    );
}

sub uninstall
{
    IM_helper::delete_activesetup(identifier=&gt;$INSTALLMONKEY_OPTIONS{package_id}) or exit(1);
    sub __uninstall_office_with_string{
        my $uninst_str = shift;
        if(!(defined $uninst_str)){
            return 0;
        }

        my $uninstaller_config_file_loc = gen_temp_file_name();

        return 0 
        unless IM_helper::write_file(
            file=&gt;$uninstaller_config_file_loc,
            data=&gt;
qq|&lt;Configuration Product="ProPlus"&gt;
    &lt;Display Level="none" CompletionNotice="no" SuppressModal="yes" AcceptEula="yes" /&gt;
    &lt;Setting Id="SETUP_REBOOT" Value="Never" /&gt;
    &lt;Setting Id="REBOOT" Value="ReallySuppress" /&gt;
&lt;/Configuration&gt;|
        );

        return IM_helper::run_command(
            description=&gt;"Visio Uninstaller",
            command=&gt;"$uninst_str /config \"$uninstaller_config_file_loc\""
        );  
    }
    IM_helper::get_uninstall_strings(
            display_name=&gt;'Microsoft Visio Professional 2016',
            succ_cb=&gt;
            sub{
                return (
                    __uninstall_office_with_string(@{{@_}-&gt;{x86}}[0])
                    | # Bitwise so both are checked
                    __uninstall_office_with_string(@{{@_}-&gt;{x64}}[0])
                );
            }
    ) or exit(1);
    exit !delete_product_registry_key($INSTALLMONKEY_OPTIONS{package_id});
}

do_install(
    allowed_versions =&gt; [OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    prerequisite_sub =&gt; \&amp;prerequisite,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\VisualStudioCode.1_2\prod\update.pl</FullName>
    <Length>2245</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-07-06T09:00:54.2135841-05:00</CreationTime>
    <CreationTimeUtc>2016-07-06T14:00:54.2135841Z</CreationTimeUtc>
    <LastWriteTime>2017-05-31T09:55:03.6171337-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-05-31T14:55:03.6171337Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-06T09:00:54.2135841-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-06T14:00:54.2135841Z</LastAccessTimeUtc>
    <Text>#practice perl script to install visual studio code from exe
#Package created 7/1/2016
#Package created by Benjamin Krueger
#Last updated on 7/1/2016

BEGIN{
    %INSTALLMONKEY_OPTIONS =(
        package_id =&gt; "VisualStudioCode1.2",
        package_revision =&gt; "2016071T1147"
    )
}

use lib(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;
GetOptions('uninstall' =&gt; sub {exit(!uninstall());});
sub install {
    output("Runninng VSCode Setup executable..\n");
    if(!run_command("".get_pkg_sourcefiles()."\\VSCodeSetup-stable.exe /VERYSILENT /NOICONS /SUPPRESSMSGBOXES /NORESTART"))
    {
        output("Vscode installation failed.\n");
        return 0;
    }
    return 1;
}
sub uninstall
{
    KillProcess("Code.exe");
    if(!run_command("\"C:\\Program Files (x86)\"\\\"Microsoft VS Code\"\\unins000.exe /VERYSILENT"))
    {
        output("Vscode Removal Failed.");
        return 0;
    }
    #run_command("REG DELETE  HKEY_LOCAL_MACHINE\\SOFTWARE\\UMR\\INSTALL\\Product_List\\VisualStudioCode1.2 /f");
    delete_product_registry_key(get_package_name().".".get_version());
    return 1;
}
sub postinstall
{
    run_command('DEL "C:\\Users\\Public\\Desktop\\Visual Studio Code.lnk"');#get rid of the shortcut
    KillProcess("Code.exe"); #kill the annoying instance of the program that comes up after it installs.
    my $shortcutdir = get_allusers_start_menu().'\VS Code';
	output("Creating shortcut in $shortcutdir\n");
    mkdir $shortcutdir unless -d $shortcutdir;
	if(!create_shortcut(
		'target' 	  =&gt; 'C:\Program Files (x86)\Microsoft VS Code\Code.exe',
		'link' 		  =&gt; $shortcutdir.'\Visual Studio Code.lnk',
		'description' =&gt; 'Launches Vs Code',
		)
	)
	{
		output("\nERROR: Could not create shortcut.\n");
	}
    return 1;
    
}
do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1,OSVER_WIN8_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['desktop','virtual-desktop','traveling','clc','virtual-clc'],
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);
IM_Exit(EXIT_SUCCESS);


</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\visual_studio.2015_2\prod\update.pl</FullName>
    <Length>5613</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-05-24T16:02:40.8236914-05:00</CreationTime>
    <CreationTimeUtc>2016-05-24T21:02:40.8236914Z</CreationTimeUtc>
    <LastWriteTime>2016-08-05T09:37:32.3448508-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-08-05T14:37:32.3448508Z</LastWriteTimeUtc>
    <LastAccessTime>2016-05-24T16:02:40.8236914-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-05-24T21:02:40.8236914Z</LastAccessTimeUtc>
    <Text># Visual Studio 2015 Professional package
# Package Created 2016-04-25
# Most of the script by Dillon Lustick
# Updated by Ian Summers 2015-04-15
# Ported to Visual Studio 2015 by Daniel T. Holtzclaw 2016-04-25
# Ported to Network Share by Daniel T. Holtzclaw 2016-05-24



=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut



################################################################################
# IF YOU ARE LOOKING TO ADD OR REMOVE MODULES FROM THIS INSTALLATION...        #
#  Go to the AdminDeployment.xml file in Data and change "selected" values,    #
#  then update the size expected down below.                                   #
#  Nothing you change here will install more or less modules.                  #
################################################################################



use strict;
use warnings;
use Getopt::Long;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'visual_studio.2015u2',
        package_revision =&gt; '20160524T1635',
    );
}


use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Win32::TieRegistry;

my $srcfiles = get_pkg_sourcefiles();

my $applog = get_default_app_log();

######
GetOptions(
    'uninstall' =&gt; sub { exit(!uninstall()); },
) || die "Usage: $!";
######


sub preinstall{
    ############################################################################
    #output("Clearing reboot flag...\n");
    #$Registry-&gt;Delimiter("/");
    # The setup will restart the machine first if this key exists
    # delete $Registry-&gt;{"LMachine/Software/Microsoft/Windows/CurrentVersion/WindowsUpdate/Auto Update/RebootRequired/"};
    output("Inside PreInstall... Checking for restart prerequisites\n");
    my @reglocs = ("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update\\RebootRequired",
                   "HKLM\\Software\\Microsoft\\Updates\\UpdateExeVolatile",
                   "HKLM\\System\\CurrentControlSet\\Control\\Session Manager\\PendingFileRenameOperations");
    #$Registry-&gt;{"LMachine/Software/Microsoft/Windows/CurrentVersion/WindowsUpdate/Auto Update/RebootRequired/"}
    foreach (@reglocs)
    {
      #output("Testing registry key checks.\n");
      my $RegQ = `reg query \"$_\"`; # run_command here will kill the program if no key found.
      #output("Testing reg key result:\n".$_."\n".$RegQ."\n");
      if($RegQ ne "ERROR: The system was unable to find the specified registry key or value.\n" &amp;&amp; $RegQ ne "")
      {
        output("Pending reboot ($_), cannot continue installing. Please reboot and try again.\n");
        output("Message: $RegQ\n");
        return 0;
      }
    }
    return 1;
    ############################################################################
}

sub install{
    output("Installing Visual Studio 2015, this will take a while... (expect 1-2 hours on a slow machine)\n");
    ### DO NOT ADJUST the /AdminFile, /Quiet, and /NoRestart flags. They ARE case sensitive
    ### despite what TechNet says. (Unless it is changed in another update.)
    #
    # In AdminDeployment, this line:
    # &lt;SelectableItemCustomization Id="WindowsPhone81EmulatorsV1" Hidden="no"
    #   MUST have the Hidden="no" argument, otherwise the file fails to validate
    #   and yes, that file is generated by Visual Studio itself, I know.

    ### NETWORK SHARE
    my $appdeploy_path = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\visual_studio.2015u2";

    my $success = run_command("$appdeploy_path\\vs_professional.exe /AdminFile $appdeploy_path\\AdminDeployment.xml /NoWeb /Quiet /NoRestart", 'IgnoreExitCodes'=&gt;[194]);
    #my $success = run_command("$srcfiles\\vs_professional.exe /AdminFile $srcfiles\\AdminDeployment.xml /Quiet /NoRestart",
    #                          'IgnoreExitCodes'=&gt;[194]);
    # Ignore reboot required for OS deployment (in WTG, a reboot happens after install.)

    if($success){
        output("Installation succeeded!\n");
    }
    else{
        ##Verify install size of Visual Studio 2015 professional and the settings we have.
        output("Installation failed. Please ensure that you have at least 13 GB free space.\n");
    }

    return $success;
}

sub postinstall{
    # This directory contains a file that will prevent new users from logging in if it exists.
    my $sqmdata = '%SYSTEMDRIVE%\Users\Default\AppData\Local\Microsoft\VSCommon';
    if (-d $sqmdata)
    {
        run_command("del $sqmdata /s /q");
    }
    return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    no_source_files =&gt; 1,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    need_reboot =&gt; 1,
);


IM_Exit(EXIT_SUCCESS);


sub uninstall{

	output("Uninstalling Visual Studio Professional 2015: ");

	my $success = run_command("$srcfiles\\vs_professional.exe /uninstall /force /quiet");

	output(($success ? "Successful\n" : "Failed\n"));

	if($success)
	{
		delete_product_registry_key(get_package_id());
	}

	return $success;
}</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\visual_studio.2015_3\prod\update.pl</FullName>
    <Length>5665</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-08-10T14:18:22.9418361-05:00</CreationTime>
    <CreationTimeUtc>2016-08-10T19:18:22.9418361Z</CreationTimeUtc>
    <LastWriteTime>2016-08-11T10:05:19.7690574-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-08-11T15:05:19.7690574Z</LastWriteTimeUtc>
    <LastAccessTime>2016-08-10T14:18:22.9418361-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-08-10T19:18:22.9418361Z</LastAccessTimeUtc>
    <Text># Visual Studio 2015 Professional package
# Package Created 2016-04-25
# Most of the script by Dillon Lustick
# Updated by Ian Summers 2015-04-15
# Ported to Visual Studio 2015 by Daniel T. Holtzclaw 2016-04-25
# Ported to Network Share by Daniel T. Holtzclaw 2016-05-24



=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut



################################################################################
# IF YOU ARE LOOKING TO ADD OR REMOVE MODULES FROM THIS INSTALLATION...        #
#  Go to the AdminDeployment.xml file in Data and change "selected" values,    #
#  then update the size expected down below.                                   #
#  Nothing you change here will install more or less modules.                  #
################################################################################



use strict;
use warnings;
use Getopt::Long;


our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'visual_studio.2015u3',
        package_revision =&gt; '20160810T1419',
    );
}


use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Win32::TieRegistry;

my $srcfiles = get_pkg_sourcefiles();

my $applog = get_default_app_log();

######
GetOptions(
    'uninstall' =&gt; sub { exit(!uninstall()); },
) || die "Usage: $!";
######


sub preinstall{
    ############################################################################
    #output("Clearing reboot flag...\n");
    #$Registry-&gt;Delimiter("/");
    # The setup will restart the machine first if this key exists
    # delete $Registry-&gt;{"LMachine/Software/Microsoft/Windows/CurrentVersion/WindowsUpdate/Auto Update/RebootRequired/"};
    output("Inside PreInstall... Checking for restart prerequisites\n");
    my @reglocs = ("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update\\RebootRequired",
                   "HKLM\\Software\\Microsoft\\Updates\\UpdateExeVolatile",
                   "HKLM\\System\\CurrentControlSet\\Control\\Session Manager\\PendingFileRenameOperations");
    #$Registry-&gt;{"LMachine/Software/Microsoft/Windows/CurrentVersion/WindowsUpdate/Auto Update/RebootRequired/"}
    foreach (@reglocs)
    {
      #output("Testing registry key checks.\n");
      my $RegQ = `reg query \"$_\"`; # run_command here will kill the program if no key found.
      #output("Testing reg key result:\n".$_."\n".$RegQ."\n");
      if($RegQ ne "ERROR: The system was unable to find the specified registry key or value.\n" &amp;&amp; $RegQ ne "")
      {
        output("Pending reboot ($_), cannot continue installing. Please reboot and try again.\n");
        output("Message: $RegQ\n");
        return 0;
      }
    }
    return 1;
    ############################################################################
}

sub install{
    output("Installing Visual Studio 2015, this will take a while... (expect 1-2 hours on a slow machine)\n");
    ### DO NOT ADJUST the /AdminFile, /Quiet, and /NoRestart flags. They ARE case sensitive
    ### despite what TechNet says. (Unless it is changed in another update.)
    #
    # In AdminDeployment, this line:
    # &lt;SelectableItemCustomization Id="WindowsPhone81EmulatorsV1" Hidden="no"
    #   MUST have the Hidden="no" argument, otherwise the file fails to validate
    #   and yes, that file is generated by Visual Studio itself, I know.

    ### NETWORK SHARE
    my $appdeploy_path = "\\\\minerfiles.mst.edu\\dfs\\Software\\appdeploy\\visual_studio.2015u3";

    my $success = run_command("$appdeploy_path\\vs_professional.exe /AdminFile \"$appdeploy_path\\AdminDeployment_3.xml\" /NoWeb /Quiet /NoRestart /ProductKey \"NFV77-V8BQ7-KPTXD-9T4JK-GJF42\"", 'IgnoreExitCodes'=&gt;[194]);
    #my $success = run_command("$srcfiles\\vs_professional.exe /AdminFile $srcfiles\\AdminDeployment.xml /Quiet /NoRestart",
    #                          'IgnoreExitCodes'=&gt;[194]);
    # Ignore reboot required for OS deployment (in WTG, a reboot happens after install.)

    if($success){
        output("Installation succeeded!\n");
    }
    else{
        ##Verify install size of Visual Studio 2015 professional and the settings we have.
        output("Installation failed. Please ensure that you have at least 13 GB free space.\n");
    }

    return $success;
}

sub postinstall{
    # This directory contains a file that will prevent new users from logging in if it exists.
    my $sqmdata = '%SYSTEMDRIVE%\Users\Default\AppData\Local\Microsoft\VSCommon';
    if (-d $sqmdata)
    {
        run_command("del $sqmdata /s /q");
    }
    return 1;
}

do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    no_source_files =&gt; 1,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    need_reboot =&gt; 1,
);


IM_Exit(EXIT_SUCCESS);


sub uninstall{

	output("Uninstalling Visual Studio Professional 2015: ");

	my $success = run_command("$srcfiles\\vs_professional.exe /uninstall /force /quiet");

	output(($success ? "Successful\n" : "Failed\n"));

	if($success)
	{
		delete_product_registry_key(get_package_id());
	}

	return $success;
}</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\visual_studio.2017\prod\update.pl</FullName>
    <Length>4548</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-08-10T15:02:13.4348811-05:00</CreationTime>
    <CreationTimeUtc>2017-08-10T20:02:13.4348811Z</CreationTimeUtc>
    <LastWriteTime>2018-01-09T13:26:16.1191722-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-09T19:26:16.1191722Z</LastWriteTimeUtc>
    <LastAccessTime>2017-08-10T15:02:13.4348811-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-08-10T20:02:13.4348811Z</LastAccessTimeUtc>
    <Text># Visual Studio 2017
# Package created 6/7/2017
# Package by Sergey Gruzdev
# Last updated 6/7/2017 by Sergey Gruzdev

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'visual_studio.2017',
		package_revision =&gt; '20170714T1033',
	);
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

my $src = get_pkg_sourcefiles();
my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\software\\itwindist\\appdeploy\\visual_studio.2017";
my $vs17loc = "C:\\VS2017";
my $key = "R36QN-84VPC-QGFFK-P4VM2-JB6XV";
my $json = "$src\\response-default.json";

GetOptions('uninstall' =&gt; sub{exit(uninstall())});

sub uninstall
{
  print "Uninstalling Visual Studio Pro 2017...\n";
  if(!run_command("\"$appdeploy\\vs_professional__422188100.1513883488.exe\" uninstall --quiet --norestart"))
  {
    print "Couldn't uninstall Visual Studio Pro 2017!\n";
	return 0;
  }
  else
  {
    print "Uninstalled successfully!\n";
	if(!delete_product_registry_key(get_package_name().".".get_version()))
	{
	  print "Couldn't delete registry key!\n";
	  return 0;
	}
  }
  
  print "Uninstallation complete!\n";
  return 1;
}

sub preinstall {
	#suppress "Open File - Security Warning" dialog from our DFS share
	output("Fixing file permisison: ");
	if(!run_command("reg import \"$src\\internetsecurity.reg\"")) {
		output("FAILED: $!\n");
		return 0;
	}
	output("OK\n");
	return 1;
}

sub install {

	output("Installing Visual Studio 2017... ");
	my $vsinstallcmd = "\"$appdeploy\\vs_professional__422188100.1513883488.exe\" --installPath \"$vs17loc\" -q --wait --norestart " .
		"--includeRecommended --productKey $key " .
		"--add Microsoft.VisualStudio.Workload.ManagedDesktop " .
		"--add Microsoft.VisualStudio.Workload.Data " .
		"--add Microsoft.VisualStudio.Workload.NativeDesktop " .
		"--add Microsoft.VisualStudio.Workload.NetWeb " .
		"--add Microsoft.VisualStudio.Workload.Office " .
		"--add Microsoft.VisualStudio.Workload.Universal " .
		"--add Component.GitHub.VisualStudio " .
		"--add Microsoft.VisualStudio.Component.VC.140 " .
		"--add Microsoft.VisualStudio.Component.Windows81SDK " .
		"--add Microsoft.VisualStudio.Component.Windows10SDK";
	run_command($vsinstallcmd, 'IgnoreExitCodes' =&gt; [3010]);
	sleep(120); #the command we look for doesn't show up until the vs_bootstrapper has run fora few minutes, sleep first.
	# The run_command spawns a separate process and returns immediately so this loop waits until all
	# vs_installer.exe processes finishes running.
	my $index = 0;
	my $success = 0;
	while($index &lt; 3600) { # 3600*5sec = 5 hours
		$_ = `tasklist`;
		if(/vs_installer\.exe/gi || /vs_bootstrapper\.exe/gi || /vs_installershell\.exe/gi || /vs_setup_bootstrapper\.exe/gi){
			$index++;
			sleep(5);
		}
		else {
			output("\n  Setup finished!\n");
			$success = 1;
			last;
		}
	}

	if (!$success) { 
		output("Timed out...\n");
		return 0;
	}
	return 1; 
}

=pod
sub install {

	output("Installing Visual Studio 2017... ");
	if(!(run_command("\"$appdeploy\\vs_professional.exe\" -q --wait --in \"$json\" --productKey $key", 'IgnoreExitCodes' =&gt; [3010]))) {
		output("FAILED: $!\n");
		return 0;
	}
	output("OK\n");
	return 1; 
}
=cut
sub postinstall {
	output("Removing Desktop Icons and some Start Menu Shortcuts...	");
	my $desk = get_allusers_desktop();
	my $start = "$ENV{'PROGRAMDATA'}\\Microsoft\\Windows\\Start Menu\\Programs";
	run_command("DEL /Q \"$start\\Visual Studio Installer.lnk\""); #no need for end user to modify install
	# run_command("DEL /Q \"$desk\\CocosCreator.exe.lnk\"");
	# run_command("DEL /Q \"$desk\\Epic Games Launcher.lnk\"");
	# run_command("DEL /Q \"$desk\\Unity 5.6.0f3 (64-bit).lnk\"");
	output("OK\n");
	return 1;
}

do_install
(
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['desktop', 'clc', 'virtual-clc', 'virtual-desktop', 'traveling'],
  exit_on_failure =&gt; 1,
  preinstall_sub =&gt; \&amp;preinstall,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\visual_studio.2017\prod.old\update.pl</FullName>
    <Length>3686</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-08-04T13:10:45.2069261-05:00</CreationTime>
    <CreationTimeUtc>2017-08-04T18:10:45.2069261Z</CreationTimeUtc>
    <LastWriteTime>2017-09-12T11:59:05.9295373-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-09-12T16:59:05.9295373Z</LastWriteTimeUtc>
    <LastAccessTime>2017-08-04T13:10:45.2069261-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-08-04T18:10:45.2069261Z</LastAccessTimeUtc>
    <Text># Visual Studio 2017
# Package created 6/7/2017
# Package by Sergey Gruzdev
# Last updated 6/7/2017 by Sergey Gruzdev

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
	%INSTALLMONKEY_OPTIONS = (
		package_id =&gt; 'visual_studio.2017',
		package_revision =&gt; '20170714T1033',
	);
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;

my $src = get_pkg_sourcefiles();
my $appdeploy = "\\\\minerfiles.mst.edu\\dfs\\software\\itwindist\\appdeploy\\visual_studio.2017";
my $vs17loc = "C:\\VS2017";
my $key = "R36QN-84VPC-QGFFK-P4VM2-JB6XV";
my $json = "$appdeploy\\response-default.json";

GetOptions('uninstall' =&gt; sub{exit(uninstall())});

sub uninstall
{
  print "Uninstalling Visual Studio Pro 2017...\n";
  if(!run_command("\"$appdeploy\\vs_professional.exe\" uninstall --quiet --norestart"))
  {
    print "Couldn't uninstall Visual Studio Pro 2017!\n";
	return 0;
  }
  else
  {
    print "Uninstalled successfully!\n";
	if(!delete_product_registry_key(get_package_name().".".get_version()))
	{
	  print "Couldn't delete registry key!\n";
	  return 0;
	}
  }
  
  print "Uninstallation complete!\n";
  return 1;
}

sub preinstall {
	#suppress "Open File - Security Warning" dialog from our DFS share
	output("Fixing file permisison: ");
	if(!run_command("reg import \"$src\\internetsecurity.reg\"")) {
		output("FAILED: $!\n");
		return 0;
	}
	output("OK\n");
	return 1;
}

sub install {

	output("Installing Visual Studio 2017... ");
	my $vsinstallcmd = "\"$appdeploy\\vs_professional.exe\" --installPath \"$vs17loc\" " .
		"--includeRecommended --productKey $key " .
		"--add Microsoft.VisualStudio.Workload.ManagedDesktop " .
		"--add Microsoft.VisualStudio.Workload.Data " .
		"--add Microsoft.VisualStudio.Workload.NativeDesktop " .
		"--add Microsoft.VisualStudio.Workload.NetWeb " .
		"--add Microsoft.VisualStudio.Workload.Office " .
		"--add Microsoft.VisualStudio.Workload.Universal " .
		"--add Component.GitHub.VisualStudio " .
		"--quiet --wait --norestart";
	output($vsinstallcmd);
	if(!run_command($vsinstallcmd, 'IgnoreExitCodes' =&gt; [3010])) {
		output("FAILED: $!\n");
		return 0;
	}
	output("OK\n");
	# if(!(run_command("\"$appdeploy\\vs_professional.exe\" --quiet --wait --norestart --in \"$json\" --productKey $key", 'IgnoreExitCodes' =&gt; [3010]))) {
		# output("FAILED: $!\n");
		# return 0;
	# }
	# output("OK\n");
	return 1; 
}

sub postinstall {
	output("Removing Desktop Icons and some Start Menu Shortcuts...	");
	my $desk = get_allusers_desktop();
	my $start = "$ENV{'PROGRAMDATA'}\\Microsoft\\Windows\\Start Menu\\Programs";
	run_command("DEL /Q \"$start\\Visual Studio Installer.lnk\""); #no need for end user to modify install
	# run_command("DEL /Q \"$desk\\CocosCreator.exe.lnk\"");
	# run_command("DEL /Q \"$desk\\Epic Games Launcher.lnk\"");
	# run_command("DEL /Q \"$desk\\Unity 5.6.0f3 (64-bit).lnk\"");
	output("OK\n");
	return 1;
}

do_install
(
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['desktop', 'clc', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  preinstall_sub =&gt; \&amp;preinstall,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\visual_studio_code.1_15_1\prod\update.pl</FullName>
    <Length>2171</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-08-30T10:33:45.1336121-05:00</CreationTime>
    <CreationTimeUtc>2017-08-30T15:33:45.1336121Z</CreationTimeUtc>
    <LastWriteTime>2017-08-30T12:44:18.910729-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-08-30T17:44:18.910729Z</LastWriteTimeUtc>
    <LastAccessTime>2017-08-30T10:33:45.1336121-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-08-30T15:33:45.1336121Z</LastAccessTimeUtc>
    <Text>#Visual Studio Code 1.15.1
#Package created 7/1/2016
#Package created by Benjamin Krueger
#Last updated by Grayson Gratop on 8/30/2017

BEGIN{
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; "visual_studio_code.1_15_1",
    package_revision =&gt; "20170830T1038"
  )
}

use lib(
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);

use InstallMonkey::Shared;
use Getopt::Long;
GetOptions('uninstall' =&gt; sub { exit(!uninstall()); });

sub install {
  output("Runninng VSCode Setup executable..\n");
  if(!run_command("".get_pkg_sourcefiles()."\\VSCodeSetup.exe /VERYSILENT /NOICONS /SUPPRESSMSGBOXES /NORESTART"))
  {
    output("Vscode installation failed.\n");
    return 0;
  }
  return 1;
}

sub uninstall {
  KillProcess("Code.exe");
  
  if (!run_command("\"C:\\Program Files (x86)\"\\\"Microsoft VS Code\"\\unins000.exe /VERYSILENT")) {
    output("Vscode Removal Failed.");
    return 0;
  }
  
  #run_command("REG DELETE  HKEY_LOCAL_MACHINE\\SOFTWARE\\UMR\\INSTALL\\Product_List\\VisualStudioCode1.2 /f");
  delete_product_registry_key(get_package_name().".".get_version());
  return 1;
}

sub postinstall {
  run_command('DEL "C:\\Users\\Public\\Desktop\\Visual Studio Code.lnk"');#get rid of the shortcut
  KillProcess("Code.exe"); #kill the annoying instance of the program that comes up after it installs.
  my $shortcutdir = get_allusers_start_menu().'\VS Code';
  output("Creating shortcut in $shortcutdir\n");
  mkdir $shortcutdir unless -d $shortcutdir;
  
  if (!create_shortcut(
    'target'    =&gt; 'C:\Program Files\Microsoft VS Code\Code.exe',
    'link'      =&gt; $shortcutdir.'\Visual Studio Code.lnk',
    'description' =&gt; 'Launches VS Code',
  )) {
    output("\nERROR: Could not create shortcut.\n");
  }
  return 1;
}

do_install(
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1,OSVER_WIN8_SP0],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['desktop','virtual-desktop','traveling','clc','virtual-clc'],
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);


</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\visual_studio_code.1_22_2\prod\update.pl</FullName>
    <Length>2250</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-11T16:52:43.2595182-05:00</CreationTime>
    <CreationTimeUtc>2018-05-11T21:52:43.2595182Z</CreationTimeUtc>
    <LastWriteTime>2018-05-11T16:58:16.4747526-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-11T21:58:16.4747526Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-11T16:52:43.2906967-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-11T21:52:43.2906967Z</LastAccessTimeUtc>
    <Text>#practice perl script to install visual studio code from exe
#Package created May 11th, 2018
#Package created by Kade Wessels
#Last updated by Kade Wessels

BEGIN{
    %INSTALLMONKEY_OPTIONS =(
        package_id =&gt; "visual_studio_code.1_22_2",
        package_revision =&gt; "20180511T1650"
    )
}

use lib(
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use Getopt::Long;
GetOptions('uninstall' =&gt; sub {exit(!uninstall());});
sub install {
    output("Runninng VSCode Setup executable..\n");
    if(!run_command("".get_pkg_sourcefiles()."\\VSCodeSetup-x64-1.22.2.exe /VERYSILENT /NOICONS /SUPPRESSMSGBOXES /NORESTART"))
    {
        output("Vscode installation failed.\n");
        return 0;
    }
    return 1;
}
sub uninstall
{
    KillProcess("Code.exe");
    if(!run_command("\"C:\\Program Files\"\\\"Microsoft VS Code\"\\unins000.exe /VERYSILENT"))
    {
        output("Vscode Removal Failed.");
        return 0;
    }
    #run_command("REG DELETE  HKEY_LOCAL_MACHINE\\SOFTWARE\\UMR\\INSTALL\\Product_List\\VisualStudioCode1.2 /f");
    delete_product_registry_key(get_package_name().".".get_version());
    return 1;
}
sub postinstall
{
    run_command('DEL "C:\\Users\\Public\\Desktop\\Visual Studio Code.lnk"');#get rid of the shortcut
    KillProcess("Code.exe"); #kill the annoying instance of the program that comes up after it installs.
    my $shortcutdir = get_allusers_start_menu().'\VS Code';
	output("Creating shortcut in $shortcutdir\n");
    mkdir $shortcutdir unless -d $shortcutdir;
	if(!create_shortcut(
		'target' 	  =&gt; 'C:\Program Files\Microsoft VS Code\Code.exe',
		'link' 		  =&gt; $shortcutdir.'\Visual Studio Code.lnk',
		'description' =&gt; 'Launches Vs Code',
		)
	)
	{
		output("\nERROR: Could not create shortcut.\n");
	}
    return 1;
    
}
do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1,OSVER_WIN8_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['desktop','virtual-desktop','traveling','clc','virtual-clc'],
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);
IM_Exit(EXIT_SUCCESS);


</Text>
  </Script>
  <Script>
    <Name>update-test.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\vlc.3_0_3\prod\update-test.pl</FullName>
    <Length>229</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-11T08:08:59.0428059-05:00</CreationTime>
    <CreationTimeUtc>2018-06-11T13:08:59.0428059Z</CreationTimeUtc>
    <LastWriteTime>2011-04-19T16:39:29.0689907-05:00</LastWriteTime>
    <LastWriteTimeUtc>2011-04-19T21:39:29.0689907Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-11T08:08:59.0428059-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-11T13:08:59.0428059Z</LastAccessTimeUtc>
    <Text>use File::Basename;
use File::Spec;
my $cmd = 
    join(' ',
         'perl.exe',
         File::Spec-&gt;canonpath(File::Spec-&gt;catfile(dirname($0),'update.pl')),
         map { '"'.$_.'"' } @ARGV,
    );
system($cmd);


</Text>
  </Script>
  <Script>
    <Name>update-wrapper.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\vlc.3_0_3\prod\update-wrapper.pl</FullName>
    <Length>229</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-11T08:08:59.0584297-05:00</CreationTime>
    <CreationTimeUtc>2018-06-11T13:08:59.0584297Z</CreationTimeUtc>
    <LastWriteTime>2011-04-19T16:39:29.0689907-05:00</LastWriteTime>
    <LastWriteTimeUtc>2011-04-19T21:39:29.0689907Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-11T08:08:59.0584297-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-11T13:08:59.0584297Z</LastAccessTimeUtc>
    <Text>use File::Basename;
use File::Spec;
my $cmd = 
    join(' ',
         'perl.exe',
         File::Spec-&gt;canonpath(File::Spec-&gt;catfile(dirname($0),'update.pl')),
         map { '"'.$_.'"' } @ARGV,
    );
system($cmd);


</Text>
  </Script>
  <Script>
    <Name>update-x64.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\vlc.3_0_3\prod\update-x64.pl</FullName>
    <Length>54</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-11T08:08:59.0740548-05:00</CreationTime>
    <CreationTimeUtc>2018-06-11T13:08:59.0740548Z</CreationTimeUtc>
    <LastWriteTime>2014-05-06T09:07:49.7584377-05:00</LastWriteTime>
    <LastWriteTimeUtc>2014-05-06T14:07:49.7584377Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-11T08:08:59.0740548-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-11T13:08:59.0740548Z</LastAccessTimeUtc>
    <Text>system(join(' ','perl.exe','"'.__FILE__.'"',@ARGV));
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\vlc.3_0_3\prod\update.pl</FullName>
    <Length>7575</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-11T08:08:59.0896807-05:00</CreationTime>
    <CreationTimeUtc>2018-06-11T13:08:59.0896807Z</CreationTimeUtc>
    <LastWriteTime>2018-06-12T10:14:37.0554619-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-12T15:14:37.0554619Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-11T08:08:59.0896807-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-11T13:08:59.0896807Z</LastAccessTimeUtc>
    <Text># VLC Media Player
# Package Created March 2011
# Packaged by Robert Smith, based on Todd Hartman's previous package
# Last Updated 2018-06-12

=pod

Begin-Doc
Modified: $Date$
Name: VideoLAN Media Player installer
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'vlc.3_0_3',
        # version, release date, download date
        package_revision =&gt; '20180611T0831',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use File::Basename;

########################################################################
# BEGIN Configuration

my $installer = 'vlc-3.0.3-win32.exe';
my $installer_amd64 = 'vlc-3.0.3-win64.exe';

my $install_subdir = build_path('VideoLAN','VLC');

my $loginscript = 'CustomizeVLCProfile.pl';
my $loginscript_dir = 'vlc';


# END Configuration
########################################################################

my $startmenu = get_allusers_start_menu();

use Getopt::Long;
GetOptions(
    'installer=s' =&gt; \$installer,
    'win64'       =&gt; sub { $installer = $installer_amd64; },
    'uninstall'   =&gt; sub { exit(! uninstall()); },
);


sub uninstall {
    foreach my $pgmfiles (get_arch_programfiles(OSARCH_x86),
                          get_arch_programfiles(OSARCH_x64)) {
        my $uninstaller = build_path($pgmfiles,$install_subdir,'uninstall.exe');

        # VLC doesn't want concurrent installations. Uninstall the old
        #   version, if it exists.
        if( -e $uninstaller)
        {
            output("A version of VLC is already installed.\n".
                   "Uninstalling old version: ");

            my @command = (
                'start','/wait','""',
                '"'.$uninstaller.'"',
                '/S',
            );
            if(!run_command(join(' ',@command)))
            {
                output("Uninstalling existing version of VLC has failed! ".
                       "Please retry or uninstall manually!\n");
                return 0;
            }
            output("OK\n");
        }
    }

    return 1;
}


sub preinstall {
    return uninstall();
}


sub install {
    my @command = (
        'start','/wait','""',
        '"'.build_path(get_pkg_sourcefiles(),$installer).'"',
        '/S', # silent
        );

    if (!run_command(join(' ',@command)))
    {
        output("   VLC installation failed!\n");
        return 0;
    }
    return 1;
}


sub configure {

    # Remove desktop icon
    output("Removing desktop shortcut: ");
    my $desktop_shortcut = build_path(get_allusers_desktop(),
                                      'VLC media player.lnk');
    if (!run_command("del /q /f \"${desktop_shortcut}\""))
    {
        output("FAILED\n".
               "Deleting desktop icon (${desktop_shortcut}) failed: $?\n");
        # This isn't critical. Don't report failure.
    }
    output("OK\n");


    return create_login_script();
}

do_install(
    allowed_versions =&gt; [ OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2,
                          OSVER_WIN7_SP0, OSVER_WIN7_SP1,
                          OSVER_WIN81_SP0, OSVER_WIN10_SP0,
                        ],
    allowed_os_architectures =&gt; [ OSARCH_x86, OSARCH_x64 ],
    allowed_regs =&gt; [ 'clc', 'desktop', 'traveling',
                      'virtual-clc','virtual-desktop' ],
    exit_on_failure =&gt; 1,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;configure,
    data_dir  =&gt; testing_data_dir(),
);
IM_Exit(EXIT_SUCCESS);


# AppData\Roaming\vlc\vlcrc
# qt-updates-notif=0

# Begin-Doc
################################
# Name: create_login_script()
# Description: Create an ActiveSetup action to invoke the VLC profile
#   customizations.
# Returns: true on success, failure otherwise
# LastUpdated: 2012-12-11
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub create_login_script {
    # Create the login script.
    output("Creating login script: ");
    my $target = build_path(get_allusers_scripts(),'standard',
                            $loginscript_dir,$loginscript);

    # Create the directory, if necessary.
    if (! -d (my $tdir = dirname($target))) {
        if (!run_command('mkdir "'.$tdir.'"')) {
            output("FAILED\n".
                   "   Error creating login script directory: ".($?&gt;&gt;8)."\n");
            return 0;
        }
    }
    # Copy the script.
    if (!run_command(sprintf('copy /y "%s" "%s"',
                             build_path(get_pkg_sourcefiles(),$loginscript),
                             $target))) {
        output("FAILED\n  Error copying login script: ".($?&gt;&gt;8)."\n");
        return 0;
    }
    # Configure the ActiveSetup item.
    # 3.0.3: unsure if necessary to update for later version
    if (!create_activesetup_action(
             'Identifier'  =&gt; 'VLC_CustomizeProfile_20121211',
             'ComponentID' =&gt; 'VLC',
             'Description' =&gt; 'Update/fix user VLC profle (vlcrc)',
             'Version'     =&gt; '2,0,4,1', # last num is the rev of this script
             'StubPath'    =&gt; $target,
        )) {
        output("FAILED\n     Error: cannot create Active Setup action to ".
               "customize the user profile.\n");
        return 0;
    }
    output("OK\n");
}



# Begin-Doc
################################
# Name: testing_data_dir
# Description: choose a data dir based on the name of this script
# Returns: the name of the data directory to use
#   If the script is named 'update-test.pl', use the directory matching
#     'data.*' that is lexically the highest.
# Comments:
#   This subroutine is designed to ease the frequent necessity of updating
#     the package. Rather than have to copy lots of things or manually
#     specify the data directory when testing updates on the command line
#     (which is not possible in a template install) or hardcoding the name
#     into the script (which frequently gets promoted and I forget to change
#     it), if the script is detected to be a "test" script, a good candidate
#     for the data dir is chosen. This should make it easier (and less error-
#     prone) to test and promote updates to the package.
# Requires:
#   File::Basename
#   File::Spec
# LastUpdated: 2011-03-24
# LastUpdatedBy: Todd Hartman
################################
# End-Doc
sub testing_data_dir {
    if (basename(__FILE__) eq 'update-test.pl') {
        my $dir = dirname(__FILE__);
        if (opendir(my $DIR,$dir)) {
            my @candidates;
            while (defined(my $entry = readdir($DIR))) {
                my $target = build_path($dir,$entry);
                next if (! -d $target);
                next if ($entry !~ /^data\./);
                push(@candidates,$entry);
            }
            closedir($DIR);
            my @sorted = sort { $b cmp $a } @candidates;
            return $sorted[0];
        } else {
            output("Cannot open cwd '${dir}': $!\n");
            return undef; # This should cause an error, resulting in an abort.
        }
    } else {
        return 'data';
    }
}
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\VMWare_Horizon.4_5_0\prod\update.pl</FullName>
    <Length>1649</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-07-05T14:19:36.4420281-05:00</CreationTime>
    <CreationTimeUtc>2017-07-05T19:19:36.4420281Z</CreationTimeUtc>
    <LastWriteTime>2017-07-10T12:08:55.7424435-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-07-10T17:08:55.7424435Z</LastWriteTimeUtc>
    <LastAccessTime>2017-07-05T14:19:36.4420281-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-07-05T19:19:36.4420281Z</LastAccessTimeUtc>
    <Text>#VMware Horizon 4.5.0
#Package Created on July 5, 2017
#Package by Austin Wall
#Last Update July 10, 2017 by Austin Wall

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'vmware_horizon.4_5_0',
        package_revision =&gt; '20170710T1208',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $SrcFiles = get_pkg_sourcefiles();
my $applog = get_default_app_log();

sub install {
    output("Installing VMware Horizon: ");    
    my $Success = run_command("$SrcFiles\\VMware-Horizon-Client-4.5.0-5650915.exe /silent /norestart VDM_SERVER=view.mst.edu");
    output($Success ? "Success!\n" : "FAILED: $!\n");
    if ($Success){
      return 1;
    }
    else{
      return 0;
    }
}

sub postinstall {
    #Delete desktop icon
    run_command("del \"%systemdrive%\\Users\\Public\\Desktop\\VMware Horizon Client.lnk\"");
}
do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', "virtual-clc", "virtual-desktop"],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    need_reboot =&gt; 0,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\vmware_horizon_client.4_8_0\prod\update.pl</FullName>
    <Length>1732</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-20T11:51:18.3871899-05:00</CreationTime>
    <CreationTimeUtc>2018-06-20T16:51:18.3871899Z</CreationTimeUtc>
    <LastWriteTime>2018-06-20T10:51:10.0656099-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-20T15:51:10.0656099Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-20T11:51:18.3871899-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-20T16:51:18.3871899Z</LastAccessTimeUtc>
    <Text>#VMware Horizon Client 4.8.0
#Package Created on June 20, 2018
#Package by Sergey Gruzdev
#Last Update July 10, 2017 by Sergey Gruzdev

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'vmware_horizon_client.4_8_0',
        package_revision =&gt; '20180620T1033',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $src = get_pkg_sourcefiles();
my $applog = get_default_app_log();

sub install {
    output("Installing VMware Horizon Client: ");    
    my $Success = run_command("$src\\VMware-Horizon-Client-4.8.0-8547331.exe /silent /norestart VDM_SERVER=view.mst.edu LOGINASCURRENTUSER_DEFAULT=1");
    output($Success ? "Success!\n" : "FAILED: $!\n");
    if ($Success){
	  print "===RESTART REQUIRED===\n";
      return 1;
    }
    else{
      return 0;
    }
}

sub postinstall {
    #Delete desktop icon
    run_command("del \"%systemdrive%\\Users\\Public\\Desktop\\VMware Horizon Client.lnk\"");
}
do_install(
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', "virtual-clc", "virtual-desktop"],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
    need_reboot =&gt; 0,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\vscode.1_12_1\prod\update.pl</FullName>
    <Length>2112</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-05-25T15:24:43.2544267-05:00</CreationTime>
    <CreationTimeUtc>2017-05-25T20:24:43.2544267Z</CreationTimeUtc>
    <LastWriteTime>2017-05-25T15:35:06.814018-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-05-25T20:35:06.814018Z</LastWriteTimeUtc>
    <LastAccessTime>2017-05-25T15:24:43.2544267-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-05-25T20:24:43.2544267Z</LastAccessTimeUtc>
    <Text>
    # vscode
    # Package Created May 25, 2017
    # Packaged by Krueger, Benjamin (S&amp;T IT Student Employee)
    # Last Updated --

    BEGIN {
        %::INSTALLMONKEY_OPTIONS = (
            package_id =&gt; 'vscode.1_12_1',
            package_revision =&gt; '20170525T1524',
        );
    }

    use lib (
        '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
        $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
        'C:\temp',
    );
    use InstallMonkey::Shared;

    my $srcfiles = get_pkg_sourcefiles();
    my $log_dir = get_applogs_dir();

    sub install {
        if(!run_command("".get_pkg_sourcefiles()."\\VSCodeSetup-1.12.1.exe /VERYSILENT /NOICONS /SUPPRESSMSGBOXES /NORESTART"))
        {
            output("Installation failed!\n");
            return 0;
        }
        
        output("Installation successful!");
        return 1;
    }
    sub postinstall
    {
    run_command('DEL "C:\\Users\\Public\\Desktop\\Visual Studio Code.lnk"');#get rid of the shortcut
    KillProcess("Code.exe"); #kill the annoying instance of the program that comes up after it installs.
    my $shortcutdir = get_allusers_start_menu().'\VS Code';
	output("Creating shortcut in $shortcutdir\n");
    mkdir $shortcutdir unless -d $shortcutdir;
	if(!create_shortcut(
		'target' 	  =&gt; 'C:\Program Files (x86)\Microsoft VS Code\Code.exe',
		'link' 		  =&gt; $shortcutdir.'\Visual Studio Code.lnk',
		'description' =&gt; 'Launches Vs Code',
		)
	)
	{
		output("\nERROR: Could not create shortcut.\n");
	}
    return 1;
    
    }
    do_install( 
        exit_on_failure =&gt; 1,
        allowed_versions          =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
        allowed_os_architectures  =&gt; [ OSARCH_x64 ],
        allowed_regs              =&gt; [ "clc", "desktop", "traveling", "virtual-desktop", "virtual-clc" ],
        install_sub               =&gt; \&amp;install,
        postinstall_sub           =&gt; \&amp;postinstall
        
    );

    IM_Exit(EXIT_SUCCESS);

    ########################################################################
    </Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\wacom_drivers.6_3_17_3\prod\update.pl</FullName>
    <Length>2351</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-02-15T16:15:59.7839754-06:00</CreationTime>
    <CreationTimeUtc>2017-02-15T22:15:59.7839754Z</CreationTimeUtc>
    <LastWriteTime>2017-02-17T16:18:29.3972315-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-02-17T22:18:29.3972315Z</LastWriteTimeUtc>
    <LastAccessTime>2017-02-15T16:15:59.7839754-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-02-15T22:15:59.7839754Z</LastAccessTimeUtc>
    <Text># Wacom Drivers 6.3.17-3 - Drivers for Wacom tablets
# Package generated with GenGen on 2017-Feb-15 16:15
# Packaged by Grayson Gratop

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
      package_id =&gt; 'wacom_drivers.6_3_17_3',
      package_revision =&gt; '20170215T1615',
  );
}

# Add InstallMonkey Library to the path
use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use Getopt::Long;
use InstallMonkey::Shared;

GetOptions(
  'uninstall' =&gt; sub { exit(!uninstall()); },
);

my $srcfilesdir = get_pkg_sourcefiles();
my $allUsersDesktop = get_allusers_desktop();
my $allUsersStartmenu = get_allusers_start_menu();
my $startmenudir = "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs";


sub install {
  #thanks, creator of python 2.7 package. second argument is whether or not it's okay if the command fails
  my @installCommands = (
    ["$srcfilesdir\\WacomTablet_6.3.17-3.exe /S", 0]
  );

  my $success = 0;
  my $allDone = 1;
  
  output("Installing Wacom Drivers 6.3.17-3... \n");
  
  for (my $i = 0; $i &lt; scalar @installCommands; $i++) {
    output("\t" . $installCommands[$i][0] . ": ");
    $success = run_command($installCommands[$i][0]);
    output($success ? "Done!\n" : "FAILED: $!\n");
    $allDone &amp;&amp;= $installCommands[$i][1] || $success;
  }

  if ($allDone) {
    output("Looks like it was a success!\n");
  }
  else {
    output("Something went wrong!\n");
  }

  return $allDone;
}


sub postInstall {


  return 1;
}


do_install( 
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
  allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postInstall,
  need_reboot =&gt; 1,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\wacom_drivers.6_3_21_10\prod\update.pl</FullName>
    <Length>2120</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-05-22T08:15:23.3461941-05:00</CreationTime>
    <CreationTimeUtc>2017-05-22T13:15:23.3461941Z</CreationTimeUtc>
    <LastWriteTime>2017-05-22T10:08:57.6655852-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-05-22T15:08:57.6655852Z</LastWriteTimeUtc>
    <LastAccessTime>2017-05-22T08:15:23.3461941-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-05-22T13:15:23.3461941Z</LastAccessTimeUtc>
    <Text># Wacom Drivers 6.3.21-10 - Drivers for Wacom tablets
# Packaged by Austin Wall
# Last updated 5/22/2017 by Austin Wall

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
      package_id =&gt; 'wacom_drivers.6_3_21_10',
      package_revision =&gt; '20170522T1001',
  );
}

# Add InstallMonkey Library to the path
use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use Getopt::Long;
use InstallMonkey::Shared;


my $srcfilesdir = get_pkg_sourcefiles();
my $allUsersDesktop = get_allusers_desktop();
my $allUsersStartmenu = get_allusers_start_menu();
my $startmenudir = "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs";

sub preinstall {
    output("Adding certificate to store...\n");
    if(!run_command("certutil -addstore \"TrustedPublisher\" $srcfilesdir\\WacomCert.cer")){
        output("Error adding certificate! $!\n");
        return 0;
    } else { 
        output("Certificate added to store.\n");
        return 1;
    }
}


sub install {
  my @installCommands = (
    ["$srcfilesdir\\WacomTablet_6.3.21-10.exe /S", 0]
  );

  my $success = 0;
  my $allDone = 1;
  
  output("Installing Wacom Drivers 6.3.21-10... \n");
  # Why is this like this?
  for (my $i = 0; $i &lt; scalar @installCommands; $i++) {
    output("\t" . $installCommands[$i][0] . ": ");
    $success = run_command($installCommands[$i][0]);
    output($success ? "Done!\n" : "FAILED: $!\n");
    $allDone &amp;&amp;= $installCommands[$i][1] || $success;
  }

  if ($allDone) {
    output("Looks like it was a success!\n");
  }
  else {
    output("Something went wrong!\n");
  }

  return $allDone;
}


do_install( 
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  preinstall_sub =&gt; \&amp;preinstall,
  install_sub =&gt; \&amp;install,
  need_reboot =&gt; 1,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\wacom_drivers.6_3_29_6\prod\update.pl</FullName>
    <Length>2116</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-30T10:43:28.1036648-05:00</CreationTime>
    <CreationTimeUtc>2018-05-30T15:43:28.1036648Z</CreationTimeUtc>
    <LastWriteTime>2018-05-30T14:39:33.1451145-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-30T19:39:33.1451145Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-30T10:43:28.1036648-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-30T15:43:28.1036648Z</LastAccessTimeUtc>
    <Text># Wacom Drivers 6.3.29.6 - Drivers for Wacom tablets
# Packaged by Austin Wall
# Last updated 5/22/2017 by Austin Wall

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
      package_id =&gt; 'wacom_drivers.6_3_29_6',
      package_revision =&gt; '20170522T1001',
  );
}

# Add InstallMonkey Library to the path
use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use Getopt::Long;
use InstallMonkey::Shared;


my $srcfilesdir = get_pkg_sourcefiles();
my $allUsersDesktop = get_allusers_desktop();
my $allUsersStartmenu = get_allusers_start_menu();
my $startmenudir = "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs";

sub preinstall {
    output("Adding certificate to store...\n");
    if(!run_command("certutil -addstore \"TrustedPublisher\" $srcfilesdir\\WacomCert.cer")){
        output("Error adding certificate! $!\n");
        return 0;
    } else { 
        output("Certificate added to store.\n");
        return 1;
    }
}


sub install {
  my @installCommands = (
    ["$srcfilesdir\\WacomTablet_6.3.29-6.exe /S", 0]
  );

  my $success = 0;
  my $allDone = 1;
  
  output("Installing Wacom Drivers 6.3.29.6... \n");
  # Why is this like this?
  for (my $i = 0; $i &lt; scalar @installCommands; $i++) {
    output("\t" . $installCommands[$i][0] . ": ");
    $success = run_command($installCommands[$i][0]);
    output($success ? "Done!\n" : "FAILED: $!\n");
    $allDone &amp;&amp;= $installCommands[$i][1] || $success;
  }

  if ($allDone) {
    output("Looks like it was a success!\n");
  }
  else {
    output("Something went wrong!\n");
  }

  return $allDone;
}


do_install( 
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  preinstall_sub =&gt; \&amp;preinstall,
  install_sub =&gt; \&amp;install,
  need_reboot =&gt; 1,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\weka.3_8_0\prod\update.pl</FullName>
    <Length>1673</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-07-15T11:00:19.8032256-05:00</CreationTime>
    <CreationTimeUtc>2016-07-15T16:00:19.8032256Z</CreationTimeUtc>
    <LastWriteTime>2016-07-15T11:00:11.5662672-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-07-15T16:00:11.5662672Z</LastWriteTimeUtc>
    <LastAccessTime>2016-07-15T11:00:19.8032256-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-07-15T16:00:19.8032256Z</LastAccessTimeUtc>
    <Text># Weka - Daniel T. Holtzclaw - 07/15/16

=pod

Begin-Doc
Modified: $Date$
Name: ACIS 3D Modeler R21
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'weka.3_8_0',
        package_revision =&gt; '20160716T1100',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $files = get_pkg_sourcefiles();

# Installer is a NSIS installer. (It has different commands than MSIs or ISS).
# start /wait is required because it will instantly return whenever it starts.
#   This encourages the installer to finish then return a code.
# /S for silent
# /D for install directory
my $command =
  "start /wait $files\\weka-3-8-0-x64.exe /S /D=C:\\Program Files\\Weka";

sub install
{
  output("\nWeka 3.8.0:\n  Command: $command\n  Result: ");
  if(!run_command($command))
  {
    output("Failed - $!\n\n");
    return 0;
  }
  output("Succeeded\n\n");
  return 1;
}

do_install(
    allowed_versions =&gt; [ OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                          'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\weka.3_8_1\prod\update.pl</FullName>
    <Length>1737</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-08T15:35:35.3834899-06:00</CreationTime>
    <CreationTimeUtc>2017-11-08T21:35:35.3834899Z</CreationTimeUtc>
    <LastWriteTime>2017-11-10T13:30:18.8768371-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-11-10T19:30:18.8768371Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-08T15:35:35.3834899-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-08T21:35:35.3834899Z</LastAccessTimeUtc>
    <Text># Weka 3.8.1
# Packaged by Daniel T. Holtzclaw - 07/15/16
# Last Updated from v3.8.0 by Alex Schrimpf

=pod

Begin-Doc
Modified: $Date$
Name: ACIS 3D Modeler R21
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'weka.3_8_1',
        package_revision =&gt; '20171108T1100',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $files = get_pkg_sourcefiles();

# Installer is a NSIS installer. (It has different commands than MSIs or ISS).
# start /wait is required because it will instantly return whenever it starts.
#   This encourages the installer to finish then return a code.
# /S for silent
# /D for install directory
my $command =
  "start /wait $files\\weka-3-8-1-x64.exe /S /D=C:\\Program Files\\Weka";

sub install
{
  output("\nWeka 3.8.1:\n  Command: $command\n  Result: ");
  if(!run_command($command))
  {
    output("Failed - $!\n\n");
    return 0;
  }
  output("Succeeded\n\n");
  return 1;
}

do_install(
    allowed_versions =&gt; [ OSVER_VISTA_SP0, OSVER_VISTA_SP1, OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1 ],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                          'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\whittle.4_6\dev\update.pl</FullName>
    <Length>3108</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-08-31T14:28:47.7025039-05:00</CreationTime>
    <CreationTimeUtc>2016-08-31T19:28:47.7025039Z</CreationTimeUtc>
    <LastWriteTime>2016-08-31T16:41:26.8549795-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-08-31T21:41:26.8549795Z</LastWriteTimeUtc>
    <LastAccessTime>2016-08-31T14:28:47.7025039-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-08-31T19:28:47.7025039Z</LastAccessTimeUtc>
    <Text># GEOVIA Whitte 4.6 - Strategic Planning Software for Mining
# Package generated with GenGen on 2016-Aug-31 14:28
# Packaged by Grayson Gratop

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
      package_id =&gt; 'whittle.4_6',
      package_revision =&gt; '20160831T1428',
  );
}

# Add InstallMonkey Library to the path
use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use Getopt::Long;
use InstallMonkey::Shared;

GetOptions(
  'uninstall' =&gt; sub { exit(!uninstall()); },
);

my $srcfilesdir = get_pkg_sourcefiles();
my $allUsersDesktop = get_allusers_desktop();
my $allUsersStartmenu = get_allusers_start_menu();
my $startmenudir = "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs";


sub install {
  #thanks, creator of python 2.7 package. second argument is whether or not it's okay if the command fails
  my @installCommands = (
    ["\"$srcfilesdir\\GEOVIA Whittle 4.6 (x64).msi\" /quiet /qn", 0],
    ["copy /y $srcfilesdir\\fx.ini \"C:\\Program Files\\Dassault Systemes\\GEOVIA Whittle\\4.6 (x64)\"", 0],
    ["icacls \"C:\\Program Files\\Dassault Systemes\\GEOVIA Whittle\\4.6 (x64)\" /grant Users:(OI)(CI)F /T", 0]
  );

  my $success = 0;
  my $allDone = 1;
  
  output("Installing GEOVIA Whitte 4.6... \n");
  
  for (my $i = 0; $i &lt; scalar @installCommands; $i++) {
    output("\t" . $installCommands[$i][0] . ": ");
    $success = run_command($installCommands[$i][0]);
    output($success ? "Done!\n" : "FAILED: $!\n");
    $allDone &amp;&amp;= $installCommands[$i][1] || $success;
  }

  if ($allDone) {
    output("Looks like it was a success!\n");
  }
  else {
    output("Something went wrong!\n");
  }

  return $allDone;
}


sub postInstall {
  my $iconSuccess = 0;

  #Delete icons in every user's Desktop folder (excluding Default). Thanks, StackOverflow
  opendir(DIR, 'C:\\Users');
  my @users = grep { (!/^\.\.?$/) &amp;&amp; (-d "C:\\Users\\$_") &amp;&amp; ($_ ne 'Default') } readdir(DIR);
  closedir(DIR);

  foreach my $place (@users) {
    $iconSuccess += run_command("DEL /Q \"C:\\Users\\$place\\Desktop\\GEOVIA Whittle 4.6 (x64).lnk\"");
  }

  output($iconSuccess ? "$iconSuccess desktop icon(s) were removed.\n"
                      : "Did not remove any desktop icons.\n");



  return 1;
}


do_install( 
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
  allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postInstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\whittle.4_7_1\dev\update.pl</FullName>
    <Length>4005</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-01-10T14:30:24.2340963-06:00</CreationTime>
    <CreationTimeUtc>2018-01-10T20:30:24.2340963Z</CreationTimeUtc>
    <LastWriteTime>2018-01-10T14:31:42.6162014-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-10T20:31:42.6162014Z</LastWriteTimeUtc>
    <LastAccessTime>2018-01-10T14:30:24.2340963-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-01-10T20:30:24.2340963Z</LastAccessTimeUtc>
    <Text># Whittle 4.7.1
# Package Created Fall 2017
# Packaged by Alex Schrimpf
# Last Updated Fall 2017 by Alex Schrimpf


=pod

Begin-Doc
Modified: 
Name: 
Type:
Description: 
Language: Perl
LastUpdatedBy:
Version:
Doc-Package-Info
Doc-SVN-Repository:
RCSId:
End-Doc

=cut

use strict;
use warnings;
our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'Whittle.4_7_1',
        package_revision =&gt; '',
    );
}

use lib ( '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 'C:\temp' );

use InstallMonkey::Shared;

use IM_helper(
   \%INSTALLMONKEY_OPTIONS,
    v2.01,
    (
        "EXTRACTION" =&gt; [
            sub {
                IM_helper::extract_files(
                    from=&gt; ["$IM_helper::source_files\\Whittle 4.7.1.zip"],
                    to =&gt; $IM_helper::source_files,
                );
            },   
        ],
        "INSTALL" =&gt; [
            sub{
               IM_helper::run_command(
                    name    =&gt; 'GEOVIA Whittle',
                    command =&gt; "\"$IM_helper::source_files\\Whittle 4.7.1\\GEOVIA Whittle 4.7.1 (x64).msi\" /quiet /qn",
                );
            },
            sub{
                IM_helper::cp_file(
                        from =&gt; "$IM_helper::source_files\\fx.ini",
                        to_dir =&gt; "C:\\Program Files\\Dassault Systemes\\GEOVIA Whittle\\4.7.1 (x64)"        
                );
            },
            sub{
                IM_helper::del_files(
                    files =&gt; [
                        "C:\\Users\\Public\\Desktop\\GEOVIA Whittle 4.7.1 (x64).lnk"
                    ]
                );
                return 1;
            },
            sub{
                IM_helper::set_perms(
                        user =&gt; "Users",
                        permissions =&gt; "F",
                        folder =&gt; "C:\\Program Files\\Dassault Systemes\\GEOVIA Whittle\\4.7.1 (x64)"
                );
            }
        ],
        "UNINSTALL" =&gt; [
            sub{
                IM_helper::get_uninstall_strings(
                    display_name=&gt; "GEOVIA Whittle 4.7.1 (x64)",
                    succ_cb =&gt; sub {
                        my $uninst_str = @{{@_}-&gt;{x64}}[0];
                        if(defined $uninst_str){
                            #Uninstall string uses /I (install) switch so replace it with /X (uninstall)
                            $uninst_str=~ s/\QI\E/X/g;
                            return IM_helper::run_command(
                                name=&gt;"uninstalling Whittle",
                                command=&gt;$uninst_str." /quiet /qn",
                            );
                        }
                        return 0;
                    }
                );          
            },
            sub {
                delete_product_registry_key($INSTALLMONKEY_OPTIONS{package_id});
            },

        ]
    )
);

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt;
      [ 'clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    no_install_check =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL'),
    no_product_key =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL'),
    install_sub =&gt; sub {
        if(scalar @{$IM_helper::IM_HELPER_OPTIONS{call_stack_override}}){
            foreach my $call_stack (@{$IM_helper::IM_HELPER_OPTIONS{call_stack_override}}){
                if(!IM_helper::exec_call_stack(id=&gt;$call_stack)){
                   return 0;
                }
            }
            return 1;
        }else{
            return (
                IM_helper::exec_call_stack(id=&gt;"EXTRACTION") &amp;&amp; 
                IM_helper::exec_call_stack(id=&gt;"INSTALL")
            );
        }
    }
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\whittle.4_7_1\prod\update.pl</FullName>
    <Length>3002</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-13T16:24:54.0878777-06:00</CreationTime>
    <CreationTimeUtc>2017-11-13T22:24:54.0878777Z</CreationTimeUtc>
    <LastWriteTime>2018-01-24T10:38:12.8101883-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-24T16:38:12.8101883Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-13T16:24:54.1347467-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-13T22:24:54.1347467Z</LastAccessTimeUtc>
    <Text># Whittle 4.7.1
# Package Created Fall 2017
# Packaged by Alex Schrimpf
# Last Updated Fall 2017 by Alex Schrimpf


=pod

Begin-Doc
Modified: 
Name: 
Type:
Description: 
Language: Perl
LastUpdatedBy:
Version:
Doc-Package-Info
Doc-SVN-Repository:
RCSId:
End-Doc

=cut

use strict;
use warnings;
our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'Whittle.4_7_1',
        package_revision =&gt; '',
    );
}

use lib ( '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 'C:\temp' );

use InstallMonkey::Shared;

use IM_helper(
   \%INSTALLMONKEY_OPTIONS,
    v4.04,
    (
        "EXTRACTION" =&gt; [
            sub {
                IM_helper::extract_files(
                    from=&gt; ["$IM_helper::source_files\\Whittle 4.7.1.zip"],
                    to =&gt; $IM_helper::source_files,
                );
            },   
        ],
        "INSTALL" =&gt; [
            sub{
               IM_helper::run_command(
                    description =&gt; 'GEOVIA Whittle',
                    command =&gt; "\"$IM_helper::source_files\\Whittle 4.7.1\\GEOVIA Whittle 4.7.1 (x64).msi\" /quiet /qn",
                );
            },
            sub{
                IM_helper::cp_file(
                        from =&gt; "$IM_helper::source_files\\fx.ini",
                        to_dir =&gt; "C:\\Program Files\\Dassault Systemes\\GEOVIA Whittle\\4.7.1 (x64)"        
                );
            },
            sub{
                IM_helper::del_files(
                    files =&gt; [
                        "C:\\Users\\Public\\Desktop\\GEOVIA Whittle 4.7.1 (x64).lnk"
                    ]
                );
                return 1;
            },
            sub{
                IM_helper::set_perms(
                        user =&gt; "Users",
                        permissions =&gt; "F",
                        folder =&gt; "C:\\Program Files\\Dassault Systemes\\GEOVIA Whittle\\4.7.1 (x64)"
                );
            }
        ],
        "UNINSTALL" =&gt; [
            sub{
                IM_helper::uninstall_using_programs_and_features(
                    display_name=&gt; "GEOVIA Whittle 4.7.1 (x64)",
                );          
            },
            sub {
                delete_product_registry_key($INSTALLMONKEY_OPTIONS{package_id});
            },

        ]
    )
);

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt;
      [ 'clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    no_install_check =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    no_product_key =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    install_sub =&gt; $IM_helper::exec_call_stack_override || sub{IM_helper::exec_call_stacks(ids=&gt;["EXTRACTION","INSTALL"])}
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\winscp.5_13_2\prod\update.pl</FullName>
    <Length>21344</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-06-11T08:46:37.3945716-05:00</CreationTime>
    <CreationTimeUtc>2018-06-11T13:46:37.3945716Z</CreationTimeUtc>
    <LastWriteTime>2018-06-11T08:52:38.8862403-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-06-11T13:52:38.8862403Z</LastWriteTimeUtc>
    <LastAccessTime>2018-06-11T08:46:37.3945716-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-06-11T13:46:37.3945716Z</LastAccessTimeUtc>
    <Text># Package Created 06-11-2018
# Packaged by Cameron Loren
# Last Updated 06-11-2018 by Cameron Loren

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'WinSCP.5_13_2',
        package_revision =&gt; '20180611T0848',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;
use File::Basename;
use File::Path;
use File::Temp qw(tempfile);
use File::Copy;
use Data::Dumper;
use Win32::TieRegistry;
use Getopt::Long;

########################################################################
# BEGIN Configuration

my $installer = get_pkg_sourcefiles().'\WinSCP-5.13.2-Setup.exe';
my $reboot_exit_code = 0x33;
# Inno Setup
my @installer_args = (
    '/VERYSILENT',
    '/NORESTART',
    '/RESTARTEXITCODE='.$reboot_exit_code,
#    '/NOCANDY', # don't bother with opencandy questions
    # logging details handled in install()
    # INF details handled in install()
    );

my $user_config_script = get_allusers_scripts().'\standard\WinSCP\winscp_settings.pl';

my $setup_inf_data = q/
[Setup]
Lang=en
Dir=/.get_arch_programfiles(OSARCH_x86).q/\WinSCP
Group=WinSCP
NoIcons=0
SetupType=full
Components=main,shellext,pageant,puttygen,transl,transl\eng
Tasks=sendtohook,urlhandler
/;

# END Configuration
########################################################################

# Begin-Doc
################################
# Name: install
# Description: Call the vendor-supplied installer, using a setup
#   configure file (.INF) and logging.
# Returns: true/false on returned success/failure
# Requires:
#   File::Temp::tempfile()
# LastUpdated: 06-10-2016
# LastUpdatedBy: Austin Wall
################################
# End-Doc
sub install {
    my $srcfiles = get_pkg_sourcefiles();
    my $need_reboot = 0;

    # The log file needs to be sent to a 32-bit-accessible location.
    my ($fh,$temp_log) = tempfile('winscp_install_log_XXXXXXXX'.
                                  'SUFFIX' =&gt; '.txt',
                                  'DIR'   =&gt; $ENV{TEMP} );
    if (!$fh) {
        output("Error creating temporary file: $!\n");
        return 0;
    }
    close($fh);
    my @other_args = (
        '/LOG="'.$temp_log.'"',
        );

    # Generate installer .INF.
    my $inf;
    ($fh,$inf) = tempfile('winscp_setup_XXXX',
                          'SUFFIX' =&gt; '.inf',
                          'DIR' =&gt; $srcfiles);
    print $fh $setup_inf_data;
    close($fh);
    push(@other_args,'/LOADINF="'.$inf.'"');

    # Call the vendor installer.
    output("   Running WinSCP Setup: ");
    my %run_info;
    my $status  = run_command(join(' ',
                                   Win32::GetShortPathName($installer),
                                   @installer_args,
                                   @other_args,
                              ),
                              'ReturnCommandInfo' =&gt; \%run_info,
                              'IgnoreExitCodes' =&gt; [ $reboot_exit_code ],
        );
    if ($status &amp;&amp; $run_info{ReturnCode}&gt;&gt;8 == $reboot_exit_code) {
        $need_reboot = 1;
    }

    # Copy the install log no matter what.
    run_command("copy /y \"${temp_log}\" \"".get_default_app_log()."\"",
                'Description' =&gt; 'moving temporary log file');

    # Remove files that ForeFront will flag for _OpenCandy_.
    #   Check in the install log for:
    #    &lt;timestamp&gt; Created temporary directory: C:\Users\ccadmin\AppData\Local\Temp\is-8VGOF.tmp
    #   That's the dir to delete.

    if (!$status) {
        output("FAILED\n");
        return 0;
    } else {
        output("OK\n");

        unlink($temp_log);
    }

    need_reboot() if ($need_reboot);

    return 1;
}

# Begin-Doc
################################
# Name: post_install
# Description: Configure WinSCP for campus use.
# Returns: true/false on success/(significant) failure
# Requires:
#   Win32::GetShortPathName()
#   InstallMonkey::Shared::create_activesetup_action()
# LastUpdated: 06-14-2016
# LastUpdatedBy: Austin Wall
# Comments:
#    Deletes any desktop shortcuts.
#    Creates the login script and the corresponding ActiveSetup action.
#    Apply the user-level customizations for the installer.
#    (2011-02-14) Forefront is now flagging the install media for having
#       OpenCandy.
################################
# End-Doc
sub post_install {
    my $success = 1;

    # Delete any desktop shortcuts.
    my @shortcuts = (
        $ENV{USERPROFILE}.'\Desktop\WinSCP.lnk',
        get_allusers_desktop().'\WinSCP.lnk',
        );
    foreach my $shortcut (@shortcuts) {
        if (-f $shortcut) {
            output("   Deleting shortcut: ");
            if(!run_command("del /F \"${shortcut}\"")) {
                output("FAILED\n");
            } else {
                output("OK\n");
            }
        }
    }

    # Create the login script.
    output("   Creating login script for WinSCP settings: ");
    if (!create_configure_script($user_config_script)) {
        output("FAILED\n");
        return 0; # Don't bother trying anything else in this sub.
    } else {
        output("OK\n");
    }

    # Call the user config script at login to configure defaults.
    my $short_cfg_path = Win32::GetShortPathName($user_config_script);
    output("   Configuring WinSCP defaults for current user: ");

    if (! create_activesetup_action(
              'ComponentID' =&gt; get_package_id(),
              'Identifier' =&gt; get_package_id(),
              'Version' =&gt; get_package_revision(),
              'StubPath' =&gt; 'C:\Perl64\bin\perl.exe ' . $short_cfg_path,
        )) {
        output("FAILED\n");
        $success = 0;
    } else {
        output("OK\n");
    }

    # Add Session info to Current User (ie. The installer) so that s/he
    #   doesn't have to log out and log back in before WinSCP is configured.
    # Checks to make sure the installer is not using the system account
    if(`whoami` != 'nt authority\system') {
        output("   Configuring WinSCP for current user: ");
        if(!(run_command(Win32::GetShortPathName($user_config_script)))) {
            output("FAILED to configure for user: ".$ENV{'USERNAME'}."\n");
        } else {
            output("OK\n");
        }
    }

    return $success;
}

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP1 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                     'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;post_install
);
IM_Exit(EXIT_SUCCESS);

########################################################################

# Begin-Doc
################################
# Name: create_configure_script
# Description: Create the logon script for default user-level
#   configuration settings.
# Returns: true/false on success/failure
# Requires:
#   File::Path::mkpath()
# LastUpdated: 06-09-2016
# LastUpdatedBy: Austin Wall
################################
# End-Doc
sub create_configure_script {
    my $filename = shift;
    my $dir = dirname($filename);
    if (! -d $dir) {
        if (!mkpath($dir)) {
            output("Error creating script directory '${dir}': $!\n",LOG_ONLY);
            return 0;
        }
    }

    if (open(my $SCRIPT,'&gt;',$user_config_script)) {
        print $SCRIPT q[
my $userid = $ENV{'USERNAME'};
my $file_path = 'C:\\Users\\'.$userid.'\\AppData\\Roaming\\WinSCP.ini';

my $ini_text = q{
[Configuration]
JumpList=
JumpListWorkspaces=

[Configuration\Interface]
RandomSeedFile=%25APPDATA%25%5Cwinscp.rnd
PuttyRegistryStorageKey=Software%5CSimonTatham%5CPuTTY
ConfirmOverwriting=1
ConfirmResume=1
AutoReadDirectoryAfterOp=1
SessionReopenAuto=5000
SessionReopenBackground=2000
SessionReopenTimeout=0
SessionReopenAutoStall=60000
TunnelLocalPortNumberLow=50000
TunnelLocalPortNumberHigh=50099
CacheDirectoryChangesMaxSize=100
ShowFtpWelcomeMessage=0
ExternalIpAddress=
TryFtpWhenSshFails=1
CollectUsage=0
ContinueOnError=0
ConfirmCommandSession=1
SynchronizeParams=66
SynchronizeOptions=5
SynchronizeModeAuto=-1
SynchronizeMode=0
MaxWatchDirectories=500
QueueTransfersLimit=2
QueueKeepDoneItems=1
QueueKeepDoneItemsFor=15
QueueAutoPopup=1
QueueRememberPassword=0
PuttySession=WinSCP%20temporary%20session
PuttyPath=%25PROGRAMFILES%25%5CPuTTY%5Cputty.exe
PuttyPassword=0
TelnetForFtpInPutty=1
IgnoreCancelBeforeFinish=DFBC9A785634023F
BeepOnFinish=0
BeepOnFinishAfter=176CC1166CC1363F
KeepUpToDateChangeDelay=500
ChecksumAlg=sha1
SessionReopenAutoIdle=9000
Interface=1
ConfirmExitOnCompletion=1
SessionColors=
CopyShortCutHintShown=0
CopyOnDoubleClick=2
CopyOnDoubleClickConfirmation=0
DDAllowMove=0
DDAllowMoveInit=0
DDTransferConfirmation2=2
DDTemporaryDirectory=
DDWarnLackOfTempSpace=1
DDWarnLackOfTempSpaceRatio=9A9999999999F13F
DeleteToRecycleBin=1
DimmHiddenFiles=1
RenameWholeName=0
SelectDirectories=0
SelectMask=%2A.%2A
ShowHiddenFiles=0
FormatSizeBytes=1
ShowInaccesibleDirectories=1
ConfirmTransferring=1
ConfirmDeleting=1
ConfirmRecycling=1
ConfirmClosingSession=1
AutoStartSession=
UseLocationProfiles=0
UseSharedBookmarks=0
LocaleSafe=1033
DDExtEnabled=1
DDExtTimeout=1000
DefaultDirIsHome=1
TemporaryDirectoryAppendSession=0
TemporaryDirectoryAppendPath=1
TemporaryDirectoryDeterministic=0
TemporaryDirectoryCleanup=1
ConfirmTemporaryDirectoryCleanup=1
PreservePanelState=1
Theme=Default
LastStoredSession=
AutoSaveWorkspace=0
AutoSaveWorkspacePasswords=0
AutoWorkspace=
PathInCaption=0
MinimizeToTray=0
BalloonNotifications=1
NotificationsTimeout=10
NotificationsStickTime=2
CopyParamAutoSelectNotice=1
LockToolbars=0
SelectiveToolbarText=1
AutoOpenInPutty=0
RefreshRemotePanel=0
RefreshRemotePanelInterval=176CC1166CC1463F
PanelFontName=
PanelFontSize=0
PanelFontStyle=0
PanelFontCharset=1
FullRowSelect=0
OfferedEditorAutoConfig=0
LastMonitor=-1
VersionHistory=507055665,stable
EnableQueueByDefault=1
OpenedStoredSessionFolders=
AutoImportedFromPuttyOrFilezilla=0
GenerateUrlComponents=-1
ExternalSessionInExistingInstance=1
LocalIconsByExt=0
HonorDrivePolicy=1

[Configuration\Logging]
Logging=0
LogFileName=%25TEMP%25%5C!S.log
LogFileAppend=1
LogSensitive=0
LogWindowLines=100
LogProtocol=0
LogActions=0
ActionsLogFileName=%25TEMP%25%5C!S.xml
LogView=0
LogWindowOnStartup=1
LogWindowParams=-1;-1;500;400;0;96

[Configuration\Interface\CopyParam]
AddXToDirectories=1
Masks=%2A.%2Ahtml;%20%2A.htm;%20%2A.txt;%20%2A.php;%20%2A.php3;%20%2A.cgi;%20%2A.c;%20%2A.cpp;%20%2A.h;%20%2A.pas;%20%2A.bas;%20%2A.tex;%20%2A.pl;%20%2A.js;%20.htaccess;%20%2A.xtml;%20%2A.css;%20%2A.cfg;%20%2A.ini;%20%2A.sh;%20%2A.xml
FileNameCase=0
PreserveReadOnly=0
PreserveTime=1
PreserveRights=0
IgnorePermErrors=0
Text=rw-r--r--
TransferMode=0
ResumeSupport=1
ResumeThreshold=102400
ReplaceInvalidChars=1
LocalInvalidChars=/%5C:%2A%3F"&lt;&gt;|
CalculateSize=1
IncludeFileMask=
ClearArchive=0
RemoveCtrlZ=0
RemoveBOM=0
CPSLimit=0
NewerOnly=0
Queue=0
QueueNoConfirmation=1
QueueIndividually=0
CopyParamList=-1

[Configuration\Interface\NewDirectory2]
Valid=00

[Configuration\Interface\SynchronizeChecklist]
WindowParams=0;-1;-1;600;450;0;96
ListParams=1;1|150,1;100,1;80,1;130,1;25,1;100,1;80,1;130,1;@96|0;1;2;3;4;5;6;7

[Configuration\Interface\FindFile]
WindowParams=646,481,96
ListParams=3;1|125,1;181,1;80,1;122,1;@96|0;1;2;3

[Configuration\Interface\ConsoleWin]
WindowSize=570,430,96

[Configuration\Interface\LoginDialog]
WindowSize=640,430,96

[Configuration\History\SpeedLimit]
0=Unlimited
1=8192
2=4096
3=2048
4=1024
5=512
6=256
7=128
8=64
9=32
10=16
11=8

[Configuration\History\PuttyPath]
0=%25PROGRAMFILES%25%5CPuTTY%5Cputty.exe
1=%25PROGRAMFILES%25%5CPuTTY%5Cputty.exe%20-t%20-m%20"%25TEMP%25%5Cputty.txt"%20!`cmd.exe%20/c%20echo%20cd%20'!/'%20;%20/bin/bash%20-login%20&gt;%20"%25TEMP%25%5Cputty.txt"`
2=kitty.exe
3=kitty.exe%20-cmd%20"cd%20'!/'"%20!U@!@

[Configuration\Interface\Editor]
FontName2=Lucida%20Console
FontSize=10
FontStyle=0
FontCharset=1
WordWrap=0
FindText=
ReplaceText=
FindMatchCase=0
FindWholeWord=0
FindDown=1
TabSize=8
MaxEditors=500
EarlyClose=2
SDIShellEditor=0
WindowParams=
Encoding=0
WarnOnEncodingFallback=1
WarnOrLargeFileSize=1

[Configuration\Interface\QueueView]
Height=140
HeightPixelsPerInch=96
Layout=70,250,250,80,80,80,100,;96
Show=1
LastHideShow=1
ToolBar=1
Label=1

[Configuration\Interface\Updates]
Period=0
LastCheck=0000000000000000
HaveResults=0
ShownResults=0
BetaVersions=2
ShowOnStartup=1
ConnectionType=1
ProxyHost=
ProxyPort=8080
ForVersion=0
Version=0
Message=
Critical=0
Release=
Disabled=0
Url=
UrlButton=
NewsUrl=
NewsWidth=0
NewsHeight=0
DotNetVersion=
ConsoleVersion=

[Configuration\Interface\Explorer]
ToolbarsLayout=Queue_Visible=1,Queue_LastDock=QueueDock,Queue_DockRow=0,Queue_DockPos=-1,Queue_FloatLeft=0,Queue_FloatTop=0,Queue_FloatRightX=0,Menu_Visible=1,Menu_DockedTo=TopDock,Menu_LastDock=TopDock,Menu_DockRow=0,Menu_DockPos=0,Menu_FloatLeft=0,Menu_FloatTop=0,Menu_FloatRightX=0,Buttons_Visible=1,Buttons_DockedTo=TopDock,Buttons_LastDock=TopDock,Buttons_DockRow=2,Buttons_DockPos=0,Buttons_FloatLeft=0,Buttons_FloatTop=0,Buttons_FloatRightX=0,Selection_Visible=0,Selection_DockedTo=TopDock,Selection_LastDock=TopDock,Selection_DockRow=3,Selection_DockPos=0,Selection_FloatLeft=227,Selection_FloatTop=445,Selection_FloatRightX=0,Session_Visible=0,Session_DockedTo=TopDock,Session_LastDock=TopDock,Session_DockRow=6,Session_DockPos=0,Session_FloatLeft=39,Session_FloatTop=160,Session_FloatRightX=0,Preferences_Visible=1,Preferences_DockedTo=TopDock,Preferences_LastDock=TopDock,Preferences_DockRow=4,Preferences_DockPos=0,Preferences_FloatLeft=0,Preferences_FloatTop=0,Preferences_FloatRightX=0,Sort_Visible=0,Sort_DockedTo=TopDock,Sort_LastDock=TopDock,Sort_DockRow=5,Sort_DockPos=0,Sort_FloatLeft=0,Sort_FloatTop=0,Sort_FloatRightX=0,Address_Visible=1,Address_DockedTo=TopDock,Address_LastDock=TopDock,Address_DockRow=1,Address_DockPos=0,Address_FloatLeft=0,Address_FloatTop=0,Address_FloatRightX=0,Updates_Visible=1,Updates_DockedTo=TopDock,Updates_LastDock=TopDock,Updates_DockRow=4,Updates_DockPos=416,Updates_FloatLeft=0,Updates_FloatTop=0,Updates_FloatRightX=0,Transfer_Visible=1,Transfer_DockedTo=TopDock,Transfer_LastDock=TopDock,Transfer_DockRow=4,Transfer_DockPos=194,Transfer_FloatLeft=0,Transfer_FloatTop=0,Transfer_FloatRightX=0,CustomCommands_Visible=0,CustomCommands_DockedTo=TopDock,CustomCommands_LastDock=TopDock,CustomCommands_DockRow=7,CustomCommands_DockPos=0,CustomCommands_FloatLeft=0,CustomCommands_FloatTop=0,CustomCommands_FloatRightX=0,PixelsPerInch=96
DirViewParams=0;1;0|150,1;70,1;150,1;79,1;62,1;55,0;20,0;150,0;125,0;@96|6;7;8;0;1;2;3;4;5
LastLocalTargetDirectory=C:%5CUsers%5C}.$userid.q{%5CDocuments
SessionsTabs=1
StatusBar=1
WindowParams=-1;-1;960;720;0;96
ViewStyle=0
ShowFullAddress=1
DriveView=1
DriveViewWidth=180
DriveViewWidthPixelsPerInch=96

[Configuration\Interface\Commander]
ToolbarsLayout=Queue_Visible=1,Queue_LastDock=QueueDock,Queue_DockRow=0,Queue_DockPos=-1,Queue_FloatLeft=0,Queue_FloatTop=0,Queue_FloatRightX=0,Menu_Visible=1,Menu_DockedTo=TopDock,Menu_LastDock=TopDock,Menu_DockRow=0,Menu_DockPos=0,Menu_FloatLeft=0,Menu_FloatTop=0,Menu_FloatRightX=0,Preferences_Visible=1,Preferences_DockedTo=TopDock,Preferences_LastDock=TopDock,Preferences_DockRow=1,Preferences_DockPos=228,Preferences_FloatLeft=0,Preferences_FloatTop=0,Preferences_FloatRightX=0,Session_Visible=0,Session_DockedTo=TopDock,Session_LastDock=TopDock,Session_DockRow=1,Session_DockPos=602,Session_FloatLeft=380,Session_FloatTop=197,Session_FloatRightX=0,Sort_Visible=0,Sort_DockedTo=TopDock,Sort_LastDock=TopDock,Sort_DockRow=2,Sort_DockPos=0,Sort_FloatLeft=0,Sort_FloatTop=0,Sort_FloatRightX=0,Commands_Visible=1,Commands_DockedTo=TopDock,Commands_LastDock=TopDock,Commands_DockRow=1,Commands_DockPos=0,Commands_FloatLeft=0,Commands_FloatTop=0,Commands_FloatRightX=0,Updates_Visible=1,Updates_DockedTo=TopDock,Updates_LastDock=TopDock,Updates_DockRow=1,Updates_DockPos=619,Updates_FloatLeft=0,Updates_FloatTop=0,Updates_FloatRightX=0,Transfer_Visible=1,Transfer_DockedTo=TopDock,Transfer_LastDock=TopDock,Transfer_DockRow=1,Transfer_DockPos=364,Transfer_FloatLeft=0,Transfer_FloatTop=0,Transfer_FloatRightX=0,CustomCommands_Visible=0,CustomCommands_DockedTo=TopDock,CustomCommands_LastDock=TopDock,CustomCommands_DockRow=3,CustomCommands_DockPos=0,CustomCommands_FloatLeft=0,CustomCommands_FloatTop=0,CustomCommands_FloatRightX=0,RemoteHistory_Visible=1,RemoteHistory_DockedTo=RemoteTopDock,RemoteHistory_LastDock=RemoteTopDock,RemoteHistory_DockRow=0,RemoteHistory_DockPos=172,RemoteHistory_FloatLeft=0,RemoteHistory_FloatTop=0,RemoteHistory_FloatRightX=0,RemoteNavigation_Visible=1,RemoteNavigation_DockedTo=RemoteTopDock,RemoteNavigation_LastDock=RemoteTopDock,RemoteNavigation_DockRow=0,RemoteNavigation_DockPos=252,RemoteNavigation_FloatLeft=0,RemoteNavigation_FloatTop=0,RemoteNavigation_FloatRightX=0,RemotePath_Visible=1,RemotePath_DockedTo=RemoteTopDock,RemotePath_LastDock=RemoteTopDock,RemotePath_DockRow=0,RemotePath_DockPos=0,RemotePath_FloatLeft=0,RemotePath_FloatTop=0,RemotePath_FloatRightX=0,RemoteFile_Visible=1,RemoteFile_DockedTo=RemoteTopDock,RemoteFile_LastDock=RemoteTopDock,RemoteFile_DockRow=1,RemoteFile_DockPos=0,RemoteFile_FloatLeft=0,RemoteFile_FloatTop=0,RemoteFile_FloatRightX=0,RemoteSelection_Visible=1,RemoteSelection_DockedTo=RemoteTopDock,RemoteSelection_LastDock=RemoteTopDock,RemoteSelection_DockRow=1,RemoteSelection_DockPos=345,RemoteSelection_FloatLeft=0,RemoteSelection_FloatTop=0,RemoteSelection_FloatRightX=0,LocalHistory_Visible=1,LocalHistory_DockedTo=LocalTopDock,LocalHistory_LastDock=LocalTopDock,LocalHistory_DockRow=0,LocalHistory_DockPos=207,LocalHistory_FloatLeft=0,LocalHistory_FloatTop=0,LocalHistory_FloatRightX=0,LocalNavigation_Visible=1,LocalNavigation_DockedTo=LocalTopDock,LocalNavigation_LastDock=LocalTopDock,LocalNavigation_DockRow=0,LocalNavigation_DockPos=287,LocalNavigation_FloatLeft=0,LocalNavigation_FloatTop=0,LocalNavigation_FloatRightX=0,LocalPath_Visible=1,LocalPath_DockedTo=LocalTopDock,LocalPath_LastDock=LocalTopDock,LocalPath_DockRow=0,LocalPath_DockPos=0,LocalPath_FloatLeft=0,LocalPath_FloatTop=0,LocalPath_FloatRightX=0,LocalFile_Visible=1,LocalFile_DockedTo=LocalTopDock,LocalFile_LastDock=LocalTopDock,LocalFile_DockRow=1,LocalFile_DockPos=0,LocalFile_FloatLeft=0,LocalFile_FloatTop=0,LocalFile_FloatRightX=0,LocalSelection_Visible=1,LocalSelection_DockedTo=LocalTopDock,LocalSelection_LastDock=LocalTopDock,LocalSelection_DockRow=1,LocalSelection_DockPos=329,LocalSelection_FloatLeft=0,LocalSelection_FloatTop=0,LocalSelection_FloatRightX=0,Toolbar2_Visible=0,Toolbar2_DockedTo=BottomDock,Toolbar2_LastDock=BottomDock,Toolbar2_DockRow=1,Toolbar2_DockPos=0,Toolbar2_FloatLeft=0,Toolbar2_FloatTop=0,Toolbar2_FloatRightX=1,CommandLine_Visible=0,CommandLine_DockedTo=BottomDock,CommandLine_LastDock=BottomDock,CommandLine_DockRow=0,CommandLine_DockPos=0,CommandLine_FloatLeft=0,CommandLine_FloatTop=0,CommandLine_FloatRightX=0,PixelsPerInch=96
CurrentPanel=0
LocalPanelWidth=000000000000E03F
SwappedPanels=0
SessionsTabs=1
StatusBar=1
WindowParams=-1;-1;1090;700;0;96
ExplorerStyleSelection=2
PreserveLocalDirectory=0
CompareByTime=1
CompareBySize=0
TreeOnLeft=0
ExplorerKeyboardShortcuts=0
SystemContextMenu=0

[Configuration\Interface\Commander\LocalPanel]
DirViewParams=0;1;0|150,1;70,1;120,1;150,1;55,0;55,0;@96|5;0;1;2;3;4
StatusBar=1
DriveView=0
DriveViewHeight=100
DriveViewHeightPixelsPerInch=96
DriveViewWidth=100
DriveViewWidthPixelsPerInch=96

[Configuration\Interface\Commander\RemotePanel]
DirViewParams=0;1;0|150,1;70,1;150,1;79,1;62,1;55,0;20,0;150,0;125,0;@96|6;7;8;0;1;2;3;4;5
StatusBar=1
DriveView=0
DriveViewHeight=100
DriveViewHeightPixelsPerInch=96
DriveViewWidth=100
DriveViewWidthPixelsPerInch=96

[Configuration\Security]
UseMasterPassword=0
MasterPasswordVerifier=

[Configuration\Interface\Editor\0]
FileMask=%2A.%2A
Editor=0
ExternalEditor=
ExternalEditorText=1
SDIExternalEditor=0
DetectMDIExternalEditor=0

[Configuration\Interface\Editor\1]
FileMask=%2A.%2A
Editor=1
ExternalEditor=notepad.exe
ExternalEditorText=1
SDIExternalEditor=0
DetectMDIExternalEditor=0


[Sessions\DFS]
HostName=minersftp.mst.edu
UserName=}.$userid.q{
Special=1

[Sessions\User%20Home%20Drive%20(S:)]
HostName=minersftp.mst.edu
UserName=}.$userid.q{
Special=1
RemoteDirectory=/dfs/users/}.$userid;

open(my $ini_file, "&gt;", $file_path)
    or die "Can't open &gt; $file_path: $!";

print $ini_file $ini_text;

close($ini_file)
    or warn "Close failed: $!";



];

        close($SCRIPT);
    } else {
        output("Error opening script file '${filename}' for writing: $!\n",
               LOG_ONLY);
        return 0;
    }

    return 1;
}
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\wireshark.2_4_2\prod\update.pl</FullName>
    <Length>2422</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-08T13:58:24.2133586-06:00</CreationTime>
    <CreationTimeUtc>2017-11-08T19:58:24.2133586Z</CreationTimeUtc>
    <LastWriteTime>2017-11-09T12:10:23.0575555-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-11-09T18:10:23.0575555Z</LastWriteTimeUtc>
    <LastAccessTime>2017-11-08T13:58:24.2133586-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-11-08T19:58:24.2133586Z</LastAccessTimeUtc>
    <Text># Wireshark 2.4.2 - A free and open source packet analyzer
# Package generated with GenGen on 2017-Nov-08 13:58
# Packaged by Grayson Gratop

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
  %INSTALLMONKEY_OPTIONS = (
    package_id =&gt; 'wireshark.2_4_2',
    package_revision =&gt; '20171108T1358',
  );
}

# Add InstallMonkey Library to the path
use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use Getopt::Long;
use InstallMonkey::Shared;

GetOptions(
  'uninstall' =&gt; sub { exit(!uninstall()); },
);

my $srcfilesdir = get_pkg_sourcefiles();
my $allUsersDesktop = get_allusers_desktop();
my $allUsersStartmenu = get_allusers_start_menu();
my $startmenudir = "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs";


sub install {
  #thanks, creator of python 2.7 package. second argument is whether or not it's okay if the command fails
  my @installCommands = (
    ["msiexec /qb /i $srcfilesdir\\Win10Pcap-v10.2-5002.msi", 0],
    ["$srcfilesdir\\Wireshark-win64-2.4.2.exe /S /quicklaunchicon=no /desktopicon=no", 0]
  );

  my $success = 0;
  my $allDone = 1;
  
  output("Installing Wireshark 2.4.2... \n");
  
  for (my $i = 0; $i &lt; scalar @installCommands; $i++) {
    output("\t" . $installCommands[$i][0] . ": ");
    $success = run_command($installCommands[$i][0]);
    output($success ? "Done!\n" : "FAILED: $!\n");
    $allDone &amp;&amp;= $installCommands[$i][1] || $success;
  }

  if ($allDone) {
    output("Looks like it was a success!\n");
  }
  else {
    output("Something went wrong!\n");
  }

  return $allDone;
}


sub postInstall {


  return 1;
}


do_install( 
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
  allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  install_sub =&gt; \&amp;install,
  postinstall_sub =&gt; \&amp;postInstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\wolframcdfplayer.11_3_0\prod\update.pl</FullName>
    <Length>1167</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-07-13T15:58:17.1180623-05:00</CreationTime>
    <CreationTimeUtc>2018-07-13T20:58:17.1180623Z</CreationTimeUtc>
    <LastWriteTime>2018-07-13T16:01:32.9794449-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-13T21:01:32.9794449Z</LastWriteTimeUtc>
    <LastAccessTime>2018-07-13T15:58:17.1180623-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-07-13T20:58:17.1180623Z</LastAccessTimeUtc>
    <Text># SketchUp Free
# Package Created July 13, 2018
# Packaged by Matthes, Alexander (S&amp;T-IT Employee)
# Last Updated --

BEGIN {
    %::INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'sketchupfree.online',
        package_revision =&gt; '20180713T1559',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles = get_pkg_sourcefiles();
my $log_dir = get_applogs_dir();

sub install {
	output("Silently running setup.exe");
	if(!run_command("$srcfiles\\setup.exe /verysilent"))
    {
        output("Installation failed!\n");
        return 0;
    }
    
    output("Installation successful!");
    return 1;
}

do_install( 
    exit_on_failure =&gt; 1,
    allowed_versions          =&gt; [ OSVER_WIN10_SP0 ],
    allowed_os_architectures  =&gt; [ OSARCH_x64 ],
    allowed_regs              =&gt; [ "clc", "desktop", "traveling", "virtual-desktop", "virtual-clc" ],
    install_sub               =&gt; \&amp;install,

    
);

IM_Exit(EXIT_SUCCESS);

########################################################################</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\xamarinstudio.6_3\prod\update.pl</FullName>
    <Length>6071</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-12-21T11:05:39.4390878-06:00</CreationTime>
    <CreationTimeUtc>2017-12-21T17:05:39.4390878Z</CreationTimeUtc>
    <LastWriteTime>2018-01-26T10:29:18.8037048-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-26T16:29:18.8037048Z</LastWriteTimeUtc>
    <LastAccessTime>2017-12-21T11:05:39.4390878-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-12-21T17:05:39.4390878Z</LastAccessTimeUtc>
    <Text># XamarinStudio 6.3
# Package Created Winter 2017
# Packaged by Alex Schrimpf
# Last Updated Winter 2017 by Alex Schrimpf


=pod

Begin-Doc
Modified: 
Name: 
Type:
Description: 
Language: Perl
LastUpdatedBy:
Version:
Doc-Package-Info
Doc-SVN-Repository:
RCSId:
End-Doc

=cut

use strict;
use warnings;

our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'xamarin.6_3',
        package_revision =&gt; '',
    );
}

use lib ( '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 'C:\temp' );

use InstallMonkey::Shared;

use IM_helper(
   \%INSTALLMONKEY_OPTIONS,
    v4.04,
    (
        "EXTRACTION" =&gt;
        [
            sub {
                IM_helper::extract_files(
                    from=&gt; [$IM_helper::source_files.'\\platform-tools_r26.0.0-rc1-windows.zip'],
                    to =&gt; "C:\\Program Files (x86)\\Android\\android-sdk",
                );
            },
            sub {
                IM_helper::extract_files(
                    from=&gt; [$IM_helper::source_files.'\\android-ndk-r14b-windows-x86_64.zip'],
                    to =&gt; "C:\\Program Files\\Android\\ndk",
                );
            }
        ],
        "PREREQS" =&gt;
        [
            sub {
                IM_helper::run_command(
                    description =&gt;'Installing JDK 8',
                    command =&gt;  $IM_helper::source_files.'\\jdk-8u101-windows-i586.exe /s',
                );
            },
            sub {
                IM_helper::run_command(
                    description =&gt;'Installing Android SDK',
                    command =&gt; $IM_helper::source_files.'\\installer_r24.4.1-windows.exe /S /ALLUSERS',
                );
            },
            sub {
                IM_helper::run_command(
                    description =&gt;'Visual Studio Build Tools',
                    command =&gt; $IM_helper::source_files.'\\BuildTools_Full.exe /S',
                );
            }
        ],
        "INSTALL" =&gt;
        [
            sub {
                IM_helper::run_command(
                    description =&gt;'Installing Xamarin Studio Simulator',
                    command =&gt;  $IM_helper::source_files.'\\Xamarin.Simulator.Installer.1.0.2.9.msi /qn /norestart',
                );
            },
            sub {
                IM_helper::run_command(
                    description =&gt;'Installing Xamarin Studio VisualStudio Plugin',
                    command =&gt;  $IM_helper::source_files.'\\Xamarin.VisualStudio_4.5.0.476.msi /qn /norestart',
                );
            },
            sub {
                IM_helper::run_command(
                    description =&gt;'Installing Xamarin Studio Interactive',
                    command =&gt;  $IM_helper::source_files.'\\XamarinInteractive-1.2.2.msi /qn /norestart',
                );
            },        
            sub {
                IM_helper::run_command(
                    description =&gt;'Installing Xamarin Studio',
                    command =&gt;  $IM_helper::source_files.'\\XamarinProfiler.Windows.Installer.1.5.4-19.msi /qn /norestart',
                );
            },
            sub {
                IM_helper::get_reg_value_data(
                    key=&gt;"HKEY_LOCAL_MACHINE/SOFTWARE/WOW6432Node/Microsoft/VisualStudio/SxS/VS7",
                    value=&gt;"15.0",
                    succ_cb=&gt; sub{
                        my $main_inst_loc = {@_}-&gt;{results};
                        # Installer doesn't like trailing backslash
                        if(substr($main_inst_loc, -1) eq "\\"){
                            chop $main_inst_loc;
                        }


                        return IM_helper::run_command(
                            description =&gt; "Visual Studio Installer",
                            command =&gt; "\"$IM_helper::source_files\\Installer\\vs_installershell.exe\" modify --installPath \"$main_inst_loc\" --add Microsoft.VisualStudio.Workload.NetCrossPlat --includeOptional --includeRecommended --q --norestart",
                            #66 means needs reboot, no idea why it returns 1 when it succeeds
                            ignore_codes =&gt; [66,1]
                        );
                    }
                );
            }
        ],
        "UNINSTALL" =&gt; 
        [
            sub {
                IM_helper::uninstall_using_programs_and_features(
                    display_name=&gt; "Xamarin Remoted iOS Simulator",
                );
            },
            sub {
                IM_helper::uninstall_using_programs_and_features(
                    display_name=&gt; "Xamarin Workbooks and Inspector",
                );             
            },
            sub {
                IM_helper::uninstall_using_programs_and_features(
                    display_name=&gt; "Xamarin Profiler"
                );
            },
            sub {
                IM_helper::uninstall_using_programs_and_features(
                    display_name=&gt; "Xamarin"
                );
            },
            # Won't extract without first removing this.
            sub {
                IM_helper::rm_dir(
                    dir=&gt; "C:\\Program Files\\Android\\ndk"
                );
            },
            sub {
                delete_product_registry_key(get_package_id());
            }
        ]
    )
);

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt;
      [ 'clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    no_install_check =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    no_product_key =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    install_sub =&gt; $IM_helper::exec_call_stack_override || sub{IM_helper::exec_call_stacks(ids=&gt;["EXTRACTION","PREREQS","INSTALL"])}
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\xamarinstudio.6_3\prod.old\update.pl</FullName>
    <Length>3200</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-12-15T16:59:46.6723802-06:00</CreationTime>
    <CreationTimeUtc>2017-12-15T22:59:46.6723802Z</CreationTimeUtc>
    <LastWriteTime>2017-12-21T11:07:56.0718627-06:00</LastWriteTime>
    <LastWriteTimeUtc>2017-12-21T17:07:56.0718627Z</LastWriteTimeUtc>
    <LastAccessTime>2017-12-15T16:59:46.6723802-06:00</LastAccessTime>
    <LastAccessTimeUtc>2017-12-15T22:59:46.6723802Z</LastAccessTimeUtc>
    <Text># Package created 12/13/2017
# Package created by Sergey Gruzdev
# Last Updated 12/13/2017 by Sergey Gruzdev

=pod

Begin-Doc
Modified: $Date$
Name: $Name$
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use warnings;
use strict;

our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id =&gt; 'xamarin.6_3',
        package_revision =&gt; '20171312T0954',
    );
}

use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $src = get_pkg_sourcefiles();
my $sdkDir = "C:\\Program Files (x86)\\Android\\android-sdk";
my $ndkDir = "C:\\Program Files\\Android\\ndk";
my $zip = "$src\\7-Zip\\7z.exe";

sub preinstall
{
  # Install jdk
  print "Installing prerequisites...\n";
  print "Installing JDK 8: ";
  if(!run_command("$src\\jdk-8u101-windows-i586.exe /s"))
  {
    print "FATAL ERROR failed to install JDK 8!\n";
	return 0;
  }
  print "Success\n";
  # Install android sdk
  print "Installing Android SDK: ";
  if(!run_command("$src\\installer_r24.4.1-windows.exe /S /ALLUSERS"))
  {
    print "FATAL ERROR failed to install Android SDK!\n";
	return 0;
  }
  print "Success\n";
  # Install platform tools for SDK
  if(!run_command("\"$zip\" x -o\"$sdkDir\tools\" -r -y $src\\platform-tools_r26.0.0-rc1-windows.zip"))
  {
    print "FATAL ERROR failed to install platform tools for Android SDK!\n";
	return 0;
  }
  # Install NDK
  run_command("mkdir $ndkDir");
  if(!run_command("\"$zip\" x -o\"$ndkDir\" -r -y $src\\android-ndk-r14b-windows-x86_64.zip"))
  {
    print "FATAL ERROR failed to install platform tools for Android SDK!\n";
	return 0;
  }
  # Install build tools
  print "Installing Build Tools: ";
  if(!run_command("$src\\BuildTools_Full.exe /S"))
  {
    print "FATAL ERROR failed to install Build Tools!\n";
  }
  print "Success\n";
  # 
  return 1;
}

sub install
{
  print "Installing Xamarin Studio...\n";
  if(!run_command("$src\\Xamarin.Simulator.Installer.1.0.2.9.msi /qn /norestart"))
  {
    print "FATAL ERROR failed to install Xamarin Simulator!\n";
	return 0;
  }
  if(!run_command("$src\\Xamarin.VisualStudio_4.5.0.476.msi /qn /norestart"))
  {
    print "FATAL ERROR failed to install Xamarin for Visual Studio!\n";
	return 0;
  }
  if(!run_command("$src\\XamarinInteractive-1.2.2.msi /qn /norestart"))
  {
    print "FATAL ERROR failed to install Xamarin Interactive!\n";
	return 0;
  }
  if(!run_command("$src\\XamarinProfiler.Windows.Installer.1.5.4-19.msi /qn /norestart"))
  {
    print "FATAL ERROR failed to install Xamarin Profiler!\n";
	return 0;
  }
  return 1;
}

do_install
(
  allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0],
  allowed_os_architectures =&gt; [OSARCH_x86, OSARCH_x64],
  allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
  exit_on_failure =&gt; 1,
  preinstall_sub =&gt;\&amp;preinstall,
  install_sub =&gt;\&amp;install,
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\xamarin_studio.6_0_2\prod\update.pl</FullName>
    <Length>2561</Length>
    <Extension>.pl</Extension>
    <CreationTime>2016-08-22T11:44:57.0404234-05:00</CreationTime>
    <CreationTimeUtc>2016-08-22T16:44:57.0404234Z</CreationTimeUtc>
    <LastWriteTime>2016-09-22T16:08:49.9968494-05:00</LastWriteTime>
    <LastWriteTimeUtc>2016-09-22T21:08:49.9968494Z</LastWriteTimeUtc>
    <LastAccessTime>2016-08-22T11:44:57.0716242-05:00</LastAccessTime>
    <LastAccessTimeUtc>2016-08-22T16:44:57.0716242Z</LastAccessTimeUtc>
    <Text># Xamarin_studio.5_9
# Package Created Aug 2016
# Packaged by Ronith
# Last Updated 2016-09-22 by Grayson Gratop

=pod

Begin-Doc
Modified: $Date$
Name:
Type: script
Description:
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info:
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'xamarin_studio.6_0_2',
        package_revision =&gt; '20160915T1150',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $sourcefilesdir = get_pkg_sourcefiles();
my $startmenu = get_allusers_start_menu();

sub preinstall {
	output("Installing prereqs\n");
 	run_command("start /wait \"\" \"$sourcefilesdir\\Prereq\\jdk-7u79-windows-i586.exe\" /quiet");
 	run_command("start /wait \"\" \"$sourcefilesdir\\Prereq\\installer_r24.4.1-windows.exe\" /S /ALLUSERS");
	run_command("start /wait \"\" \"$sourcefilesdir\\prereq\\BuildTools_2013.exe\" /S");
	run_command("start /wait \"\" \"$sourcefilesdir\\prereq\\BuildTools_2015.exe\" /S");
	run_command("start /wait \"\" \"$sourcefilesdir\\prereq\\gtk-sharp-2.12.38.msi\" /quiet /passive");
	run_command("start /wait \"\" \"$sourcefilesdir\\prereq\\mono-android-4.8.03015.msi\" /quiet /passive");
	run_command("start /wait \"\" \"$sourcefilesdir\\prereq\\Xamarin.iOS_Setup-1.4.2.0.msi\" /quiet /passive");
 	return 1;
}

 sub install {
	output("Installing Xamarin studio\n");
	if(!run_command("$sourcefilesdir\\XamarinStudio-6.0.2.73-0.msi /quiet /passive"))
	{
		output("FAILED!!\n");
		return 0;
	}
	output("Success");
	return 1;
 }

 sub postinstall{
	output("Creating start menu entry\n");
	if(!run_command("COPY \"$sourcefilesdir\\XamarinStudio.lnk\" \"$startmenu\"")) {
    output("Error creating shortcut\n");
  }
	return 1;
 }

do_install(
    allowed_versions =&gt; [ OSVER_WIN10_SP0,OSVER_WIN7_SP0,OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,OSARCH_x64],
    allowed_regs =&gt; ['clc','desktop','traveling','virtual-clc','virtual-desktop'],
    exit_on_failure =&gt; 1,
    preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
	postinstall_sub =&gt; \&amp;postinstall,
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\xampp.7_2_4_0\prod\update.pl</FullName>
    <Length>3539</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-05-08T11:59:15.2577064-05:00</CreationTime>
    <CreationTimeUtc>2018-05-08T16:59:15.2577064Z</CreationTimeUtc>
    <LastWriteTime>2018-05-31T09:24:52.9697432-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-31T14:24:52.9697432Z</LastWriteTimeUtc>
    <LastAccessTime>2018-05-08T11:59:15.2577064-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-05-08T16:59:15.2577064Z</LastAccessTimeUtc>
    <Text>#Xampp 7.2.4.0
# Package Created May 8th, 2018
# Packaged by Cameron Loren
# Last updated by Cameron Loren

use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'xampp.7_2_4_0',
        package_revision =&gt; '20180531T0855',
    );
}

# Add InstallMonkey Library to the path
use lib (
	'\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
	$ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
	'C:\temp',
);
use InstallMonkey::Shared;
use File::Basename;
use File::Path;
use File::Copy;

my $sourcefilesdir = get_pkg_sourcefiles();
my $applogs=get_applogs_dir();
my $programfiles = get_arch_programfiles(OSARCH_x64);

my $user_config_script = get_pkg_sourcefiles()."\\login.pl";

sub install
{

  # Create the login script.
  output("   Creating login script for xampp: ");
  if (!create_configure_script($user_config_script))
  {
    output("FAILED\n");
    return 0; # Don't bother trying anything else in this sub.
  }
  else
  {
    output("OK\n");
  }


  # Call the user config script at login to configure defaults.
  my $short_cfg_path = Win32::GetShortPathName($user_config_script);
  output("   Configuring xamp defaults for current user: ");
  output($short_cfg_path."\n");
  if (! create_activesetup_action(
            'ComponentID' =&gt; get_package_id(),
            'Identifier' =&gt; get_package_id(),
            'Version' =&gt; get_package_revision(),
            'StubPath' =&gt; 'C:\Perl64\bin\perl.exe ' . $short_cfg_path,
      ))
  {
    output("FAILED ACTIVESETUP ACTION\n");
    return 0;
  }
  else
  {
    output("ACTIVESETUP ACTION COMPLETE\n");
  }
  return 1;
}

sub create_configure_script
{

    my $filename = shift;
    my $dir = dirname($filename);
    if (! -d $dir) {
        if (!mkpath($dir))
        {
            output("Error creating script directory '${dir}': $!\n",LOG_ONLY);
            return 0;
        }
    }

    if (open(my $SCRIPT,'&gt;',$user_config_script))
    {
        print $SCRIPT q[
        use strict;
        use warnings;

        my $sourcefilesdir = "C:\\\\SourceFiles\\\\xampp.7_2_4_0";
        my $login = getlogin || getpwuid($&lt;);

        print("Installing Xampp 7.2.4.0\n");

        system("$sourcefilesdir\\\\xampp-win32-7.2.4-0-VC15-installer.exe --mode unattended") == 0
          or die "Xampp 7.2.4.0 installation did not complete!\n";

        system("move \"C:\\\\xampp\" \"C:\\\\Users\\\\$login\\\\Documents\\\\\\"") == 0
          or die "Failed moving Xampp.\n";

        system("C: &amp;&amp; cd C:\\\\Users\\\\$login\\\\Documents\\\\xampp\\ &amp;&amp; echo 1 | setup_xampp.bat") == 0
          or die "Failed at setting up new Xampp directory.\n";

        print("Xampp 7.2.4.0 installation completed!\n");

        ];
        close($SCRIPT);
    }
    else
    {
        output("Error opening script file '${filename}' for writing: $!\n", LOG_ONLY);
        return 0;
    }
}

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling',
                     'virtual-clc', 'virtual-desktop' ],
    exit_on_failure =&gt; 1,
	  need_reboot =&gt; 0,
    install_sub =&gt; \&amp;install
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\xming.7_7_0_19\prod\update.pl</FullName>
    <Length>2597</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-29T09:22:48.9861525-05:00</CreationTime>
    <CreationTimeUtc>2017-06-29T14:22:48.9861525Z</CreationTimeUtc>
    <LastWriteTime>2017-06-29T10:23:13.7664262-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-29T15:23:13.7664262Z</LastWriteTimeUtc>
    <LastAccessTime>2011-08-02T14:15:54-05:00</LastAccessTime>
    <LastAccessTimeUtc>2011-08-02T19:15:54Z</LastAccessTimeUtc>
    <Text># Xming 7.7.0.19
# Package Created June 2017
# Packaged by Benjamin Krueger
# Last Updated ...

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'xming.7_7_0_19',

        # some unique id that's updated any time the package undergoes
        #  any sort of minor revision
        package_revision =&gt; '20170629T0925',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles= get_pkg_sourcefiles();

sub preinstall
{
  #probably dont need a preinstall
  return 1;
}

sub install
{
  output "\nInstalling Xming 7.7.0.19: ";
  push_dir($srcfiles);
  if(!run_command("\"$srcfiles\\rel_x64_Xming-7-7-0-19-setup.exe\" /VerySilent"))
  {
    output "FAILED!!\n";
    return 0;
  }
  else
  {
    output "Success\n";
  }
  pop_dir();
  return 1;
}

sub postinstall 
{
  output "\nInstalling fonts...\n";
  run_command("\"$srcfiles\\Xming-fonts-7-7-0-10-setup.exe\" /verysilent");
  
  # install firewall exception
  output "\nAdding Firewall Exception...\n";
  my $xming = get_arch_programfiles(OSARCH_x86)."\\xming\\xming.exe";
  run_command("netsh advfirewall firewall add rule name=\"Xming\" dir=in action=allow program=\"$xming\"");
  
  output "\nDeleting an erroneous shortcut...\n";  # I don't think I used erroneous correctly. But do I care? No, no I don't.
  my $uninstall = get_allusers_start_menu().'\\Programs\\Xming';
  run_command("DEL /q \"$uninstall\\Uninstall*.lnk\"");
  # run_command("DEL /q \"$uninstall\"");
  return 1;
}

do_install( 
    allowed_versions =&gt; [OSVER_VISTA_SP0,  OSVER_VISTA_SP1,  OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    # preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\xming.7_7_0_33\prod\update.pl</FullName>
    <Length>2588</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-07-24T13:36:41.5436468-05:00</CreationTime>
    <CreationTimeUtc>2018-07-24T18:36:41.5436468Z</CreationTimeUtc>
    <LastWriteTime>2018-07-25T09:10:17.6680618-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-25T14:10:17.6680618Z</LastWriteTimeUtc>
    <LastAccessTime>2011-08-02T14:15:54-05:00</LastAccessTime>
    <LastAccessTimeUtc>2011-08-02T19:15:54Z</LastAccessTimeUtc>
    <Text># Xming 7.7.0.33
# Package Created 2018-07-25
# Packaged by Alexander Matthes
# Last Updated ...

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'xming.7_7_0_33',

        # some unique id that's updated any time the package undergoes
        #  any sort of minor revision
        package_revision =&gt; '20180725T0849',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

my $srcfiles= get_pkg_sourcefiles();

sub preinstall
{
  #probably dont need a preinstall
  return 1;
}

sub install
{
  output "\nInstalling Xming 7.7.0.33: ";
  push_dir($srcfiles);
  if(!run_command("$srcfiles\\rel_Xming-7-7-0-33-setup.exe\ /VerySilent"))
  {
    output "FAILED!!\n";
    return 0;
  }
  else
  {
    output "Success\n";
  }
  pop_dir();
  return 1;
}

sub postinstall 
{
  output "\nInstalling fonts...\n";
  run_command("$srcfiles\\Xming-fonts-7-7-0-10-setup.exe /verysilent");
  
  # install firewall exception
  output "\nAdding Firewall Exception...\n";
  my $xming = get_arch_programfiles(OSARCH_x86)."\\xming\\xming.exe";
  run_command("netsh advfirewall firewall add rule name=\"Xming\" dir=in action=allow program=\"$xming\"");
  
  output "\nDeleting an erroneous shortcut...\n";  # I don't think I used erroneous correctly. But do I care? No, no I don't.
  my $uninstall = get_allusers_start_menu().'\\Programs\\Xming';
  run_command("DEL /q \"$uninstall\\Uninstall*.lnk\"");
  # run_command("DEL /q \"$uninstall\"");
  return 1;
}

do_install( 
    allowed_versions =&gt; [OSVER_VISTA_SP0,  OSVER_VISTA_SP1,  OSVER_VISTA_SP2, OSVER_WIN7_SP0, OSVER_WIN7_SP1,OSVER_WIN10_SP0],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    # preinstall_sub =&gt; \&amp;preinstall,
    install_sub =&gt; \&amp;install,
    postinstall_sub =&gt; \&amp;postinstall,
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\zoom 4_1_27702_0702\prod\update.pl</FullName>
    <Length>1925</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-07-12T14:03:21.8404722-05:00</CreationTime>
    <CreationTimeUtc>2018-07-12T19:03:21.8404722Z</CreationTimeUtc>
    <LastWriteTime>2018-07-12T15:17:45.490996-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-07-12T20:17:45.490996Z</LastWriteTimeUtc>
    <LastAccessTime>2018-07-12T14:03:21.8404722-05:00</LastAccessTime>
    <LastAccessTimeUtc>2018-07-12T19:03:21.8404722Z</LastAccessTimeUtc>
    <Text># Zoom 4.1
# Package Created Fall 2017
# Packaged by Alex Schrimpf
# Updated Fall 2017 by Alex Schrimpf
#Last Updated 7/12/2018 by Gavin Altermatt

=pod

Begin-Doc
Modified:
Name:
Type:
Description:
Language: Perl
LastUpdatedBy:
Version:
Doc-Package-Info
Doc-SVN-Repository:
RCSId:
End-Doc

=cut

use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'zoom.4_1_27702_0702',
        package_revision =&gt; '',
    );
}

use lib ( '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 'C:\temp' );

use InstallMonkey::Shared;

use IM_helper(
    \%INSTALLMONKEY_OPTIONS,
    v4.04,
    (
        "INSTALL" =&gt; [
            sub {
                IM_helper::run_command(
                    description =&gt; 'Main Installer',
                    command =&gt; "msiexec /package \"$IM_helper::source_files\\ZoomInstallerFull.msi\" /quiet /qn /norestart ZNoDesktopShortCut=\"true\""
                );
            },
        ],
        "UNINSTALL" =&gt; [
            sub{
               IM_helper::uninstall_using_programs_and_features(
                    display_name=&gt; "Zoom",
                );
            },
            sub {
                delete_product_registry_key(get_package_id());
            },
        ]
    )
);

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt;
      [ 'clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    no_install_check =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    no_product_key =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    install_sub =&gt; $IM_helper::exec_call_stack_override || sub{IM_helper::exec_call_stacks(ids=&gt;["INSTALL"])}
);

IM_Exit(EXIT_SUCCESS);
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\Zoom.4_1\prod\update.pl</FullName>
    <Length>1887</Length>
    <Extension>.pl</Extension>
    <CreationTime>2018-01-14T14:26:31.1333277-06:00</CreationTime>
    <CreationTimeUtc>2018-01-14T20:26:31.1333277Z</CreationTimeUtc>
    <LastWriteTime>2018-05-07T17:09:38.2777799-05:00</LastWriteTime>
    <LastWriteTimeUtc>2018-05-07T22:09:38.2777799Z</LastWriteTimeUtc>
    <LastAccessTime>2018-01-14T14:26:31.1333277-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-01-14T20:26:31.1333277Z</LastAccessTimeUtc>
    <Text># Zoom 4.1
# Package Created Fall 2017
# Packaged by Alex Schrimpf
# Last Updated Fall 2017 by Alex Schrimpf

=pod

Begin-Doc
Modified: 
Name: 
Type:
Description: 
Language: Perl
LastUpdatedBy:
Version:
Doc-Package-Info
Doc-SVN-Repository:
RCSId:
End-Doc

=cut

use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'Zoom.4_1',
        package_revision =&gt; '',
    );
}

use lib ( '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 'C:\temp' );

use InstallMonkey::Shared;

use IM_helper(
    \%INSTALLMONKEY_OPTIONS,
    v4.04,
    (
        "INSTALL" =&gt; [
            sub {
                IM_helper::run_command(
                    description =&gt; 'Main Installer',
                    command =&gt; "msiexec /package \"$IM_helper::source_files\\ZoomInstallerFull.msi\" /quiet /qn /norestart ZNoDesktopShortCut=\"true\""
                );           
            },
        ],
        "UNINSTALL" =&gt; [
            sub{
               IM_helper::uninstall_using_programs_and_features(
                    display_name=&gt; "Zoom",
                );
            },
            sub {
                delete_product_registry_key(get_package_id());
            },
        ]
    )
);

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt;
      [ 'clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    no_install_check =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    no_product_key =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    install_sub =&gt; $IM_helper::exec_call_stack_override || sub{IM_helper::exec_call_stacks(ids=&gt;["INSTALL"])}
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\Zoom_Cap_Card_Driver\prod\update.pl</FullName>
    <Length>1585</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-11-17T19:02:19.1576831-06:00</CreationTime>
    <CreationTimeUtc>2017-11-18T01:02:19.1576831Z</CreationTimeUtc>
    <LastWriteTime>2018-01-24T10:37:29.5836909-06:00</LastWriteTime>
    <LastWriteTimeUtc>2018-01-24T16:37:29.5836909Z</LastWriteTimeUtc>
    <LastAccessTime>2018-01-14T14:19:34.4964184-06:00</LastAccessTime>
    <LastAccessTimeUtc>2018-01-14T20:19:34.4964184Z</LastAccessTimeUtc>
    <Text># Zoom Capture Card Driver
# Package Created Fall 2017
# Packaged by Alex Schrimpf
# Last Updated Fall 2017 by Alex Schrimpf

=pod

Begin-Doc
Modified: 
Name: 
Type:
Description: 
Language: Perl
LastUpdatedBy:
Version:
Doc-Package-Info
Doc-SVN-Repository:
RCSId:
End-Doc

=cut

use strict;
use warnings;


our %INSTALLMONKEY_OPTIONS;

BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        package_id       =&gt; 'ZoomCapCardDriver',
        package_revision =&gt; '',
    );
}

use lib ( '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'} . '\SYSTEM32\UMRINST', 'C:\temp' );

use InstallMonkey::Shared;

use IM_helper(
    \%INSTALLMONKEY_OPTIONS,
    v4.04,
    (
        "INSTALL" =&gt; [
            sub {
                IM_helper::run_command(
                    description =&gt; 'Main Installer',
                    command =&gt; "\"$IM_helper::source_files\\C985_RECentral_1.3.0.116.2017061201_Drv_3.3.x.52.exe\" /S /v/qn"
                );           
            },
        ],
    )
);

do_install(
    allowed_versions =&gt; [ OSVER_WIN7_SP0, OSVER_WIN7_SP1, OSVER_WIN10_SP0 ],
    allowed_os_architectures =&gt; [OSARCH_x64],
    allowed_regs =&gt;
      [ 'clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop' ],
    no_install_check =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    no_product_key =&gt; IM_helper::override_exists(id=&gt;'UNINSTALL',quiet=&gt;1),
    install_sub =&gt; $IM_helper::exec_call_stack_override || sub{IM_helper::exec_call_stacks(ids=&gt;["INSTALL"])}
);

IM_Exit(EXIT_SUCCESS);</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\zoom_plugin.4_0_33354\dev\update.pl</FullName>
    <Length>1964</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-07T13:50:04.3751389-05:00</CreationTime>
    <CreationTimeUtc>2017-06-07T18:50:04.3751389Z</CreationTimeUtc>
    <LastWriteTime>2017-06-07T15:23:39.8903275-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-07T20:23:39.8903275Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-07T13:50:04.4063395-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-07T18:50:04.4063395Z</LastAccessTimeUtc>
    <Text># Package Name: Zoom Plugin Install
# Package Created: June 7th, 2017
# Packaged By: Jason S. Holm
# Last Update: Not Yet Updated

# WIP!!

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'zoom_plugin.4_0_33354',

        # some unique id that's updated any time the package undergoes
        #  any sort of minor revision
        package_revision =&gt; '20170607T1356',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

use Getopt::Long;
GetOptions
(
	'uninstall' =&gt; sub { exit (!uninstall());},
);

sub postinstall 
{
  # print "\nRemoving Desktop Icon...";
  # my $desk = get_allusers_desktop().'\\Zoom.lnk';
  #
  # if(!run_command("DEL /Q \"$desk\""))
  # {
  # print "FAILED!!\n"; 
  # }
  # else
  # {
  # print "Success!\n";
  # }
  # print "\nMoving to next step...";
  return 1;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    postinstall_sub =&gt; \&amp;postinstall,
    msi_name_x64 =&gt; 'ZoomInstallerFull.msi',
    msi_name_x86 =&gt; 'ZoomInstallerFull.msi',
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

sub uninstall {
    print "\nNothing to do here...moving to next step.";
    
}
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\zoom_plugin.4_0_33354\prod\update.pl</FullName>
    <Length>2048</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-06-07T14:22:39.2799325-05:00</CreationTime>
    <CreationTimeUtc>2017-06-07T19:22:39.2799325Z</CreationTimeUtc>
    <LastWriteTime>2017-06-08T15:13:09.7047708-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-06-08T20:13:09.7047708Z</LastWriteTimeUtc>
    <LastAccessTime>2017-06-07T14:22:39.2799325-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-06-07T19:22:39.2799325Z</LastAccessTimeUtc>
    <Text># Package Name: Zoom Plugin Install
# Package Created: June 7th, 2017
# Packaged By: Jason S. Holm
# Last Update: Not Yet Updated

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # same name as the appdist directory
        package_id =&gt; 'zoom_plugin.4_0_33354',

        # some unique id that's updated any time the package undergoes
        #  any sort of minor revision
        package_revision =&gt; '20170607T1356',
    );
}

# Add InstallMonkey Library to the path
use lib (
    '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
    $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
    'C:\temp',
);
use InstallMonkey::Shared;

use Getopt::Long;
GetOptions
(
	'uninstall' =&gt; sub { exit (!uninstall());},
);

sub postinstall 
{
  print "\nNothing to do here...moving to next step.";

  return 1;
}

do_install( 
    allowed_versions =&gt; [OSVER_WIN7_SP0, OSVER_WIN7_SP1],
    allowed_os_architectures =&gt; [OSARCH_x86,  OSARCH_x64],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    postinstall_sub =&gt; \&amp;postinstall,
    msi_name_x64 =&gt; 'ZoomInstallerFull.msi',
    msi_name_x86 =&gt; 'ZoomInstallerFull.msi',
);

# ALL installers need to have an explicit exit code.
IM_Exit(EXIT_SUCCESS);

sub uninstall {
    print "\nNothing to do here...moving to next step.";
    # output("Uninstalling Skype 7.26");
    # my $outcome = install_msi(app_id =&gt; '{1845470B-EB14-4ABC-835B-E36C693DC07D}',msi_action_flag =&gt; 'x');
    # output(($outcome?'OK':'Failed')."\n");
    # if($outcome)
    # {
    #    delete_product_registry_key(get_package_name().".".get_version());
    # }
}
</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\zoom_plugin.4_0_38982\dev\update.pl</FullName>
    <Length>1977</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-08-01T14:11:40.26848-05:00</CreationTime>
    <CreationTimeUtc>2017-08-01T19:11:40.26848Z</CreationTimeUtc>
    <LastWriteTime>2017-08-01T15:56:01.6637327-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-08-01T20:56:01.6637327Z</LastWriteTimeUtc>
    <LastAccessTime>2017-08-01T14:11:40.2997218-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-08-01T19:11:40.2997218Z</LastAccessTimeUtc>
    <Text># Package Name: Zoom Plugin Install
# Package Created: June 7th, 2017
# Packaged By: Jason S. Holm
# Last Update: August 1st, 2017

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # Package ID (should be the same name as the appdist directory)
		# Note for Zoom Version: The most recent version will be in a static location
		# from the vendor (Windows Outlook plugin):
		# https://www.zoom.us/client/latest/ZoomInstallerFull.msi
		# 
		# package_id =&gt; 'zoom_plugin.4_0_33354', # Newer Version Exists: 4.0.37702.0703
		# package_id =&gt; 'zoom_plugin.4_0_37702', # Downloaded on 201707311132
		package_id =&gt; 'zoom_plugin.4_0_38982', # Downloaded on 201708011534

        # some unique id that's updated any time the package undergoes
        # any sort of minor revision
        package_revision =&gt; '20170801T1411',
    );
}

# Add InstallMonkey Library to the path
my $umrinst = $ENV{'WINDIR'}.'\\SYSTEM32\\UMRINST';
use lib (
    '\\\\minerfiles.mst.edu\\dfs\\software\\loginscripts\\im',
    '$umrinst',
    'C:\\temp',
);
use InstallMonkey::Shared;

use Getopt::Long;
 GetOptions
 (
 	'uninstall' =&gt; sub { exit (!uninstall());},
 );

do_install( 
    allowed_versions =&gt; ['OSVER_WIN7_SP0', 'OSVER_WIN7_SP1'],
    allowed_os_architectures =&gt; ['OSARCH_x86', 'OSARCH_x64', 'x64'],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    msi_name_x64 =&gt; 'ZoomInstallerFull.msi',
    msi_name_x86 =&gt; 'ZoomInstallerFull.msi',
);

# ALL installers need to have an explicit exit code.
IM_Exit('EXIT_SUCCESS');

</Text>
  </Script>
  <Script>
    <Name>update.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\appdist\zoom_plugin.4_0_38982\prod\update.pl</FullName>
    <Length>1999</Length>
    <Extension>.pl</Extension>
    <CreationTime>2017-08-01T16:10:54.0422842-05:00</CreationTime>
    <CreationTimeUtc>2017-08-01T21:10:54.0422842Z</CreationTimeUtc>
    <LastWriteTime>2017-08-02T10:49:29.6033951-05:00</LastWriteTime>
    <LastWriteTimeUtc>2017-08-02T15:49:29.6033951Z</LastWriteTimeUtc>
    <LastAccessTime>2017-08-01T16:10:54.0422842-05:00</LastAccessTime>
    <LastAccessTimeUtc>2017-08-01T21:10:54.0422842Z</LastAccessTimeUtc>
    <Text># Package Name: Zoom Plugin Install
# Package Created: June 7th, 2017
# Packaged By: Jason S. Holm
# Last Update: August 1st, 2017

=pod

Begin-Doc
Modified: $Date$
Name: 
Type: script
Description: 
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut


use strict;
use warnings;

# Global InstallMonkey options that must be specified before you load the
#   module.
our %INSTALLMONKEY_OPTIONS;
BEGIN {
    %INSTALLMONKEY_OPTIONS = (
        # Package ID (should be the same name as the appdist directory)
		# Note for Zoom Version: The most recent version will be in a static location
		# from the vendor (Windows Outlook plugin):
		# https://www.zoom.us/client/latest/ZoomInstallerFull.msi
		# 
		# package_id =&gt; 'zoom_plugin.4_0_33354', # Newer Version Exists: 4.0.37702.0703
		# package_id =&gt; 'zoom_plugin.4_0_37702', # Downloaded on 201707311132
		package_id =&gt; 'zoom_plugin.4_0_38982',   # Downloaded on 201708011534

        # some unique id that's updated any time the package undergoes
        # any sort of minor revision.
        package_revision =&gt; '20170802T1049',
    );
}

# Add InstallMonkey Library to the path
my $umrinst = $ENV{'WINDIR'}.'\\SYSTEM32\\UMRINST';
use lib (
    '\\\\minerfiles.mst.edu\\dfs\\software\\loginscripts\\im',
    '$umrinst',
    'C:\\temp',
);
use InstallMonkey::Shared;

use Getopt::Long;
 GetOptions
 (
 	'uninstall' =&gt; sub { exit (!uninstall());},
 );

do_install( 
    allowed_versions =&gt; ['OSVER_WIN7_SP0', 'OSVER_WIN7_SP1', 'OSVER_WIN10_SP0'],
    allowed_os_architectures =&gt; ['OSARCH_x86', 'OSARCH_x64', 'x64'],
    allowed_regs =&gt; ['clc', 'desktop', 'traveling', 'virtual-clc', 'virtual-desktop'],
    exit_on_failure =&gt; 1,
    msi_name_x64 =&gt; 'ZoomInstallerFull.msi',
    msi_name_x86 =&gt; 'ZoomInstallerFull.msi',
);

# ALL installers need to have an explicit exit code.
IM_Exit('EXIT_SUCCESS');

</Text>
  </Script>
  <Script>
    <Name>drive_mappings_and_path.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\loginscripts\pe_production\drive_mappings_and_path.pl</FullName>
    <Length>2759</Length>
    <Extension>.pl</Extension>
    <CreationTime>2015-09-25T09:38:48.8559289-05:00</CreationTime>
    <CreationTimeUtc>2015-09-25T14:38:48.8559289Z</CreationTimeUtc>
    <LastWriteTime>2010-04-08T10:31:40.9648227-05:00</LastWriteTime>
    <LastWriteTimeUtc>2010-04-08T15:31:40.9648227Z</LastWriteTimeUtc>
    <LastAccessTime>2015-09-25T09:38:48.8559289-05:00</LastAccessTime>
    <LastAccessTimeUtc>2015-09-25T14:38:48.8559289Z</LastAccessTimeUtc>
    <Text># Maps network drives that can be mapped using passed login credentials
# Last Updated 03/29/2007


# Determine location of this script
$cwd=Win32::GetFullPathName($0);
$cwd=~s/^(.*)\\.*$/\1/;


# Capture Commandline info
$userid=$ARGV[0];
$password=$ARGV[1];


# Install ImageX driver so images can be mounted from WinPE
system("$cwd\\imagex\\install.cmd");


# Connect to \\minerfiles.umr.edu\dfs first, then map drives to DFS without specifying a userid or password
# Trying to log into multiple DFS paths causes it to complain about trying to log into one server with
# more than one userid/password

print "Mapping Drive L:...\n";
#system("net use l: \\\\minerfiles.umr.edu\\dfs\\software\\clcimages /user:umr-users\\$userid $password &gt; NUL &lt; NUL");
$drive="L\:";
$share="\\\\minerfiles.mst.edu\\dfs\\software\\images";
system("net","use",$drive,$share);

print "Mapping Drive M:...\n";
#system("net use m: \\\\minerfiles.umr.edu\\dfs\\software\\desktopimages /user:umr-users\\$userid $password &gt; NUL &lt; NUL");
$drive="M\:";
$share="\\\\minerfiles.mst.edu\\dfs\\software\\desktopimages";
system("net","use",$drive,$share);

print "Mapping Drive S:...\n";
#system("net use s: \\\\minerfiles.umr.edu\\dfs\\users\\$userid /user:umr-users\\$userid $password &gt; NUL &lt; NUL");
$drive="S\:";
$share="\\\\minerfiles.mst.edu\\dfs\\users\\$userid";
system("net","use",$drive,$share);

print "Mapping InstallMonkey Path...\n";
#system("net use s: \\\\minerfiles.umr.edu\\dfs\\users\\$userid /user:umr-users\\$userid $password &gt; NUL &lt; NUL");
$share="\\\\minerfiles.mst.edu\\dfs\\software\\loginscripts";
system("net","use",$share);

#End of standard drive mappings

#
# Custom Drive Mappings
#
my $custom_mappings = "\\\\minerfiles.mst.edu\\dfs\\users\\${userid}\\WinPE\\userdrives.txt";
if (-f $custom_mappings) {
    print("Processing custom drive mappings...\n");
    if (open(my $MAPPINGS,'&lt;',$custom_mappings)) {
        while (defined(my $line = &lt;$MAPPINGS&gt;)) {
            chomp($line); $line =~ s/\s*#.*$//;
            next if ($line =~ /^\s*$/);
            my @map = split(/\s+/,$line,2);
            print("Mapping ($map[0]) to '$map[1]': ");
            my $cmd = "net use $map[0] $map[1] /user:MST-USERS\\${userid} \"${password}\" 2&gt;\&amp;1";
            my $output = '';
            if (open(my $OUTPUT,'-|',$cmd)) {
                $output = join('',&lt;$OUTPUT&gt;);
                close($OUTPUT);
            }
            if (!$?) {
                print("OK\n");
            } else {
                print("FAILED\n${output}\n");
            }
        }
        close($MAPPINGS);
    } else {
        print("  Error opening custom mapping file '${custom_mappings}': $!\n");
    }
}
</Text>
  </Script>
  <Script>
    <Name>shell.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\loginscripts\pe_production\shell.pl</FullName>
    <Length>1544</Length>
    <Extension>.pl</Extension>
    <CreationTime>2015-09-25T09:38:48.8715293-05:00</CreationTime>
    <CreationTimeUtc>2015-09-25T14:38:48.8715293Z</CreationTimeUtc>
    <LastWriteTime>2010-05-24T11:28:28.8499657-05:00</LastWriteTime>
    <LastWriteTimeUtc>2010-05-24T16:28:28.8499657Z</LastWriteTimeUtc>
    <LastAccessTime>2015-09-25T09:38:48.8715293-05:00</LastAccessTime>
    <LastAccessTimeUtc>2015-09-25T14:38:48.8715293Z</LastAccessTimeUtc>
    <Text>#Start of shell.pl

system ("cls");

#
# Change the path
$oldpath=$ENV{"PATH"};
$network_path="K:\\win7\\install_scripts\\bin";
$ENV{"PATH"}="$network_path;$oldpath";
$autorun="S:\\WinPE\\login.cmd";



#Launch CMD
#print "Launching cmd.\n";
#system('cmd');


#Display all ethernet addresses
$ether="";
# Get Ethernet Address
open(IPCONFIG,"ipconfig /all |");
while ($line=&lt;IPCONFIG&gt;)
{
 if ($line =~ /Physical Address/)
 {
  $val=$line;
  # Remove newline
  chomp($val);
  # Remove extra CR
  $val=~ s/\r//;
  # Remove extra text on line
  $val =~ s/^.*: *//;
  # Convert - to :
  @val=split(/-/,$val);
  $val=join(':',@val);
  # Switch to uppercase
  $val=uc $val;
  # Exclude VMWare and Vista TUnneling Adapter Hardware Addresses
  if (($val ne '02:00:4C:4F:4F:50')&amp;&amp;($val ne '00:00:00:00:00:00:00:E0')&amp;&amp;($val ne '00:20:54:55:4E:01'))
  {
   # Use first ethernet address that isn't a loopback adapter
   if ($ether eq "")
   {
    $ether=$val;
   }
   @ethers=(@ethers,$val);
  }
 }
}
close(IPCONFIG);

$ether=join('',split(/:/,$ether));
$ENV{"ETHER"}=$ether;
print "Found the following ethernet address(es):\n";
for ($i=0;$i&lt;@ethers;$i++)
{
    $ethers[$i] = join('',split(/:/,$ethers[$i]));
    print $ethers[$i]."\n";
}
print "\n";


# Launch CMD
# Pass the MAC addresses to the login script.
print "Launching cmd.\n";
if (-f $autorun) {
    print "Running user login script.\n";
    system("cmd /k \"${autorun}\" ".join(' ',@ethers));
} else {
    system('cmd');
}
</Text>
  </Script>
  <Script>
    <Name>Win7_create_pe5_boot_disk.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\pe\PE5_Boot_CD_Creator\Win7_create_pe5_boot_disk.pl</FullName>
    <Length>9973</Length>
    <Extension>.pl</Extension>
    <CreationTime>2015-09-25T09:38:06.3136381-05:00</CreationTime>
    <CreationTimeUtc>2015-09-25T14:38:06.3136381Z</CreationTimeUtc>
    <LastWriteTime>2015-06-08T13:35:08.8626327-05:00</LastWriteTime>
    <LastWriteTimeUtc>2015-06-08T18:35:08.8626327Z</LastWriteTimeUtc>
    <LastAccessTime>2015-09-25T09:38:06.3136381-05:00</LastAccessTime>
    <LastAccessTimeUtc>2015-09-25T14:38:06.3136381Z</LastAccessTimeUtc>
    <Text>###############################################
#                                             #
#  Win 7 PE 5.0 Boot CD Creator v1.1          #
#   By Bryan A. Thompson, et al.              #
#                                             #
###############################################

# v1.2 - 2014-03-19 bjrq48 (Billy)
#   - Updating script for Windows 8.1 compatibility / WinPE 5
#   - Microsoft put all the folders in a hat and shuffled them, renamed to Windows Deployment Kit
#   - NOTE: The copype.cmd script that comes from M$ is broken. You have to swap out
#     a few folder names with 8.0 to 8.1.
# 2010-12-08 thartman
#   - added dism.log and pe_version.txt to ISO 9660 filesystem
#     * Previously these were only in boot.wim, relatively
#       inaccessible unless PE was booted
#     * dism.log contains (among other things) the drivers that were
#       installed in the offline image.
# v1.1 - 2010-05-20 batee
# Updated script to run on a Win7 x64 host.
# Eliminated Vista support because Win7 replaces peimg with DISM.
# Eliminated 64bit boot CD support
# v1.0 - caught my computer on fire, thereby vanishing itself.


INIT {
  %INSTALLMONKEY_OPTIONS = (
	package_id =&gt; 'PE5_0Creator.1_1',
	package_revision =&gt; '20130316T1600',
    );
}
use lib (
  '\\\\minerfiles.mst.edu\dfs\software\loginscripts\im',
  $ENV{'WINDIR'}.'\SYSTEM32\UMRINST',
  'C:\temp',
);
use InstallMonkey::Shared;
use POSIX qw(strftime);
use Getopt::Long;

# Obtain required info
$time=localtime();
chomp($time);
$userid=$ENV{'USERNAME'};
$cwd=cwd();

my $location_of_standard_drivers="$cwd\\drivers";
my $arch = 'amd64'; # default (possible: 'x86', 'amd64', 'ia64')
GetOptions(
    'standard-drivers=s' =&gt; \$location_of_standard_drivers,
    'architecture=s' =&gt; \$arch,
);

# Vars
$temp_dir="C:\\temp\\pe";
$temp="$temp_dir"."\\winpe_${arch}";
$basedirectory = "C:\\Program Files (x86)\\Windows Kits\\8.1\\Assessment and Deployment Kit\\";

# Pull our cwd from the script
$0 =~ /^(.*)\\Win7_create_pe5_boot_disk.pl$/;
$copype = "$1\\copype.new.cmd";
$dism=$basedirectory."Deployment Tools\\${arch}\\DISM\\dism.exe";
$packagepath=$basedirectory."Windows Preinstallation Environment\\${arch}\\WinPE_OCs\\";
$imagex=$basedirectory."Deployment Tools\\${arch}\\DISM\\imagex.exe";
$oscdimgdir=$basedirectory."Deployment Tools\\${arch}\\Oscdimg\\";
$scriptname="WinPE v5.0 Boot CD Creator v1.1";
$version_file="Windows\\System32\\pe_version.txt";
$dism_log=$temp.'\\dism.log';
$dism_log_args="/LogPath:\"${dism_log}\" /LogLevel:3";
$iso_dir=$temp.'\\ISO';

# Tell user what's happening
system("cls");
print "$scriptname\n";
print "by Bryan A. Thompson\n";
print " \n";
print " \n";


# Check for correct Windows version - SP1 required!
print "Checking Prerequisites...";
unless (check_windows_version("6.1.7601") ||
        check_windows_version("6.1.7600")) {
  print "\nWin 7 Host OS required but not found.  Exiting.\n";
  exit(0);
}



# Check for prerequisites (WAIK)
if ((-f $copype) &amp;&amp; (-f $dism) &amp;&amp; (-f $imagex) &amp;&amp; (-x $oscdimgdir)) {
  print "Passed.\n";
  print " \n";
  print " \n";
} else {
  print "Failed.\n";
  print "It appears that one of the required tools is missing.  Please (re)install Windows AIK and retry.\n";
  exit(0);
}


# Get version information from the user.
print "What version number would you like to use for this disc? ";
my $input_pe_version = &lt;STDIN&gt;; 
chomp($input_pe_version);
print "\n";

  
# 1)  Delete the contents of the dir C:\temp\pe if it exists, and create it if it doesn't exist.
print "Warning!  \n";
print "The directory C:\\temp\\pe and all of its files and folders will be deleted!\n";
print "Press 'Y' to continue:  ";
$line=&lt;STDIN&gt;;
chomp($line);
print " \n";
print " \n";
print "Preparing temp dir...\n";
unless($line =~/Y/i) {
  print "Exiting.\n";
	exit(0);
}
# unmount the image in case it's still mounted from a previoulsly failed attempt.
run_command("\"$dism\" \/unmount-wim \/mountdir\:\"$temp\\mount\" \/discard", 'IgnoreReturnCode'=&gt;1);
run_command("\"$dism\" \/cleanup\-wim", 'IgnoreReturnCode'=&gt;1);
# Delete the file or dir required for the temp dir
if (-f $temp_dir) { 
  run_command("del \/q \"$temp_dir\""); 
}
elsif (-d $temp_dir) { 
  # Perl's system() command will invoke an executable before a shell builtin.
  # Prepend it with 'cmd /c' to invoke the builtin.
  run_command("cmd /c rmdir \/s \/q \"$temp_dir\""); 
}
# recreate the temp dir
run_command("mkdir $temp_dir");
print "Done.\n";
print " \n";
print " \n";


# 2)  Copy the files needed for the WinPE creation process to the temp dir.
print "Copying PE Base Image files...\n";
run_command("\"$copype\" ${arch} $temp");
print "Done.\n";
print " \n";
print " \n";


# 3)  Mount the WIM for writing
print "Mounting WIM for writing...\n";
run_command("\"$dism\" \/mount-wim \/wimfile\:\"$temp\\media\\sources\\boot.wim\" \/index\:1 \/mountdir\:\"$temp\\mount\"" );
print "Done.\n";
print " \n";
print " \n";


# 4)  Add MST Customizations (Perl, Login scripts, etc)
print "Copying files for MST Customization...\n";
run_command("xcopy \"$cwd\\mst_customizations_${arch}\\*.*\" \/e\/s\/v\/y \"$temp\\mount\\Windows\\system32\"");
open(README,"&gt;$temp\\mount\\readme.txt");
print README "This is a Win7 ${arch} PE image created by the WinPE v3.0 Boot CD Creator v1.1.\n";
print README "by user $userid on $time\n";
print "Done.\n";
print " \n";
print " \n";

# 4.1) Time Zone (not setting this screws up time-based state settings)
run_command("\"$dism\" \/image:\"$temp\\mount\" $dism_log_args \/Set-TimeZone:\"Central Standard Time\"");


# 5) Update the pe_version.txt in the mounted %WINDIR%\System32
my $pe_ver_file = $temp.'\mount\\'.$version_file;
my $PE_VERSION;
my $stamp = strftime('%Y%m%d',localtime());
if (open($PE_VERSION,'&gt;',$pe_ver_file)) {
  print $PE_VERSION &lt;&lt;EOPEVER
  PE_VERSION=${input_pe_version}
  PE_CREATION_DATE=${stamp}
EOPEVER
  ;
} else {
  print "Cannot open PE version file (${pe_ver_file}): $!\n";
}
close($PE_VERSION);


# 6)  Add standard packages to the image
my @packages = qw(
  winpe-wds-tools.cab
  winpe-hta.cab
  en-us\\winpe-hta_en-us.cab
  winpe-legacysetup.cab
  en-us\\winpe-legacysetup_en-us.cab
  winpe-mdac.cab
  en-us\\winpe-mdac_en-us.cab
  winpe-pppoe.cab
  en-us\\winpe-PPPOE_en-us.cab
  winpe-scripting.cab
  en-us\\winpe-scripting_en-us.cab
  winpe-wds-tools.cab
  en-us\\winpe-wds-tools_en-us.cab
  winpe-wmi.cab
  en-us\\winpe-wmi_en-us.cab
  WinPE-Dot3Svc.cab
  en-us\\WinPE-Dot3Svc_en-us.cab
);
# omitted packages
#winpe-setup.cab
#en-us\\winpe-setup_en-us.cab
#winpe-setup-client.cab
#en-us\\winpe-setup-client_en-us.cab
#winpe-setup-server.cab
#en-us\\winpe-setup-server_en-us.cab

print "Adding standard WinPE packages...\n";
foreach my $pkg (@packages) {
    run_command("\"$dism\" \/image:\"$temp\\mount\" $dism_log_args \/add-package \/packagepath\:\"${packagepath}\\${pkg}\"");
}

print "Done.\n";
print " \n";
print " \n";


# 7)  Add drivers to the image
print "Adding drivers...\n";
print " \n";
# Import standard drivers folder
print "  Location of standard drivers:  $location_of_standard_drivers\n";
print README "Adding standard drivers from location:  $location_of_standard_drivers\n";
run_command("\"$dism\" \/image\:\"$temp\\mount\" $dism_log_args \/add-driver \/driver\:\"$location_of_standard_drivers\" \/recurse ", 'IgnoreReturnCode'=&gt;1);
print " \n";
# Check for additional drivers
print "Press 'Y' to include additional Windows 7 ${arch} drivers, or any other key to skip this step:  ";
$line=&lt;STDIN&gt;;
chomp($line);
print " \n";
print " \n";
if ($line =~/Y/i) {
  # Import nonstandard drivers folder
  print "  Enter the path to an optional Windows 7 x86 ${arch} drivers folder: ";
  $location_of_nonstandard_drivers=&lt;STDIN&gt;;
  $location_of_nonstandard_drivers =~ s/[\n\r]+$//;
  print " \n";
  print README "Adding non-standard ${arch} drivers from location: $location_of_nonstandard_drivers\n";
  run_command("\"$dism\" \/image\:\"$temp\\mount\" $dism_log_args \/add-driver \/driver\:\"$location_of_nonstandard_drivers\" \/recurse", 'IgnoreReturnCode'=&gt;1);    
} else {
  print "Skipping additional drivers.\n";
}
close(README);
print "Done.\n";
print " \n";
print " \n";


# 8) Pause for manual customizations
print "Standard PE disc content preparation complete.\n";
print "Pausing to allow you to perform any customizations needed.\n";
system('pause');
print " \n";
print " \n";

# 10-1.1) Copy files out of the mount directory that will go directly into
#         the ISO filesystem.
run_command("mkdir $temp_dir\\ISO");
run_command("copy \"$pe_ver_file\" \"$iso_dir\" /Y");
run_command("copy \"$dism_log\" \"$iso_dir\" /Y");

# 9)  Unmount the Image
print "Unmounting the image...\n";
run_command("copy \"$dism_log\" \"$temp\\mount\" /Y");
run_command("\"$dism\" \/unmount-wim \/mountdir\:\"$temp\\mount\" \/commit", 'IgnoreReturnCode'=&gt;1);
print "Done.\n";
print " \n";
print " \n";

# 10)  Make the ISO
#print "Making the ISO...\n";
#run_command("copy \"$temp\\winpe.wim\" \"$temp\\ISO\\sources\\boot.wim\" \/Y");
#
# OSCDIMG commands
# -o:  Optimize, only copy duplicate files once
# -n:  Allow longer than DOS 8.3 names... 
# -b:  Use this file as the bootfile


#NOTE: etfsboot.com is also in the oscdimg directory, it's possible they changed this
run_command("\"${oscdimgdir}oscdimg.exe\" -b\"${oscdimgdir}etfsboot.com\" -n -o \"$temp\\media\" \"$temp_dir\\ISO\\winpe_${arch}.iso\"");
print "Done.\n";
print " \n";
print " \n";


# 11) Cleanup
print "The ISO has been saved in the following location:\n";
print "$temp_dir\\ISO\\winpe_${arch}.iso\n";
print " \n";
print " \n";
print "The WinPE Boot CD ISO creation process is complete.\n";
print " \n";
print " \n";
</Text>
  </Script>
  <Script>
    <Name>pe.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\pe\PE5_Boot_CD_Creator\mst_customizations_amd64\pe.pl</FullName>
    <Length>1687</Length>
    <Extension>.pl</Extension>
    <CreationTime>2015-09-25T09:39:47.9502441-05:00</CreationTime>
    <CreationTimeUtc>2015-09-25T14:39:47.9502441Z</CreationTimeUtc>
    <LastWriteTime>2010-07-08T12:38:28.6296481-05:00</LastWriteTime>
    <LastWriteTimeUtc>2010-07-08T17:38:28.6296481Z</LastWriteTimeUtc>
    <LastAccessTime>2015-09-25T09:39:47.9502441-05:00</LastAccessTime>
    <LastAccessTimeUtc>2015-09-25T14:39:47.9502441Z</LastAccessTimeUtc>
    <Text>#!perl

=pod

Begin-Doc
Modified: $Date$
Name: pe.pl
Type: script
Description: control script for MST PE
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

##############################
# BEGIN Configuration

my $PE_Version_file = $ENV{SystemRoot} . '\\System32\\pe_version.txt';

# END Configuration
##############################

sub usage {
    print qq/
usage: $0 [-help] [-version]
/;
}

my $version = 0;

use Getopt::Long;
Getopt::Long::Configure('prefix_pattern=(?:--|-)?'); # Don't require - or --
GetOptions(
    'help'    =&gt; sub { usage(); exit(0); },
    'version' =&gt; \$version,
);

my $exit_code = 0;
$exit_code |= !get_pe_version() if ($version);


exit($exit_code);

########################################################################

sub get_pe_version {
    if ( ! -f $PE_Version_file ) {
        print("Cannot find PE version file. This is not a recent MST PE disc.\n");
        return 0;
    }

    if ( open( my $PEVER, '&lt;', $PE_Version_file ) ) {
        my ( $version, $date );
        while ( defined( my $line = &lt;$PEVER&gt; ) ) {
            $line =~ s/(^\s+|[\n\r]+$)//g;
            my @info = split( /=/, $line );
            if ( $info[0] eq 'PE_VERSION' ) {
                $version = $info[1];
            }
            elsif ( $info[0] eq 'PE_CREATION_DATE' ) {
                $date = $info[1];
            }
        }
        close($PEVER);

        print("MST PE Version: ${version} (created ${date})\n");
        return 1;
    }
    else {
        print("Error opening PE version file '${PE_Version_file}': $!\n");
        return 0;
    }
}
</Text>
  </Script>
  <Script>
    <Name>pe.pl</Name>
    <FullName>\\minerfiles.mst.edu\dfs\software\itwindist\win10\pe\PE5_Boot_CD_Creator\mst_customizations_x86\pe.pl</FullName>
    <Length>1687</Length>
    <Extension>.pl</Extension>
    <CreationTime>2015-09-25T09:41:30.5384745-05:00</CreationTime>
    <CreationTimeUtc>2015-09-25T14:41:30.5384745Z</CreationTimeUtc>
    <LastWriteTime>2010-07-08T12:38:28.6296481-05:00</LastWriteTime>
    <LastWriteTimeUtc>2010-07-08T17:38:28.6296481Z</LastWriteTimeUtc>
    <LastAccessTime>2015-09-25T09:41:30.5384745-05:00</LastAccessTime>
    <LastAccessTimeUtc>2015-09-25T14:41:30.5384745Z</LastAccessTimeUtc>
    <Text>#!perl

=pod

Begin-Doc
Modified: $Date$
Name: pe.pl
Type: script
Description: control script for MST PE
Language: Perl
LastUpdatedBy: $Author$
Version: $Revision$
Doc-Package-Info: 
Doc-SVN-Repository: $URL$
RCSId: $Id$
End-Doc

=cut

use strict;
use warnings;

##############################
# BEGIN Configuration

my $PE_Version_file = $ENV{SystemRoot} . '\\System32\\pe_version.txt';

# END Configuration
##############################

sub usage {
    print qq/
usage: $0 [-help] [-version]
/;
}

my $version = 0;

use Getopt::Long;
Getopt::Long::Configure('prefix_pattern=(?:--|-)?'); # Don't require - or --
GetOptions(
    'help'    =&gt; sub { usage(); exit(0); },
    'version' =&gt; \$version,
);

my $exit_code = 0;
$exit_code |= !get_pe_version() if ($version);


exit($exit_code);

########################################################################

sub get_pe_version {
    if ( ! -f $PE_Version_file ) {
        print("Cannot find PE version file. This is not a recent MST PE disc.\n");
        return 0;
    }

    if ( open( my $PEVER, '&lt;', $PE_Version_file ) ) {
        my ( $version, $date );
        while ( defined( my $line = &lt;$PEVER&gt; ) ) {
            $line =~ s/(^\s+|[\n\r]+$)//g;
            my @info = split( /=/, $line );
            if ( $info[0] eq 'PE_VERSION' ) {
                $version = $info[1];
            }
            elsif ( $info[0] eq 'PE_CREATION_DATE' ) {
                $date = $info[1];
            }
        }
        close($PEVER);

        print("MST PE Version: ${version} (created ${date})\n");
        return 1;
    }
    else {
        print("Error opening PE version file '${PE_Version_file}': $!\n");
        return 0;
    }
}
</Text>
  </Script>
</ArrayOfScript>